extlib2 = """ (Ext.cmd.derive("Ext.layout.component.Auto", Ext.layout.component.Component, {
    type: "autocomponent",
    setHeightInDom: false,
    setWidthInDom: false,
    waitForOuterHeightInDom: false,
    waitForOuterWidthInDom: false,
    beginLayoutCycle: function (d, a) {
        var c = this, g = c.lastWidthModel, e = c.lastHeightModel, b = c.owner.el;
        Ext.layout.component.Component.prototype.beginLayoutCycle.apply(this, arguments);
        if (g && g.fixed && d.widthModel.shrinkWrap) {
            b.setWidth(null)
        }
        if (e && e.fixed && d.heightModel.shrinkWrap) {
            b.setHeight(null)
        }
    },
    calculate: function (h) {
        var g = this, e = g.measureAutoDimensions(h), b = h.heightModel, c = h.widthModel, d, a;
        if (e.gotWidth) {
            if (c.shrinkWrap) {
                g.publishOwnerWidth(h, e.contentWidth)
            } else {
                if (g.publishInnerWidth) {
                    g.publishInnerWidth(h, e.width)
                }
            }
        } else {
            if (!c.auto && g.publishInnerWidth) {
                d = g.waitForOuterWidthInDom ? h.getDomProp("width") : h.getProp("width");
                if (d === undefined) {
                    g.done = false
                } else {
                    g.publishInnerWidth(h, d)
                }
            }
        }
        if (e.gotHeight) {
            if (b.shrinkWrap) {
                g.publishOwnerHeight(h, e.contentHeight)
            } else {
                if (g.publishInnerHeight) {
                    g.publishInnerHeight(h, e.height)
                }
            }
        } else {
            if (!b.auto && g.publishInnerHeight) {
                a = g.waitForOuterHeightInDom ? h.getDomProp("height") : h.getProp("height");
                if (a === undefined) {
                    g.done = false
                } else {
                    g.publishInnerHeight(h, a)
                }
            }
        }
        if (!e.gotAll) {
            g.done = false
        }
    },
    calculateOwnerHeightFromContentHeight: function (b, a) {
        return a + b.getFrameInfo().height
    },
    calculateOwnerWidthFromContentWidth: function (b, a) {
        return a + b.getFrameInfo().width
    },
    publishOwnerHeight: function (i, g) {
        var e = this, b = e.owner, a = e.calculateOwnerHeightFromContentHeight(i, g), h, d, c;
        if (isNaN(a)) {
            e.done = false
        } else {
            h = Ext.Number.constrain(a, b.minHeight, b.maxHeight);
            if (h === a) {
                d = e.setHeightInDom
            } else {
                c = e.sizeModels[(h < a) ? "constrainedMax" : "constrainedMin"];
                a = h;
                if (i.heightModel.calculatedFromShrinkWrap) {
                    i.heightModel = c
                } else {
                    i.invalidate({heightModel: c})
                }
            }
            i.setHeight(a, d)
        }
    },
    publishOwnerWidth: function (h, b) {
        var g = this, a = g.owner, e = g.calculateOwnerWidthFromContentWidth(h, b), i, d, c;
        if (isNaN(e)) {
            g.done = false
        } else {
            i = Ext.Number.constrain(e, a.minWidth, a.maxWidth);
            if (i === e) {
                d = g.setWidthInDom
            } else {
                c = g.sizeModels[(i < e) ? "constrainedMax" : "constrainedMin"];
                e = i;
                if (h.widthModel.calculatedFromShrinkWrap) {
                    h.widthModel = c
                } else {
                    h.invalidate({widthModel: c})
                }
            }
            h.setWidth(e, d)
        }
    }
}, 0, 0, 0, 0, ["layout.autocomponent"], 0, [Ext.layout.component, "Auto"], 0));
(Ext.cmd.derive("Ext.layout.component.ProgressBar", Ext.layout.component.Auto, {
    type: "progressbar",
    beginLayout: function (d) {
        var b = this, a, c;
        Ext.layout.component.Auto.prototype.beginLayout.apply(this, arguments);
        if (!d.textEls) {
            c = b.owner.textEl;
            if (c.isComposite) {
                d.textEls = [];
                c = c.elements;
                for (a = c.length; a--;) {
                    d.textEls[a] = d.getEl(Ext.get(c[a]))
                }
            } else {
                d.textEls = [d.getEl("textEl")]
            }
        }
    },
    calculate: function (e) {
        var c = this, a, d, b;
        Ext.layout.component.Auto.prototype.calculate.apply(this, arguments);
        if (Ext.isNumber(b = e.getProp("width"))) {
            b -= e.getBorderInfo().width;
            d = e.textEls;
            for (a = d.length; a--;) {
                d[a].setWidth(b)
            }
        } else {
            c.done = false
        }
    }
}, 0, 0, 0, 0, ["layout.progressbar"], 0, [Ext.layout.component, "ProgressBar"], 0));
(Ext.cmd.derive("Ext.ProgressBar", Ext.Component, {
    config: {value: 0, textTpl: null},
    baseCls: "x-progress",
    animate: false,
    text: "",
    waitTimer: null,
    childEls: ["bar"],
    defaultBindProperty: "value",
    renderTpl: ['<tpl if="internalText">', '<div class="{baseCls}-text {baseCls}-text-back">{text}</div>', "</tpl>", '<div id="{id}-bar" data-ref="bar" class="{baseCls}-bar {baseCls}-bar-{ui}" role="presentation" style="width:{percentage}%">', '<tpl if="internalText">', '<div class="{baseCls}-text">', "<div>{text}</div>", "</div>", "</tpl>", "</div>"],
    componentLayout: "progressbar",
    ariaRole: "progressbar",
    initRenderData: function () {
        var a = this, b = a.value || 0;
        return Ext.apply(Ext.Component.prototype.initRenderData.call(this), {
            internalText: !a.hasOwnProperty("textEl"),
            text: a.text || "&#160;",
            percentage: b * 100
        })
    },
    onRender: function () {
        var a = this;
        Ext.Component.prototype.onRender.apply(this, arguments);
        if (a.textEl) {
            a.textEl = Ext.get(a.textEl);
            a.updateText(a.text)
        } else {
            a.textEl = a.el.select("." + a.baseCls + "-text")
        }
    },
    applyValue: function (a) {
        return a || 0
    },
    updateValue: function (a) {
        this.updateProgress(a, Math.round(a * 100) + "%")
    },
    updateProgress: function (e, g, a) {
        e = e || 0;
        var d = this, b = d.value, c = d.getTextTpl();
        d.value = e || (e = 0);
        if (g != null) {
            d.updateText(g)
        } else {
            if (c) {
                d.updateText(c.apply({value: e, percent: e * 100}))
            }
        }
        if (d.rendered && !d.destroyed) {
            if (a === true || (a !== false && d.animate)) {
                d.bar.stopAnimation();
                d.bar.animate(Ext.apply({from: {width: (b * 100) + "%"}, to: {width: (e * 100) + "%"}}, d.animate))
            } else {
                d.bar.setStyle("width", (e * 100) + "%")
            }
        }
        d.fireEvent("update", d, e, g);
        return d
    },
    updateText: function (b) {
        var a = this;
        a.text = b;
        if (a.rendered) {
            a.textEl.setHtml(a.text)
        }
        return a
    },
    applyTextTpl: function (a) {
        if (!a.isTemplate) {
            a = new Ext.XTemplate(a)
        }
        return a
    },
    applyText: function (a) {
        this.updateText(a)
    },
    getText: function () {
        return this.text
    },
    wait: function (c) {
        var b = this, a;
        if (!b.waitTimer) {
            a = b;
            c = c || {};
            b.updateText(c.text);
            b.waitTimer = Ext.TaskManager.start({
                run: function (d) {
                    var e = c.increment || 10;
                    d -= 1;
                    b.updateProgress(((((d + e) % e) + 1) * (100 / e)) * 0.01, null, c.animate)
                }, interval: c.interval || 1000, duration: c.duration, onStop: function () {
                    if (c.fn) {
                        c.fn.apply(c.scope || b)
                    }
                    b.reset()
                }, scope: a
            })
        }
        return b
    },
    isWaiting: function () {
        return this.waitTimer !== null
    },
    reset: function (a) {
        var b = this;
        b.updateProgress(0);
        b.clearTimer();
        if (a === true) {
            b.hide()
        }
        return b
    },
    clearTimer: function () {
        var a = this;
        if (a.waitTimer) {
            a.waitTimer.onStop = null;
            Ext.TaskManager.stop(a.waitTimer);
            a.waitTimer = null
        }
    },
    onDestroy: function () {
        var b = this, a = b.bar;
        b.clearTimer();
        if (b.rendered) {
            if (b.textEl.isComposite) {
                b.textEl.clear()
            }
            Ext.destroyMembers(b, "textEl", "progressBar");
            if (a && b.animate) {
                a.stopAnimation()
            }
        }
        Ext.Component.prototype.onDestroy.call(this)
    }
}, 0, ["progressbar"], ["component", "box", "progressbar"], {
    component: true,
    box: true,
    progressbar: true
}, ["widget.progressbar"], 0, [Ext, "ProgressBar"], 0));
(Ext.cmd.derive("Ext.ProgressBarWidget", Ext.Widget, {
    config: {text: null, value: 0, animate: false, textTpl: null},
    cachedConfig: {baseCls: "x-progress", textCls: "x-progress-text", ui: "default"},
    template: [{reference: "backgroundEl"}, {reference: "barEl", children: [{reference: "textEl"}]}],
    defaultBindProperty: "value",
    updateWidth: function (b, a) {
        var c = this;
        Ext.Widget.prototype.updateWidth.call(this, b, a);
        b -= c.element.getBorderWidth("lr");
        c.backgroundEl.setWidth(b);
        c.textEl.setWidth(b)
    },
    updateUi: function (e, d) {
        var c = this.element, a = this.barEl, b = this.getBaseCls() + "-";
        if (d) {
            c.removeCls(b + d);
            a.removeCls(b + "bar-" + d)
        }
        c.addCls(b + e);
        a.addCls(b + "bar-" + e)
    },
    updateBaseCls: function (b, a) {
        this.element.addCls(b);
        this.barEl.addCls(b + "-bar")
    },
    updateTextCls: function (a) {
        this.backgroundEl.addCls(a + " " + a + "-back");
        this.textEl.addCls(a)
    },
    applyValue: function (a) {
        return a || 0
    },
    updateValue: function (e, b) {
        var d = this, a = d.barEl, c = d.getTextTpl();
        if (c) {
            d.setText(c.apply({value: e, percent: Math.round(e * 100)}))
        }
        if (d.getAnimate()) {
            a.stopAnimation();
            a.animate(Ext.apply({from: {width: (b * 100) + "%"}, to: {width: (e * 100) + "%"}}, d.animate))
        } else {
            a.setStyle("width", (e * 100) + "%")
        }
    },
    updateText: function (a) {
        this.backgroundEl.setHtml(a);
        this.textEl.setHtml(a)
    },
    applyTextTpl: function (a) {
        if (!a.isTemplate) {
            a = new Ext.XTemplate(a)
        }
        return a
    }
}, 0, ["progressbarwidget"], ["widget", "progressbarwidget"], {
    widget: true,
    progressbarwidget: true
}, ["widget.progressbarwidget"], 0, [Ext, "ProgressBarWidget"], 0));
(Ext.cmd.derive("Ext.dom.ButtonElement", Ext.dom.Element, {
    setSize: function (d, a, b) {
        var e = this, c = e.component;
        Ext.dom.Element.prototype.setSize.call(this, d, a, b);
        c.btnWrap.setStyle("table-layout", (!d || d === "auto") ? "" : "fixed");
        c.btnEl.setStyle("height", (!a || a === "auto") ? "" : "auto");
        return e
    }, setStyle: function (g, e) {
        var d = this, b = d.component, c, a;
        Ext.dom.Element.prototype.setStyle.call(this, g, e);
        if (g) {
            if (g === "width" || (typeof g !== "string" && "width" in g)) {
                c = e || g.width;
                b.btnWrap.setStyle("table-layout", (!c || c === "auto") ? "" : "fixed")
            }
            if (g === "height" || (typeof g !== "string" && "height" in g)) {
                a = e || g.height;
                b.btnEl.setStyle("height", (!a || a === "auto") ? "" : "auto")
            }
        }
        return d
    }, setHeight: function (a, b) {
        Ext.dom.Element.prototype.setHeight.call(this, a, b);
        this.component.btnEl.setStyle("height", (!a || a === "auto") ? "" : "auto");
        return this
    }, setWidth: function (b, a) {
        Ext.dom.Element.prototype.setWidth.call(this, b, a);
        this.component.btnWrap.setStyle("table-layout", (!b || b === "auto") ? "" : "fixed");
        return this
    }
}, 0, 0, 0, 0, 0, 0, [Ext.dom, "ButtonElement"], 0));
(Ext.cmd.derive("Ext.button.Manager", Ext.Base, {
    singleton: true,
    alternateClassName: "Ext.ButtonToggleManager",
    groups: {},
    pressedButton: null,
    init: function () {
        var a = this;
        if (!a.initialized) {
            Ext.getDoc().on({mouseup: a.onDocumentMouseUp, scope: a});
            a.initialized = true
        }
    },
    onButtonMousedown: function (a, c) {
        var b = this.pressedButton;
        if (b) {
            b.onMouseUp(c)
        }
        this.pressedButton = a
    },
    onDocumentMouseUp: function (b) {
        var a = this.pressedButton;
        if (a) {
            a.onMouseUp(b);
            this.pressedButton = null
        }
    },
    toggleGroup: function (b, e) {
        if (e) {
            var d = this.groups[b.toggleGroup], c = d.length, a;
            for (a = 0; a < c; a++) {
                if (d[a] !== b) {
                    d[a].toggle(false)
                }
            }
        }
    },
    register: function (b) {
        var c = this, a = this.groups, d = a[b.toggleGroup];
        c.init();
        if (!b.toggleGroup) {
            return
        }
        if (!d) {
            d = a[b.toggleGroup] = []
        }
        d.push(b);
        b.on("toggle", c.toggleGroup, c)
    },
    unregister: function (a) {
        if (!a.toggleGroup) {
            return
        }
        var b = this, c = b.groups[a.toggleGroup];
        if (c) {
            Ext.Array.remove(c, a);
            a.un("toggle", b.toggleGroup, b)
        }
    },
    getPressed: function (d) {
        var c = this.groups[d], b = 0, a;
        if (c) {
            for (a = c.length; b < a; b++) {
                if (c[b].pressed === true) {
                    return c[b]
                }
            }
        }
        return null
    }
}, 0, 0, 0, 0, 0, 0, [Ext.button, "Manager", Ext, "ButtonToggleManager"], 0));
(Ext.cmd.derive("Ext.menu.Manager", Ext.Base, {
    singleton: true, alternateClassName: "Ext.menu.MenuMgr", groups: {}, visible: [], constructor: function () {
        var a = this;
        a.onShow = function () {
            delete a.onShow;
            Ext.on("mousedown", a.checkActiveMenus, a);
            return a.onShow.apply(a, arguments)
        }
    }, checkActiveMenus: function (d) {
        var h = this.visible, a = h.length, b, g, c = Ext.Component.fromElement(d.target);
        if (a) {
            h = h.slice();
            for (b = 0; b < a; ++b) {
                g = h[b];
                if (!(g.owns(d) || (c && c.isMenuCheckItem && c.menu === g))) {
                    g.hide()
                }
            }
        }
    }, onShow: function (a) {
        if (a.floating) {
            Ext.Array.include(this.visible, a)
        }
    }, onHide: function (a) {
        if (a.floating) {
            Ext.Array.remove(this.visible, a)
        }
    }, hideAll: function () {
        var d = this.visible, b = d.length, a = false, c;
        if (b) {
            d = d.slice();
            for (c = 0; c < b; c++) {
                d[c].hide();
                a = true
            }
        }
        return a
    }, get: function (c, b) {
        var a;
        if (typeof c === "string") {
            a = Ext.getCmp(c);
            if (a instanceof Ext.menu.Menu) {
                c = a
            }
        } else {
            if (Ext.isArray(c)) {
                b = Ext.apply({items: c}, b);
                c = new Ext.menu.Menu(b)
            } else {
                if (!c.isComponent) {
                    b = Ext.apply({}, c, b);
                    c = Ext.ComponentManager.create(b, "menu")
                }
            }
        }
        return c
    }, registerCheckable: function (c) {
        var a = this.groups, b = c.group;
        if (b) {
            if (!a[b]) {
                a[b] = []
            }
            a[b].push(c)
        }
    }, unregisterCheckable: function (c) {
        var a = this.groups, b = c.group;
        if (b) {
            Ext.Array.remove(a[b], c)
        }
    }, onCheckChange: function (d, g) {
        var a = this.groups, c = d.group, b = 0, j, e, h;
        if (c && g) {
            j = a[c];
            e = j.length;
            for (; b < e; b++) {
                h = j[b];
                if (h !== d) {
                    h.setChecked(false)
                }
            }
        }
    }
}, 1, 0, 0, 0, 0, 0, [Ext.menu, "Manager", Ext.menu, "MenuMgr"], 0));
(Ext.cmd.derive("Ext.util.ClickRepeater", Ext.util.Observable, {
    constructor: function (b, a) {
        var c = this;
        c.el = Ext.get(b);
        c.el.unselectable();
        Ext.apply(c, a);
        Ext.util.Observable.prototype.constructor.call(this);
        if (!c.disabled) {
            c.disabled = true;
            c.enable()
        }
        if (c.handler) {
            c.on("click", c.handler, c.scope || c)
        }
    }, interval: 20, delay: 250, preventDefault: true, stopDefault: false, timer: 0, enable: function () {
        if (this.disabled) {
            this.el.on("mousedown", this.handleMouseDown, this);
            if (Ext.isIE8) {
                this.el.on("dblclick", this.handleDblClick, this)
            }
            if (this.preventDefault || this.stopDefault) {
                this.el.on("click", this.eventOptions, this)
            }
        }
        this.disabled = false
    }, disable: function (a) {
        if (a || !this.disabled) {
            clearTimeout(this.timer);
            if (this.pressedCls) {
                this.el.removeCls(this.pressedCls)
            }
            Ext.getDoc().un("mouseup", this.handleMouseUp, this);
            this.el.clearListeners()
        }
        this.disabled = true
    }, setDisabled: function (a) {
        this[a ? "disable" : "enable"]()
    }, eventOptions: function (a) {
        if (this.preventDefault) {
            a.preventDefault()
        }
        if (this.stopDefault) {
            a.stopEvent()
        }
    }, destroy: function () {
        this.disable(true);
        Ext.util.Observable.prototype.destroy.call(this)
    }, handleDblClick: function (a) {
        clearTimeout(this.timer);
        this.fireEvent("mousedown", this, a);
        this.fireEvent("click", this, a)
    }, handleMouseDown: function (a) {
        clearTimeout(this.timer);
        if (this.pressedCls) {
            this.el.addCls(this.pressedCls)
        }
        this.mousedownTime = new Date();
        Ext.getDoc().on("mouseup", this.handleMouseUp, this);
        this.el.on("mouseout", this.handleMouseOut, this);
        this.fireEvent("mousedown", this, a);
        this.fireEvent("click", this, a);
        if (this.accelerate) {
            this.delay = 400
        }
        this.timer = Ext.defer(this.click, this.delay || this.interval, this, [a])
    }, click: function (a) {
        this.fireEvent("click", this, a);
        this.timer = Ext.defer(this.click, this.accelerate ? this.easeOutExpo(Ext.Date.getElapsed(this.mousedownTime), 400, -390, 12000) : this.interval, this, [a])
    }, easeOutExpo: function (e, a, h, g) {
        return (e === g) ? a + h : h * (-Math.pow(2, -10 * e / g) + 1) + a
    }, handleMouseOut: function () {
        clearTimeout(this.timer);
        if (this.pressedCls) {
            this.el.removeCls(this.pressedCls)
        }
        this.el.on("mouseover", this.handleMouseReturn, this)
    }, handleMouseReturn: function (a) {
        this.el.un("mouseover", this.handleMouseReturn, this);
        if (this.pressedCls) {
            this.el.addCls(this.pressedCls)
        }
        this.click(a)
    }, handleMouseUp: function (a) {
        clearTimeout(this.timer);
        this.el.un("mouseover", this.handleMouseReturn, this);
        this.el.un("mouseout", this.handleMouseOut, this);
        Ext.getDoc().un("mouseup", this.handleMouseUp, this);
        if (this.pressedCls) {
            this.el.removeCls(this.pressedCls)
        }
        this.fireEvent("mouseup", this, a)
    }
}, 1, 0, 0, 0, 0, 0, [Ext.util, "ClickRepeater"], 0));
(Ext.cmd.derive("Ext.button.Button", Ext.Component, {
    alternateClassName: "Ext.Button",
    config: {iconAlign: "left", text: null, textAlign: "center", arrowVisible: true},
    isButton: true,
    _syncFrameHeight: true,
    liquidLayout: true,
    hidden: false,
    disabled: false,
    pressed: false,
    tabIndex: 0,
    enableToggle: false,
    menuAlign: "tl-bl?",
    showEmptyMenu: false,
    clickEvent: "click",
    preventDefault: true,
    handleMouseEvents: true,
    tooltipType: "qtip",
    baseCls: "x-btn",
    hrefTarget: "_blank",
    destroyMenu: true,
    focusable: true,
    ariaRole: "button",
    keyHandlers: {SPACE: "onEnterKey", ENTER: "onEnterKey", DOWN: "onDownKey"},
    defaultBindProperty: "text",
    childEls: ["btnEl", "btnWrap", "btnInnerEl", "btnIconEl", "arrowEl"],
    publishes: {pressed: 1},
    _btnWrapCls: "x-btn-wrap",
    _btnCls: "x-btn-button",
    _baseIconCls: "x-btn-icon-el",
    _glyphCls: "x-btn-glyph",
    _innerCls: "x-btn-inner",
    _textCls: "x-btn-text",
    _noTextCls: "x-btn-no-text",
    _hasIconCls: "x-btn-icon",
    _pressedCls: "x-btn-pressed",
    overCls: "x-btn-over",
    _disabledCls: "x-btn-disabled",
    _menuActiveCls: "x-btn-menu-active",
    _arrowElCls: "x-btn-arrow-el",
    _focusCls: "x-btn-focus",
    _arrowFocusCls: "x-arrow-focus",
    renderTpl: '<span id="{id}-btnWrap" data-ref="btnWrap" role="presentation" unselectable="on" style="{btnWrapStyle}" class="{btnWrapCls} {btnWrapCls}-{ui} {splitCls}{childElCls}"><span id="{id}-btnEl" data-ref="btnEl" role="presentation" unselectable="on" style="{btnElStyle}" class="{btnCls} {btnCls}-{ui} {textCls} {noTextCls} {hasIconCls} {iconAlignCls} {textAlignCls} {btnElAutoHeightCls}{childElCls}"><tpl if="iconBeforeText">{[values.$comp.renderIcon(values)]}</tpl><span id="{id}-btnInnerEl" data-ref="btnInnerEl" unselectable="on" class="{innerCls} {innerCls}-{ui}{childElCls}">{text}</span><tpl if="!iconBeforeText">{[values.$comp.renderIcon(values)]}</tpl></span></span>{[values.$comp.getAfterMarkup ? values.$comp.getAfterMarkup(values) : ""]}<tpl if="closable"><span id="{id}-closeEl" data-ref="closeEl" class="{baseCls}-close-btn"><tpl if="closeText"> {closeText}</tpl></span></tpl><tpl if="split"><span id="{id}-arrowEl" class="{arrowElCls}" data-ref="arrowEl" role="button" hidefocus="on" unselectable="on"<tpl if="tabIndex != null"> tabindex="{tabIndex}"</tpl><tpl foreach="arrowElAttributes"> {$}="{.}"</tpl>>{arrowElText}</span></tpl>',
    iconTpl: '<span id="{id}-btnIconEl" data-ref="btnIconEl" role="presentation" unselectable="on" class="{baseIconCls} {baseIconCls}-{ui} {iconCls} {glyphCls}{childElCls}" style="<tpl if="iconUrl">background-image:url({iconUrl});</tpl><tpl if="glyph && glyphFontFamily">font-family:{glyphFontFamily};</tpl>"><tpl if="glyph">&#{glyph};</tpl></span>',
    scale: "small",
    allowedScales: ["small", "medium", "large"],
    arrowAlign: "right",
    arrowCls: "arrow",
    maskOnDisable: false,
    shrinkWrap: 3,
    frame: true,
    autoEl: {tag: "a", hidefocus: "on", unselectable: "on"},
    hasFrameTable: function () {
        return this.href && this.frameTable
    },
    frameTableListener: function () {
        if (!this.disabled) {
            this.doNavigate()
        }
    },
    doNavigate: function () {
        if (this.hrefTarget === "_blank") {
            window.open(this.getHref(), this.hrefTarget)
        } else {
            location.href = this.getHref()
        }
    },
    _triggerRegion: {},
    initComponent: function () {
        var a = this;
        a.addCls("x-unselectable");
        Ext.Component.prototype.initComponent.call(this);
        if (a.menu) {
            a.split = true;
            a.setMenu(a.menu, false, true)
        }
        if (a.url) {
            a.href = a.url
        }
        a.configuredWithPreventDefault = a.hasOwnProperty("preventDefault");
        if (a.href && !a.configuredWithPreventDefault) {
            a.preventDefault = false
        }
        if (Ext.isString(a.toggleGroup) && a.toggleGroup !== "") {
            a.enableToggle = true
        }
        if (a.html && !a.text) {
            a.text = a.html;
            delete a.html
        }
    },
    getElConfig: function () {
        var c = this, b = Ext.Component.prototype.getElConfig.call(this), a = c.getHref(), d = c.hrefTarget;
        if (b.tag === "a") {
            if (!c.disabled) {
                b.tabIndex = c.tabIndex
            }
            if (a) {
                if (!c.disabled) {
                    b.href = a;
                    if (d) {
                        b.target = d
                    }
                }
            }
        }
        if (!c.ariaStaticRoles[c.ariaRole]) {
            if (c.menu && !c.isSplitButton) {
                b["aria-haspopup"] = true
            }
            if (c.enableToggle) {
                b["aria-pressed"] = !!c.pressed
            }
        }
        return b
    },
    beforeRender: function () {
        Ext.Component.prototype.beforeRender.call(this);
        if (this.pressed) {
            this.addCls(this._pressedCls)
        }
    },
    initRenderData: function () {
        return Ext.apply(Ext.Component.prototype.initRenderData.call(this), this.getTemplateArgs())
    },
    getMenu: function () {
        return this.menu || null
    },
    setMenu: function (i, h, e) {
        var g = this, b = g.menu, a = g.isSplitButton ? g.arrowEl && g.arrowEl.dom : g.ariaEl.dom, c, d;
        if (b && !e) {
            if (h !== false && g.destroyMenu) {
                b.destroy()
            }
            b.ownerCmp = null
        }
        if (i) {
            c = i.isMenu;
            i = Ext.menu.Manager.get(i, {ownerCmp: g});
            i.setOwnerCmp(g, c);
            i.menuClickBuffer = 250;
            g.mon(i, {scope: g, show: g.onMenuShow, hide: g.onMenuHide});
            if (!b && g.getArrowVisible()) {
                g.split = true;
                if (g.rendered) {
                    g._addSplitCls();
                    g.updateLayout()
                }
            }
            g.menu = i;
            if (a) {
                a.setAttribute("aria-haspopup", true);
                a.setAttribute("aria-owns", i.id)
            } else {
                d = g.isSplitButton ? (g.ariaArrowElAttributes || (g.ariaArrowElAttributes = {})) : (g.ariaRenderAttributes || (g.ariaRenderAttributes = {}));
                d["aria-haspopup"] = true;
                d["aria-owns"] = i.id
            }
        } else {
            if (g.rendered) {
                a.removeAttribute("aria-haspopup");
                a.removeAttribute("aria-owns");
                g._removeSplitCls();
                g.updateLayout()
            } else {
                d = g.isSplitButton ? g.ariaArrowElAttributes : g.ariaRenderAttributes;
                if (d) {
                    delete d["aria-haspopup"];
                    delete d["aria-owns"]
                }
            }
            g.split = false;
            g.menu = null
        }
    },
    onRender: function () {
        var c = this, d, a, b;
        Ext.Component.prototype.onRender.apply(this, arguments);
        a = c.el;
        if (c.tooltip) {
            c.setTooltip(c.tooltip, true)
        }
        if (c.handleMouseEvents) {
            b = {scope: c, mouseover: c.onMouseOver, mouseout: c.onMouseOut, mousedown: c.onMouseDown};
            if (c.split) {
                b.mousemove = c.onMouseMove
            }
        } else {
            b = {scope: c}
        }
        if (Ext.supports.Touch) {
            b.touchstart = c.onTouchStart
        }
        if (c.repeat) {
            c.mon(new Ext.util.ClickRepeater(a, Ext.isObject(c.repeat) ? c.repeat : {}), "click", c.onRepeatClick, c)
        } else {
            if (b[c.clickEvent]) {
                d = true
            } else {
                b[c.clickEvent] = c.onClick
            }
        }
        c.mon(a, b);
        if (c.hasFrameTable()) {
            c.mon(c.frameTable, "click", c.frameTableListener, c)
        }
        if (d) {
            c.mon(a, c.clickEvent, c.onClick, c)
        }
        Ext.button.Manager.register(c)
    },
    onFocusLeave: function (a) {
        Ext.Component.prototype.onFocusLeave.call(this, a);
        if (this.menu) {
            this.menu.hide()
        }
    },
    getTemplateArgs: function () {
        var i = this, c = i._btnCls, e = i._baseIconCls, a = i.getIconAlign(), j = i.glyph, h = Ext._glyphFontFamily,
            k = i.text, d = i._hasIcon(), g = i._hasIconCls, b;
        if (typeof j === "string") {
            b = j.split("@");
            j = b[0];
            h = b[1]
        }
        return {
            split: i.isSplitButton,
            innerCls: i._innerCls,
            splitCls: i.getArrowVisible() ? i.getSplitCls() : "",
            iconUrl: i.icon,
            iconCls: i.iconCls,
            glyph: j,
            glyphCls: j ? i._glyphCls : "",
            glyphFontFamily: h,
            text: k || "&#160;",
            closeText: i.closeText,
            textCls: k ? i._textCls : "",
            noTextCls: k ? "" : i._noTextCls,
            hasIconCls: d ? g : "",
            btnWrapCls: i._btnWrapCls,
            btnWrapStyle: i.width ? "table-layout:fixed;" : "",
            btnElStyle: i.height ? "height:auto;" : "",
            btnCls: c,
            baseIconCls: e,
            iconBeforeText: a === "left" || a === "top",
            iconAlignCls: d ? (g + "-" + a) : "",
            textAlignCls: c + "-" + i.getTextAlign(),
            arrowElCls: i._arrowElCls,
            tabIndex: i.tabIndex
        }
    },
    renderIcon: function (a) {
        return this.getTpl("iconTpl").apply(a)
    },
    setHref: function (a) {
        var b = this, d = b.hrefTarget, c;
        b.href = a;
        if (!b.configuredWithPreventDefault) {
            b.preventDefault = !a
        }
        if (b.rendered) {
            c = b.el.dom;
            if (!a || b.disabled) {
                c.removeAttribute("href");
                c.removeAttribute("hrefTarget")
            } else {
                c.href = b.getHref();
                if (d) {
                    c.target = d
                }
            }
        }
    },
    getHref: function () {
        var b = this, a = b.href;
        return a ? Ext.urlAppend(a, Ext.Object.toQueryString(Ext.apply({}, b.params, b.baseParams))) : false
    },
    setParams: function (c) {
        var a = this, b;
        a.params = c;
        if (a.rendered) {
            b = a.el.dom;
            if (a.disabled) {
                b.removeAttribute("href")
            } else {
                b.href = a.getHref() || ""
            }
        }
    },
    getSplitCls: function () {
        var a = this;
        return a.split ? (a.baseCls + "-" + a.arrowCls) + " " + (a.baseCls + "-" + a.arrowCls + "-" + a.arrowAlign) : ""
    },
    setIcon: function (b) {
        b = b || "";
        var c = this, a = c.btnIconEl, d = c.icon || "";
        c.icon = b;
        if (b !== d) {
            if (a) {
                a.setStyle("background-image", b ? "url(" + b + ")" : "");
                c._syncHasIconCls();
                if (c.didIconStateChange(d, b)) {
                    c.updateLayout()
                }
            }
            c.fireEvent("iconchange", c, d, b)
        }
        return c
    },
    setIconCls: function (b) {
        b = b || "";
        var d = this, a = d.btnIconEl, c = d.iconCls || "";
        d.iconCls = b;
        if (c !== b) {
            if (a) {
                a.removeCls(c);
                a.addCls(b);
                d._syncHasIconCls();
                if (d.didIconStateChange(c, b)) {
                    d.updateLayout()
                }
            }
            d.fireEvent("iconchange", d, c, b)
        }
        return d
    },
    setGlyph: function (g) {
        g = g || 0;
        var e = this, b = e.btnIconEl, c = e.glyph, h = e._glyphCls, a, d;
        e.glyph = g;
        if (b) {
            if (typeof g === "string") {
                d = g.split("@");
                g = d[0];
                a = d[1] || Ext._glyphFontFamily
            }
            if (!g) {
                b.dom.innerHTML = "";
                b.removeCls(h)
            } else {
                if (c !== g) {
                    b.dom.innerHTML = "&#" + g + ";";
                    b.addCls(h)
                }
            }
            if (a) {
                b.setStyle("font-family", a)
            }
            e._syncHasIconCls();
            if (e.didIconStateChange(c, g)) {
                e.updateLayout()
            }
        }
        e.fireEvent("glyphchange", e, e.glyph, c);
        return e
    },
    setTooltip: function (c, a) {
        var b = this;
        if (b.rendered) {
            if (!a || !c) {
                b.clearTip()
            }
            if (c) {
                if (Ext.quickTipsActive && Ext.isObject(c)) {
                    Ext.tip.QuickTipManager.register(Ext.apply({target: b.el.id}, c));
                    b.tooltip = c
                } else {
                    b.el.dom.setAttribute(b.getTipAttr(), c)
                }
            }
        } else {
            b.tooltip = c
        }
        return b
    },
    updateIconAlign: function (g, d) {
        var c = this, b, a, e;
        if (c.rendered) {
            b = c.btnEl;
            a = c.btnIconEl;
            e = c._hasIconCls;
            if (d) {
                b.removeCls(e + "-" + d)
            }
            b.addCls(e + "-" + g);
            if (g === "top" || g === "left") {
                b.insertFirst(a)
            } else {
                b.appendChild(a)
            }
            c.updateLayout()
        }
    },
    updateTextAlign: function (e, d) {
        var c = this, b = c.btnEl, a = c._btnCls;
        if (c.rendered) {
            b.removeCls(a + "-" + d);
            b.addCls(a + "-" + e)
        }
    },
    getTipAttr: function () {
        return this.tooltipType === "qtip" ? "data-qtip" : "title"
    },
    getRefItems: function (a) {
        var c = this.menu, b;
        if (c) {
            b = c.getRefItems(a);
            b.unshift(c)
        }
        return b || []
    },
    clearTip: function () {
        var b = this, a = b.el;
        if (Ext.quickTipsActive && Ext.isObject(b.tooltip)) {
            Ext.tip.QuickTipManager.unregister(a)
        } else {
            a.dom.removeAttribute(b.getTipAttr())
        }
    },
    beforeDestroy: function () {
        var a = this;
        if (a.rendered) {
            a.clearTip()
        }
        Ext.destroy(a.repeater);
        Ext.Component.prototype.beforeDestroy.call(this)
    },
    onDestroy: function () {
        var a = this, b = a.menu;
        if (a.rendered) {
            Ext.destroy(a.keyMap);
            delete a.keyMap
        }
        if (b && a.destroyMenu) {
            a.menu = Ext.destroy(b)
        }
        Ext.button.Manager.unregister(a);
        Ext.Component.prototype.onDestroy.call(this)
    },
    setHandler: function (b, a) {
        this.handler = b;
        if (arguments.length > 1) {
            this.scope = a
        }
        return this
    },
    updateText: function (d, a) {
        d = d == null ? "" : String(d);
        a = a || "";
        var c = this, e = c.btnInnerEl, b = c.btnEl;
        if (c.rendered) {
            e.setHtml(d || "&#160;");
            b[d ? "addCls" : "removeCls"](c._textCls);
            b[d ? "removeCls" : "addCls"](c._noTextCls);
            c.updateLayout()
        }
        c.fireEvent("textchange", c, a, d)
    },
    didIconStateChange: function (a, c) {
        var b = Ext.isEmpty(c);
        return Ext.isEmpty(a) ? !b : b
    },
    click: function (a) {
        return this.onClick(a)
    },
    setPressed: function (a) {
        return this.toggle(a !== false)
    },
    toggle: function (d, b) {
        var c = this, a = c.ariaEl.dom;
        d = d === undefined ? !c.pressed : !!d;
        if (c.fireEvent("beforetoggle", c, d) !== false) {
            if (d !== c.pressed) {
                c[d ? "addCls" : "removeCls"](c._pressedCls);
                c.pressed = d;
                if (a) {
                    a.setAttribute("aria-pressed", d)
                }
                if (!b) {
                    c.fireEvent("toggle", c, d);
                    Ext.callback(c.toggleHandler, c.scope, [c, d], 0, c);
                    if (c.reference && c.publishState) {
                        c.publishState("pressed", d)
                    }
                }
            }
        }
        return c
    },
    maybeShowMenu: function (a) {
        if (this.menu) {
            this.showMenu(a)
        }
    },
    showMenu: function (a) {
        var c = this, d = c.menu, b = !a || a.pointerType;
        if (d && c.rendered) {
            if (c.tooltip && Ext.quickTipsActive && c.getTipAttr() !== "title") {
                Ext.tip.QuickTipManager.getQuickTip().cancelShow(c.el)
            }
            if (d.isVisible()) {
                if (b) {
                    d.hide()
                } else {
                    d.focus()
                }
            } else {
                if (!a || c.showEmptyMenu || d.items.getCount() > 0) {
                    d.autoFocus = !b;
                    d.showBy(c.el, c.menuAlign)
                }
            }
        }
        return c
    },
    hideMenu: function () {
        if (this.hasVisibleMenu()) {
            this.menu.hide()
        }
        return this
    },
    hasVisibleMenu: function () {
        var a = this.menu;
        return a && a.rendered && a.isVisible()
    },
    onRepeatClick: function (a, b) {
        this.onClick(b)
    },
    onTouchStart: function (a) {
        this.doPreventDefault(a)
    },
    onEnterKey: function (a) {
        this.onClick(a);
        a.stopEvent();
        return false
    },
    onClick: function (b) {
        var a = this;
        a.doPreventDefault(b);
        if (b.type !== "keydown" && b.button) {
            return
        }
        if (!a.disabled) {
            a.doToggle();
            a.maybeShowMenu(b);
            a.fireHandler(b)
        }
    },
    doPreventDefault: function (a) {
        if (a && (this.preventDefault || (this.disabled && this.getHref()))) {
            a.preventDefault()
        }
    },
    fireHandler: function (b) {
        var a = this;
        if (a.fireEvent("click", a, b) !== false && !a.destroyed) {
            Ext.callback(a.handler, a.scope, [a, b], 0, a)
        }
    },
    doToggle: function () {
        var a = this;
        if (a.enableToggle && (a.allowDepress !== false || !a.pressed)) {
            a.toggle()
        }
    },
    onMouseOver: function (b) {
        var a = this;
        if (!a.disabled && !b.within(a.el, true, true)) {
            a.onMouseEnter(b)
        }
    },
    onMouseOut: function (b) {
        var a = this;
        if (!b.within(a.el, true, true)) {
            if (a.overMenuTrigger) {
                a.onMenuTriggerOut(b)
            }
            a.onMouseLeave(b)
        }
    },
    onMouseMove: function (c) {
        var a = this, b = a.overMenuTrigger;
        if (a.split) {
            if (a.isWithinTrigger(c)) {
                if (!b) {
                    a.onMenuTriggerOver(c)
                }
            } else {
                if (b) {
                    a.onMenuTriggerOut(c)
                }
            }
        }
    },
    isWithinTrigger: function (d) {
        var c = this, b = c.el, g, a;
        g = (c.arrowAlign === "right") ? d.getX() - c.getX() : d.getY() - b.getY();
        a = c.getTriggerRegion();
        return g > a.begin && g < a.end
    },
    getTriggerRegion: function () {
        var d = this, e = d._triggerRegion, c = d.arrowAlign === "right", b = c ? "getRight" : "getBottom",
            a = c ? d.getWidth() : d.getHeight();
        e.begin = a - (d.el[b]() - d.btnEl[b]());
        e.end = a;
        return e
    },
    onMouseEnter: function (a) {
        this.fireEvent("mouseover", this, a)
    },
    onMouseLeave: function (a) {
        this.fireEvent("mouseout", this, a)
    },
    onMenuTriggerOver: function (c) {
        var b = this, a = b.arrowTooltip;
        b.overMenuTrigger = true;
        if (b.split && a) {
            b.btnWrap.dom.setAttribute(b.getTipAttr(), a)
        }
        b.fireEvent("menutriggerover", b, b.menu, c)
    },
    onMenuTriggerOut: function (b) {
        var a = this;
        delete a.overMenuTrigger;
        if (a.split && a.arrowTooltip) {
            a.btnWrap.dom.setAttribute(a.getTipAttr(), "")
        }
        a.fireEvent("menutriggerout", a, a.menu, b)
    },
    onEnable: function () {
        var b = this, a = b.href, d = b.hrefTarget, c = b.el.dom;
        Ext.Component.prototype.onEnable.call(this);
        b.removeCls(b._disabledCls);
        c.setAttribute("tabIndex", b.tabIndex);
        if (a) {
            c.href = a
        }
        if (d) {
            c.target = d
        }
    },
    onDisable: function () {
        var a = this, b = a.el.dom;
        Ext.Component.prototype.onDisable.call(this);
        a.addCls(a._disabledCls);
        a.removeCls(a.overCls);
        b.removeAttribute("tabIndex");
        if (a.href) {
            b.removeAttribute("href")
        }
        if (a.hrefTarget) {
            b.removeAttribute("target")
        }
    },
    setScale: function (c) {
        var a = this, b = a.ui.replace("-" + a.scale, "");
        if (!Ext.Array.contains(a.allowedScales, c)) {
            throw ("#setScale: scale must be an allowed scale (" + a.allowedScales.join(", ") + ")")
        }
        a.scale = c;
        a.setUI(b)
    },
    setUI: function (b) {
        var a = this;
        if (a.scale && !b.match(a.scale)) {
            b = b + "-" + a.scale
        }
        Ext.Component.prototype.setUI.call(this, b)
    },
    onMouseDown: function (b) {
        var a = this;
        if (Ext.isIE || b.pointerType === "touch") {
            Ext.defer(function () {
                var c = a.getFocusEl();
                if (c && !b.defaultPrevented) {
                    c.focus()
                }
            }, 1)
        }
        if (!a.disabled && b.button === 0) {
            Ext.button.Manager.onButtonMousedown(a, b);
            a.addCls(a._pressedCls)
        }
    },
    onMouseUp: function (b) {
        var a = this;
        if (!a.destroyed && b.button === 0) {
            if (!a.pressed) {
                a.removeCls(a._pressedCls)
            }
        }
    },
    onMenuShow: function () {
        var a = this;
        a.addCls(a._menuActiveCls);
        a.fireEvent("menushow", a, a.menu)
    },
    onMenuHide: function (b) {
        var a = this;
        a.removeCls(a._menuActiveCls);
        a.fireEvent("menuhide", a, a.menu)
    },
    onDownKey: function (b) {
        var a = this;
        if (a.menu && !a.disabled) {
            a.showMenu(b);
            b.stopEvent();
            return false
        }
    },
    updateArrowVisible: function (b) {
        var a = this;
        if (a.rendered) {
            if (b) {
                if (a.menu || a.isSplitButton) {
                    a.split = true;
                    a._addSplitCls()
                }
            } else {
                a._removeSplitCls();
                a.split = false
            }
        }
        return b
    },
    privates: {
        addOverCls: function () {
            if (!this.disabled) {
                this.addCls(this.overCls)
            }
        }, _addSplitCls: function () {
            var a = this;
            a.btnWrap.addCls(a.getSplitCls())
        }, getTdCls: function () {
            return "x-button-" + this.ui + "-" + this.scale + "-cell"
        }, removeOverCls: function () {
            this.removeCls(this.overCls)
        }, _removeSplitCls: function () {
            var a = this;
            a.btnWrap.removeCls(a.getSplitCls())
        }, _syncHasIconCls: function () {
            var b = this, a = b.btnEl, c = b._hasIconCls;
            if (a) {
                a[b._hasIcon() ? "addCls" : "removeCls"]([c, c + "-" + b.iconAlign])
            }
        }, _hasIcon: function () {
            return !!(this.icon || this.iconCls || this.glyph)
        }, wrapPrimaryEl: function (a) {
            this.el = new Ext.dom.ButtonElement(a);
            Ext.Component.prototype.wrapPrimaryEl.call(this, a)
        }
    }
}, 0, ["button"], ["component", "box", "button"], {
    component: true,
    box: true,
    button: true
}, ["widget.button"], [[Ext.mixin.Queryable.prototype.mixinId || Ext.mixin.Queryable.$className, Ext.mixin.Queryable], [Ext.util.KeyboardInteractive.prototype.mixinId || Ext.util.KeyboardInteractive.$className, Ext.util.KeyboardInteractive]], [Ext.button, "Button", Ext, "Button"], 0));
(Ext.cmd.derive("Ext.button.Split", Ext.button.Button, {
    alternateClassName: "Ext.SplitButton",
    isSplitButton: true,
    arrowCls: "split",
    split: true,
    getTemplateArgs: function () {
        var b = this, a, c;
        c = Ext.button.Button.prototype.getTemplateArgs.call(this);
        if (b.disabled) {
            c.tabIndex = null
        }
        a = b.ariaArrowElAttributes || {};
        a["aria-hidden"] = !!b.hidden;
        a["aria-disabled"] = !!b.disabled;
        if (b.arrowTooltip) {
            a["aria-label"] = b.arrowTooltip
        } else {
            a["aria-labelledby"] = b.id
        }
        c.arrowElAttributes = a;
        return c
    },
    onRender: function () {
        var b = this, a;
        Ext.button.Button.prototype.onRender.call(this);
        a = b.getFocusEl();
        if (a) {
            a.on({scope: b, focus: b.onMainElFocus, blur: b.onMainElBlur})
        }
        a = b.arrowEl;
        if (a) {
            a.dom.setAttribute(Ext.Component.componentIdAttribute, b.id);
            a.setVisibilityMode(Ext.dom.Element.DISPLAY);
            a.on({scope: b, focus: b.onArrowElFocus, blur: b.onArrowElBlur})
        }
    },
    setArrowHandler: function (b, a) {
        this.arrowHandler = b;
        this.scope = a
    },
    onClick: function (c) {
        var b = this, a = c.type === "keydown" && c.target === b.arrowEl.dom;
        b.doPreventDefault(c);
        if (!b.disabled) {
            if (a || b.isWithinTrigger(c)) {
                c.preventDefault();
                b.maybeShowMenu(c);
                b.fireEvent("arrowclick", b, c);
                if (b.arrowHandler) {
                    b.arrowHandler.call(b.scope || b, b, c)
                }
            } else {
                b.doToggle();
                b.fireHandler(c)
            }
        }
    },
    enable: function (b) {
        var c = this, a = c.arrowEl;
        Ext.button.Button.prototype.enable.call(this, b);
        if (a) {
            a.dom.setAttribute("tabIndex", c.tabIndex);
            a.dom.setAttribute("aria-disabled", "false")
        }
    },
    disable: function (b) {
        var c = this, a = c.arrowEl;
        Ext.button.Button.prototype.disable.call(this, b);
        if (a) {
            a.dom.removeAttribute("tabIndex");
            a.dom.setAttribute("aria-disabled", "true")
        }
    },
    afterHide: function (a, b) {
        Ext.button.Button.prototype.afterHide.call(this, a, b);
        this.arrowEl.dom.setAttribute("aria-hidden", "true")
    },
    afterShow: function (c, a, b) {
        Ext.button.Button.prototype.afterShow.call(this, c, a, b);
        this.arrowEl.dom.setAttribute("aria-hidden", "false")
    },
    privates: {
        isFocusing: function (d) {
            var c = this, h = d.fromElement, g = d.toElement, b = c.focusEl && c.focusEl.dom,
                a = c.arrowEl && c.arrowEl.dom;
            if (c.focusable) {
                if (g === b) {
                    return h === a ? false : true
                } else {
                    if (g === a) {
                        return h === b ? false : true
                    }
                }
                return true
            }
            return false
        }, isBlurring: function (d) {
            var c = this, h = d.fromElement, g = d.toElement, b = c.focusEl && c.focusEl.dom,
                a = c.arrowEl && c.arrowEl.dom;
            if (c.focusable) {
                if (h === b) {
                    return g === a ? false : true
                } else {
                    if (h === a) {
                        return g === b ? false : true
                    }
                }
                return true
            }
            return false
        }, getFocusClsEl: Ext.privateFn, onMainElFocus: function (a) {
            this.el.addCls(this._focusCls)
        }, onMainElBlur: function (a) {
            this.el.removeCls(this._focusCls)
        }, onArrowElFocus: function (a) {
            this.el.addCls(this._arrowFocusCls)
        }, onArrowElBlur: function () {
            this.el.removeCls(this._arrowFocusCls)
        }, setTabIndex: function (a) {
            Ext.button.Button.prototype.setTabIndex.call(this, a);
            if (this.arrowEl) {
                this.arrowEl.set({tabIndex: a})
            }
        }, _addSplitCls: function () {
            var a = this.arrowEl;
            Ext.button.Button.prototype._addSplitCls.call(this);
            a.dom.setAttribute("tabIndex", this.tabIndex);
            a.setVisible(true)
        }, _removeSplitCls: function () {
            var a = this.arrowEl;
            Ext.button.Button.prototype._removeSplitCls.call(this);
            a.dom.removeAttribute("tabIndex");
            a.setVisible(false)
        }
    }
}, 0, ["splitbutton"], ["component", "box", "button", "splitbutton"], {
    component: true,
    box: true,
    button: true,
    splitbutton: true
}, ["widget.splitbutton"], 0, [Ext.button, "Split", Ext, "SplitButton"], 0));
(Ext.cmd.derive("Ext.button.Cycle", Ext.button.Split, {
    alternateClassName: "Ext.CycleButton", getButtonText: function (b) {
        var a = this, c = "";
        if (b && a.showText === true) {
            if (a.prependText) {
                c += a.prependText
            }
            c += b.text;
            return c
        }
        return a.text
    }, setActiveItem: function (g, a) {
        var e = this, b = e.changeHandler, d = e.forceIcon, c = e.forceGlyph;
        e.settingActive = true;
        if (!Ext.isObject(g)) {
            g = e.menu.getComponent(g)
        }
        if (g) {
            e.setText(e.getButtonText(g));
            e.setIconCls(d ? d : g.iconCls);
            e.setGlyph(c ? c : g.glyph);
            e.activeItem = g;
            if (!g.checked) {
                g.setChecked(true, false)
            }
            if (!a) {
                if (b) {
                    Ext.callback(b, e.scope, [e, g], 0, e)
                }
                e.fireEvent("change", e, g)
            }
        }
        e.settingActive = false
    }, getActiveItem: function () {
        return this.activeItem
    }, initComponent: function () {
        var g = this, e = 0, b, c, a, d;
        b = (g.menu.items || []).concat(g.items || []);
        g.menu = Ext.applyIf({cls: "x-cycle-menu", items: []}, g.menu);
        a = b.length;
        for (c = 0; c < a; c++) {
            d = b[c];
            d = Ext.applyIf({
                group: g.id,
                itemIndex: c,
                checkHandler: g.checkHandler,
                scope: g,
                checked: d.checked || false
            }, d);
            g.menu.items.push(d);
            if (d.checked) {
                e = c
            }
        }
        g.itemCount = g.menu.items.length;
        Ext.button.Split.prototype.initComponent.apply(this, arguments);
        g.on("click", g.toggleSelected, g);
        g.setActiveItem(e, true)
    }, checkHandler: function (a, b) {
        if (b && !this.settingActive) {
            this.setActiveItem(a)
        }
    }, toggleSelected: function () {
        var c = this, a = c.menu, b;
        b = c.activeItem.next(":not([disabled])") || a.items.getAt(0);
        b.setChecked(true)
    }
}, 0, ["cycle"], ["component", "box", "button", "splitbutton", "cycle"], {
    component: true,
    box: true,
    button: true,
    splitbutton: true,
    cycle: true
}, ["widget.cycle"], 0, [Ext.button, "Cycle", Ext, "CycleButton"], 0));
(Ext.cmd.derive("Ext.layout.container.SegmentedButton", Ext.layout.container.Container, {
    needsItemSize: false,
    setsItemSize: false,
    _btnRowCls: "x-segmented-button-row",
    getRenderTree: function () {
        var d = this, a = Ext.layout.container.Container.prototype.getRenderTree.call(this), b, c;
        if (d.owner.getVertical()) {
            for (b = 0, c = a.length; b < c; b++) {
                a[b] = {cls: d._btnRowCls, cn: a[b]}
            }
        }
        return a
    },
    getItemLayoutEl: function (a) {
        var b = a.el.dom;
        return this.owner.getVertical() ? b.parentNode : b
    },
    onDestroy: function () {
        if (this.rendered) {
            var b = this.getRenderTarget(), a;
            while ((a = b.last())) {
                a.destroy()
            }
        }
    }
}, 0, 0, 0, 0, ["layout.segmentedbutton"], 0, [Ext.layout.container, "SegmentedButton"], 0));
(Ext.cmd.derive("Ext.button.Segmented", Ext.container.Container, {
    config: {
        allowDepress: false,
        allowMultiple: false,
        forceSelection: false,
        allowToggle: true,
        vertical: false,
        defaultUI: "default"
    },
    beforeRenderConfig: {value: undefined},
    defaultBindProperty: "value",
    publishes: ["value"],
    twoWayBindable: ["value"],
    layout: "segmentedbutton",
    defaultType: "button",
    maskOnDisable: false,
    isSegmentedButton: true,
    baseCls: "x-segmented-button",
    itemCls: "x-segmented-button-item",
    _firstCls: "x-segmented-button-first",
    _lastCls: "x-segmented-button-last",
    _middleCls: "x-segmented-button-middle",
    applyValue: function (k, a) {
        var j = this, n = j.getAllowMultiple(), d, e, l, m, h, c, g, b;
        l = (k instanceof Array) ? k : (k == null) ? [] : [k];
        m = (a instanceof Array) ? a : (a == null) ? [] : [a];
        j._isApplyingValue = true;
        if (!j.rendered) {
            h = j.items.items;
            for (c = h.length - 1; c >= 0; c--) {
                e = h[c];
                if (j.forceSelection && !c && !b) {
                    e.pressed = true
                }
                if (e.pressed) {
                    b = true;
                    d = e.value;
                    if (d == null) {
                        d = j.items.indexOf(e)
                    }
                    if (!Ext.Array.contains(l, d)) {
                        l.unshift(d)
                    }
                }
            }
        }
        g = l.length;
        for (c = 0; c < g; c++) {
            k = l[c];
            e = j._lookupButtonByValue(k);
            if (e) {
                d = e.value;
                if ((d != null) && d !== k) {
                    l[c] = d
                }
                if (!e.pressed) {
                    e.setPressed(true)
                }
            }
        }
        k = n ? l : g ? l[0] : null;
        for (c = 0, g = m.length; c < g; c++) {
            a = m[c];
            if (!Ext.Array.contains(l, a)) {
                j._lookupButtonByValue(a).setPressed(false)
            }
        }
        j._isApplyingValue = false;
        if (j.hasListeners.change && !Ext.Array.equals(l, m)) {
            j.fireEvent("change", j, l, m)
        }
        return k
    },
    beforeRender: function () {
        var a = this;
        a.addCls(a.baseCls + a._getClsSuffix());
        a._syncItemClasses(true);
        Ext.container.Container.prototype.beforeRender.call(this)
    },
    onAdd: function (c) {
        var b = this, a = "_syncItemClasses";
        b.mon(c, {hide: a, show: a, beforetoggle: "_onBeforeItemToggle", toggle: "_onItemToggle", scope: b});
        if (b.getAllowToggle()) {
            c.enableToggle = true;
            if (!b.getAllowMultiple()) {
                c.toggleGroup = b.getId();
                c.allowDepress = b.getAllowDepress()
            }
        }
        c.addCls(b.itemCls + b._getClsSuffix());
        b._syncItemClasses();
        Ext.container.Container.prototype.onAdd.call(this, c)
    },
    onRemove: function (b) {
        var a = this;
        b.removeCls(a.itemCls + a._getClsSuffix());
        a._syncItemClasses();
        Ext.container.Container.prototype.onRemove.call(this, b)
    },
    beforeLayout: function () {
        if (Ext.isChrome) {
            this.el.dom.offsetWidth
        }
        Ext.container.Container.prototype.beforeLayout.call(this)
    },
    updateDefaultUI: function (e) {
        var a = this.items, d, b, c;
        if (this.rendered) {
            Ext.raise("Changing the ui config of a segmented button after render is not supported.")
        } else {
            if (a) {
                if (a.items) {
                    a = a.items
                }
                for (b = 0, c = a.length; b < c; b++) {
                    d = a[b];
                    if (d.ui === "default" && e !== "default" && !d.hasOwnProperty("ui")) {
                        a[b].ui = e
                    }
                }
            }
        }
    },
    privates: {
        _getClsSuffix: function () {
            return this.getVertical() ? "-vertical" : "-horizontal"
        }, _getFirstCls: function () {
            return this._firstCls
        }, _getLastCls: function () {
            return this._lastCls
        }, _lookupButtonByValue: function (h) {
            var b = this.items.items, g = b.length, e = 0, d = null, a, c;
            for (; e < g; e++) {
                c = b[e];
                a = c.value;
                if ((a != null) && a === h) {
                    d = c;
                    break
                }
            }
            if (!d && typeof h === "number") {
                d = b[h]
            }
            return d
        }, _onBeforeItemToggle: function (a, b) {
            if (this.allowMultiple && this.forceSelection && !b && this.getValue().length === 1) {
                return false
            }
        }, _onItemToggle: function (c, h) {
            if (this._isApplyingValue) {
                return
            }
            var e = this, d = Ext.Array, b = e.allowMultiple, a = (c.value != null) ? c.value : e.items.indexOf(c),
                g = e.getValue(), i;
            if (b) {
                i = d.indexOf(g, a)
            }
            if (h) {
                if (b) {
                    if (i === -1) {
                        g = d.slice(g);
                        g.push(a)
                    }
                } else {
                    g = a
                }
            } else {
                if (b) {
                    if (i > -1) {
                        g = d.slice(g);
                        g.splice(i, 1)
                    }
                } else {
                    if (g === a) {
                        g = null
                    }
                }
            }
            e.setValue(g);
            e.fireEvent("toggle", e, c, h)
        }, _syncItemClasses: function (a) {
            var h = this, b, d, k, g, e, l, j, c;
            if (!a && !h.rendered) {
                return
            }
            b = h._getFirstCls();
            d = h._middleCls;
            k = h._getLastCls();
            g = h.items.items;
            e = g.length;
            l = [];
            for (c = 0; c < e; c++) {
                j = g[c];
                if (!j.hidden) {
                    l.push(j)
                }
            }
            e = l.length;
            for (c = 0; c < e; c++) {
                l[c].removeCls([b, d, k])
            }
            if (e > 1) {
                l[0].addCls(b);
                for (c = 1; c < e - 1; c++) {
                    l[c].addCls(d)
                }
                l[e - 1].addCls(k)
            }
        }
    }
}, 0, ["segmentedbutton"], ["component", "box", "container", "segmentedbutton"], {
    component: true,
    box: true,
    container: true,
    segmentedbutton: true
}, ["widget.segmentedbutton"], 0, [Ext.button, "Segmented"], 0));
(Ext.cmd.derive("Ext.panel.Bar", Ext.container.Container, {
    vertical: false, _verticalSides: {left: 1, right: 1}, initComponent: function () {
        var b = this, a = b.vertical;
        b.dock = b.dock || (a ? "left" : "top");
        b.layout = Ext.apply(a ? {type: "vbox", align: "middle", alignRoundingMethod: "ceil"} : {
            type: "hbox",
            align: "middle",
            alignRoundingMethod: "floor"
        }, b.layout);
        Ext.container.Container.prototype.initComponent.call(this)
    }, onAdded: function (b, c, a) {
        this.initOrientation();
        Ext.container.Container.prototype.onAdded.call(this, b, c, a)
    }, onRemoved: function (a) {
        this.removeClsWithUI(this.uiCls);
        Ext.container.Container.prototype.onRemoved.call(this, a)
    }, beforeRender: function () {
        var a = this;
        if (a.forceOrientation || !a.ownerCt) {
            a.initOrientation()
        }
        Ext.container.Container.prototype.beforeRender.call(this)
    }, setDock: function (d) {
        var c = this, b, a;
        if (d !== c.dock) {
            Ext.suspendLayouts();
            c.clearOrientation();
            Ext.container.Container.prototype.setDock.call(this, d);
            c.initOrientation();
            a = c.vertical;
            b = c.layout;
            b.setVertical(a);
            b.setAlignRoundingMethod(a ? "ceil" : "floor");
            Ext.resumeLayouts(true)
        }
    }, privates: {
        clearOrientation: function () {
            this.removeClsWithUI([this.vertical ? "vertical" : "horizontal", this.getDockName()])
        }, getDockName: function () {
            return this.dock
        }, initOrientation: function () {
            var c = this, b = c.dock, a = (c.vertical = (b ? b in c._verticalSides : c.vertical));
            c.addClsWithUI([a ? "vertical" : "horizontal", c.getDockName()])
        }
    }
}, 0, 0, ["component", "box", "container"], {
    component: true,
    box: true,
    container: true
}, 0, 0, [Ext.panel, "Bar"], 0));
(Ext.cmd.derive("Ext.panel.Title", Ext.Component, {
    isTitle: true,
    noWrap: true,
    textAlign: "left",
    iconAlign: "left",
    rotation: 0,
    text: "&#160;",
    beforeRenderConfig: {
        textAlign: null,
        text: null,
        glyph: null,
        icon: null,
        iconAlign: null,
        iconCls: null,
        rotation: null
    },
    autoEl: {role: "presentation", unselectable: "on"},
    textElRole: "presentation",
    tabIndex: 0,
    childEls: ["textEl", "iconEl", "iconWrapEl"],
    renderTpl: '<tpl if="iconMarkup && iconBeforeTitle">{iconMarkup}</tpl><div id="{id}-textEl" data-ref="textEl" class="{textCls} {textCls}-{ui} {itemCls}{childElCls}" unselectable="on"<tpl if="textElRole"> role="{textElRole}"</tpl>>{text}</div><tpl if="iconMarkup && !iconBeforeTitle">{iconMarkup}</tpl>',
    iconTpl: '<div id="{id}-iconWrapEl" data-ref="iconWrapEl" role="presentation" class="{iconWrapCls} {iconWrapCls}-{ui} {iconAlignCls} {itemCls}{childElCls}"<tpl if="iconWrapStyle"> style="{iconWrapStyle}"</tpl>><div id="{id}-iconEl" data-ref="iconEl" role="presentation" unselectable="on" class="{baseIconCls} {baseIconCls}-{ui} {iconCls} {glyphCls}" style="<tpl if="iconUrl">background-image:url({iconUrl});</tpl><tpl if="glyph && glyphFontFamily">font-family:{glyphFontFamily};</tpl>"><tpl if="glyph">&#{glyph};</tpl></div></div>',
    _textAlignClasses: {left: "x-title-align-left", center: "x-title-align-center", right: "x-title-align-right"},
    _iconAlignClasses: {
        top: "x-title-icon-top",
        right: "x-title-icon-right",
        bottom: "x-title-icon-bottom",
        left: "x-title-icon-left"
    },
    _rotationClasses: {0: "x-title-rotate-none", 1: "x-title-rotate-right", 2: "x-title-rotate-left"},
    _rotationAngles: {1: 90, 2: 270},
    baseCls: "x-title",
    _titleSuffix: "-title",
    _glyphCls: "x-title-glyph",
    _iconWrapCls: "x-title-icon-wrap",
    _baseIconCls: "x-title-icon",
    _itemCls: "x-title-item",
    _textCls: "x-title-text",
    afterComponentLayout: function () {
        var d = this, b = d.getRotation(), a, e, c;
        if (b && !Ext.isIE8) {
            c = d.el;
            a = d.lastBox;
            e = a.x;
            c.setStyle(d._getVerticalAdjustDirection(), (e + ((b === 1) ? a.width : -a.height)) + "px")
        }
        Ext.Component.prototype.afterComponentLayout.call(this)
    },
    onRender: function () {
        var c = this, a = c.getRotation(), b = c.el;
        Ext.Component.prototype.onRender.call(this);
        if (a) {
            b.setVertical(c._rotationAngles[a])
        }
        if (Ext.supports.FixedTableWidthBug) {
            b._needsTableWidthFix = true
        }
    },
    applyText: function (a) {
        if (!a) {
            a = "&#160;"
        }
        return a
    },
    beforeRender: function () {
        var a = this;
        Ext.Component.prototype.beforeRender.call(this);
        a.addCls(a._rotationClasses[a.getRotation()]);
        a.addCls(a._textAlignClasses[a.getTextAlign()])
    },
    getIconMarkup: function () {
        return this.getTpl("iconTpl").apply(this.getIconRenderData())
    },
    getIconRenderData: function () {
        var g = this, c = g.getIcon(), b = g.getIconCls(), e = g.getGlyph(), h = Ext._glyphFontFamily,
            a = g.getIconAlign(), d;
        if (typeof e === "string") {
            d = e.split("@");
            e = d[0];
            h = d[1]
        }
        return {
            id: g.id,
            ui: g.ui,
            itemCls: g._itemCls,
            iconUrl: c,
            iconCls: b,
            iconWrapCls: g._iconWrapCls,
            baseIconCls: g._baseIconCls,
            iconAlignCls: g._iconAlignClasses[a],
            glyph: e,
            glyphCls: e ? g._glyphCls : "",
            glyphFontFamily: h
        }
    },
    initRenderData: function () {
        var b = this, a, c;
        c = Ext.apply({
            text: b.getText(),
            textElRole: b.textElRole,
            id: b.id,
            ui: b.ui,
            itemCls: b._itemCls,
            textCls: b._textCls,
            iconMarkup: null,
            iconBeforeTitle: null
        }, Ext.Component.prototype.initRenderData.call(this));
        if (b._hasIcon()) {
            a = b.getIconAlign();
            c.iconMarkup = b.getIconMarkup();
            c.iconBeforeTitle = (a === "top" || a === "left")
        }
        return c
    },
    onAdded: function (b, g, a) {
        var d = this, e = d._titleSuffix, c = b.baseCls;
        d.addCls([c + e, c + e + "-" + b.ui]);
        Ext.Component.prototype.onAdded.call(this, b, g, a)
    },
    updateGlyph: function (g, c) {
        g = g || 0;
        var e = this, h = e._glyphCls, b, a, d;
        e.glyph = g;
        if (e.rendered) {
            e._syncIconVisibility();
            b = e.iconEl;
            if (typeof g === "string") {
                d = g.split("@");
                g = d[0];
                a = d[1] || Ext._glyphFontFamily
            }
            if (!g) {
                b.dom.innerHTML = "";
                b.removeCls(h)
            } else {
                if (c !== g) {
                    b.dom.innerHTML = "&#" + g + ";";
                    b.addCls(h)
                }
            }
            if (a) {
                b.setStyle("font-family", a)
            }
            if (e._didIconStateChange(c, g)) {
                e.updateLayout()
            }
        }
    },
    updateIcon: function (b, d) {
        b = b || "";
        var c = this, a;
        if (c.rendered && b !== d) {
            c._syncIconVisibility();
            a = c.iconEl;
            a.setStyle("background-image", b ? "url(" + b + ")" : "");
            if (c._didIconStateChange(d, b)) {
                c.updateLayout()
            }
        }
    },
    updateIconAlign: function (g, c) {
        var b = this, e = b.iconWrapEl, a, d;
        if (b.iconWrapEl) {
            a = b.el;
            d = b._iconAlignClasses;
            if (c) {
                e.removeCls(d[c])
            }
            e.addCls(d[g]);
            if (g === "top" || g === "left") {
                a.insertFirst(e)
            } else {
                a.appendChild(e)
            }
            b.updateLayout()
        }
    },
    updateIconCls: function (b, c) {
        b = b || "";
        var d = this, a;
        if (d.rendered && c !== b) {
            d._syncIconVisibility();
            a = d.iconEl;
            if (c) {
                a.removeCls(c)
            }
            a.addCls(b);
            if (d._didIconStateChange(c, b)) {
                d.updateLayout()
            }
        }
    },
    updateRotation: function (b, a) {
        var d = this, c, e;
        if (d.rendered) {
            c = d.el;
            e = d._rotationClasses;
            d.removeCls(e[a]);
            d.addCls(e[b]);
            c.setHorizontal();
            if (b) {
                c.setVertical(d._rotationAngles[b])
            }
            c.setStyle({right: "", left: "", top: "", height: "", width: ""});
            d.lastBox = null;
            d.updateLayout()
        }
    },
    updateText: function (a) {
        if (this.rendered) {
            this.textEl.setHtml(a);
            this.updateLayout()
        }
    },
    updateTextAlign: function (d, b) {
        var a = this, c = a._textAlignClasses;
        if (a.rendered) {
            if (b) {
                a.removeCls(c[b])
            }
            a.addCls(c[d]);
            a.updateLayout()
        }
    },
    privates: {
        _getVerticalAdjustDirection: function () {
            return "left"
        }, _didIconStateChange: function (a, c) {
            var b = Ext.isEmpty(c);
            return Ext.isEmpty(a) ? !b : b
        }, _hasIcon: function () {
            return !!(this.getIcon() || this.getIconCls() || this.getGlyph())
        }, _syncIconVisibility: function () {
            var e = this, d = e.el, a = e._hasIcon(), g = e.iconWrapEl, c, b;
            if (a && !g) {
                b = e.iconAlign;
                c = (b === "left" || b === "top");
                d.dom.insertAdjacentHTML(c ? "afterbegin" : "beforeend", e.getIconMarkup());
                g = e.iconWrapEl = d[c ? "first" : "last"]();
                e.iconEl = g.first()
            }
            if (g) {
                g.setDisplayed(a)
            }
        }
    }
}, 0, ["title"], ["component", "box", "title"], {
    component: true,
    box: true,
    title: true
}, ["widget.title"], 0, [Ext.panel, "Title"], 0));
(Ext.cmd.derive("Ext.panel.Tool", Ext.Component, {
    isTool: true,
    baseCls: "x-tool",
    disabledCls: "x-tool-disabled",
    toolPressedCls: "x-tool-pressed",
    toolOverCls: "x-tool-over",
    childEls: ["toolEl"],
    renderTpl: ['<div id="{id}-toolEl" data-ref="toolEl" class="{baseCls}-img {baseCls}-{type}{childElCls}" role="presentation"></div>'],
    toolOwner: null,
    tooltipType: "qtip",
    stopEvent: true,
    ariaRole: "button",
    focusable: true,
    tabIndex: 0,
    keyHandlers: {SPACE: "onClick", ENTER: "onClick"},
    cacheHeight: true,
    cacheWidth: true,
    initComponent: function () {
        var a = this;
        a.type = a.type || a.id;
        Ext.applyIf(a.renderData, {baseCls: a.baseCls, type: a.type});
        a.tooltip = a.tooltip || a.qtip;
        Ext.Component.prototype.initComponent.call(this)
    },
    afterRender: function () {
        var a = this, b;
        Ext.Component.prototype.afterRender.apply(this, arguments);
        a.el.on({
            click: a.onClick,
            mousedown: a.onMouseDown,
            mouseover: a.onMouseOver,
            mouseout: a.onMouseOut,
            scope: a
        });
        b = a.tooltip;
        if (b) {
            a.setTooltip(b)
        }
    },
    tipAttrs: {qtip: "data-qtip"},
    setTooltip: function (h, d) {
        var e = this, b = e.tooltip, g = e.tooltipType, i = e.id, c = e.el, a;
        if (b && Ext.quickTipsActive && Ext.isObject(b)) {
            Ext.tip.QuickTipManager.unregister(i)
        }
        e.tooltip = h;
        if (d) {
            e.tooltipType = d
        }
        if (h) {
            if (Ext.quickTipsActive && Ext.isObject(h)) {
                Ext.tip.QuickTipManager.register(Ext.apply({target: i}, h))
            } else {
                if (c) {
                    if (d && g && d !== g) {
                        a = e.tipAttrs[g] || "title";
                        c.dom.removeAttribute(a)
                    }
                    a = e.tipAttrs[d || g] || "title";
                    c.dom.setAttribute(a, h)
                }
            }
            if (a !== "title" && e.ariaRole && e.ariaRole !== "presentation") {
                if (c) {
                    c.dom.setAttribute("aria-label", h)
                } else {
                    e.ariaRenderAttributes = e.ariaRenderAttributes || {};
                    e.ariaRenderAttributes["aria-label"] = h
                }
            }
        }
    },
    setType: function (a) {
        var b = this, c = b.type;
        b.type = a;
        if (b.rendered) {
            if (c) {
                b.toolEl.removeCls(b.baseCls + "-" + c)
            }
            b.toolEl.addCls(b.baseCls + "-" + a)
        } else {
            b.renderData.type = a
        }
        return b
    },
    onDestroy: function () {
        var a = this, b = a.keyMap;
        a.setTooltip(null);
        delete a.toolOwner;
        Ext.Component.prototype.onDestroy.call(this)
    },
    privates: {
        onClick: function (c, b) {
            var a = this;
            if (a.disabled) {
                return false
            }
            if (c.type !== "keydown") {
                a.el.removeCls(a.toolPressedCls + " " + a.toolOverCls)
            }
            if (a.stopEvent !== false) {
                c.stopEvent()
            }
            if (a.handler) {
                Ext.callback(a.handler, a.scope, [c, b, a.ownerCt, a], 0, a)
            } else {
                if (a.callback) {
                    Ext.callback(a.callback, a.scope, [a.toolOwner || a.ownerCt, a, c], 0, a)
                }
            }
            a.fireEvent("click", a, c, a.toolOwner || a.ownerCt);
            return true
        }, onMouseDown: function (a) {
            a.preventDefault();
            if (this.disabled) {
                return false
            }
            this.el.addCls(this.toolPressedCls)
        }, onMouseOver: function () {
            if (this.disabled) {
                return false
            }
            this.el.addCls(this.toolOverCls)
        }, onMouseOut: function () {
            this.el.removeCls(this.toolOverCls)
        }
    }
}, 0, ["tool"], ["component", "box", "tool"], {
    component: true,
    box: true,
    tool: true
}, ["widget.tool"], 0, [Ext.panel, "Tool"], 0));
(Ext.cmd.derive("Ext.util.KeyMap", Ext.Base, {
    alternateClassName: "Ext.KeyMap", eventName: "keydown", constructor: function (a) {
        var b = this;
        if ((arguments.length !== 1) || (typeof a === "string") || a.dom || a.tagName || a === document || a.isComponent) {
            b.legacyConstructor.apply(b, arguments);
            return
        }
        Ext.apply(b, a);
        b.bindings = [];
        if (!b.target.isComponent) {
            b.target = Ext.get(b.target)
        }
        if (b.binding) {
            b.addBinding(b.binding)
        } else {
            if (a.key) {
                b.addBinding(a)
            }
        }
        b.enable()
    }, legacyConstructor: function (b, d, a) {
        var c = this;
        Ext.apply(c, {target: Ext.get(b), eventName: a || c.eventName, bindings: []});
        if (d) {
            c.addBinding(d)
        }
        c.enable()
    }, addBinding: function (e) {
        var c = this, d = e.key, b, a;
        if (c.processing) {
            c.bindings = c.bindings.slice(0)
        }
        if (Ext.isArray(e)) {
            for (b = 0, a = e.length; b < a; b++) {
                c.addBinding(e[b])
            }
            return
        }
        c.bindings.push(Ext.apply({keyCode: c.processKeys(d)}, e))
    }, removeBinding: function (g) {
        var e = this, h = e.bindings, a = h.length, b, d, c;
        if (e.processing) {
            e.bindings = h.slice(0)
        }
        c = e.processKeys(g.key);
        for (b = 0; b < a; ++b) {
            d = h[b];
            if ((d.fn || d.handler) === (g.fn || g.handler) && d.scope === g.scope) {
                if (g.alt === d.alt && g.crtl === d.crtl && g.shift === d.shift) {
                    if (Ext.Array.equals(d.keyCode, c)) {
                        Ext.Array.erase(e.bindings, b, 1);
                        return
                    }
                }
            }
        }
    }, processKeys: function (g) {
        var h = false, d, e, b, a, c;
        if (g.test) {
            return g
        }
        if (Ext.isString(g)) {
            e = [];
            b = g.toUpperCase();
            for (c = 0, a = b.length; c < a; ++c) {
                e.push(b.charCodeAt(c))
            }
            g = e;
            h = true
        }
        if (!Ext.isArray(g)) {
            g = [g]
        }
        if (!h) {
            for (c = 0, a = g.length; c < a; ++c) {
                d = g[c];
                if (Ext.isString(d)) {
                    g[c] = d.toUpperCase().charCodeAt(0)
                }
            }
        }
        return g
    }, handleTargetEvent: function (e) {
        var d = this, g, c, b, a;
        if (d.enabled) {
            g = d.bindings;
            c = 0;
            b = g.length;
            e = d.processEvent.apply(d.processEventScope || d, arguments);
            if (e) {
                d.lastKeyEvent = e;
                if (d.ignoreInputFields && Ext.fly(e.target).isInputField()) {
                    return
                }
                if (!e.getKey) {
                    return e
                }
                d.processing = true;
                for (; c < b; ++c) {
                    a = d.processBinding(g[c], e);
                    if (a === false) {
                        d.processing = false;
                        return a
                    }
                }
                d.processing = false
            }
        }
    }, processEvent: Ext.identityFn, processBinding: function (e, a) {
        if (this.checkModifiers(e, a)) {
            var g = a.getKey(), j = e.fn || e.handler, k = e.scope || this, h = e.keyCode, b = e.defaultEventAction, c,
                d, l;
            if (h.test) {
                if (h.test(String.fromCharCode(a.getCharCode()))) {
                    l = j.call(k, g, a);
                    if (l !== true && b) {
                        a[b]()
                    }
                    if (l === false) {
                        return l
                    }
                }
            } else {
                if (h.length) {
                    for (c = 0, d = h.length; c < d; ++c) {
                        if (g === h[c]) {
                            l = j.call(k, g, a);
                            if (l !== true && b) {
                                a[b]()
                            }
                            if (l === false) {
                                return l
                            }
                            break
                        }
                    }
                }
            }
        }
    }, checkModifiers: function (h, e) {
        var d = ["shift", "ctrl", "alt"], c = 0, a = d.length, g, b;
        for (; c < a; ++c) {
            b = d[c];
            g = h[b];
            if (!(g === undefined || (g === e[b + "Key"]))) {
                return false
            }
        }
        return true
    }, on: function (b, d, c) {
        var h, a, e, g;
        if (Ext.isObject(b) && !Ext.isArray(b)) {
            h = b.key;
            a = b.shift;
            e = b.ctrl;
            g = b.alt
        } else {
            h = b
        }
        this.addBinding({key: h, shift: a, ctrl: e, alt: g, fn: d, scope: c})
    }, un: function (b, d, c) {
        var h, a, e, g;
        if (Ext.isObject(b) && !Ext.isArray(b)) {
            h = b.key;
            a = b.shift;
            e = b.ctrl;
            g = b.alt
        } else {
            h = b
        }
        this.removeBinding({key: h, shift: a, ctrl: e, alt: g, fn: d, scope: c})
    }, isEnabled: function () {
        return this.enabled
    }, enable: function () {
        var a = this;
        if (!a.enabled) {
            a.target.on(a.eventName, a.handleTargetEvent, a, {capture: a.capture, priority: a.priority});
            a.enabled = true
        }
    }, disable: function () {
        var a = this;
        if (a.enabled) {
            a.target.removeListener(a.eventName, a.handleTargetEvent, a);
            a.enabled = false
        }
    }, setDisabled: function (a) {
        if (a) {
            this.disable()
        } else {
            this.enable()
        }
    }, destroy: function (c) {
        var a = this, b = a.target;
        a.bindings = [];
        a.disable();
        if (c) {
            b.destroy()
        }
        delete a.target;
        a.callParent()
    }
}, 1, 0, 0, 0, 0, 0, [Ext.util, "KeyMap", Ext, "KeyMap"], 0));
(Ext.cmd.derive("Ext.util.KeyNav", Ext.Base, {
    alternateClassName: "Ext.KeyNav",
    disabled: false,
    defaultEventAction: false,
    forceKeyDown: false,
    eventName: "keypress",
    statics: {
        keyOptions: {
            left: 37,
            right: 39,
            up: 38,
            down: 40,
            space: 32,
            pageUp: 33,
            pageDown: 34,
            del: 46,
            backspace: 8,
            home: 36,
            end: 35,
            enter: 13,
            esc: 27,
            tab: 9
        }
    },
    constructor: function (a) {
        var b = this;
        if (arguments.length === 2) {
            b.legacyConstructor.apply(b, arguments);
            return
        }
        b.doConstruction(a)
    },
    legacyConstructor: function (b, a) {
        this.doConstruction(Ext.apply({target: b}, a))
    },
    doConstruction: function (a) {
        var c = this, b = {
            target: a.target,
            ignoreInputFields: a.ignoreInputFields,
            eventName: c.getKeyEvent("forceKeyDown" in a ? a.forceKeyDown : c.forceKeyDown, a.eventName),
            capture: a.capture
        }, d;
        if (c.map) {
            c.map.destroy()
        }
        c.initConfig(a);
        if (a.processEvent) {
            b.processEvent = a.processEvent;
            b.processEventScope = a.processEventScope || c
        }
        if (a.priority) {
            b.priority = a.priority
        }
        if (a.keyMap) {
            d = c.map = a.keyMap
        } else {
            d = c.map = new Ext.util.KeyMap(b);
            c.destroyKeyMap = true
        }
        this.addBindings(a);
        d.disable();
        if (!a.disabled) {
            d.enable()
        }
    },
    addBindings: function (i) {
        var c = this, b, g, e = c.map, a = Ext.util.KeyNav.keyOptions, d, h = i.scope || c;
        for (b in i) {
            g = i[b];
            d = a[b];
            if (d != null) {
                b = d
            }
            if (g && (b.length === 1 || !isNaN(b = parseInt(b, 10)))) {
                if (typeof g === "function") {
                    g = {
                        handler: g,
                        defaultEventAction: (i.defaultEventAction !== undefined) ? i.defaultEventAction : c.defaultEventAction
                    }
                }
                e.addBinding({
                    key: b,
                    ctrl: g.ctrl,
                    shift: g.shift,
                    alt: g.alt,
                    handler: Ext.Function.bind(c.handleEvent, g.scope || h, [g.handler || g.fn, c], true),
                    defaultEventAction: (g.defaultEventAction !== undefined) ? g.defaultEventAction : c.defaultEventAction
                })
            }
        }
    },
    handleEvent: function (d, c, b, a) {
        a.lastKeyEvent = c;
        return b.call(this, c)
    },
    destroy: function (b) {
        var a = this;
        if (a.destroyKeyMap) {
            a.map.destroy(b)
        }
        delete a.map;
        a.callParent()
    },
    enable: function () {
        if (this.map) {
            this.map.enable();
            this.disabled = false
        }
    },
    disable: function () {
        if (this.map) {
            this.map.disable()
        }
        this.disabled = true
    },
    setDisabled: function (a) {
        this.map.setDisabled(a);
        this.disabled = a
    },
    getKeyEvent: function (b, a) {
        if (b || (Ext.supports.SpecialKeyDownRepeat && !a)) {
            return "keydown"
        } else {
            return a || this.eventName
        }
    }
}, 1, 0, 0, 0, 0, 0, [Ext.util, "KeyNav", Ext, "KeyNav"], 0));
(Ext.cmd.derive("Ext.util.FocusableContainer", Ext.Mixin, {
    mixinConfig: {
        id: "focusablecontainer",
        before: {
            onAdd: "onFocusableChildAdd",
            onRemove: "onFocusableChildRemove",
            destroy: "destroyFocusableContainer",
            onFocusEnter: "onFocusEnter"
        },
        after: {
            afterRender: "initFocusableContainer",
            onFocusLeave: "onFocusLeave",
            afterShow: "activateFocusableContainerEl"
        }
    },
    isFocusableContainer: true,
    enableFocusableContainer: true,
    activeChildTabIndex: 0,
    inactiveChildTabIndex: -1,
    privates: {
        initFocusableContainer: function (c) {
            var b, d, a;
            if (this.enableFocusableContainer) {
                c = c != null ? c : true;
                this.doInitFocusableContainer(c)
            } else {
                b = this.getFocusables();
                for (d = 0, a = b.length; d < a; d++) {
                    b[d].focusableContainer = null
                }
            }
        },
        doInitFocusableContainer: function (a) {
            var c = this, b;
            b = c.getFocusableContainerEl();
            c.activateFocusableContainerEl(b);
            if (a) {
                c.clearFocusables()
            }
            c.focusableContainerMouseListener = c.mon(b, "mousedown", c.onFocusableContainerMousedown, c);
            c.focusableKeyNav = c.createFocusableContainerKeyNav(b)
        },
        createFocusableContainerKeyNav: function (a) {
            var b = this;
            return new Ext.util.KeyNav(a, {
                eventName: "keydown",
                ignoreInputFields: true,
                scope: b,
                tab: b.onFocusableContainerTabKey,
                enter: b.onFocusableContainerEnterKey,
                space: b.onFocusableContainerSpaceKey,
                up: b.onFocusableContainerUpKey,
                down: b.onFocusableContainerDownKey,
                left: b.onFocusableContainerLeftKey,
                right: b.onFocusableContainerRightKey
            })
        },
        destroyFocusableContainer: function () {
            if (this.enableFocusableContainer) {
                this.doDestroyFocusableContainer()
            }
        },
        doDestroyFocusableContainer: function () {
            var a = this;
            if (a.keyNav) {
                a.keyNav.destroy()
            }
            if (a.focusableContainerMouseListener) {
                a.focusableContainerMouseListener.destroy()
            }
            a.focusableKeyNav = a.focusableContainerMouseListener = null
        },
        getFocusables: function () {
            return this.items.items
        },
        initDefaultFocusable: function (k) {
            var g = this, j = g.activeChildTabIndex, c = false, e, h, b, d, a;
            e = g.getFocusables();
            d = e.length;
            if (!d) {
                return
            }
            for (b = 0; b < d; b++) {
                h = e[b];
                if (h.focusable) {
                    c = true;
                    a = h.getTabIndex();
                    if (a != null && a >= j) {
                        return h
                    }
                }
            }
            if (!c) {
                return
            }
            h = g.findNextFocusableChild(null, true, e, k);
            if (h) {
                g.activateFocusable(h)
            }
            return h
        },
        clearFocusables: function () {
            var e = this, b = e.getFocusables(), a = b.length, d, c;
            for (c = 0; c < a; c++) {
                d = b[c];
                if (d.focusable) {
                    e.deactivateFocusable(d)
                }
            }
        },
        activateFocusable: function (c, b) {
            var a = b != null ? b : this.activeChildTabIndex;
            c.setTabIndex(a)
        },
        deactivateFocusable: function (c, b) {
            var a = b != null ? b : this.inactiveChildTabIndex;
            c.setTabIndex(a)
        },
        onFocusableContainerTabKey: function () {
            return true
        },
        onFocusableContainerEnterKey: function () {
            return true
        },
        onFocusableContainerSpaceKey: function () {
            return true
        },
        onFocusableContainerUpKey: function (a) {
            return this.moveChildFocus(a, false)
        },
        onFocusableContainerLeftKey: function (a) {
            return this.moveChildFocus(a, false)
        },
        onFocusableContainerRightKey: function (a) {
            return this.moveChildFocus(a, true)
        },
        onFocusableContainerDownKey: function (a) {
            return this.moveChildFocus(a, true)
        },
        getFocusableFromEvent: function (a) {
            var b = Ext.Component.fromElement(a.getTarget());
            return b
        },
        moveChildFocus: function (b, a) {
            var c = this.getFocusableFromEvent(b);
            return this.focusChild(c, a, b)
        },
        focusChild: function (c, a) {
            var b = this.findNextFocusableChild(c, a);
            if (b) {
                b.focus()
            }
            return b
        },
        findNextFocusableChild: function (j, h, c, e) {
            var g, b, d, a;
            c = c || this.getFocusables();
            b = Ext.Array.indexOf(c, j);
            h = h === true ? 1 : h === false ? -1 : h;
            a = c.length;
            d = h > 0 ? (b < a ? b + h : 0) : (b > 0 ? b + h : a - 1);
            for (; ; d += h) {
                if (b < 0 && (d >= a || d < 0)) {
                    return null
                } else {
                    if (d >= a) {
                        d = -1;
                        continue
                    } else {
                        if (d < 0) {
                            d = a;
                            continue
                        } else {
                            if (d === b) {
                                return null
                            }
                        }
                    }
                }
                g = c[d];
                if (!g || !g.focusable) {
                    continue
                }
                if (e || (g.isFocusable && g.isFocusable())) {
                    return g
                }
            }
            return null
        },
        getFocusableContainerEl: function () {
            return this.el
        },
        onFocusableChildAdd: function (a) {
            if (this.enableFocusableContainer) {
                return this.doFocusableChildAdd(a)
            }
        },
        activateFocusableContainerEl: function (a) {
            a = a || this.getFocusableContainerEl();
            a.set({tabIndex: this.activeChildTabIndex})
        },
        deactivateFocusableContainerEl: function (a) {
            a = a || this.getFocusableContainerEl();
            a.set({tabIndex: this.inactiveChildTabIndex})
        },
        doFocusableChildAdd: function (a) {
            if (a.focusable) {
                a.focusableContainer = this
            }
        },
        onFocusableChildRemove: function (a) {
            if (this.enableFocusableContainer) {
                return this.doFocusableChildRemove(a)
            }
            a.focusableContainer = null
        },
        doFocusableChildRemove: function (a) {
            if (a === this.lastFocusedChild) {
                this.lastFocusedChild = null;
                this.activateFocusableContainerEl()
            }
        },
        onFocusableContainerMousedown: function (c, b) {
            var a = Ext.Component.fromElement(b);
            this.mousedownTimestamp = a === this ? Ext.Date.now() : 0;
            if (a === this) {
                c.preventDefault()
            }
        },
        onFocusEnter: function (c) {
            var a = this, b = c.toComponent, d = a.mousedownTimestamp, h = 50, g;
            if (!a.enableFocusableContainer) {
                return null
            }
            a.mousedownTimestamp = 0;
            if (b === a) {
                if (!d || Ext.Date.now() - d > h) {
                    g = a.initDefaultFocusable();
                    if (g) {
                        a.deactivateFocusableContainerEl();
                        g.focus()
                    }
                }
            } else {
                a.deactivateFocusableContainerEl()
            }
            return b
        },
        onFocusLeave: function (c) {
            var b = this, a = b.lastFocusedChild;
            if (!b.enableFocusableContainer) {
                return
            }
            if (!b.destroyed && !b.destroying) {
                b.clearFocusables();
                if (a) {
                    b.activateFocusable(a)
                } else {
                    b.activateFocusableContainerEl()
                }
            }
        },
        beforeFocusableChildBlur: Ext.privateFn,
        afterFocusableChildBlur: Ext.privateFn,
        beforeFocusableChildFocus: function (b) {
            var a = this;
            if (!a.enableFocusableContainer) {
                return
            }
            a.clearFocusables();
            a.activateFocusable(b);
            if (b.needArrowKeys) {
                a.guardFocusableChild(b)
            }
        },
        guardFocusableChild: function (d) {
            var c = this, a = c.activeChildTabIndex, b;
            b = c.findNextFocusableChild(d, -1);
            if (b) {
                b.setTabIndex(a)
            }
            b = c.findNextFocusableChild(d, 1);
            if (b) {
                b.setTabIndex(a)
            }
        },
        afterFocusableChildFocus: function (a) {
            if (!this.enableFocusableContainer) {
                return
            }
            this.lastFocusedChild = a
        },
        onFocusableChildShow: Ext.privateFn,
        onFocusableChildHide: Ext.privateFn,
        onFocusableChildEnable: Ext.privateFn,
        onFocusableChildDisable: Ext.privateFn,
        onFocusableChildMasked: Ext.privateFn,
        onFocusableChildDestroy: Ext.privateFn,
        onFocusableChildUpdate: Ext.privateFn
    }
}, 0, 0, 0, 0, 0, 0, [Ext.util, "FocusableContainer"], 0));
(Ext.cmd.derive("Ext.panel.Header", Ext.panel.Bar, {
    isHeader: true,
    defaultType: "tool",
    indicateDrag: false,
    weight: -1,
    shrinkWrap: 3,
    iconAlign: "left",
    titleAlign: "left",
    titlePosition: 0,
    titleRotation: "default",
    autoEl: {role: "presentation"},
    beforeRenderConfig: {
        glyph: null,
        icon: null,
        iconCls: null,
        iconAlign: null,
        title: {
            $value: {xtype: "title", flex: 1}, merge: function (b, a) {
                if (typeof b !== "object") {
                    b = {text: b}
                }
                return Ext.merge(a ? Ext.Object.chain(a) : {}, b)
            }
        },
        titleAlign: null,
        titlePosition: null,
        titleRotation: null
    },
    headerCls: "x-header",
    initComponent: function () {
        var d = this, c = d.items, b = d.itemPosition, a = [d.headerCls];
        d.tools = d.tools || [];
        d.items = c = (c ? c.slice() : []);
        if (b !== undefined) {
            d._userItems = c.slice();
            d.items = c = []
        }
        d.indicateDragCls = d.headerCls + "-draggable";
        if (d.indicateDrag) {
            a.push(d.indicateDragCls)
        }
        d.addCls(a);
        d.syncNoBorderCls();
        d.enableFocusableContainer = !d.isAccordionHeader && d.tools.length > 0;
        if (d.enableFocusableContainer) {
            d.ariaRole = "toolbar"
        }
        Ext.Array.push(c, d.tools);
        d.tools.length = 0;
        Ext.panel.Bar.prototype.initComponent.call(this);
        d.on({dblclick: d.onDblClick, click: d.onClick, element: "el", scope: d})
    },
    addTool: function (a) {
        var b = this;
        b.add(Ext.ComponentManager.create(a, "tool"));
        if (!b.isAccordionHeader && b.tools.length > 0 && !b.enableFocusableContainer) {
            b.enableFocusableContainer = true;
            b.ariaRole = "toolbar";
            if (b.rendered) {
                b.ariaEl.dom.setAttribute("role", "toolbar");
                b.initFocusableContainer(true)
            }
        }
    },
    afterLayout: function () {
        var b = this, e, a, c, d;
        if (b.vertical) {
            a = b.frameTR;
            if (a) {
                e = b.frameBR;
                c = b.frameTL;
                d = (b.getWidth() - a.getPadding("r") - ((c) ? c.getPadding("l") : b.el.getBorderWidth("l"))) + "px";
                e.setStyle("background-position-x", d);
                a.setStyle("background-position-x", d)
            }
        }
        Ext.panel.Bar.prototype.afterLayout.call(this)
    },
    applyTitle: function (e, c) {
        var d = this, a, b;
        e = e || "";
        a = typeof e === "string";
        if (a) {
            e = {text: e}
        }
        if (c) {
            Ext.suspendLayouts();
            c.setConfig(e);
            Ext.resumeLayouts(true);
            e = c
        } else {
            if (a) {
                e.xtype = "title"
            }
            e.ui = d.ui;
            b = ("rotation" in e);
            e.id = d.id + "-title";
            if (d.isAccordionHeader) {
                e.ariaRole = "tab";
                e.textElRole = null;
                e.focusable = true
            }
            e = Ext.create(e);
            if (!b && d.vertical && d.titleRotation === "default") {
                e.rotation = 1
            }
        }
        return e
    },
    applyTitlePosition: function (b) {
        var a = this.items.getCount();
        if (this._titleInItems) {
            --a
        }
        return Math.max(Math.min(b, a), 0)
    },
    beforeLayout: function () {
        Ext.panel.Bar.prototype.beforeLayout.call(this);
        this.syncBeforeAfterTitleClasses()
    },
    beforeRender: function () {
        var b = this, a = b.itemPosition;
        b.protoEl.unselectable();
        Ext.panel.Bar.prototype.beforeRender.call(this);
        if (a !== undefined) {
            b.insert(a, b._userItems)
        }
    },
    getTools: function () {
        return this.tools.slice()
    },
    onAdd: function (b, a) {
        var c = this.tools;
        Ext.panel.Bar.prototype.onAdd.call(this, b, a);
        if (b.isTool) {
            c.push(b);
            c[b.type] = b
        }
    },
    onAdded: function (b, c, a) {
        this.syncNoBorderCls();
        Ext.panel.Bar.prototype.onAdded.call(this, b, c, a)
    },
    onRemoved: function (b, c, a) {
        this.syncNoBorderCls();
        Ext.panel.Bar.prototype.onRemoved.call(this, b, c, a)
    },
    setDock: function (c) {
        var b = this, e = b.getTitle(), a = b.getTitleRotation(), d = e.getRotation();
        Ext.suspendLayouts();
        Ext.panel.Bar.prototype.setDock.call(this, c);
        if (a === "default") {
            a = (b.vertical ? 1 : 0);
            if (a !== d) {
                e.setRotation(a)
            }
            if (b.rendered) {
                b.resetItemMargins()
            }
        }
        Ext.resumeLayouts(true)
    },
    updateGlyph: function (a) {
        this.getTitle().setGlyph(a)
    },
    updateIcon: function (a) {
        this.getTitle().setIcon(a)
    },
    updateIconAlign: function (b, a) {
        this.getTitle().setIconAlign(b)
    },
    updateIconCls: function (a) {
        this.getTitle().setIconCls(a)
    },
    updateTitle: function (b, a) {
        if (!a) {
            this.insert(this.getTitlePosition(), b);
            this._titleInItems = true
        }
        this.titleCmp = b
    },
    updateTitleAlign: function (b, a) {
        this.getTitle().setTextAlign(b)
    },
    updateTitlePosition: function (a) {
        this.insert(a, this.getTitle())
    },
    updateTitleRotation: function (a) {
        if (a === "default") {
            a = (this.vertical ? 1 : 0)
        }
        this.getTitle().setRotation(a)
    },
    privates: {
        fireClickEvent: function (a, c) {
            var b = "." + Ext.panel.Tool.prototype.baseCls;
            if (!c.getTarget(b)) {
                this.fireEvent(a, this, c)
            }
        }, getFramingInfoCls: function () {
            var c = this, b = Ext.panel.Bar.prototype.getFramingInfoCls.call(this), a = c.ownerCt;
            if (!c.expanding && a && (a.collapsed || c.isCollapsedExpander)) {
                b += "-" + a.collapsedCls
            }
            return b + "-" + c.dock
        }, onClick: function (a) {
            this.fireClickEvent("click", a)
        }, onDblClick: function (a) {
            this.fireClickEvent("dblclick", a)
        }, onFocusableContainerMousedown: function (c, b) {
            var a = Ext.Component.fromElement(b);
            if (a === this) {
                c.preventDefault()
            } else {
                this.mixins.focusablecontainer.onFocusableContainerMousedown.apply(this, arguments)
            }
        }, syncBeforeAfterTitleClasses: function (c) {
            var k = this, j = k.items, g = j.items, b = k.getTitlePosition(), a = g.length, h = j.generation,
                l = k.syncBeforeAfterGen, n, e, d, m;
            if (!c && (l === h)) {
                return
            }
            k.syncBeforeAfterGen = h;
            for (d = 0; d < a; ++d) {
                m = g[d];
                n = m.afterTitleCls || (m.afterTitleCls = m.baseCls + "-after-title");
                e = m.beforeTitleCls || (m.beforeTitleCls = m.baseCls + "-before-title");
                if (!k.title || d < b) {
                    if (l) {
                        m.removeCls(n)
                    }
                    m.addCls(e)
                } else {
                    if (d > b) {
                        if (l) {
                            m.removeCls(e)
                        }
                        m.addCls(n)
                    }
                }
            }
        }, syncNoBorderCls: function () {
            var b = this, a = this.ownerCt, c = b.headerCls + "-noborder";
            if (a ? (a.border === false && !a.frame) : b.border === false) {
                b.addCls(c)
            } else {
                b.removeCls(c)
            }
        }
    }
}, 0, ["header"], ["component", "box", "container", "header"], {
    component: true,
    box: true,
    container: true,
    header: true
}, ["widget.header"], [[Ext.util.FocusableContainer.prototype.mixinId || Ext.util.FocusableContainer.$className, Ext.util.FocusableContainer]], [Ext.panel, "Header"], 0));
(Ext.cmd.derive("Ext.layout.container.boxOverflow.None", Ext.Base, {
    alternateClassName: "Ext.layout.boxOverflow.None",
    factoryConfig: {defaultType: "none"},
    isBoxOverflowHandler: true,
    $configPrefixed: false,
    $configStrict: false,
    constructor: function (a) {
        this.initConfig(a)
    },
    handleOverflow: Ext.emptyFn,
    clearOverflow: Ext.emptyFn,
    beginLayout: Ext.emptyFn,
    beginLayoutCycle: Ext.emptyFn,
    calculate: function (b) {
        var a = this, c = b.state.boxPlan, d;
        if (c && c.tooNarrow) {
            d = a.handleOverflow(b);
            if (d) {
                if (d.reservedSpace) {
                    a.layout.publishInnerCtSize(b, d.reservedSpace)
                }
            }
        } else {
            a.clearOverflow()
        }
    },
    completeLayout: Ext.emptyFn,
    finishedLayout: function (d) {
        var c = this, a = c.layout.owner, b, e;
        if (a.hasListeners.overflowchange) {
            b = a.query(">[hidden]");
            e = b.length;
            if (e !== c.lastHiddenCount) {
                a.fireEvent("overflowchange", c.lastHiddenCount, e, b);
                c.lastHiddenCount = e
            }
        }
    },
    onRemove: Ext.emptyFn,
    getItem: function (a) {
        return this.layout.owner.getComponent(a)
    },
    getOwnerType: function (a) {
        var b;
        if (a.isToolbar) {
            b = "toolbar"
        } else {
            if (a.isTabBar) {
                b = "tab-bar"
            } else {
                if (a.isMenu) {
                    b = "menu"
                } else {
                    if (a.isBreadcrumb) {
                        b = "breadcrumb"
                    } else {
                        b = a.getXType()
                    }
                }
            }
        }
        return b
    },
    getPrefixConfig: Ext.emptyFn,
    getSuffixConfig: Ext.emptyFn,
    getOverflowCls: function () {
        return ""
    },
    setVertical: function () {
        var b = this, a = b.layout, c = a.innerCt;
        c.removeCls(b.getOverflowCls(a.oppositeDirection));
        c.addCls(b.getOverflowCls(a.direction))
    }
}, 1, 0, 0, 0, ["box.overflow.None", "box.overflow.none"], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.layout.container.boxOverflow, "None", Ext.layout.boxOverflow, "None"], 0));
(Ext.cmd.derive("Ext.layout.container.boxOverflow.Scroller", Ext.layout.container.boxOverflow.None, {
    alternateClassName: "Ext.layout.boxOverflow.Scroller",
    animateScroll: false,
    scrollIncrement: 20,
    wheelIncrement: 10,
    scrollRepeatInterval: 60,
    scrollDuration: 400,
    scrollerCls: "x-box-scroller",
    beforeSuffix: "-before-scroller",
    afterSuffix: "-after-scroller",
    constructor: function (a) {
        var b = this;
        b.mixins.observable.constructor.call(b, a);
        b.scrollPosition = 0;
        b.scrollSize = 0
    },
    getPrefixConfig: function () {
        return {
            role: "presentation",
            id: this.layout.owner.id + this.beforeSuffix,
            cls: this.createScrollerCls("beforeX"),
            style: "display:none"
        }
    },
    getSuffixConfig: function () {
        return {
            role: "presentation",
            id: this.layout.owner.id + this.afterSuffix,
            cls: this.createScrollerCls("afterX"),
            style: "display:none"
        }
    },
    createScrollerCls: function (e) {
        var h = this, g = h.layout, b = g.owner, d = h.getOwnerType(b), a = h.scrollerCls,
            c = a + " " + a + "-" + g.names[e] + " " + a + "-" + d + " " + a + "-" + d + "-" + b.ui;
        if (b.plain) {
            c += " " + a + "-plain"
        }
        return c
    },
    getOverflowCls: function (a) {
        return this.scrollerCls + "-body-" + a
    },
    beginLayout: function (a) {
        a.innerCtScrollPos = this.getScrollPosition();
        Ext.layout.container.boxOverflow.None.prototype.beginLayout.apply(this, arguments)
    },
    finishedLayout: function (d) {
        var c = this, g = d.state.boxPlan, b = c.layout, e = b.names,
            h = Math.min(c.getMaxScrollPosition(), d.innerCtScrollPos), a;
        if (g && g.tooNarrow) {
            a = d.childItems[d.childItems.length - 1].props;
            c.scrollSize = a[e.x] + a[e.width];
            c.updateScrollButtons()
        }
        b.innerCt[e.setScrollLeft](h);
        Ext.layout.container.boxOverflow.None.prototype.finishedLayout.call(this, d)
    },
    handleOverflow: function (b) {
        var h = this, g = h.layout.names, i = g.getWidth, j = g.parallelMargins, c, e, d, a;
        h.showScrollers();
        d = h.getBeforeScroller();
        a = h.getAfterScroller();
        c = d[i]() + a[i]() + d.getMargin(j) + a.getMargin(j);
        e = b.targetContext.getPaddingInfo()[g.width];
        return {reservedSpace: Math.max(c - e, 0)}
    },
    getBeforeScroller: function () {
        var a = this;
        return a._beforeScroller || (a._beforeScroller = a.createScroller(a.beforeSuffix, "beforeRepeater", "scrollLeft"))
    },
    getAfterScroller: function () {
        var a = this;
        return a._afterScroller || (a._afterScroller = a.createScroller(a.afterSuffix, "afterRepeater", "scrollRight"))
    },
    createScroller: function (g, d, h) {
        var e = this, c = e.layout.owner, b = e.scrollerCls, a;
        a = c.el.getById(c.id + g);
        a.addClsOnOver(b + "-hover");
        a.addClsOnClick(b + "-pressed");
        a.setVisibilityMode(Ext.Element.DISPLAY);
        e[d] = new Ext.util.ClickRepeater(a, {interval: e.scrollRepeatInterval, handler: h, scope: e});
        return a
    },
    createWheelListener: function () {
        var a = this;
        a.wheelListener = a.layout.innerCt.on("mousewheel", a.onMouseWheel, a, {destroyable: true})
    },
    onMouseWheel: function (a) {
        a.stopEvent();
        this.scrollBy(this.getWheelDelta(a) * this.wheelIncrement * -1, false)
    },
    getWheelDelta: function (a) {
        return a.getWheelDelta()
    },
    clearOverflow: function () {
        this.hideScrollers()
    },
    showScrollers: function () {
        var a = this;
        if (!a.wheelListener) {
            a.createWheelListener()
        }
        a.getBeforeScroller().show();
        a.getAfterScroller().show();
        a.layout.owner.addClsWithUI(a.layout.direction === "vertical" ? "vertical-scroller" : "scroller")
    },
    hideScrollers: function () {
        var b = this, c = b.getBeforeScroller(), a = b.getAfterScroller();
        if (c) {
            c.hide();
            a.hide();
            b.layout.owner.removeClsWithUI(b.layout.direction === "vertical" ? "vertical-scroller" : "scroller")
        }
    },
    destroy: function () {
        Ext.destroyMembers(this, "beforeRepeater", "afterRepeater", "_beforeScroller", "_afterScroller", "wheelListener");
        this.callParent()
    },
    scrollBy: function (b, a) {
        this.scrollTo(this.getScrollPosition() + b, a)
    },
    getScrollAnim: function () {
        return {duration: this.scrollDuration, callback: this.updateScrollButtons, scope: this}
    },
    updateScrollButtons: function () {
        var b = this, d = b.getBeforeScroller(), a = b.getAfterScroller(), c;
        if (!d || !a) {
            return
        }
        c = b.scrollerCls + "-disabled";
        d[b.atExtremeBefore() ? "addCls" : "removeCls"](c);
        a[b.atExtremeAfter() ? "addCls" : "removeCls"](c);
        b.scrolling = false
    },
    scrollLeft: function () {
        this.scrollBy(-this.scrollIncrement, false)
    },
    scrollRight: function () {
        this.scrollBy(this.scrollIncrement, false)
    },
    getScrollPosition: function () {
        var c = this, b = c.layout, a;
        if (isNaN(c.scrollPosition)) {
            a = b.innerCt[b.names.getScrollLeft]()
        } else {
            a = c.scrollPosition
        }
        return a
    },
    getMaxScrollPosition: function () {
        var b = this, a = b.layout, c = b.scrollSize - a.innerCt[a.names.getWidth]();
        return (c < 0) ? 0 : c
    },
    atExtremeBefore: function () {
        return !this.getScrollPosition()
    },
    atExtremeAfter: function () {
        return this.getScrollPosition() >= this.getMaxScrollPosition()
    },
    setVertical: function () {
        var c = this, d = c.getBeforeScroller(), b = c.getAfterScroller(), e = c.layout.names, a = c.scrollerCls;
        d.removeCls(a + "-" + e.beforeY);
        b.removeCls(a + "-" + e.afterY);
        d.addCls(a + "-" + e.beforeX);
        b.addCls(a + "-" + e.afterX);
        Ext.layout.container.boxOverflow.None.prototype.setVertical.call(this)
    },
    scrollTo: function (a, b) {
        var g = this, e = g.layout, h = e.names, d = g.getScrollPosition(),
            c = Ext.Number.constrain(a, 0, g.getMaxScrollPosition());
        if (c !== d && !g.scrolling) {
            g.scrollPosition = NaN;
            if (b === undefined) {
                b = g.animateScroll
            }
            e.innerCt[h.scrollTo](h.beforeScrollX, c, b ? g.getScrollAnim() : false);
            if (b) {
                g.scrolling = true
            } else {
                g.updateScrollButtons()
            }
            g.fireEvent("scroll", g, c, b ? g.getScrollAnim() : false)
        }
    },
    scrollToItem: function (k, c) {
        var j = this, g = j.layout, d = g.owner, i = g.names, b = g.innerCt, a, e, h;
        k = j.getItem(k);
        if (k !== undefined) {
            if (k === d.items.first()) {
                h = 0
            } else {
                if (k === d.items.last()) {
                    h = j.getMaxScrollPosition()
                } else {
                    a = j.getItemVisibility(k);
                    if (!a.fullyVisible) {
                        e = k.getBox(false, true);
                        h = e[i.x];
                        if (a.hiddenEnd) {
                            h -= (b[i.getWidth]() - e[i.width])
                        }
                    }
                }
            }
            if (h !== undefined) {
                j.scrollTo(h, c)
            }
        }
    },
    getItemVisibility: function (j) {
        var h = this, b = h.getItem(j).getBox(true, true), c = h.layout, g = c.names, e = b[g.x], d = e + b[g.width],
            a = h.getScrollPosition(), i = a + c.innerCt[g.getWidth]();
        return {hiddenStart: e < a, hiddenEnd: d > i, fullyVisible: e >= a && d <= i}
    }
}, 1, 0, 0, 0, ["box.overflow.Scroller", "box.overflow.scroller"], [["observable", Ext.mixin.Observable]], [Ext.layout.container.boxOverflow, "Scroller", Ext.layout.boxOverflow, "Scroller"], 0));
(Ext.cmd.derive("Ext.dd.DragDropManager", Ext.Base, {
    singleton: true,
    alternateClassName: ["Ext.dd.DragDropMgr", "Ext.dd.DDM"],
    ids: {},
    handleIds: {},
    dragCurrent: null,
    dragOvers: {},
    deltaX: 0,
    deltaY: 0,
    preventDefault: true,
    stopPropagation: true,
    initialized: false,
    locked: false,
    init: function () {
        this.initialized = true
    },
    POINT: 0,
    INTERSECT: 1,
    mode: 0,
    notifyOccluded: false,
    dragCls: "x-dd-drag-current",
    _execOnAll: function (c, b) {
        var e = this.ids, d, a, h, g;
        for (d in e) {
            if (e.hasOwnProperty(d)) {
                g = e[d];
                for (a in g) {
                    if (g.hasOwnProperty(a)) {
                        h = g[a];
                        if (!this.isTypeOfDD(h)) {
                            continue
                        }
                        h[c].apply(h, b)
                    }
                }
            }
        }
    },
    addListeners: function () {
        var a = this;
        a.init();
        Ext.getDoc().on({
            mouseup: a.handleMouseUp,
            mousemove: {fn: a.handleMouseMove, capture: false},
            dragstart: a.preventDrag,
            drag: a.preventDrag,
            dragend: a.preventDrag,
            capture: true,
            scope: a
        });
        Ext.getWin().on({unload: a._onUnload, resize: a._onResize, scope: a})
    },
    preventDrag: function (a) {
        if (this.isMouseDown) {
            a.stopPropagation()
        }
    },
    _onResize: function (a) {
        this._execOnAll("resetConstraints", [])
    },
    lock: function () {
        this.locked = true
    },
    unlock: function () {
        this.locked = false
    },
    isLocked: function () {
        return this.locked
    },
    locationCache: {},
    useCache: true,
    clickPixelThresh: 8,
    dragThreshMet: false,
    clickTimeout: null,
    startX: 0,
    startY: 0,
    regDragDrop: function (b, a) {
        if (!this.initialized) {
            this.init()
        }
        if (!this.ids[a]) {
            this.ids[a] = {}
        }
        this.ids[a][b.id] = b
    },
    removeDDFromGroup: function (c, a) {
        if (!this.ids[a]) {
            this.ids[a] = {}
        }
        var b = this.ids[a];
        if (b && b[c.id]) {
            delete b[c.id]
        }
    },
    _remove: function (h, b) {
        var e = this, c = e.ids, a = h.groups, d;
        if (e.clearingAll) {
            return
        }
        if (e.dragCurrent === h) {
            e.dragCurrent = null
        }
        for (d in a) {
            if (a.hasOwnProperty(d)) {
                if (b) {
                    delete c[d]
                } else {
                    if (c[d]) {
                        delete c[d][h.id]
                    }
                }
            }
        }
        delete e.handleIds[h.id];
        delete e.locationCache[h.id]
    },
    regHandle: function (b, a) {
        if (!this.handleIds[b]) {
            this.handleIds[b] = {}
        }
        this.handleIds[b][a] = a
    },
    isDragDrop: function (a) {
        return (this.getDDById(a)) ? true : false
    },
    getRelated: function (g, b) {
        var e = [], d, c, a;
        for (d in g.groups) {
            for (c in this.ids[d]) {
                a = this.ids[d][c];
                if (!this.isTypeOfDD(a)) {
                    continue
                }
                if (!b || a.isTarget) {
                    e[e.length] = a
                }
            }
        }
        return e
    },
    isLegalTarget: function (e, d) {
        var b = this.getRelated(e, true), c, a;
        for (c = 0, a = b.length; c < a; ++c) {
            if (b[c].id === d.id) {
                return true
            }
        }
        return false
    },
    isTypeOfDD: function (a) {
        return (a && a.__ygDragDrop)
    },
    isHandle: function (b, a) {
        return (this.handleIds[b] && this.handleIds[b][a])
    },
    getDDById: function (d, c) {
        var b, a;
        for (b in this.ids) {
            a = this.ids[b][d];
            if (a instanceof Ext.dd.DDTarget || c) {
                return a
            }
        }
        return null
    },
    handleMouseDown: function (g, d) {
        var b = this, c, a;
        b.isMouseDown = true;
        if (Ext.quickTipsActive) {
            Ext.tip.QuickTipManager.ddDisable()
        }
        b.currentPoint = g.getPoint();
        if (b.dragCurrent) {
            b.handleMouseUp(g)
        }
        b.mousedownEvent = g;
        b.currentTarget = g.getTarget();
        b.dragCurrent = d;
        a = d.getEl();
        Ext.fly(a).setCapture();
        c = g.getXY();
        b.startX = c[0];
        b.startY = c[1];
        b.offsetX = b.offsetY = 0;
        b.deltaX = b.startX - a.offsetLeft;
        b.deltaY = b.startY - a.offsetTop;
        b.dragThreshMet = false
    },
    startDrag: function (b, e) {
        var c = this, d = c.dragCurrent, a;
        clearTimeout(c.clickTimeout);
        if (d) {
            d.b4StartDrag(b, e);
            d.startDrag(b, e);
            a = d.getDragEl();
            if (a) {
                Ext.fly(a).addCls(c.dragCls)
            }
        }
        c.dragThreshMet = true
    },
    handleMouseUp: function (b) {
        var a = this;
        a.isMouseDown = false;
        if (Ext.quickTipsActive) {
            Ext.tip.QuickTipManager.ddEnable()
        }
        if (!a.dragCurrent) {
            return
        }
        if (Ext.isIE && document.releaseCapture) {
            document.releaseCapture()
        }
        clearTimeout(a.clickTimeout);
        if (a.dragThreshMet) {
            a.fireEvents(b, true)
        }
        a.stopDrag(b);
        a.stopEvent(b);
        a.mousedownEvent = a.currentTarget = null
    },
    stopEvent: function (a) {
        if (this.stopPropagation) {
            a.stopPropagation()
        }
        if (this.preventDefault) {
            a.preventDefault()
        }
    },
    stopDrag: function (d) {
        var b = this, c = b.dragCurrent, a;
        if (c) {
            if (b.dragThreshMet) {
                a = c.getDragEl();
                if (a) {
                    Ext.fly(a).removeCls(b.dragCls)
                }
                c.b4EndDrag(d);
                c.endDrag(d)
            }
            b.dragCurrent.onMouseUp(d)
        }
        b.dragCurrent = null;
        b.dragOvers = {}
    },
    handleMouseMove: function (j) {
        var h = this, i = h.dragCurrent, a = h.currentPoint = j.getPoint(), d = a.x, b = a.y, g, c;
        h.offsetX = d - h.startX;
        h.offsetY = b - h.startY;
        if (!i) {
            return true
        }
        if (!h.dragThreshMet) {
            g = Math.abs(h.offsetX);
            c = Math.abs(h.offsetY);
            if (g > h.clickPixelThresh || c > h.clickPixelThresh) {
                h.startDrag(h.startX, h.startY)
            }
        }
        if (h.dragThreshMet) {
            i.b4Drag(j);
            i.onDrag(j);
            if (!i.moveOnly) {
                h.fireEvents(j, false)
            }
        }
        h.stopEvent(j);
        return true
    },
    fireEvents: function (x, n) {
        var z = this, o = Ext.supports.Touch, h = z.dragCurrent, v = z.currentPoint, r = v.x, q = v.y, p = [], j = [],
            l = [], b = [], y = [], w = [], a = o ? document.documentElement.clientWidth / window.innerWidth : 1, d, g,
            m, c, t, u, s, k;
        if (!h || h.isLocked()) {
            return
        }
        k = !(h.deltaX < 0 || h.deltaY < 0);
        if (o || (!z.notifyOccluded && (!Ext.supports.CSSPointerEvents || Ext.isIE10m || Ext.isOpera) && k)) {
            d = h.getDragEl();
            if (k) {
                d.style.visibility = "hidden"
            }
            x.target = document.elementFromPoint(r / a, q / a);
            if (k) {
                d.style.visibility = "visible"
            }
        }
        for (t in z.dragOvers) {
            g = z.dragOvers[t];
            delete z.dragOvers[t];
            if (!z.isTypeOfDD(g) || g.destroyed) {
                continue
            }
            if (z.notifyOccluded) {
                if (!this.isOverTarget(v, g, z.mode)) {
                    l.push(g)
                }
            } else {
                if (!x.within(g.getEl())) {
                    l.push(g)
                }
            }
            j[t] = true
        }
        for (s in h.groups) {
            if ("string" !== typeof s) {
                continue
            }
            for (t in z.ids[s]) {
                g = z.ids[s][t];
                if (z.isTypeOfDD(g) && (m = g.getEl()) && (g.isTarget) && (!g.isLocked()) && (Ext.fly(m).isVisible(true)) && ((g !== h) || (h.ignoreSelf === false))) {
                    if (z.notifyOccluded) {
                        if ((g.zIndex = z.getZIndex(m)) !== -1) {
                            c = true
                        }
                        p.push(g)
                    } else {
                        if (x.within(g.getEl())) {
                            p.push(g);
                            break
                        }
                    }
                }
            }
        }
        if (c) {
            Ext.Array.sort(p, z.byZIndex)
        }
        for (t = 0, u = p.length; t < u; t++) {
            g = p[t];
            if (z.isOverTarget(v, g, z.mode)) {
                if (n) {
                    y.push(g)
                } else {
                    if (!j[g.id]) {
                        w.push(g)
                    } else {
                        b.push(g)
                    }
                    z.dragOvers[g.id] = g
                }
                if (!z.notifyOccluded) {
                    break
                }
            }
        }
        if (z.mode) {
            if (l.length) {
                h.b4DragOut(x, l);
                h.onDragOut(x, l)
            }
            if (w.length) {
                h.onDragEnter(x, w)
            }
            if (b.length) {
                h.b4DragOver(x, b);
                h.onDragOver(x, b)
            }
            if (y.length) {
                h.b4DragDrop(x, y);
                h.onDragDrop(x, y)
            }
        } else {
            for (t = 0, u = l.length; t < u; ++t) {
                h.b4DragOut(x, l[t].id);
                h.onDragOut(x, l[t].id)
            }
            for (t = 0, u = w.length; t < u; ++t) {
                h.onDragEnter(x, w[t].id)
            }
            for (t = 0, u = b.length; t < u; ++t) {
                h.b4DragOver(x, b[t].id);
                h.onDragOver(x, b[t].id)
            }
            for (t = 0, u = y.length; t < u; ++t) {
                h.b4DragDrop(x, y[t].id);
                h.onDragDrop(x, y[t].id)
            }
        }
        if (n && !y.length) {
            h.onInvalidDrop(x)
        }
    },
    getZIndex: function (b) {
        var a = document.body, c, d = -1;
        b = Ext.getDom(b);
        while (b !== a) {
            if (!isNaN(c = Number(Ext.fly(b).getStyle("zIndex")))) {
                d = c
            }
            b = b.parentNode
        }
        return d
    },
    byZIndex: function (b, a) {
        return b.zIndex < a.zIndex
    },
    getBestMatch: function (c) {
        var e = null, b = c.length, d, a;
        if (b === 1) {
            e = c[0]
        } else {
            for (d = 0; d < b; ++d) {
                a = c[d];
                if (a.cursorIsOver) {
                    e = a;
                    break
                } else {
                    if (!e || e.overlap.getArea() < a.overlap.getArea()) {
                        e = a
                    }
                }
            }
        }
        return e
    },
    refreshCache: function (b) {
        var a, c, d, e;
        for (a in b) {
            if ("string" !== typeof a) {
                continue
            }
            for (c in this.ids[a]) {
                d = this.ids[a][c];
                if (this.isTypeOfDD(d)) {
                    e = this.getLocation(d);
                    if (e) {
                        this.locationCache[d.id] = e
                    } else {
                        delete this.locationCache[d.id]
                    }
                }
            }
        }
    },
    verifyEl: function (b) {
        if (b) {
            var a;
            if (Ext.isIE) {
                try {
                    a = b.offsetParent
                } catch (c) {
                }
            } else {
                a = b.offsetParent
            }
            if (a) {
                return true
            }
        }
        return false
    },
    getLocation: function (i) {
        if (!this.isTypeOfDD(i)) {
            return null
        }
        if (i.getRegion) {
            return i.getRegion()
        }
        var g = i.getEl(), m, d, c, o, n, p, a, k, h;
        try {
            m = Ext.fly(g).getXY()
        } catch (j) {
        }
        if (!m) {
            return null
        }
        d = m[0];
        c = d + g.offsetWidth;
        o = m[1];
        n = o + g.offsetHeight;
        p = o - i.padding[0];
        a = c + i.padding[1];
        k = n + i.padding[2];
        h = d - i.padding[3];
        return new Ext.util.Region(p, a, k, h)
    },
    isOverTarget: function (j, a, c) {
        var e = this.locationCache[a.id], i, g, b, d, h;
        if (!e || !this.useCache) {
            e = this.getLocation(a);
            this.locationCache[a.id] = e
        }
        if (!e) {
            return false
        }
        a.cursorIsOver = e.contains(j);
        i = this.dragCurrent;
        if (!i || !i.getTargetCoord || (!c && !i.constrainX && !i.constrainY)) {
            return a.cursorIsOver
        }
        a.overlap = null;
        g = i.getTargetCoord(j.x, j.y);
        b = i.getDragEl();
        d = new Ext.util.Region(g.y, g.x + b.offsetWidth, g.y + b.offsetHeight, g.x);
        h = d.intersect(e);
        if (h) {
            a.overlap = h;
            return (c) ? true : a.cursorIsOver
        } else {
            return false
        }
    },
    _onUnload: function (b, a) {
        Ext.dd.DragDropManager.unregAll()
    },
    unregAll: function () {
        var c = this, a = c.elementCache, b;
        if (c.dragCurrent) {
            c.stopDrag();
            c.dragCurrent = null
        }
        c.clearingAll = true;
        c._execOnAll("unreg", []);
        delete c.clearingAll;
        for (b in a) {
            delete a[b]
        }
        c.elementCache = {};
        c.ids = {};
        c.handleIds = {}
    },
    elementCache: {},
    getElWrapper: function (b) {
        var a = this.elementCache[b];
        if (!a || !a.el) {
            a = this.elementCache[b] = new this.ElementWrapper(Ext.getDom(b))
        }
        return a
    },
    getElement: function (a) {
        return Ext.getDom(a)
    },
    getCss: function (b) {
        var a = Ext.getDom(b);
        return (a) ? a.style : null
    },
    ElementWrapper: function (a) {
        this.el = a || null;
        this.id = this.el && a.id;
        this.css = this.el && a.style
    },
    getPosX: function (a) {
        return Ext.fly(a).getX()
    },
    getPosY: function (a) {
        return Ext.fly(a).getY()
    },
    swapNode: function (c, a) {
        if (c.swapNode) {
            c.swapNode(a)
        } else {
            var d = a.parentNode, b = a.nextSibling;
            if (b === c) {
                d.insertBefore(c, a)
            } else {
                if (a === c.nextSibling) {
                    d.insertBefore(a, c)
                } else {
                    c.parentNode.replaceChild(a, c);
                    d.insertBefore(c, b)
                }
            }
        }
    },
    getScroll: function () {
        var d = window.document, e = d.documentElement, a = d.body, c = 0, b = 0;
        if (e && (e.scrollTop || e.scrollLeft)) {
            c = e.scrollTop;
            b = e.scrollLeft
        } else {
            if (a) {
                c = a.scrollTop;
                b = a.scrollLeft
            }
        }
        return {top: c, left: b}
    },
    getStyle: function (b, a) {
        return Ext.fly(b).getStyle(a)
    },
    getScrollTop: function () {
        return this.getScroll().top
    },
    getScrollLeft: function () {
        return this.getScroll().left
    },
    moveToEl: function (a, c) {
        var b = Ext.fly(c).getXY();
        Ext.fly(a).setXY(b)
    },
    numericSort: function (d, c) {
        return (d - c)
    },
    handleWasClicked: function (a, c) {
        if (this.isHandle(c, a.id)) {
            return true
        } else {
            var b = a.parentNode;
            while (b) {
                if (this.isHandle(c, b.id)) {
                    return true
                } else {
                    b = b.parentNode
                }
            }
        }
        return false
    }
}, 0, 0, 0, 0, 0, 0, [Ext.dd, "DragDropManager", Ext.dd, "DragDropMgr", Ext.dd, "DDM"], function (a) {
    Ext.onInternalReady(function () {
        a.addListeners()
    })
}));
(Ext.cmd.derive("Ext.resizer.Splitter", Ext.Component, {
    childEls: ["collapseEl"],
    renderTpl: ['<tpl if="collapsible===true">', '<div id="{id}-collapseEl" data-ref="collapseEl" role="presentation" class="', "x-", "collapse-el ", "x-", 'layout-split-{collapseDir}{childElCls}">', "</div>", "</tpl>"],
    isSplitter: true,
    baseCls: "x-splitter",
    collapsedClsInternal: "x-splitter-collapsed",
    canResize: true,
    collapsible: null,
    collapseOnDblClick: true,
    defaultSplitMin: 40,
    defaultSplitMax: 1000,
    collapseTarget: "next",
    horizontal: false,
    vertical: false,
    size: 5,
    tracker: null,
    ariaRole: "separator",
    focusable: true,
    tabIndex: 0,
    getTrackerConfig: function () {
        return Ext.apply({xclass: "Ext.resizer.SplitterTracker", el: this.el, splitter: this}, this.tracker)
    },
    beforeRender: function () {
        var c = this, d = c.getCollapseTarget(), b = c.collapsible, a;
        Ext.Component.prototype.beforeRender.call(this);
        if (d.collapsed) {
            c.addCls(c.collapsedClsInternal)
        }
        if (!c.canResize) {
            c.addCls(c.baseCls + "-noresize")
        }
        Ext.applyIf(c.renderData, {
            collapseDir: c.getCollapseDirection(),
            collapsible: (b !== null) ? b : d.collapsible
        });
        c.ariaRenderAttributes = c.ariaRenderAttributes || {};
        c.ariaRenderAttributes["aria-orientation"] = c.orientation;
        c.protoEl.unselectable()
    },
    onRender: function () {
        var b = this, a;
        Ext.Component.prototype.onRender.apply(this, arguments);
        if (b.performCollapse !== false) {
            if (b.renderData.collapsible) {
                b.mon(b.collapseEl, "click", b.toggleTargetCmp, b)
            }
            if (b.collapseOnDblClick) {
                b.mon(b.el, "dblclick", b.toggleTargetCmp, b)
            }
        }
        b.getCollapseTarget().on({
            collapse: b.onTargetCollapse,
            expand: b.onTargetExpand,
            beforeexpand: b.onBeforeTargetExpand,
            beforecollapse: b.onBeforeTargetCollapse,
            scope: b
        });
        if (b.canResize) {
            b.tracker = Ext.create(b.getTrackerConfig());
            b.relayEvents(b.tracker, ["beforedragstart", "dragstart", "dragend"])
        }
        a = b.collapseEl;
        if (a) {
            a.lastCollapseDirCls = b.collapseDirProps[b.collapseDirection].cls
        }
    },
    getCollapseDirection: function () {
        var g = this, c = g.collapseDirection, e, a, b, d;
        if (!c) {
            e = g.collapseTarget;
            if (e.isComponent) {
                c = e.collapseDirection
            }
            if (!c) {
                d = g.ownerCt.layout.type;
                if (e.isComponent) {
                    b = g.ownerCt.items;
                    a = Number(b.indexOf(e) === b.indexOf(g) - 1) << 1 | Number(d === "hbox")
                } else {
                    a = Number(g.collapseTarget === "prev") << 1 | Number(d === "hbox")
                }
                c = ["bottom", "right", "top", "left"][a]
            }
            g.collapseDirection = c
        }
        g.setOrientation((c === "top" || c === "bottom") ? "horizontal" : "vertical");
        return c
    },
    getCollapseTarget: function () {
        var a = this;
        return a.collapseTarget.isComponent ? a.collapseTarget : a.collapseTarget === "prev" ? a.previousSibling() : a.nextSibling()
    },
    setCollapseEl: function (b) {
        var a = this.collapseEl;
        if (a) {
            a.setDisplayed(b)
        }
    },
    onBeforeTargetExpand: function (a) {
        this.setCollapseEl("none")
    },
    onBeforeTargetCollapse: function () {
        this.setCollapseEl("none")
    },
    onTargetCollapse: function (b) {
        var a = this;
        if (b === a.getCollapseTarget() && b[a.orientation === "vertical" ? "collapsedHorizontal" : "collapsedVertical"]()) {
            a.el.addCls(a.collapsedClsInternal + " " + (a.collapsedCls || ""))
        }
        a.setCollapseEl("")
    },
    onTargetExpand: function (b) {
        var a = this;
        a.el.removeCls(a.collapsedClsInternal + " " + (a.collapsedCls || ""));
        a.setCollapseEl("")
    },
    collapseDirProps: {
        top: {cls: "x-layout-split-top"},
        right: {cls: "x-layout-split-right"},
        bottom: {cls: "x-layout-split-bottom"},
        left: {cls: "x-layout-split-left"}
    },
    orientationProps: {
        horizontal: {opposite: "vertical", fixedAxis: "height", stretchedAxis: "width"},
        vertical: {opposite: "horizontal", fixedAxis: "width", stretchedAxis: "height"}
    },
    applyCollapseDirection: function () {
        var c = this, b = c.collapseEl, d = c.collapseDirProps[c.collapseDirection], a;
        if (b) {
            a = b.lastCollapseDirCls;
            if (a) {
                b.removeCls(a)
            }
            b.addCls(b.lastCollapseDirCls = d.cls)
        }
    },
    applyOrientation: function () {
        var e = this, c = e.orientation, d = e.orientationProps[c], g = e.size, b = d.fixedAxis, h = d.stretchedAxis,
            a = e.baseCls + "-";
        e[c] = true;
        e[d.opposite] = false;
        if (!e.hasOwnProperty(b) || e[b] === "100%") {
            e[b] = g
        }
        if (!e.hasOwnProperty(h) || e[h] === g) {
            e[h] = "100%"
        }
        e.removeCls(a + d.opposite);
        e.addCls(a + c)
    },
    setOrientation: function (a) {
        var b = this;
        if (b.orientation !== a) {
            b.orientation = a;
            b.applyOrientation()
        }
    },
    updateOrientation: function () {
        delete this.collapseDirection;
        this.getCollapseDirection();
        this.applyCollapseDirection()
    },
    toggleTargetCmp: function (d, b) {
        var c = this.getCollapseTarget(), g = c.placeholder, a;
        if (Ext.isFunction(c.expand) && Ext.isFunction(c.collapse)) {
            if (g && !g.hidden) {
                a = true
            } else {
                a = !c.hidden
            }
            if (a) {
                if (c.collapsed) {
                    c.expand()
                } else {
                    if (c.collapseDirection) {
                        c.collapse()
                    } else {
                        c.collapse(this.renderData.collapseDir)
                    }
                }
            }
        }
    },
    setSize: function () {
        var a = this;
        Ext.Component.prototype.setSize.apply(this, arguments);
        if (Ext.isIE && a.el) {
            a.el.repaint()
        }
    },
    beforeDestroy: function () {
        Ext.destroy(this.tracker);
        Ext.Component.prototype.beforeDestroy.call(this)
    }
}, 0, ["splitter"], ["component", "box", "splitter"], {
    component: true,
    box: true,
    splitter: true
}, ["widget.splitter"], 0, [Ext.resizer, "Splitter"], 0));
(Ext.cmd.derive("Ext.layout.container.Box", Ext.layout.container.Container, {
    alternateClassName: "Ext.layout.BoxLayout",
    type: "box",
    config: {
        align: "begin",
        constrainAlign: false,
        enableSplitters: true,
        overflowHandler: {
            $value: null, merge: function (b, a) {
                if (typeof b === "string") {
                    b = {type: b}
                }
                return Ext.merge(a ? Ext.Object.chain(a) : {}, b)
            }
        },
        padding: 0,
        pack: "start",
        stretchMaxPartner: undefined,
        vertical: false,
        alignRoundingMethod: "round"
    },
    itemCls: "x-box-item",
    targetCls: "x-box-layout-ct",
    targetElCls: "x-box-target",
    innerCls: "x-box-inner",
    manageMargins: true,
    createsInnerCt: true,
    childEls: ["innerCt", "targetEl"],
    renderTpl: ['{%var oc,l=values.$comp.layout,oh=l.overflowHandler;if (oh && oh.getPrefixConfig!==Ext.emptyFn) {if(oc=oh.getPrefixConfig())dh.generateMarkup(oc, out)}%}<div id="{ownerId}-innerCt" data-ref="innerCt" role="presentation" class="{[l.innerCls]}{[oh ? (" " + oh.getOverflowCls(l.direction)) : ""]}"><div id="{ownerId}-targetEl" data-ref="targetEl" class="{targetElCls}" role="presentation">{%this.renderBody(out, values)%}</div></div>{%if (oh && oh.getSuffixConfig!==Ext.emptyFn) {if(oc=oh.getSuffixConfig())dh.generateMarkup(oc, out)}%}', {
        disableFormats: true,
        definitions: "var dh=Ext.DomHelper;"
    }],
    constructor: function (a) {
        var c = this, b;
        Ext.layout.container.Container.prototype.constructor.apply(this, arguments);
        c.setVertical(c.vertical);
        c.flexSortFn = c.flexSort.bind(c);
        b = typeof c.padding;
        if (b === "string" || b === "number") {
            c.padding = Ext.util.Format.parseBox(c.padding);
            c.padding.height = c.padding.top + c.padding.bottom;
            c.padding.width = c.padding.left + c.padding.right
        }
    },
    _beginRe: /^(?:begin|left|top)$/,
    _centerRe: /^(?:center|middle)$/,
    _endRe: /^(?:end|right|bottom)$/,
    _percentageRe: /^\\s*(\\d+(?:\\.\\d*)?)\\s*[%]\\s*$/,
    getItemSizePolicy: function (q, r) {
        var l = this, j = l.sizePolicy, h = l.align, g = q.flex, o = h, k = l.names, i = k.height, n = k.width,
            b = q[n], p = q[i], d = l._percentageRe, c = d.test(b), e = (h === "stretch"), a = (h === "stretchmax"),
            m = l.constrainAlign;
        if (!r && (e || g || c || (m && !a))) {
            r = l.owner.getSizeModel()
        }
        if (e) {
            if (!d.test(p) && r[i].shrinkWrap) {
                o = "stretchmax"
            }
        } else {
            if (!a) {
                if (d.test(p)) {
                    o = "stretch"
                } else {
                    if (m && !r[i].shrinkWrap) {
                        o = "stretchmax"
                    } else {
                        o = ""
                    }
                }
            }
        }
        if (g || c) {
            if (!r[n].shrinkWrap) {
                j = j.flex
            }
        }
        return j[o]
    },
    flexSort: function (o, n) {
        var l = this.names.maxWidth, e = this.names.minWidth, m = Infinity, k = o.target, r = n.target, i = k.flex,
            h = r.flex, s = 0, c, p, j, d, q, g;
        j = k[l] || m;
        d = r[l] || m;
        c = k[e] || 0;
        p = r[e] || 0;
        q = isFinite(c) || isFinite(p);
        g = isFinite(j) || isFinite(d);
        if (q || g) {
            if (g) {
                s = j - d
            }
            if (s === 0 && q) {
                s = p - c
            }
            if (s === 0) {
                if (g) {
                    s = h - i
                } else {
                    s = i - h
                }
            }
        }
        return s
    },
    isItemBoxParent: function (a) {
        return true
    },
    isItemShrinkWrap: function (a) {
        return true
    },
    roundFlex: function (a) {
        return Math.floor(a)
    },
    beginCollapse: function (b) {
        var a = this;
        if (a.direction === "vertical" && b.collapsedVertical()) {
            b.collapseMemento.capture(["flex"]);
            delete b.flex
        } else {
            if (a.direction === "horizontal" && b.collapsedHorizontal()) {
                b.collapseMemento.capture(["flex"]);
                delete b.flex
            }
        }
    },
    beginExpand: function (a) {
        a.collapseMemento.restore(["flex"])
    },
    beginLayout: function (e) {
        var i = this, b = i.owner, d = b.stretchMaxPartner, a = i.innerCt.dom.style, h = i.names, g = i.overflowHandler,
            j = b.getScrollable(), c;
        e.boxNames = h;
        if (g) {
            g.beginLayout(e)
        }
        if (typeof d === "string") {
            d = Ext.getCmp(d) || b.query(d)[0]
        }
        e.stretchMaxPartner = d && e.context.getCmp(d);
        Ext.layout.container.Container.prototype.beginLayout.apply(this, arguments);
        e.innerCtContext = e.getEl("innerCt", i);
        e.targetElContext = e.getEl("targetEl", i);
        e.ownerScrollable = j = b.getScrollable();
        if (j) {
            e.scrollRestore = j.getPosition()
        }
        a.width = "";
        a.height = ""
    },
    beginLayoutCycle: function (d, n) {
        var k = this, a = d.state, l = d.ownerScrollable, i = k.align, j = d.boxNames, m = k.pack, c = k._centerRe,
            e = k.overflowHandler, b = d.state.canScroll, h, g;
        if (e) {
            e.beginLayoutCycle(d, n)
        }
        Ext.layout.container.Container.prototype.beginLayoutCycle.apply(this, arguments);
        d.parallelSizeModel = h = d[j.widthModel];
        d.perpendicularSizeModel = g = d[j.heightModel];
        d.boxOptions = {
            align: i = {
                stretch: i === "stretch",
                stretchmax: i === "stretchmax",
                center: c.test(i),
                bottom: k._endRe.test(i)
            }, pack: m = {center: c.test(m), end: m === "end"}
        };
        if (l) {
            if (!b) {
                a.canScroll = {parallel: !h.shrinkWrap && l[j.getX](), perpendicular: !g.shrinkWrap && l[j.getY]()}
            }
            if (!a.actualScroll) {
                a.actualScroll = {parallel: false, perpendicular: false}
            }
        }
        if (i.stretch && g.shrinkWrap) {
            i.stretchmax = true;
            i.stretch = false
        }
        i.nostretch = !(i.stretch || i.stretchmax);
        if (h.shrinkWrap) {
            m.center = m.end = false
        }
        k.cacheFlexes(d);
        k.targetEl.setWidth(20000)
    },
    cacheFlexes: function (m) {
        var B = this, n = m.boxNames, a = n.widthModel, h = n.heightModel, c = m.boxOptions.align.nostretch, t = 0,
            b = m.childItems, v = b.length, z = [], o = 0, w = 0, s = 0, l = n.minWidth, y = n.minHeight,
            j = B._percentageRe, x = 0, A = 0, g, q, u, k, d, e, r, p;
        while (v--) {
            q = b[v];
            g = q.target;
            e = q[a];
            if (e.calculated) {
                q.flex = u = g.flex;
                if (u) {
                    t += u;
                    z.push(q);
                    o += g[l] || 0
                } else {
                    k = j.exec(g[n.width]);
                    q.percentageParallel = parseFloat(k[1]) / 100;
                    ++x
                }
            }
            if (e.configured) {
                r = g[n.width]
            } else {
                r = g[l] || 0
            }
            s += r;
            d = q[h];
            if (c && d.calculated) {
                k = j.exec(g[n.height]);
                q.percentagePerpendicular = parseFloat(k[1]) / 100;
                ++A
            }
            if (d.configured) {
                p = g[n.height]
            } else {
                p = g[y] || 0
            }
            if (p > w) {
                w = p
            }
        }
        m.flexedItems = z;
        m.flexedMinWidth = o;
        m.smallestWidth = s;
        m.smallestHeight = w;
        m.totalFlex = t;
        m.percentageWidths = x;
        m.percentageHeights = A;
        Ext.Array.sort(z, B.flexSortFn)
    },
    calculate: function (c) {
        var h = this, g = c.boxNames, a = c.state, e = a.actualScroll, j = a.needsScroll, b = a.canScroll,
            i = a.boxPlan || (a.boxPlan = {}), d = h.overflowHandler;
        i.targetSize = h.getContainerSize(c);
        if (b && !j) {
            a.needsScroll = j = {
                parallel: b.parallel && i.targetSize[g.width] < c.smallestWidth,
                perpendicular: b.perpendicular && i.targetSize[g.height] < c.smallestHeight
            }
        }
        if (!a.parallelDone) {
            a.parallelDone = h.calculateParallel(c, g, i)
        }
        if (!a.perpendicularDone) {
            a.perpendicularDone = h.calculatePerpendicular(c, g, i)
        }
        if (a.parallelDone && a.perpendicularDone) {
            if (b && !a.scrollPass) {
                if (j.parallel !== e.parallel || j.perpendicular !== e.perpendicular) {
                    c.invalidate({state: {scrollPass: true, canScroll: b, needsScroll: e}});
                    h.done = false;
                    return
                }
            }
            h.publishInnerCtSize(c);
            if (h.done && c.boxOptions.align.stretchmax && !a.stretchMaxDone) {
                h.calculateStretchMax(c, g, i);
                a.stretchMaxDone = true
            }
            if (d) {
                d.calculate(c)
            }
        } else {
            h.done = false
        }
    },
    calculateParallel: function (x, L, C) {
        var r = this, o = x.parallelSizeModel.shrinkWrap, D = L.width, h = x.childItems, t = L.beforeX, H = L.afterX,
            l = L.setWidth, A = h.length, w = x.flexedItems, G = w.length, q = x.boxOptions.pack, I = r.padding,
            b = C.targetSize, p = b[D], M = x.state, z = M.needsScroll, s = M.canScroll, B = 0, j = I[t], F = j + I[H],
            u = Ext.getScrollbarSize(), e = u[L.width], a = u[L.height], J, y, g, m, n, k, c, K, E, v, d;
        if (!o && !b[L.gotWidth]) {
            return false
        }
        for (J = 0; J < A; ++J) {
            n = h[J];
            y = n.marginInfo || n.getMarginInfo();
            B += y[D];
            if (!n[L.widthModel].calculated) {
                E = n.getProp(D);
                F += E;
                if (isNaN(F)) {
                    return false
                }
            }
        }
        F += B;
        if (x.percentageWidths) {
            v = p - B;
            if (isNaN(v)) {
                return false
            }
            for (J = 0; J < A; ++J) {
                n = h[J];
                if (n.percentageParallel) {
                    E = Math.ceil(v * n.percentageParallel);
                    E = n.setWidth(E);
                    F += E
                }
            }
        }
        if (o) {
            d = 0;
            C.tooNarrow = false
        } else {
            d = p - F;
            if (z && z.perpendicular) {
                d -= a
            }
            C.tooNarrow = d < x.flexedMinWidth;
            if (C.tooNarrow && s && s.parallel) {
                M.actualScroll.parallel = true
            }
        }
        K = F;
        g = d;
        m = x.totalFlex;
        for (J = 0; J < G; J++) {
            n = w[J];
            k = n.flex;
            c = r.roundFlex((k / m) * g);
            c = n[l](c);
            K += c;
            g = Math.max(0, g - c);
            m -= k
        }
        if (q.center) {
            j += g / 2;
            if (j < 0) {
                j = 0
            }
        } else {
            if (q.end) {
                j += g
            }
        }
        for (J = 0; J < A; ++J) {
            n = h[J];
            y = n.marginInfo;
            j += y[t];
            n.setProp(L.x, j);
            j += y[H] + n.props[D]
        }
        K += x.targetContext.getPaddingInfo()[D];
        x.state.contentWidth = K;
        if (z && z.perpendicular) {
            if (o) {
                K += e
            }
            x[L.hasOverflowY] = true;
            x.target.componentLayout[L.setWidthInDom] = true;
            x[L.invalidateScrollY] = Ext.isIE8
        }
        x[L.setContentWidth](K);
        return true
    },
    calculatePerpendicular: function (v, M, B) {
        var t = this, Q = v.state, x = Q.needsScroll, u = Q.canScroll, d = v.perpendicularSizeModel.shrinkWrap,
            b = B.targetSize, j = v.childItems, A = j.length, m = Math.max, l = M.height, n = M.setHeight,
            h = M.beforeY, s = M.y, J = t.padding, k = J[h], o = b[l] - k - J[M.afterY], G = v.boxOptions.align,
            p = G.stretch, q = G.stretchmax, P = G.center, O = G.bottom, I = t.constrainAlign, H = 0, D = 0,
            F = t.onBeforeConstrainInvalidateChild, C = t.onAfterConstrainInvalidateChild,
            a = Ext.getScrollbarSize().height, z, K, E, w, y, c, r, e, N, L, g;
        if (!d && !b[M.gotHeight]) {
            return false
        }
        if (p || ((P || O) && !d)) {
            if (isNaN(o)) {
                return false
            }
        }
        if (x && x.parallel) {
            if (d) {
                L = true
            } else {
                o -= a;
                B.targetSize[l] -= a
            }
        }
        if (p) {
            c = o;
            H = m(c, v.smallestHeight)
        } else {
            for (K = 0; K < A; K++) {
                r = j[K];
                w = (r.marginInfo || r.getMarginInfo())[l];
                if (!(g = r.percentagePerpendicular)) {
                    E = r.getProp(l)
                } else {
                    ++D;
                    if (d) {
                        continue
                    } else {
                        E = g * o - w;
                        E = r[M.setHeight](E)
                    }
                }
                if (!d && I && r[M.heightModel].shrinkWrap && E > o) {
                    r.invalidate({before: F, after: C, layout: t, childHeight: o, names: M});
                    v.state.parallelDone = false
                }
                if (isNaN(H = m(H, E + w, r.target[M.minHeight] || 0))) {
                    return false
                }
            }
        }
        if (L) {
            H += a;
            v[M.hasOverflowX] = true;
            v.target.componentLayout[M.setHeightInDom] = true;
            v[M.invalidateScrollX] = Ext.isIE8
        }
        e = v.stretchMaxPartner;
        if (e) {
            v.setProp("maxChildHeight", H);
            N = e.childItems;
            if (N && N.length) {
                H = m(H, e.getProp("maxChildHeight"));
                if (isNaN(H)) {
                    return false
                }
            }
        }
        v[M.setContentHeight](H + t.padding[l] + v.targetContext.getPaddingInfo()[l]);
        if (L) {
            H -= a
        }
        if (H > b[l] && u && u.perpendicular) {
            Q.actualScroll.perpendicular = true
        }
        B.maxSize = H;
        if (q) {
            c = H
        } else {
            if (P || O || D) {
                if (I) {
                    c = d ? H : o
                } else {
                    c = d ? H : m(o, H)
                }
                c -= v.innerCtContext.getBorderInfo()[l]
            }
        }
        for (K = 0; K < A; K++) {
            r = j[K];
            w = r.marginInfo || r.getMarginInfo();
            z = k + w[h];
            if (p) {
                r[n](c - w[l])
            } else {
                g = r.percentagePerpendicular;
                if (d && g) {
                    w = r.marginInfo || r.getMarginInfo();
                    E = g * c - w[l];
                    E = r.setHeight(E)
                }
                if (P) {
                    y = c - r.props[l];
                    if (y > 0) {
                        z = k + Math[t.alignRoundingMethod](y / 2)
                    }
                } else {
                    if (O) {
                        z = m(0, c - z - r.props[l])
                    }
                }
            }
            r.setProp(s, z)
        }
        return true
    },
    onBeforeConstrainInvalidateChild: function (b, a) {
        var c = a.names.heightModel;
        if (!b[c].constrainedMin) {
            b[c] = Ext.layout.SizeModel.calculated
        }
    },
    onAfterConstrainInvalidateChild: function (b, a) {
        var c = a.names;
        b.setProp(c.beforeY, 0);
        if (b[c.heightModel].calculated) {
            b[c.setHeight](a.childHeight)
        }
    },
    calculateStretchMax: function (c, k, m) {
        var l = this, h = k.height, n = k.width, g = c.childItems, a = g.length, p = m.maxSize,
            o = l.onBeforeStretchMaxInvalidateChild, e = l.onAfterStretchMaxInvalidateChild, q, j, d, b;
        for (d = 0; d < a; ++d) {
            q = g[d];
            j = q.props;
            b = p - q.getMarginInfo()[h];
            if (b !== j[h] || q[k.heightModel].constrained) {
                q.invalidate({
                    before: o,
                    after: e,
                    layout: l,
                    childWidth: j[n],
                    childHeight: b,
                    childX: j.x,
                    childY: j.y,
                    names: k
                })
            }
        }
    },
    onBeforeStretchMaxInvalidateChild: function (b, a) {
        var c = a.names.heightModel;
        if (!b[c].constrainedMax) {
            b[c] = Ext.layout.SizeModel.calculated
        }
    },
    onAfterStretchMaxInvalidateChild: function (d, c) {
        var e = c.names, a = c.childHeight, b = c.childWidth;
        d.setProp("x", c.childX);
        d.setProp("y", c.childY);
        if (d[e.heightModel].calculated) {
            d[e.setHeight](a)
        }
        if (d[e.widthModel].calculated) {
            d[e.setWidth](b)
        }
    },
    completeLayout: function (b) {
        var k = this, j = b.boxNames, i = b.invalidateScrollX, h = b.invalidateScrollY, c = k.overflowHandler,
            n = b.scrollRestore, e, a, g, d, o, m, l;
        if (c) {
            c.completeLayout(b)
        }
        if (i || h) {
            a = k.getTarget();
            e = a.dom;
            o = e.style;
            if (i) {
                g = a.getStyle("overflowX");
                if (g === "auto") {
                    g = o.overflowX;
                    o.overflowX = "scroll"
                } else {
                    i = false
                }
            }
            if (h) {
                d = a.getStyle("overflowY");
                if (d === "auto") {
                    d = o.overflowY;
                    o.overflowY = "scroll"
                } else {
                    h = false
                }
            }
            if (i || h) {
                e.scrollWidth;
                if (i) {
                    o.overflowX = g
                }
                if (h) {
                    o.overflowY = d
                }
            }
        }
        if (n) {
            b.ownerScrollable.scrollTo(n.x, n.y)
        }
    },
    finishedLayout: function (b) {
        var a = this.overflowHandler;
        if (a) {
            a.finishedLayout(b)
        }
        Ext.layout.container.Container.prototype.finishedLayout.apply(this, arguments)
    },
    getLayoutItems: function () {
        var j = Ext.layout.container.Container.prototype.getLayoutItems.call(this), b = j.length, e, d, c, k, h, g, a;
        for (c = 0; c < b; ++c) {
            if ((k = j[c]).isSplitter) {
                continue
            }
            a = k.splitter;
            if (k.hidden) {
                if (a) {
                    if (!a.hidden) {
                        a.hidden = true;
                        if (a.el) {
                            a.el.hide()
                        }
                    }
                }
                continue
            }
            if (a) {
                g = a.collapseTarget === "next"
            } else {
                g = false
            }
            d = null;
            if (e && h) {
                if (h.hidden) {
                    h.hidden = false;
                    if (h.el) {
                        h.el.show()
                    }
                }
                if (g) {
                    d = true
                }
            } else {
                if (g) {
                    d = !e
                }
            }
            if (d !== null && a.hidden !== d) {
                a.hidden = d;
                if (a.el) {
                    a.el.setVisible(!d)
                }
            }
            h = !g && a;
            e = k
        }
        if (e && h && !h.hidden) {
            h.hidden = true;
            if (h.el) {
                h.el.hide()
            }
        }
        return j
    },
    getScrollerEl: function () {
        return this.innerCt
    },
    insertSplitter: function (d, c, g, b) {
        var e = {xtype: "splitter", id: d.id + "-splitter", hidden: g, splitterFor: d, synthetic: true},
            a = c + ((b.collapseTarget === "prev") ? 1 : 0);
        e[this.names.height] = "100%";
        if (b) {
            Ext.apply(e, b)
        }
        d.splitter = this.owner.add(a, e)
    },
    publishInnerCtSize: function (b, d) {
        d = d || 0;
        var j = this, a = b.state, i = b.boxNames, h = i.height, l = i.width, g = b.boxOptions.align, n = j.padding,
            k = a.boxPlan, e = k.targetSize, p = k.maxSize, m = a.needsScroll, q = b.innerCtContext, c, o;
        if (b.parallelSizeModel.shrinkWrap || (k.tooNarrow && a.canScroll)) {
            c = a.contentWidth - b.targetContext.getPaddingInfo()[l]
        } else {
            c = e[l];
            if (m && m.perpendicular) {
                c -= Ext.getScrollbarSize()[l]
            }
        }
        c -= d;
        j.owner.tooNarrow = k.tooNarrow;
        if (g.stretch) {
            o = p
        } else {
            o = k.maxSize + n[i.beforeY] + n[i.afterY] + q.getBorderInfo()[h];
            if (!b.perpendicularSizeModel.shrinkWrap && (g.center || g.bottom)) {
                o = Math.max(e[h], o)
            }
        }
        q[i.setWidth](c);
        q[i.setHeight](o);
        b.targetElContext.setWidth(b.innerCtContext.props.width - (j.vertical ? 0 : (d || 0)));
        if (isNaN(c + o)) {
            j.done = false
        }
    },
    onAdd: function (d, a) {
        var c = this, b = c.enableSplitters && d.split && !d.isButton;
        Ext.layout.container.Container.prototype.onAdd.apply(this, arguments);
        if (b) {
            if (b === true) {
                b = {collapseTarget: "next"}
            } else {
                if (Ext.isString(b)) {
                    b = {collapseTarget: b === "before" ? "next" : "prev"}
                } else {
                    b = Ext.apply({collapseTarget: b.side === "before" ? "next" : "prev"}, b)
                }
            }
            c.insertSplitter(d, a, !!d.hidden, b)
        }
    },
    onRemove: function (b, e) {
        var g = this, i = g.names, a = g.owner, h = b.splitter, c = g.overflowHandler, d;
        Ext.layout.container.Container.prototype.onRemove.apply(this, arguments);
        if (h && a.contains(h)) {
            a.doRemove(h, true);
            b.splitter = null
        }
        if (c) {
            c.onRemove(b)
        }
        if (b.layoutMarginCap === g.id) {
            delete b.layoutMarginCap
        }
        if (!a.destroying && !e && b.rendered) {
            d = b.getEl();
            if (d) {
                d.setStyle(i.beforeY, "");
                d.setStyle(i.beforeX, "");
                d.setStyle("margin", "")
            }
        }
    },
    applyOverflowHandler: function (b, a) {
        var c;
        if (typeof b === "string") {
            b = {type: b}
        }
        c = b.type;
        if (a && a.type === b.type) {
            delete b.type;
            a.setConfig(b);
            return a
        }
        b.layout = this;
        return Ext.Factory.boxOverflow(b)
    },
    getRenderTarget: function () {
        return this.targetEl
    },
    getElementTarget: function () {
        return this.innerCt
    },
    destroy: function () {
        var a = this;
        Ext.destroy(a.innerCt, a.overflowHandler);
        a.flexSortFn = a.innerCt = null;
        Ext.layout.container.Container.prototype.destroy.call(this)
    },
    getRenderData: function () {
        var a = Ext.layout.container.Container.prototype.getRenderData.call(this);
        a.targetElCls = this.targetElCls;
        return a
    },
    updateVertical: function (b) {
        var e = this, c = e.overflowHandler, a = e.owner, d = e._props;
        Ext.apply(e, b ? d.vbox : d.hbox);
        if (c && a && a.rendered) {
            c.setVertical(b)
        }
    },
    _props: {
        hbox: {
            direction: "horizontal",
            oppositeDirection: "vertical",
            horizontal: true,
            vertical: false,
            names: {
                beforeX: "left",
                beforeScrollX: "left",
                leftCap: "Left",
                afterX: "right",
                width: "width",
                contentWidth: "contentWidth",
                minWidth: "minWidth",
                maxWidth: "maxWidth",
                widthCap: "Width",
                widthModel: "widthModel",
                widthIndex: 0,
                x: "x",
                getX: "getX",
                setX: "setX",
                scrollLeft: "scrollLeft",
                overflowX: "overflowX",
                hasOverflowX: "hasOverflowX",
                invalidateScrollX: "invalidateScrollX",
                parallelMargins: "lr",
                center: "middle",
                beforeY: "top",
                afterY: "bottom",
                height: "height",
                contentHeight: "contentHeight",
                minHeight: "minHeight",
                maxHeight: "maxHeight",
                heightCap: "Height",
                heightModel: "heightModel",
                heightIndex: 1,
                y: "y",
                getY: "getY",
                setY: "setY",
                overflowY: "overflowY",
                hasOverflowY: "hasOverflowY",
                invalidateScrollY: "invalidateScrollY",
                perpendicularMargins: "tb",
                getWidth: "getWidth",
                getHeight: "getHeight",
                setWidth: "setWidth",
                setHeight: "setHeight",
                gotWidth: "gotWidth",
                gotHeight: "gotHeight",
                setContentWidth: "setContentWidth",
                setContentHeight: "setContentHeight",
                setWidthInDom: "setWidthInDom",
                setHeightInDom: "setHeightInDom",
                getScrollLeft: "getScrollLeft",
                setScrollLeft: "setScrollLeft",
                scrollTo: "scrollTo"
            },
            sizePolicy: {
                flex: {
                    "": {readsWidth: 0, readsHeight: 1, setsWidth: 1, setsHeight: 0},
                    stretch: {readsWidth: 0, readsHeight: 0, setsWidth: 1, setsHeight: 1},
                    stretchmax: {readsWidth: 0, readsHeight: 1, setsWidth: 1, setsHeight: 1}
                },
                "": {readsWidth: 1, readsHeight: 1, setsWidth: 0, setsHeight: 0},
                stretch: {readsWidth: 1, readsHeight: 0, setsWidth: 0, setsHeight: 1},
                stretchmax: {readsWidth: 1, readsHeight: 1, setsWidth: 0, setsHeight: 1}
            }
        }, vbox: {
            direction: "vertical",
            oppositeDirection: "horizontal",
            horizontal: false,
            vertical: true,
            names: {
                beforeX: "top",
                beforeScrollX: "top",
                leftCap: "Top",
                afterX: "bottom",
                width: "height",
                contentWidth: "contentHeight",
                minWidth: "minHeight",
                maxWidth: "maxHeight",
                widthCap: "Height",
                widthModel: "heightModel",
                widthIndex: 1,
                x: "y",
                getX: "getY",
                setX: "setY",
                scrollLeft: "scrollTop",
                overflowX: "overflowY",
                hasOverflowX: "hasOverflowY",
                invalidateScrollX: "invalidateScrollY",
                parallelMargins: "tb",
                center: "center",
                beforeY: "left",
                afterY: "right",
                height: "width",
                contentHeight: "contentWidth",
                minHeight: "minWidth",
                maxHeight: "maxWidth",
                heightCap: "Width",
                heightModel: "widthModel",
                heightIndex: 0,
                y: "x",
                getY: "getX",
                setY: "setX",
                overflowY: "overflowX",
                hasOverflowY: "hasOverflowX",
                invalidateScrollY: "invalidateScrollX",
                perpendicularMargins: "lr",
                getWidth: "getHeight",
                getHeight: "getWidth",
                setWidth: "setHeight",
                setHeight: "setWidth",
                gotWidth: "gotHeight",
                gotHeight: "gotWidth",
                setContentWidth: "setContentHeight",
                setContentHeight: "setContentWidth",
                setWidthInDom: "setHeightInDom",
                setHeightInDom: "setWidthInDom",
                getScrollLeft: "getScrollTop",
                setScrollLeft: "setScrollTop",
                scrollTo: "scrollTo"
            },
            sizePolicy: {
                flex: {
                    "": {readsWidth: 1, readsHeight: 0, setsWidth: 0, setsHeight: 1},
                    stretch: {readsWidth: 0, readsHeight: 0, setsWidth: 1, setsHeight: 1},
                    stretchmax: {readsWidth: 1, readsHeight: 0, setsWidth: 1, setsHeight: 1}
                },
                "": {readsWidth: 1, readsHeight: 1, setsWidth: 0, setsHeight: 0},
                stretch: {readsWidth: 0, readsHeight: 1, setsWidth: 1, setsHeight: 0},
                stretchmax: {readsWidth: 1, readsHeight: 1, setsWidth: 1, setsHeight: 0}
            }
        }
    }
}, 1, 0, 0, 0, ["layout.box"], 0, [Ext.layout.container, "Box", Ext.layout, "BoxLayout"], 0));
(Ext.cmd.derive("Ext.layout.container.HBox", Ext.layout.container.Box, {
    alternateClassName: "Ext.layout.HBoxLayout",
    type: "hbox",
    vertical: false
}, 0, 0, 0, 0, ["layout.hbox"], 0, [Ext.layout.container, "HBox", Ext.layout, "HBoxLayout"], 0));
(Ext.cmd.derive("Ext.layout.container.VBox", Ext.layout.container.Box, {
    alternateClassName: "Ext.layout.VBoxLayout",
    type: "vbox",
    vertical: true
}, 0, 0, 0, 0, ["layout.vbox"], 0, [Ext.layout.container, "VBox", Ext.layout, "VBoxLayout"], 0));
(Ext.cmd.derive("Ext.toolbar.Toolbar", Ext.container.Container, {
    alternateClassName: "Ext.Toolbar",
    isToolbar: true,
    baseCls: "x-toolbar",
    ariaRole: "toolbar",
    defaultType: "button",
    layout: undefined,
    vertical: undefined,
    enableOverflow: false,
    overflowHandler: null,
    defaultButtonUI: "default-toolbar",
    defaultFieldUI: "default",
    defaultFooterButtonUI: "default",
    defaultFooterFieldUI: "default",
    trackMenus: true,
    itemCls: "x-toolbar-item",
    statics: {
        shortcuts: {"-": "tbseparator", " ": "tbspacer"},
        shortcutsHV: {0: {"->": {xtype: "tbfill", height: 0}}, 1: {"->": {xtype: "tbfill", width: 0}}}
    },
    initComponent: function () {
        var c = this, b = c.layout, a = c.vertical;
        if (a === undefined) {
            c.vertical = a = c.dock === "right" || c.dock === "left"
        }
        c.layout = b = Ext.applyIf(Ext.isString(b) ? {type: b} : b || {}, {
            type: a ? "vbox" : "hbox",
            align: a ? "stretchmax" : "middle"
        });
        if (c.overflowHandler) {
            b.overflowHandler = c.overflowHandler
        } else {
            if (c.enableOverflow) {
                b.overflowHandler = "menu"
            }
        }
        if (a) {
            c.addClsWithUI("vertical")
        }
        if (c.ui === "footer") {
            c.ignoreBorderManagement = true
        }
        Ext.container.Container.prototype.initComponent.call(this)
    },
    getRefItems: function (a) {
        var e = this, b = Ext.container.Container.prototype.getRefItems.apply(this, arguments), d = e.layout, c;
        if (a && (e.enableOverflow || (e.overflowHandler === "menu"))) {
            c = d.overflowHandler;
            if (c && c.menu) {
                b = b.concat(c.menu.getRefItems(a))
            }
        }
        return b
    },
    lookupComponent: function (e) {
        var d = arguments, a, b;
        if (typeof e === "string") {
            b = Ext.toolbar.Toolbar;
            a = b.shortcutsHV[this.vertical ? 1 : 0][e] || b.shortcuts[e];
            if (typeof a === "string") {
                e = {xtype: a}
            } else {
                if (a) {
                    e = Ext.apply({}, a)
                } else {
                    e = {xtype: "tbtext", text: e}
                }
            }
            this.applyDefaults(e);
            d = [e]
        }
        return Ext.container.Container.prototype.lookupComponent.apply(this, d)
    },
    onBeforeAdd: function (b) {
        var c = this, d = c.ui === "footer", a = d ? c.defaultFooterButtonUI : c.defaultButtonUI;
        if (b.isSegmentedButton) {
            if (b.getDefaultUI() === "default" && !b.config.hasOwnProperty("defaultUI")) {
                b.setDefaultUI(a)
            }
        } else {
            if (b.ui === "default" && !b.hasOwnProperty("ui")) {
                if (b.isButton) {
                    b.ui = a
                } else {
                    if (b.isFormField) {
                        b.ui = d ? c.defaultFooterFieldUI : c.defaultFieldUI
                    }
                }
            }
        }
        if (b instanceof Ext.toolbar.Separator) {
            b.setUI(c.vertical ? "vertical" : "horizontal")
        }
        Ext.container.Container.prototype.onBeforeAdd.apply(this, arguments)
    },
    onAdd: function (a) {
        if (a.needArrowKeys && this.enableFocusableContainer) {
            this.enableFocusableContainer = false
        }
        Ext.container.Container.prototype.onAdd.apply(this, arguments);
        this.trackMenu(a)
    },
    onRemove: function (a) {
        Ext.container.Container.prototype.onRemove.apply(this, arguments);
        this.trackMenu(a, true)
    },
    privates: {
        applyDefaults: function (a) {
            if (!Ext.isString(a)) {
                a = Ext.container.Container.prototype.applyDefaults.apply(this, arguments)
            }
            return a
        }, trackMenu: function (c, a) {
            var b = this;
            if (b.trackMenus && c.menu) {
                c[a ? "un" : "on"]({
                    mouseover: b.onButtonOver,
                    menushow: b.onButtonMenuShow,
                    menuhide: b.onButtonMenuHide,
                    scope: b
                })
            }
        }, getChildItemsToDisable: function () {
            return this.items.getRange()
        }, onButtonOver: function (b, c) {
            var a = this.activeMenuBtn;
            if (a && a !== b) {
                a.hideMenu();
                b.focus();
                b.showMenu(c);
                this.activeMenuBtn = b
            }
        }, onButtonMenuShow: function (a) {
            this.activeMenuBtn = a
        }, onButtonMenuHide: function (a) {
            this.activeMenuBtn = null
        }
    }
}, 0, ["toolbar"], ["component", "box", "container", "toolbar"], {
    component: true,
    box: true,
    container: true,
    toolbar: true
}, ["widget.toolbar"], [[Ext.util.FocusableContainer.prototype.mixinId || Ext.util.FocusableContainer.$className, Ext.util.FocusableContainer]], [Ext.toolbar, "Toolbar", Ext, "Toolbar"], 0));
(Ext.cmd.derive("Ext.dd.DragDrop", Ext.Base, {
    constructor: function (c, a, b) {
        if (c) {
            this.init(c, a, b)
        }
    },
    id: null,
    config: null,
    dragElId: null,
    handleElId: null,
    invalidHandleTypes: null,
    invalidHandleIds: null,
    invalidHandleClasses: null,
    startPageX: 0,
    startPageY: 0,
    groups: null,
    locked: false,
    lock: function () {
        this.locked = true
    },
    moveOnly: false,
    unlock: function () {
        this.locked = false
    },
    isTarget: true,
    padding: null,
    _domRef: null,
    __ygDragDrop: true,
    constrainX: false,
    constrainY: false,
    minX: 0,
    maxX: 0,
    minY: 0,
    maxY: 0,
    maintainOffset: false,
    xTicks: null,
    yTicks: null,
    primaryButtonOnly: true,
    available: false,
    hasOuterHandles: false,
    triggerEvent: "mousedown",
    b4StartDrag: function (a, b) {
    },
    startDrag: function (a, b) {
    },
    b4Drag: function (a) {
    },
    onDrag: function (a) {
    },
    onDragEnter: function (a, b) {
    },
    b4DragOver: function (a) {
    },
    onDragOver: function (a, b) {
    },
    b4DragOut: function (a) {
    },
    onDragOut: function (a, b) {
    },
    b4DragDrop: function (a) {
    },
    onDragDrop: function (a, b) {
    },
    onInvalidDrop: function (a) {
    },
    b4EndDrag: function (a) {
    },
    endDrag: function (a) {
    },
    b4MouseDown: function (a) {
    },
    onMouseDown: function (a) {
    },
    onMouseUp: function (a) {
    },
    onAvailable: function () {
    },
    defaultPadding: {left: 0, right: 0, top: 0, bottom: 0},
    constrainTo: function (e, b, l) {
        if (Ext.isNumber(b)) {
            b = {left: b, right: b, top: b, bottom: b}
        }
        b = b || this.defaultPadding;
        var h = Ext.get(this.getEl()).getBox(), m = Ext.get(e), k = m.getScroll(), g, i = m.dom, j, d, a;
        if (i === document.body) {
            g = {x: k.left, y: k.top, width: Ext.Element.getViewportWidth(), height: Ext.Element.getViewportHeight()}
        } else {
            j = m.getXY();
            g = {x: j[0], y: j[1], width: i.clientWidth, height: i.clientHeight}
        }
        d = h.y - g.y;
        a = h.x - g.x;
        this.resetConstraints();
        this.setXConstraint(a - (b.left || 0), g.width - a - h.width - (b.right || 0), this.xTickSize);
        this.setYConstraint(d - (b.top || 0), g.height - d - h.height - (b.bottom || 0), this.yTickSize)
    },
    getEl: function () {
        if (!this._domRef) {
            this._domRef = Ext.getDom(this.id)
        }
        return this._domRef
    },
    getDragEl: function () {
        return Ext.getDom(this.dragElId)
    },
    init: function (d, a, b) {
        var c = this;
        c.el = c.el || Ext.get(d);
        c.initTarget(d, a, b);
        Ext.get(c.id).on(c.triggerEvent, c.handleMouseDown, c)
    },
    initTarget: function (c, a, b) {
        this.config = b || {};
        this.DDMInstance = Ext.dd.DragDropManager;
        this.groups = {};
        if (typeof c !== "string") {
            c = Ext.id(c)
        }
        this.id = c;
        this.addToGroup((a) ? a : "default");
        this.handleElId = c;
        this.setDragElId(c);
        this.invalidHandleTypes = {A: "A"};
        this.invalidHandleIds = {};
        this.invalidHandleClasses = [];
        this.applyConfig();
        this.handleOnAvailable()
    },
    applyConfig: function () {
        this.padding = this.config.padding || [0, 0, 0, 0];
        this.isTarget = (this.config.isTarget !== false);
        this.maintainOffset = (this.config.maintainOffset);
        this.primaryButtonOnly = (this.config.primaryButtonOnly !== false)
    },
    handleOnAvailable: function () {
        this.available = true;
        this.resetConstraints();
        this.onAvailable()
    },
    setPadding: function (c, a, d, b) {
        if (!a && 0 !== a) {
            this.padding = [c, c, c, c]
        } else {
            if (!d && 0 !== d) {
                this.padding = [c, a, c, a]
            } else {
                this.padding = [c, a, d, b]
            }
        }
    },
    setInitPosition: function (d, c) {
        var e = this.getEl(), b, a, g;
        if (!this.DDMInstance.verifyEl(e)) {
            return
        }
        b = d || 0;
        a = c || 0;
        g = Ext.fly(e).getXY();
        this.initPageX = g[0] - b;
        this.initPageY = g[1] - a;
        this.lastPageX = g[0];
        this.lastPageY = g[1];
        this.setStartPosition(g)
    },
    setStartPosition: function (b) {
        var a = b || Ext.fly(this.getEl()).getXY();
        this.deltaSetXY = null;
        this.startPageX = a[0];
        this.startPageY = a[1]
    },
    addToGroup: function (a) {
        this.groups[a] = true;
        this.DDMInstance.regDragDrop(this, a)
    },
    removeFromGroup: function (a) {
        if (this.groups[a]) {
            delete this.groups[a]
        }
        this.DDMInstance.removeDDFromGroup(this, a)
    },
    setDragElId: function (a) {
        this.dragElId = a
    },
    setHandleElId: function (a) {
        if (typeof a !== "string") {
            a = Ext.id(a)
        }
        this.handleElId = a;
        this.DDMInstance.regHandle(this.id, a)
    },
    setOuterHandleElId: function (a) {
        if (typeof a !== "string") {
            a = Ext.id(a)
        }
        Ext.get(a).on(this.triggerEvent, this.handleMouseDown, this);
        this.setHandleElId(a);
        this.hasOuterHandles = true
    },
    unreg: function () {
        var b = this, a;
        if (b._domRef) {
            a = Ext.fly(b.id);
            if (a) {
                a.un(b.triggerEvent, b.handleMouseDown, b)
            }
        }
        b._domRef = null;
        b.DDMInstance._remove(b, b.autoGroup)
    },
    destroy: function () {
        this.unreg();
        this.callParent()
    },
    isLocked: function () {
        return (this.DDMInstance.isLocked() || this.locked)
    },
    handleMouseDown: function (c, b) {
        var a = this;
        if ((a.primaryButtonOnly && c.button) || a.isLocked()) {
            return
        }
        a.DDMInstance.refreshCache(a.groups);
        if (a.hasOuterHandles || a.DDMInstance.isOverTarget(c.getPoint(), a)) {
            if (a.clickValidator(c)) {
                a.setStartPosition();
                a.b4MouseDown(c);
                a.onMouseDown(c);
                a.DDMInstance.handleMouseDown(c, a);
                a.DDMInstance.stopEvent(c)
            }
        }
    },
    clickValidator: function (b) {
        var a = b.getTarget();
        return (this.isValidHandleChild(a) && (this.id === this.handleElId || this.DDMInstance.handleWasClicked(a, this.id)))
    },
    addInvalidHandleType: function (a) {
        var b = a.toUpperCase();
        this.invalidHandleTypes[b] = b
    },
    addInvalidHandleId: function (a) {
        if (typeof a !== "string") {
            a = Ext.id(a)
        }
        this.invalidHandleIds[a] = a
    },
    addInvalidHandleClass: function (a) {
        this.invalidHandleClasses.push(a)
    },
    removeInvalidHandleType: function (a) {
        var b = a.toUpperCase();
        delete this.invalidHandleTypes[b]
    },
    removeInvalidHandleId: function (a) {
        if (typeof a !== "string") {
            a = Ext.id(a)
        }
        delete this.invalidHandleIds[a]
    },
    removeInvalidHandleClass: function (b) {
        var d = this.invalidHandleClasses, a = d.length, c;
        for (c = 0; c < a; ++c) {
            if (d[c] === b) {
                delete d[c]
            }
        }
    },
    isValidHandleChild: function (d) {
        var c = true, h, b, a;
        try {
            h = d.nodeName.toUpperCase()
        } catch (g) {
            h = d.nodeName
        }
        c = c && !this.invalidHandleTypes[h];
        c = c && !this.invalidHandleIds[d.id];
        for (b = 0, a = this.invalidHandleClasses.length; c && b < a; ++b) {
            c = !Ext.fly(d).hasCls(this.invalidHandleClasses[b])
        }
        return c
    },
    setXTicks: function (d, a) {
        this.xTicks = [];
        this.xTickSize = a;
        var c = {}, b;
        for (b = this.initPageX; b >= this.minX; b = b - a) {
            if (!c[b]) {
                this.xTicks[this.xTicks.length] = b;
                c[b] = true
            }
        }
        for (b = this.initPageX; b <= this.maxX; b = b + a) {
            if (!c[b]) {
                this.xTicks[this.xTicks.length] = b;
                c[b] = true
            }
        }
        Ext.Array.sort(this.xTicks, this.DDMInstance.numericSort)
    },
    setYTicks: function (d, a) {
        this.yTicks = [];
        this.yTickSize = a;
        var c = {}, b;
        for (b = this.initPageY; b >= this.minY; b = b - a) {
            if (!c[b]) {
                this.yTicks[this.yTicks.length] = b;
                c[b] = true
            }
        }
        for (b = this.initPageY; b <= this.maxY; b = b + a) {
            if (!c[b]) {
                this.yTicks[this.yTicks.length] = b;
                c[b] = true
            }
        }
        Ext.Array.sort(this.yTicks, this.DDMInstance.numericSort)
    },
    setXConstraint: function (c, b, a) {
        this.leftConstraint = c;
        this.rightConstraint = b;
        this.minX = this.initPageX - c;
        this.maxX = this.initPageX + b;
        if (a) {
            this.setXTicks(this.initPageX, a)
        }
        this.constrainX = true
    },
    clearConstraints: function () {
        this.constrainX = false;
        this.constrainY = false;
        this.clearTicks()
    },
    clearTicks: function () {
        this.xTicks = null;
        this.yTicks = null;
        this.xTickSize = 0;
        this.yTickSize = 0
    },
    setYConstraint: function (a, c, b) {
        this.topConstraint = a;
        this.bottomConstraint = c;
        this.minY = this.initPageY - a;
        this.maxY = this.initPageY + c;
        if (b) {
            this.setYTicks(this.initPageY, b)
        }
        this.constrainY = true
    },
    resetConstraints: function () {
        if (this.initPageX || this.initPageX === 0) {
            var b = (this.maintainOffset) ? this.lastPageX - this.initPageX : 0,
                a = (this.maintainOffset) ? this.lastPageY - this.initPageY : 0;
            this.setInitPosition(b, a)
        } else {
            this.setInitPosition()
        }
        if (this.constrainX) {
            this.setXConstraint(this.leftConstraint, this.rightConstraint, this.xTickSize)
        }
        if (this.constrainY) {
            this.setYConstraint(this.topConstraint, this.bottomConstraint, this.yTickSize)
        }
    },
    getTick: function (h, d) {
        if (!d) {
            return h
        } else {
            if (d[0] >= h) {
                return d[0]
            } else {
                var b, a, c, g, e;
                for (b = 0, a = d.length; b < a; ++b) {
                    c = b + 1;
                    if (d[c] && d[c] >= h) {
                        g = h - d[b];
                        e = d[c] - h;
                        return (e > g) ? d[b] : d[c]
                    }
                }
                return d[d.length - 1]
            }
        }
    },
    toString: function () {
        return ("DragDrop " + this.id)
    }
}, 3, 0, 0, 0, 0, 0, [Ext.dd, "DragDrop"], 0));
(Ext.cmd.derive("Ext.dd.DD", Ext.dd.DragDrop, {
    constructor: function (c, a, b) {
        if (c) {
            this.init(c, a, b)
        }
    }, scroll: true, autoOffset: function (c, b) {
        var a = c - this.startPageX, d = b - this.startPageY;
        this.setDelta(a, d)
    }, setDelta: function (b, a) {
        this.deltaX = b;
        this.deltaY = a
    }, setDragElPos: function (c, b) {
        var a = this.getDragEl();
        this.alignElWithMouse(a, c, b)
    }, alignElWithMouse: function (b, e, c) {
        var g = this.getTargetCoord(e, c), d = b.dom ? b : Ext.fly(b, "_dd"), l = d.getSize(), i = Ext.Element, j, a, k,
            h;
        if (!this.deltaSetXY) {
            j = this.cachedViewportSize = {width: i.getDocumentWidth(), height: i.getDocumentHeight()};
            a = [Math.max(0, Math.min(g.x, j.width - l.width)), Math.max(0, Math.min(g.y, j.height - l.height))];
            d.setXY(a);
            k = this.getLocalX(d);
            h = d.getLocalY();
            this.deltaSetXY = [k - g.x, h - g.y]
        } else {
            j = this.cachedViewportSize;
            this.setLocalXY(d, Math.max(0, Math.min(g.x + this.deltaSetXY[0], j.width - l.width)), Math.max(0, Math.min(g.y + this.deltaSetXY[1], j.height - l.height)))
        }
        this.cachePosition(g.x, g.y);
        this.autoScroll(g.x, g.y, b.offsetHeight, b.offsetWidth);
        return g
    }, cachePosition: function (b, a) {
        if (b) {
            this.lastPageX = b;
            this.lastPageY = a
        } else {
            var c = Ext.fly(this.getEl()).getXY();
            this.lastPageX = c[0];
            this.lastPageY = c[1]
        }
    }, autoScroll: function (l, k, e, m) {
        if (this.scroll) {
            var n = Ext.Element.getViewportHeight(), b = Ext.Element.getViewportWidth(),
                p = this.DDMInstance.getScrollTop(), d = this.DDMInstance.getScrollLeft(), j = e + k, o = m + l,
                i = (n + p - k - this.deltaY), g = (b + d - l - this.deltaX), c = 40, a = (document.all) ? 80 : 30;
            if (j > n && i < c) {
                window.scrollTo(d, p + a)
            }
            if (k < p && p > 0 && k - p < c) {
                window.scrollTo(d, p - a)
            }
            if (o > b && g < c) {
                window.scrollTo(d + a, p)
            }
            if (l < d && d > 0 && l - d < c) {
                window.scrollTo(d - a, p)
            }
        }
    }, getTargetCoord: function (c, b) {
        var a = c - this.deltaX, d = b - this.deltaY;
        if (this.constrainX) {
            if (a < this.minX) {
                a = this.minX
            }
            if (a > this.maxX) {
                a = this.maxX
            }
        }
        if (this.constrainY) {
            if (d < this.minY) {
                d = this.minY
            }
            if (d > this.maxY) {
                d = this.maxY
            }
        }
        a = this.getTick(a, this.xTicks);
        d = this.getTick(d, this.yTicks);
        return {x: a, y: d}
    }, applyConfig: function () {
        Ext.dd.DragDrop.prototype.applyConfig.call(this);
        this.scroll = (this.config.scroll !== false)
    }, b4MouseDown: function (b) {
        var a = b.getXY();
        this.autoOffset(a[0], a[1])
    }, b4Drag: function (b) {
        var a = b.getXY();
        this.setDragElPos(a[0], a[1])
    }, toString: function () {
        return ("DD " + this.id)
    }, getLocalX: function (a) {
        return a.getLocalX()
    }, setLocalXY: function (b, a, c) {
        b.setLocalXY(a, c)
    }
}, 3, 0, 0, 0, 0, 0, [Ext.dd, "DD"], 0));
(Ext.cmd.derive("Ext.dd.DDProxy", Ext.dd.DD, {
    statics: {dragElId: "ygddfdiv"}, constructor: function (c, a, b) {
        if (c) {
            this.init(c, a, b);
            this.initFrame()
        }
    }, resizeFrame: true, centerFrame: false, createFrame: function () {
        var b = this, a = document.body, d, c;
        if (!a || !a.firstChild) {
            Ext.defer(function () {
                b.createFrame()
            }, 50);
            return
        }
        d = this.getDragEl();
        if (!d) {
            d = document.createElement("div");
            d.id = this.dragElId;
            d.setAttribute("role", "presentation");
            c = d.style;
            c.position = "absolute";
            c.visibility = "hidden";
            c.cursor = "move";
            c.border = "2px solid #aaa";
            c.zIndex = 999;
            a.insertBefore(d, a.firstChild)
        }
    }, initFrame: function () {
        this.createFrame()
    }, applyConfig: function () {
        Ext.dd.DD.prototype.applyConfig.call(this);
        this.resizeFrame = (this.config.resizeFrame !== false);
        this.centerFrame = (this.config.centerFrame);
        this.setDragElId(this.config.dragElId || Ext.dd.DDProxy.dragElId)
    }, showFrame: function (e, d) {
        var c = this, a = c.getDragEl(), b = a.style;
        c._resizeProxy();
        if (c.centerFrame) {
            c.setDelta(Math.round(parseInt(b.width, 10) / 2), Math.round(parseInt(b.height, 10) / 2))
        }
        c.setDragElPos(e, d);
        Ext.fly(a).show()
    }, _resizeProxy: function () {
        if (this.resizeFrame) {
            var a = this.getEl();
            Ext.fly(this.getDragEl()).setSize(a.offsetWidth, a.offsetHeight)
        }
    }, b4MouseDown: function (c) {
        var b = c.getXY(), a = b[0], d = b[1];
        this.autoOffset(a, d);
        this.setDragElPos(a, d)
    }, b4StartDrag: function (a, b) {
        this.showFrame(a, b)
    }, b4EndDrag: function (a) {
        Ext.fly(this.getDragEl()).hide()
    }, endDrag: function (c) {
        var b = this.getEl(), a = this.getDragEl();
        a.style.visibility = "";
        this.beforeMove();
        b.style.visibility = "hidden";
        Ext.dd.DDM.moveToEl(b, a);
        a.style.visibility = "hidden";
        b.style.visibility = "";
        this.afterDrag()
    }, beforeMove: function () {
    }, afterDrag: function () {
    }, toString: function () {
        return ("DDProxy " + this.id)
    }
}, 3, 0, 0, 0, 0, 0, [Ext.dd, "DDProxy"], 0));
(Ext.cmd.derive("Ext.dd.StatusProxy", Ext.Component, {
    animRepair: false,
    childEls: ["ghost"],
    renderTpl: ['<div class="x-dd-drop-icon" role="presentation"></div><div id="{id}-ghost" data-ref="ghost" class="x-dd-drag-ghost" role="presentation"></div>'],
    repairCls: "x-dd-drag-repair",
    ariaRole: "presentation",
    skipLayout: true,
    constructor: function (a) {
        var b = this;
        a = a || {};
        Ext.apply(b, {
            hideMode: "visibility",
            hidden: true,
            floating: true,
            id: b.id || Ext.id(),
            cls: "x-dd-drag-proxy " + this.dropNotAllowed,
            shadow: a.shadow || false,
            renderTo: Ext.getDetachedBody()
        });
        Ext.Component.prototype.constructor.apply(this, arguments);
        this.dropStatus = this.dropNotAllowed
    },
    dropAllowed: "x-dd-drop-ok",
    dropNotAllowed: "x-dd-drop-nodrop",
    setStatus: function (a) {
        a = a || this.dropNotAllowed;
        if (this.dropStatus !== a) {
            this.el.replaceCls(this.dropStatus, a);
            this.dropStatus = a
        }
    },
    reset: function (b) {
        var c = this, a = "x-dd-drag-proxy ";
        c.el.replaceCls(a + c.dropAllowed, a + c.dropNotAllowed);
        c.dropStatus = c.dropNotAllowed;
        if (b) {
            c.ghost.setHtml("")
        }
    },
    update: function (a) {
        if (typeof a === "string") {
            this.ghost.setHtml(a)
        } else {
            this.ghost.setHtml("");
            a.style.margin = "0";
            this.ghost.dom.appendChild(a)
        }
        var b = this.ghost.dom.firstChild;
        if (b) {
            Ext.fly(b).setStyle("float", "none")
        }
    },
    getGhost: function () {
        return this.ghost
    },
    hide: function (a) {
        Ext.Component.prototype.hide.call(this);
        if (a) {
            this.reset(true)
        }
    },
    stop: function () {
        if (this.anim && this.anim.isAnimated && this.anim.isAnimated()) {
            this.anim.stop()
        }
    },
    sync: function () {
        this.el.syncUnderlays()
    },
    repair: function (c, d, a) {
        var b = this;
        b.callback = d;
        b.scope = a;
        if (c && b.animRepair !== false) {
            b.el.addCls(b.repairCls);
            b.el.setUnderlaysVisible(false);
            b.anim = b.el.animate({
                duration: b.repairDuration || 500,
                easing: "ease-out",
                to: {x: c[0], y: c[1]},
                stopAnimation: true,
                callback: b.afterRepair,
                scope: b
            })
        } else {
            b.afterRepair()
        }
    },
    afterRepair: function () {
        var a = this;
        a.hide(true);
        a.el.removeCls(a.repairCls);
        if (typeof a.callback === "function") {
            a.callback.call(a.scope || a)
        }
        delete a.callback;
        delete a.scope
    }
}, 1, 0, ["component", "box"], {component: true, box: true}, 0, 0, [Ext.dd, "StatusProxy"], 0));
(Ext.cmd.derive("Ext.dd.DragSource", Ext.dd.DDProxy, {
    dropAllowed: "x-dd-drop-ok",
    dropNotAllowed: "x-dd-drop-nodrop",
    animRepair: true,
    repairHighlightColor: "c3daf9",
    constructor: function (b, a) {
        this.el = Ext.get(b);
        if (!this.dragData) {
            this.dragData = {}
        }
        Ext.apply(this, a);
        if (!this.proxy) {
            this.proxy = new Ext.dd.StatusProxy({id: this.el.id + "-drag-status-proxy", animRepair: this.animRepair})
        }
        Ext.dd.DDProxy.prototype.constructor.call(this, this.el.dom, this.ddGroup || this.group, {
            dragElId: this.proxy.id,
            resizeFrame: false,
            isTarget: false,
            scroll: this.scroll === true
        });
        this.dragging = false
    },
    getDragData: function (a) {
        return this.dragData
    },
    onDragEnter: function (c, d) {
        var b = Ext.dd.DragDropManager.getDDById(d), a;
        this.cachedTarget = b;
        if (this.beforeDragEnter(b, c, d) !== false) {
            if (b.isNotifyTarget) {
                a = b.notifyEnter(this, c, this.dragData);
                this.proxy.setStatus(a)
            } else {
                this.proxy.setStatus(this.dropAllowed)
            }
            if (this.afterDragEnter) {
                this.afterDragEnter(b, c, d)
            }
        }
    },
    beforeDragEnter: function (b, a, c) {
        return true
    },
    onDragOver: function (c, d) {
        var b = this.cachedTarget || Ext.dd.DragDropManager.getDDById(d), a;
        if (this.beforeDragOver(b, c, d) !== false) {
            if (b.isNotifyTarget) {
                a = b.notifyOver(this, c, this.dragData);
                this.proxy.setStatus(a)
            }
            if (this.afterDragOver) {
                this.afterDragOver(b, c, d)
            }
        }
    },
    beforeDragOver: function (b, a, c) {
        return true
    },
    onDragOut: function (b, c) {
        var a = this.cachedTarget || Ext.dd.DragDropManager.getDDById(c);
        if (this.beforeDragOut(a, b, c) !== false) {
            if (a.isNotifyTarget) {
                a.notifyOut(this, b, this.dragData)
            }
            this.proxy.reset();
            if (this.afterDragOut) {
                this.afterDragOut(a, b, c)
            }
        }
        this.cachedTarget = null
    },
    beforeDragOut: function (b, a, c) {
        return true
    },
    onDragDrop: function (b, c) {
        var a = this.cachedTarget || Ext.dd.DragDropManager.getDDById(c);
        if (this.beforeDragDrop(a, b, c) !== false) {
            if (a.isNotifyTarget) {
                if (a.notifyDrop(this, b, this.dragData) !== false) {
                    this.onValidDrop(a, b, c)
                } else {
                    this.onInvalidDrop(a, b, c)
                }
            } else {
                this.onValidDrop(a, b, c)
            }
            if (this.afterDragDrop) {
                this.afterDragDrop(a, b, c)
            }
        }
        delete this.cachedTarget
    },
    beforeDragDrop: function (b, a, c) {
        return true
    },
    onValidDrop: function (b, a, c) {
        this.hideProxy();
        if (this.afterValidDrop) {
            this.afterValidDrop(b, a, c)
        }
    },
    getRepairXY: function (b, a) {
        return this.el.getXY()
    },
    onInvalidDrop: function (c, b, d) {
        var a = this;
        if (!b) {
            b = c;
            c = null;
            d = b.getTarget().id
        }
        if (a.beforeInvalidDrop(c, b, d) !== false) {
            if (a.cachedTarget) {
                if (a.cachedTarget.isNotifyTarget) {
                    a.cachedTarget.notifyOut(a, b, a.dragData)
                }
                a.cacheTarget = null
            }
            a.proxy.repair(a.getRepairXY(b, a.dragData), a.afterRepair, a);
            if (a.afterInvalidDrop) {
                a.afterInvalidDrop(b, d)
            }
        }
    },
    afterRepair: function () {
        var a = this;
        if (Ext.enableFx) {
            a.el.highlight(a.repairHighlightColor)
        }
        a.dragging = false
    },
    beforeInvalidDrop: function (b, a, c) {
        return true
    },
    handleMouseDown: function (b) {
        if (this.dragging) {
            return
        }
        var a = this.getDragData(b);
        if (a && this.onBeforeDrag(a, b) !== false) {
            this.dragData = a;
            this.proxy.stop();
            Ext.dd.DDProxy.prototype.handleMouseDown.apply(this, arguments)
        }
    },
    onBeforeDrag: function (a, b) {
        return true
    },
    onStartDrag: Ext.emptyFn,
    alignElWithMouse: function () {
        this.proxy.ensureAttachedToBody(true);
        return Ext.dd.DDProxy.prototype.alignElWithMouse.apply(this, arguments)
    },
    startDrag: function (a, b) {
        this.proxy.reset();
        this.proxy.hidden = false;
        this.dragging = true;
        this.proxy.update("");
        this.onInitDrag(a, b);
        this.proxy.show()
    },
    onInitDrag: function (a, c) {
        var b = this.el.dom.cloneNode(true);
        b.id = Ext.id();
        this.proxy.update(b);
        this.onStartDrag(a, c);
        return true
    },
    getProxy: function () {
        return this.proxy
    },
    hideProxy: function () {
        this.proxy.hide();
        this.proxy.reset(true);
        this.dragging = false
    },
    triggerCacheRefresh: function () {
        Ext.dd.DDM.refreshCache(this.groups)
    },
    b4EndDrag: function (a) {
    },
    endDrag: function (a) {
        this.onEndDrag(this.dragData, a)
    },
    onEndDrag: function (a, b) {
    },
    autoOffset: function (a, b) {
        this.setDelta(-12, -20)
    },
    destroy: function () {
        Ext.dd.DDProxy.prototype.destroy.call(this);
        Ext.destroy(this.proxy)
    }
}, 1, 0, 0, 0, 0, 0, [Ext.dd, "DragSource"], 0));
(Ext.cmd.derive("Ext.panel.Proxy", Ext.Base, {
    alternateClassName: "Ext.dd.PanelProxy",
    moveOnDrag: true,
    constructor: function (a, b) {
        var c = this;
        c.panel = a;
        c.id = c.panel.id + "-ddproxy";
        Ext.apply(c, b)
    },
    insertProxy: true,
    setStatus: Ext.emptyFn,
    reset: Ext.emptyFn,
    update: Ext.emptyFn,
    stop: Ext.emptyFn,
    sync: Ext.emptyFn,
    getEl: function () {
        return this.ghost.el
    },
    getGhost: function () {
        return this.ghost
    },
    getProxy: function () {
        return this.proxy
    },
    hide: function () {
        var a = this;
        if (a.ghost) {
            if (a.proxy) {
                a.proxy.destroy();
                delete a.proxy
            }
            a.panel.unghost(null, a.moveOnDrag);
            delete a.ghost
        }
    },
    show: function () {
        var b = this, a;
        if (!b.ghost) {
            a = b.panel.getSize();
            b.panel.el.setVisibilityMode(Ext.Element.DISPLAY);
            b.ghost = b.panel.ghost();
            if (b.insertProxy) {
                b.proxy = b.panel.el.insertSibling({role: "presentation", cls: "x-panel-dd-spacer"});
                b.proxy.setSize(a)
            }
        }
    },
    repair: function (b, c, a) {
        this.hide();
        Ext.callback(c, a || this)
    },
    moveProxy: function (a, b) {
        if (this.proxy) {
            a.insertBefore(this.proxy.dom, b)
        }
    }
}, 1, 0, 0, 0, 0, 0, [Ext.panel, "Proxy", Ext.dd, "PanelProxy"], 0));
(Ext.cmd.derive("Ext.panel.DD", Ext.dd.DragSource, {
    constructor: function (b, a) {
        var c = this;
        c.panel = b;
        c.dragData = {panel: b};
        c.panelProxy = new Ext.panel.Proxy(b, a);
        c.proxy = c.panelProxy.proxy;
        Ext.dd.DragSource.prototype.constructor.call(this, b.el, a);
        c.setupEl(b)
    }, setupEl: function (a) {
        var c = this, d = a.header, b = a.body;
        if (d) {
            c.setHandleElId(d.id);
            b = d.el
        }
        if (b) {
            b.setStyle("cursor", "move");
            c.scroll = false
        } else {
            a.on("boxready", c.setupEl, c, {single: true})
        }
    }, showFrame: Ext.emptyFn, startDrag: Ext.emptyFn, b4StartDrag: function (a, b) {
        this.panelProxy.show()
    }, b4MouseDown: function (c) {
        var b = c.getXY(), a = b[0], d = b[1];
        this.autoOffset(a, d)
    }, onInitDrag: function (a, b) {
        this.onStartDrag(a, b);
        return true
    }, createFrame: Ext.emptyFn, getDragEl: function (b) {
        var a = this.panelProxy.ghost;
        if (a) {
            return a.el.dom
        }
    }, endDrag: function (a) {
        this.panelProxy.hide();
        this.panel.saveState()
    }, autoOffset: function (a, b) {
        a -= this.startPageX;
        b -= this.startPageY;
        this.setDelta(a, b)
    }, onInvalidDrop: function (c, b, d) {
        var a = this;
        if (a.beforeInvalidDrop(c, b, d) !== false) {
            if (a.cachedTarget) {
                if (a.cachedTarget.isNotifyTarget) {
                    a.cachedTarget.notifyOut(a, b, a.dragData)
                }
                a.cacheTarget = null
            }
            if (a.afterInvalidDrop) {
                a.afterInvalidDrop(b, d)
            }
        }
    }
}, 1, 0, 0, 0, 0, 0, [Ext.panel, "DD"], 0));
(Ext.cmd.derive("Ext.layout.component.Dock", Ext.layout.component.Component, {
    alternateClassName: "Ext.layout.component.AbstractDock",
    type: "dock",
    horzAxisProps: {
        name: "horz",
        oppositeName: "vert",
        dockBegin: "left",
        dockEnd: "right",
        horizontal: true,
        marginBegin: "margin-left",
        maxSize: "maxWidth",
        minSize: "minWidth",
        pos: "x",
        setSize: "setWidth",
        shrinkWrapDock: "shrinkWrapDockWidth",
        size: "width",
        sizeModel: "widthModel"
    },
    vertAxisProps: {
        name: "vert",
        oppositeName: "horz",
        dockBegin: "top",
        dockEnd: "bottom",
        horizontal: false,
        marginBegin: "margin-top",
        maxSize: "maxHeight",
        minSize: "minHeight",
        pos: "y",
        setSize: "setHeight",
        shrinkWrapDock: "shrinkWrapDockHeight",
        size: "height",
        sizeModel: "heightModel"
    },
    initializedBorders: -1,
    horizontalCollapsePolicy: {width: true, x: true},
    verticalCollapsePolicy: {height: true, y: true},
    finishRender: function () {
        var b = this, c, a;
        Ext.layout.component.Component.prototype.finishRender.call(this);
        c = b.getRenderTarget();
        a = b.getDockedItems();
        b.finishRenderItems(c, a)
    },
    isItemBoxParent: function (a) {
        return true
    },
    isItemShrinkWrap: function (a) {
        return true
    },
    noBorderClasses: ["x-docked-noborder-top", "x-docked-noborder-right", "x-docked-noborder-bottom", "x-docked-noborder-left"],
    noBorderClassesSides: {
        top: "x-docked-noborder-top",
        right: "x-docked-noborder-right",
        bottom: "x-docked-noborder-bottom",
        left: "x-docked-noborder-left"
    },
    borderWidthProps: {
        top: "border-top-width",
        right: "border-right-width",
        bottom: "border-bottom-width",
        left: "border-left-width"
    },
    _itemCls: "x-docked",
    handleItemBorders: function () {
        var m = this, a = m.owner, l, q, h = m.lastDockedItems, g = m.borders, b = a.dockedItems.generation,
            c = m.noBorderClassesSides, n = m.borderWidthProps, e, k, p, o, j, d = m.collapsed;
        if (m.initializedBorders === b || (a.border && !a.manageBodyBorders) || (a.collapsed && a.collapseMode === "mini")) {
            return
        }
        m.initializedBorders = b;
        m.collapsed = false;
        m.lastDockedItems = q = m.getLayoutItems();
        m.collapsed = d;
        l = {top: [], right: [], bottom: [], left: []};
        for (e = 0, k = q.length; e < k; e++) {
            p = q[e];
            o = p.dock;
            if (p.ignoreBorderManagement) {
                continue
            }
            if (!l[o].satisfied) {
                l[o].push(p);
                l[o].satisfied = true
            }
            if (!l.top.satisfied && o !== "bottom") {
                l.top.push(p)
            }
            if (!l.right.satisfied && o !== "left") {
                l.right.push(p)
            }
            if (!l.bottom.satisfied && o !== "top") {
                l.bottom.push(p)
            }
            if (!l.left.satisfied && o !== "right") {
                l.left.push(p)
            }
        }
        if (h) {
            for (e = 0, k = h.length; e < k; e++) {
                p = h[e];
                if (!p.destroyed && !p.ignoreBorderManagement && !a.manageBodyBorders) {
                    p.removeCls(m.noBorderClasses)
                }
            }
        }
        if (g) {
            for (j in g) {
                if (a.manageBodyBorders && g[j].satisfied) {
                    a.setBodyStyle(n[j], "")
                }
            }
        }
        for (j in l) {
            k = l[j].length;
            if (!a.manageBodyBorders) {
                for (e = 0; e < k; e++) {
                    l[j][e].addCls(c[j])
                }
                if ((!l[j].satisfied && !a.bodyBorder) || a.bodyBorder === false) {
                    a.addBodyCls(c[j])
                } else {
                    a.removeBodyCls(c[j])
                }
            } else {
                if (l[j].satisfied) {
                    a.setBodyStyle(n[j], "1px")
                }
            }
        }
        m.borders = l
    },
    beforeLayoutCycle: function (g) {
        var c = this, b = c.owner, h = c.sizeModels.shrinkWrap, e = b.shrinkWrapDock, d, a;
        if (b.collapsed) {
            if (b.collapsedVertical()) {
                a = true;
                g.measureDimensions = 1
            } else {
                d = true;
                g.measureDimensions = 2
            }
        }
        g.collapsedVert = a;
        g.collapsedHorz = d;
        if (a) {
            g.heightModel = h
        } else {
            if (d) {
                g.widthModel = h
            }
        }
        e = e === true ? 3 : (e || 0);
        g.shrinkWrapDockHeight = (e & 1) && g.heightModel.shrinkWrap;
        g.shrinkWrapDockWidth = (e & 2) && g.widthModel.shrinkWrap
    },
    beginLayout: function (d) {
        var l = this, c = l.owner, p = l.getLayoutItems(), b = d.context, g = p.length, k = l.lastCollapsedState, m, j,
            o, a, e, h, n;
        Ext.layout.component.Component.prototype.beginLayout.apply(this, arguments);
        h = c.getCollapsed();
        if (h !== k && k !== undefined) {
            if (l.owner.collapsed) {
                d.isCollapsingOrExpanding = 1;
                c.addClsWithUI(c.collapsedCls)
            } else {
                d.isCollapsingOrExpanding = 2;
                c.removeClsWithUI(c.collapsedCls);
                d.lastCollapsedState = l.lastCollapsedState
            }
        }
        l.lastCollapsedState = h;
        d.dockedItems = m = [];
        for (j = 0; j < g; j++) {
            o = p[j];
            if (o.rendered) {
                n = o.dock;
                a = b.getCmp(o);
                a.dockedAt = {x: 0, y: 0};
                a.offsets = e = Ext.Element.parseBox(o.offsets || 0);
                a.horizontal = n === "top" || n === "bottom";
                e.width = e.left + e.right;
                e.height = e.top + e.bottom;
                m.push(a)
            }
        }
        d.bodyContext = d.getEl("body")
    },
    beginLayoutCycle: function (b) {
        var e = this, l = b.dockedItems, d = l.length, a = e.owner, g = a.frameBody, k = e.lastHeightModel, c, j, h;
        Ext.layout.component.Component.prototype.beginLayoutCycle.apply(this, arguments);
        if (e.owner.manageHeight) {
            if (e.lastBodyDisplay) {
                a.body.dom.style.display = e.lastBodyDisplay = ""
            }
        } else {
            if (e.lastBodyDisplay !== "inline-block") {
                a.body.dom.style.display = e.lastBodyDisplay = "inline-block"
            }
            if (k && k.shrinkWrap && !b.heightModel.shrinkWrap) {
                a.body.dom.style.marginBottom = ""
            }
        }
        if (b.widthModel.auto) {
            if (b.widthModel.shrinkWrap) {
                a.el.setWidth(null)
            }
            a.body.setWidth(null);
            if (g) {
                g.setWidth(null)
            }
        }
        if (b.heightModel.auto) {
            a.body.setHeight(null);
            if (g) {
                g.setHeight(null)
            }
        }
        if (b.collapsedVert) {
            b.setContentHeight(0)
        } else {
            if (b.collapsedHorz) {
                b.setContentWidth(0)
            }
        }
        for (c = 0; c < d; c++) {
            j = l[c].target;
            h = j.dock;
            if (h === "right") {
                j.setLocalX(0)
            } else {
                if (h !== "left") {
                    continue
                }
            }
        }
    },
    calculate: function (d) {
        var l = this, c = l.measureAutoDimensions(d, d.measureDimensions), b = d.state, k = b.horzDone, e = b.vertDone,
            g = d.bodyContext, j, a, i, h, m;
        d.borderInfo || d.getBorderInfo();
        d.paddingInfo || d.getPaddingInfo();
        d.frameInfo || d.getFrameInfo();
        g.borderInfo || g.getBorderInfo();
        g.paddingInfo || g.getPaddingInfo();
        if (!d.frameBorder) {
            if (!(j = d.framing)) {
                d.frameBorder = d.borderInfo;
                d.framePadding = d.paddingInfo
            } else {
                d.frameBorder = j.border;
                d.framePadding = j.padding
            }
        }
        a = !k && l.createAxis(d, c.contentWidth, d.widthModel, l.horzAxisProps, d.collapsedHorz);
        i = !e && l.createAxis(d, c.contentHeight, d.heightModel, l.vertAxisProps, d.collapsedVert);
        for (h = 0, m = d.dockedItems.length; m--; ++h) {
            if (a) {
                l.dockChild(d, a, m, h)
            }
            if (i) {
                l.dockChild(d, i, m, h)
            }
        }
        if (a && l.finishAxis(d, a)) {
            b.horzDone = k = a
        }
        if (i && l.finishAxis(d, i)) {
            b.vertDone = e = i
        }
        if (k && e && l.finishConstraints(d, k, e)) {
            l.finishPositions(d, k, e)
        } else {
            l.done = false
        }
    },
    createAxis: function (p, j, e, m, d) {
        var u = this, t = 0, b = u.owner, g = b[m.maxSize], c = b[m.minSize] || 0, n = m.dockBegin, i = m.dockEnd,
            r = m.pos, l = m.size, k = g != null, o = e.shrinkWrap, a, s, q, h;
        if (o) {
            if (d) {
                h = 0
            } else {
                a = p.bodyContext;
                h = j + a.borderInfo[l]
            }
        } else {
            s = p.frameBorder;
            q = p.framePadding;
            t = s[n] + q[n];
            h = p.getProp(l) - (s[i] + q[i])
        }
        return {
            shrinkWrap: e.shrinkWrap,
            sizeModel: e,
            initialBegin: t,
            begin: t,
            end: h,
            collapsed: d,
            horizontal: m.horizontal,
            ignoreFrameBegin: null,
            ignoreFrameEnd: null,
            initialSize: h - t,
            maxChildSize: 0,
            hasMinMaxConstraints: (c || k) && e.shrinkWrap,
            minSize: c,
            maxSize: k ? g : 1000000000,
            bodyPosProp: u.owner.manageHeight ? r : m.marginBegin,
            dockBegin: n,
            dockEnd: i,
            posProp: r,
            sizeProp: l,
            setSize: m.setSize,
            shrinkWrapDock: p[m.shrinkWrapDock],
            sizeModelName: m.sizeModel,
            dockedPixelsEnd: 0
        }
    },
    dockChild: function (b, c, l, e) {
        var g = this, a = b.dockedItems[c.shrinkWrap ? l : e], i = a.target, j = i.dock, d = c.sizeProp, h, k;
        if (i.ignoreParentFrame && b.isCollapsingOrExpanding) {
            a.clearMarginCache()
        }
        if (!a.marginInfo) {
            a.getMarginInfo()
        }
        if (j === c.dockBegin) {
            if (c.shrinkWrap) {
                h = g.dockOutwardBegin(b, a, i, c)
            } else {
                h = g.dockInwardBegin(b, a, i, c)
            }
        } else {
            if (j === c.dockEnd) {
                if (c.shrinkWrap) {
                    h = g.dockOutwardEnd(b, a, i, c)
                } else {
                    h = g.dockInwardEnd(b, a, i, c)
                }
            } else {
                if (c.shrinkWrapDock) {
                    k = a.getProp(d) + a.marginInfo[d];
                    c.maxChildSize = Math.max(c.maxChildSize, k);
                    h = 0
                } else {
                    h = g.dockStretch(b, a, i, c)
                }
            }
        }
        a.dockedAt[c.posProp] = h
    },
    dockInwardBegin: function (b, a, j, d) {
        var g = d.begin, e = d.sizeProp, c = j.ignoreParentFrame, h, k, i;
        if (c) {
            d.ignoreFrameBegin = a;
            i = j.dock;
            h = b.frameBorder[i];
            g -= h + b.framePadding[i]
        }
        if (!j.overlay) {
            k = a.getProp(e) + a.marginInfo[e];
            d.begin += k;
            if (c) {
                d.begin -= h
            }
        }
        return g
    },
    dockInwardEnd: function (e, d, c, b) {
        var i = b.sizeProp, a = d.getProp(i) + d.marginInfo[i], h = b.end - a, g;
        if (!c.overlay) {
            b.end = h
        }
        if (c.ignoreParentFrame) {
            b.ignoreFrameEnd = d;
            g = e.frameBorder[c.dock];
            h += g + e.framePadding[c.dock];
            b.end += g
        }
        return h
    },
    dockOutwardBegin: function (e, d, c, b) {
        var h = b.begin, g = b.sizeProp, a;
        if (b.collapsed) {
            b.ignoreFrameBegin = b.ignoreFrameEnd = d
        } else {
            if (c.ignoreParentFrame) {
                b.ignoreFrameBegin = d
            }
        }
        if (!c.overlay) {
            a = d.getProp(g) + d.marginInfo[g];
            h -= a;
            b.begin = h
        }
        return h
    },
    dockOutwardEnd: function (e, d, c, b) {
        var h = b.end, g = b.sizeProp, a;
        a = d.getProp(g) + d.marginInfo[g];
        if (b.collapsed) {
            b.ignoreFrameBegin = b.ignoreFrameEnd = d
        } else {
            if (c.ignoreParentFrame) {
                b.ignoreFrameEnd = d
            }
        }
        if (!c.overlay) {
            b.end = h + a;
            b.dockedPixelsEnd += a
        }
        return h
    },
    dockStretch: function (c, b, m, d) {
        var n = m.dock, j = d.sizeProp, a = n === "top" || n === "bottom", i = c.frameBorder, e = b.offsets,
            l = c.framePadding, h = a ? "right" : "bottom", p = a ? "left" : "top", k = d.begin + e[p], g, o;
        if (m.stretch !== false) {
            o = d.end - k - e[h];
            if (m.ignoreParentFrame) {
                k -= l[p] + i[p];
                o += l[j] + i[j]
            }
            g = b.marginInfo;
            o -= g[j];
            b[d.setSize](o)
        }
        return k
    },
    finishAxis: function (m, e) {
        if (isNaN(e.maxChildSize)) {
            return false
        }
        var d = e.begin, p = e.end - d, h = e.collapsed, w = e.setSize, k = e.dockBegin, u = e.dockEnd,
            o = m.framePadding, r = m.frameBorder, g = r[k], s = m.framing, n = s && s[k], b = h ? 0 : o[k],
            j = e.sizeProp, t = e.ignoreFrameBegin, q = e.ignoreFrameEnd, a = m.bodyContext, l = Math.max(g + b - n, 0),
            c, x, v, i;
        if (e.shrinkWrap) {
            x = e.initialSize;
            if (s) {
                v = -d + g + b;
                c = v - n - l
            } else {
                c = -d;
                v = c + b
            }
            if (!h) {
                p += o[j]
            }
            if (t) {
                v -= g;
                c -= g;
                t.dockedAt[e.posProp] -= b
            } else {
                p += g
            }
            if (h) {
            } else {
                if (q) {
                    q.dockedAt[e.posProp] += o[u]
                } else {
                    p += r[u]
                }
            }
            e.size = p;
            if (!e.horizontal && !this.owner.manageHeight) {
                i = false
            }
        } else {
            if (s) {
                v = 0;
                c = d - n - l
            } else {
                v = -g;
                c = d - b - g
            }
            x = p
        }
        e.delta = v;
        a[w](x, i);
        a.setProp(e.bodyPosProp, c);
        return !isNaN(p)
    },
    beforeInvalidateShrinkWrapDock: function (c, b) {
        var a = b.axis.sizeModelName;
        if (!c[a].constrainedMin) {
            c[a] = Ext.layout.SizeModel.calculated
        }
    },
    afterInvalidateShrinkWrapDock: function (d, a) {
        var b = a.axis, c = a.layout, e;
        if (d[b.sizeModelName].calculated) {
            e = c.dockStretch(a.ownerContext, d, d.target, b);
            d.setProp(b.posProp, b.delta + e)
        }
    },
    finishConstraints: function (k, c, p) {
        var s = this, r = s.sizeModels, o = c.shrinkWrap, q = p.shrinkWrap, a = s.owner, i, m, n, g, h, l, b, d, e, j;
        if (o) {
            l = c.size;
            b = c.collapsed ? 0 : c.minSize;
            d = c.maxSize;
            e = c.maxChildSize;
            j = Math.max(l, e);
            if (j > d) {
                h = r.constrainedMax;
                n = d
            } else {
                if (j < b) {
                    h = r.constrainedMin;
                    n = b
                } else {
                    if (l < e) {
                        h = r.constrainedDock;
                        a.dockConstrainedWidth = n = e
                    } else {
                        n = l
                    }
                }
            }
        }
        if (q) {
            l = p.size;
            b = p.collapsed ? 0 : p.minSize;
            d = p.maxSize;
            e = p.maxChildSize;
            j = Math.max(l, e + l - p.initialSize);
            if (j > d) {
                g = r.constrainedMax;
                m = d
            } else {
                if (j < b) {
                    g = r.constrainedMin;
                    m = b
                } else {
                    if (l < e) {
                        g = r.constrainedDock;
                        a.dockConstrainedHeight = m = e
                    } else {
                        if (!k.collapsedVert && !a.manageHeight) {
                            i = false;
                            k.bodyContext.setProp("margin-bottom", p.dockedPixelsEnd)
                        }
                        m = l
                    }
                }
            }
        }
        if (h || g) {
            if (h && g && h.constrainedMax && g.constrainedByMin) {
                k.invalidate({widthModel: h});
                return false
            }
            if (!k.widthModel.calculatedFromShrinkWrap && !k.heightModel.calculatedFromShrinkWrap) {
                k.invalidate({widthModel: h, heightModel: g});
                return false
            }
        } else {
            s.invalidateAxes(k, c, p)
        }
        if (o) {
            k.setWidth(n);
            if (h) {
                k.widthModel = h
            }
        }
        if (q) {
            k.setHeight(m, i);
            if (g) {
                k.heightModel = g
            }
        }
        return true
    },
    invalidateAxes: function (g, a, l) {
        var p = this.beforeInvalidateShrinkWrapDock, b = this.afterInvalidateShrinkWrapDock, e = a.end - a.begin,
            s = l.initialSize, c = a.shrinkWrapDock && a.maxChildSize <= e, m = l.shrinkWrapDock && l.maxChildSize <= s,
            q, n, k, d, r, o, h, j;
        if (c || m) {
            if (m) {
                l.begin = l.initialBegin;
                l.end = l.begin + l.initialSize
            }
            q = g.dockedItems;
            for (k = 0, n = q.length; k < n; ++k) {
                d = q[k];
                o = d.horizontal;
                h = null;
                if (c && o) {
                    j = a.sizeProp;
                    r = e;
                    h = a
                } else {
                    if (m && !o) {
                        j = l.sizeProp;
                        r = s;
                        h = l
                    }
                }
                if (h) {
                    r -= d.getMarginInfo()[j];
                    if (r !== d.props[j]) {
                        d.invalidate({before: p, after: b, axis: h, ownerContext: g, layout: this})
                    }
                }
            }
        }
    },
    finishPositions: function (d, a, h) {
        var j = d.dockedItems, c = j.length, g = a.delta, e = h.delta, i, b;
        for (i = 0; i < c; ++i) {
            b = j[i];
            b.setProp("x", g + b.dockedAt.x);
            b.setProp("y", e + b.dockedAt.y)
        }
    },
    finishedLayout: function (b) {
        var a = this, c = b.target;
        Ext.layout.component.Component.prototype.finishedLayout.apply(this, arguments);
        if (!b.animatePolicy) {
            if (b.isCollapsingOrExpanding === 1) {
                c.afterCollapse(false)
            } else {
                if (b.isCollapsingOrExpanding === 2) {
                    c.afterExpand(false)
                }
            }
        }
    },
    getAnimatePolicy: function (c) {
        var b = this, a, d;
        if (c.isCollapsingOrExpanding === 1) {
            a = b.lastCollapsedState
        } else {
            if (c.isCollapsingOrExpanding === 2) {
                a = c.lastCollapsedState
            }
        }
        if (a === "left" || a === "right") {
            d = b.horizontalCollapsePolicy
        } else {
            if (a === "top" || a === "bottom") {
                d = b.verticalCollapsePolicy
            }
        }
        return d
    },
    getDockedItems: function (c, n) {
        var j = this, e = (c === "visual"),
            k = e ? Ext.ComponentQuery.query("[rendered]", j.owner.dockedItems.items) : j.owner.dockedItems.items,
            h = k && k.length && c !== false, b, m, l, g, d, a;
        if (n == null) {
            l = h && !e ? k.slice() : k
        } else {
            l = [];
            for (g = 0, a = k.length; g < a; ++g) {
                m = k[g].dock;
                d = (m === "top" || m === "left");
                if (n ? d : !d) {
                    l.push(k[g])
                }
            }
            h = h && l.length
        }
        if (h) {
            b = (c = c || "render") === "render";
            Ext.Array.sort(l, function (o, i) {
                var p, q;
                if (b && ((p = j.owner.dockOrder[o.dock]) !== (q = j.owner.dockOrder[i.dock]))) {
                    if (!(p + q)) {
                        return p - q
                    }
                }
                p = j.getItemWeight(o, c);
                q = j.getItemWeight(i, c);
                if ((p !== undefined) && (q !== undefined)) {
                    return p - q
                }
                return 0
            })
        }
        return l || []
    },
    getItemWeight: function (b, a) {
        var c = b.weight || this.owner.defaultDockWeights[b.dock];
        return c[a] || c
    },
    getLayoutItems: function () {
        var e = this, b, g, d, c, a;
        if (e.owner.collapsed) {
            a = e.owner.getCollapsedDockedItems()
        } else {
            b = e.getDockedItems("visual");
            g = b.length;
            a = [];
            for (c = 0; c < g; c++) {
                d = b[c];
                if (!d.hidden) {
                    a.push(d)
                }
            }
        }
        return a
    },
    measureContentWidth: function (a) {
        var b = a.bodyContext;
        return b.el.getWidth() - b.getBorderInfo().width
    },
    measureContentHeight: function (a) {
        var b = a.bodyContext;
        return b.el.getHeight() - b.getBorderInfo().height
    },
    redoLayout: function (c) {
        var b = this, a = b.owner;
        if (c.isCollapsingOrExpanding === 1) {
            if (a.reExpander) {
                a.reExpander.el.show()
            }
            a.addClsWithUI(a.collapsedCls);
            c.redo(true)
        } else {
            if (c.isCollapsingOrExpanding === 2) {
                a.removeClsWithUI(a.collapsedCls);
                c.bodyContext.redo()
            }
        }
    },
    renderChildren: function () {
        var b = this, a = b.getDockedItems(), c = b.getRenderTarget();
        b.handleItemBorders();
        b.renderItems(a, c)
    },
    renderItems: function (j, h) {
        var k = this, a = k.owner, n = a.dockedItems, b = j.length, q = a.body, m, o, g, c, l, d, p, e;
        if (b) {
            o = k.getRenderTarget().dom.childNodes;
            g = o.length;
            n = n.map;
            l = 0;
            for (d = 0; d < g; ++d) {
                c = o[d];
                if (c === q.dom) {
                    m = d;
                    break
                }
                if (n[c.id]) {
                    ++l
                }
            }
            m -= l;
            for (d = 0; d < b; ++d) {
                p = j[d];
                e = m + d;
                if (p.dock === "right" || p.dock === "bottom") {
                    ++e
                }
                if (!p.rendered) {
                    k.renderItem(p, h, e)
                } else {
                    if (!k.isValidParent(p, h, e)) {
                        k.moveItem(p, h, e)
                    }
                }
            }
        }
    },
    undoLayout: function (c) {
        var b = this, a = b.owner;
        if (c.isCollapsingOrExpanding === 1) {
            if (a.reExpander) {
                a.reExpander.el.hide()
            }
            a.removeClsWithUI(a.collapsedCls);
            c.undo(true)
        } else {
            if (c.isCollapsingOrExpanding === 2) {
                a.addClsWithUI(a.collapsedCls);
                c.bodyContext.undo()
            }
        }
    },
    sizePolicy: {
        nostretch: {setsWidth: 0, setsHeight: 0},
        horz: {shrinkWrap: {setsWidth: 1, setsHeight: 0, readsWidth: 1}, stretch: {setsWidth: 1, setsHeight: 0}},
        vert: {shrinkWrap: {setsWidth: 0, setsHeight: 1, readsHeight: 1}, stretch: {setsWidth: 0, setsHeight: 1}},
        stretchV: {setsWidth: 0, setsHeight: 1},
        autoStretchH: {readsWidth: 1, setsWidth: 1, setsHeight: 0},
        autoStretchV: {readsHeight: 1, setsWidth: 0, setsHeight: 1}
    },
    getItemSizePolicy: function (d, g) {
        var c = this, h = c.sizePolicy, e = c.owner.shrinkWrapDock, b, a;
        if (d.stretch === false) {
            return h.nostretch
        }
        b = d.dock;
        a = (b === "left" || b === "right");
        e = e === true ? 3 : (e || 0);
        if (a) {
            h = h.vert;
            e = e & 1
        } else {
            h = h.horz;
            e = e & 2
        }
        if (e) {
            if (!g) {
                g = c.owner.getSizeModel()
            }
            if (g[a ? "height" : "width"].shrinkWrap) {
                return h.shrinkWrap
            }
        }
        return h.stretch
    },
    configureItem: function (a, b) {
        Ext.layout.component.Component.prototype.configureItem.apply(this, arguments);
        a.addCls(this._itemCls);
        if (!a.ignoreBorderManagement) {
            a.addClsWithUI(this.getDockCls(a.dock))
        }
    },
    getDockCls: function (a) {
        return "docked-" + a
    },
    afterRemove: function (a) {
        var b;
        Ext.layout.component.Component.prototype.afterRemove.apply(this, arguments);
        a.removeCls(this._itemCls);
        if (!a.ignoreBorderManagement) {
            a.removeClsWithUI(this.getDockCls(a.dock))
        }
        b = a.el.dom;
        if (!a.destroying && b) {
            b.parentNode.removeChild(b)
        }
        this.childrenChanged = true
    },
    borderCollapseMap: {},
    getBorderCollapseTable: function () {
        var d = this, g = d.borderCollapseMap, a = d.owner, b = a.baseCls, e = a.ui, c;
        g = g[b] || (g[b] = {});
        c = g[e];
        if (!c) {
            b += "-" + e + "-outer-border-";
            g[e] = c = [0, b + "l", b + "b", b + "bl", b + "r", b + "rl", b + "rb", b + "rbl", b + "t", b + "tl", b + "tb", b + "tbl", b + "tr", b + "trl", b + "trb", b + "trbl"]
        }
        return c
    }
}, 0, 0, 0, 0, ["layout.dock"], 0, [Ext.layout.component, "Dock", Ext.layout.component, "AbstractDock"], 0));
(Ext.cmd.derive("Ext.util.Memento", Ext.Base, (function () {
    function d(i, h, j, g) {
        i[g ? g + j : j] = h[j]
    }

    function c(h, g, i) {
        delete h[i]
    }

    function e(k, j, l, i) {
        var g = i ? i + l : l, h = k[g];
        if (h || k.hasOwnProperty(g)) {
            a(j, l, h)
        }
    }

    function a(h, i, g) {
        if (Ext.isDefined(g)) {
            h[i] = g
        } else {
            delete h[i]
        }
    }

    function b(h, m, l, i, j) {
        if (m) {
            if (Ext.isArray(i)) {
                var k, g = i.length;
                for (k = 0; k < g; k++) {
                    h(m, l, i[k], j)
                }
            } else {
                h(m, l, i, j)
            }
        }
    }

    return {
        data: null, target: null, constructor: function (h, g) {
            this.data = {};
            if (h) {
                this.target = h;
                if (g) {
                    this.capture(g)
                }
            }
        }, capture: function (g, j, i) {
            var h = this;
            b(d, h.data || (h.data = {}), j || h.target, g, i)
        }, remove: function (g) {
            b(c, this.data, null, g)
        }, restore: function (h, g, j, i) {
            b(e, this.data, j || this.target, h, i);
            if (g !== false) {
                this.remove(h)
            }
        }, restoreAll: function (g, k) {
            var i = this, h = k || this.target, j = i.data, l;
            g = g !== false;
            for (l in j) {
                if (j.hasOwnProperty(l)) {
                    a(h, l, j[l]);
                    if (g) {
                        delete j[l]
                    }
                }
            }
        }
    }
}()), 1, 0, 0, 0, 0, 0, [Ext.util, "Memento"], 0));
(Ext.cmd.derive("Ext.container.DockingContainer", Ext.Base, {
    isDockingContainer: true,
    defaultDockWeights: {
        top: {render: 1, visual: 1},
        left: {render: 3, visual: 5},
        right: {render: 5, visual: 7},
        bottom: {render: 7, visual: 3}
    },
    dockOrder: {top: -1, left: -1, right: 1, bottom: 1},
    horizontalDocks: 0,
    tabGuard: false,
    tabGuardTpl: '<div id="{id}-{tabGuardEl}" data-ref="{tabGuardEl}" tabIndex="0" class="x-tab-guard x-tab-guard-{tabGuard}" ></div>',
    addDocked: function (g, k) {
        var j = this, b = j.rendered, c = 0, l = j.dockedItems, d = l.getCount(), e, h, m, a;
        g = j.prepareItems(g);
        a = g.length;
        if (b) {
            Ext.suspendLayouts()
        }
        if (k === undefined) {
            k = d
        } else {
            k = Math.min(k, d)
        }
        for (; c < a; c++) {
            m = g[c];
            m.dock = m.dock || "top";
            if (m.dock === "left" || m.dock === "right") {
                j.horizontalDocks++
            }
            e = k + c;
            l.insert(e, m);
            h = !!m.instancedCmp;
            delete m.instancedCmp;
            m.onAdded(j, e, h);
            delete m.$initParent;
            if (j.onDockedAdd !== Ext.emptyFn) {
                j.onDockedAdd(m)
            }
            if (j.hasListeners.dockedadd) {
                j.fireEvent("dockedadd", j, m, e)
            }
        }
        if (j.rendered) {
            j.updateLayout();
            Ext.resumeLayouts(true)
        }
        return g
    },
    destroyDockedItems: function () {
        var a = this.dockedItems, b;
        if (a) {
            while ((b = a.first())) {
                this.removeDocked(b, true)
            }
        }
    },
    doRenderDockedItems: function (d, h, i) {
        var g = h.$comp, e = g.componentLayout, c = g.tabGuard && g.getTpl("tabGuardTpl"), b, a;
        if (e.getDockedItems && !h.$skipDockedItems) {
            if (c && !i) {
                h.tabGuard = "before";
                g.addChildEl(h.tabGuardEl = "tabGuardBeforeEl");
                c.applyOut(h, d)
            }
            b = e.getDockedItems("render", !i);
            a = b && e.getItemsRenderTree(b);
            if (a) {
                Ext.DomHelper.generateMarkup(a, d)
            }
            if (c && i) {
                h.tabGuard = "after";
                g.addChildEl(h.tabGuardEl = "tabGuardAfterEl");
                c.applyOut(h, d)
            }
        }
    },
    getDockedComponent: function (a) {
        if (Ext.isObject(a)) {
            a = a.getItemId()
        }
        return this.dockedItems.get(a)
    },
    getDockedItems: function (a, c) {
        var b = this.getComponentLayout().getDockedItems("render", c);
        if (a && b.length) {
            b = Ext.ComponentQuery.query(a, b)
        }
        return b
    },
    getDockingRefItems: function (b, e) {
        var a = b && "*,* *", d = this.getDockedItems(a, true), c;
        d.push.apply(d, e);
        c = this.getDockedItems(a, false);
        d.push.apply(d, c);
        return d
    },
    initDockingItems: function () {
        var b = this, a = b.dockedItems;
        if (!a || !a.isMixedCollection) {
            b.dockedItems = new Ext.util.ItemCollection();
            if (a) {
                b.addDocked(a)
            }
        }
    },
    insertDocked: function (b, a) {
        this.addDocked(a, b)
    },
    onDockedAdd: Ext.emptyFn,
    onDockedRemove: Ext.emptyFn,
    removeDocked: function (e, b) {
        var d = this, c, a;
        b = b === true || (b !== false && d.autoDestroy);
        if (!d.dockedItems.contains(e)) {
            return e
        }
        if (e.dock === "left" || e.dock === "right") {
            d.horizontalDocks--
        }
        c = d.componentLayout;
        a = c && d.rendered;
        if (a) {
            c.onRemove(e)
        }
        d.dockedItems.remove(e);
        e.onRemoved(e.destroying || b);
        d.onDockedRemove(e);
        if (b) {
            e.destroy()
        } else {
            if (a) {
                c.afterRemove(e)
            }
        }
        if (d.hasListeners.dockedremove) {
            d.fireEvent("dockedremove", d, e)
        }
        if (!d.destroying) {
            d.updateLayout()
        }
        return e
    },
    moveDocked: function (c, a) {
        var b = this;
        if (b.rendered) {
            Ext.suspendLayouts()
        }
        b.removeDocked(c, false);
        c.dock = a;
        b.addDocked(c);
        if (b.rendered) {
            if (c.frame) {
                Ext.getDetachedBody().appendChild(c.el);
                c.updateFrame()
            }
            Ext.resumeLayouts(true)
        }
    },
    setupDockingRenderTpl: function (a) {
        a.renderDockedItems = this.doRenderDockedItems
    }
}, 0, 0, 0, 0, 0, 0, [Ext.container, "DockingContainer"], 0));
(Ext.cmd.derive("Ext.panel.Panel", Ext.container.Container, {
    alternateClassName: "Ext.Panel",
    childEls: ["body"],
    renderTpl: ['<tpl if="headingText">', '<div id="{id}-headingEl" data-ref="headingEl" role="heading"', ' class="', "x-", 'hidden-clip" style="height:0">', "{headingText}", "</div>", "</tpl>", "{% this.renderDockedItems(out,values,0); %}", '<div id="{id}-body" data-ref="body" class="{baseCls}-body<tpl if="bodyCls"> {bodyCls}</tpl>', ' {baseCls}-body-{ui}<tpl if="uiCls">', '<tpl for="uiCls"> {parent.baseCls}-body-{parent.ui}-{.}</tpl>', '</tpl>{childElCls}"', '<tpl if="bodyAriaAttributes">', '<tpl foreach="bodyAriaAttributes"> {$}="{.}"</tpl>', "<tpl else>", ' role="presentation"', "</tpl>", '<tpl if="bodyStyle"> style="{bodyStyle}"</tpl>>', "{%this.renderContainer(out,values);%}", "</div>", "{% this.renderDockedItems(out,values,1); %}"],
    headerPosition: "top",
    iconAlign: "left",
    titleAlign: "left",
    titleRotation: "default",
    beforeRenderConfig: {
        glyph: null,
        headerPosition: null,
        icon: null,
        iconAlign: null,
        iconCls: null,
        title: null,
        titleAlign: null,
        titleRotation: null
    },
    animCollapse: Ext.enableFx,
    border: true,
    closable: false,
    closeAction: "destroy",
    closeToolText: "Close panel",
    collapsed: false,
    collapsedCls: "collapsed",
    collapseFirst: true,
    collapsible: undefined,
    collapseToolText: "Collapse panel",
    expandToolText: "Expand panel",
    constrain: false,
    constrainHeader: false,
    dockedItems: null,
    tbar: null,
    bbar: null,
    fbar: null,
    lbar: null,
    rbar: null,
    buttons: null,
    floatable: true,
    frame: false,
    frameHeader: true,
    hideCollapseTool: false,
    manageHeight: true,
    maskElement: "el",
    minButtonWidth: 75,
    preventHeader: false,
    shrinkWrapDock: false,
    titleCollapse: undefined,
    baseCls: "x-panel",
    bodyPosProps: {x: "x", y: "y"},
    componentLayout: "dock",
    contentPaddingProperty: "bodyPadding",
    emptyArray: [],
    isPanel: true,
    defaultBindProperty: "title",
    addBodyCls: function (b) {
        var c = this, a = c.rendered ? c.body : c.getProtoBody();
        a.addCls(b);
        return c
    },
    addTool: function (e) {
        if (!Ext.isArray(e)) {
            e = [e]
        }
        var d = this, h = d.header, a = e.length, g = d.tools, c, b;
        if (!h || !h.isHeader) {
            h = null;
            if (!g) {
                d.tools = g = []
            }
        }
        for (c = 0; c < a; c++) {
            b = e[c];
            b.toolOwner = d;
            if (h) {
                h.addTool(b)
            } else {
                g.push(b)
            }
        }
        d.updateHeader()
    },
    addTools: Ext.emptyFn,
    setCollapsible: function (c) {
        var b = this, d = b.collapsible, a = b.collapseTool;
        b.collapsible = c;
        if (c && !d) {
            b.updateCollapseTool();
            a = b.collapseTool;
            if (a) {
                a.show()
            }
        } else {
            if (!c && d) {
                if (a) {
                    a.hide()
                }
            }
        }
    },
    addUIClsToElement: function (b) {
        var c = this, a = Ext.container.Container.prototype.addUIClsToElement.apply(this, arguments);
        c.addBodyCls(["x-" + b, c.baseCls + "-body-" + b, c.baseCls + "-body-" + c.ui + "-" + b]);
        return a
    },
    afterCollapse: function (c) {
        var b = this, a = b.ariaEl.dom, d = b.ownerLayout;
        b.isCollapsingOrExpanding = 0;
        b.updateCollapseTool();
        if (c) {
            b.removeCls("x-animating-size")
        }
        if (d) {
            d.afterCollapse(b, c)
        }
        if (a) {
            a.setAttribute("aria-expanded", false)
        }
        if (b.isAccordionPanel) {
            b.body.dom.setAttribute("aria-hidden", true)
        }
        b.setHiddenDocked();
        b.fireEvent("collapse", b)
    },
    afterExpand: function (c) {
        var b = this, a = b.ariaEl.dom, d = b.ownerLayout;
        b.isCollapsingOrExpanding = 0;
        b.updateCollapseTool();
        if (c) {
            b.removeCls("x-animating-size")
        }
        if (d) {
            d.afterExpand(b, c)
        }
        if (a) {
            a.setAttribute("aria-expanded", true)
        }
        if (b.isAccordionPanel) {
            b.body.dom.setAttribute("aria-hidden", false)
        }
        b.fireEvent("expand", b);
        b.fireHierarchyEvent("expand")
    },
    beforeDestroy: function () {
        var a = this;
        Ext.destroy(a.placeholder, a.ghostPanel, a.dd, a.accordionKeyNav, a.defaultButtonKeyNav);
        a.destroyDockedItems();
        Ext.container.Container.prototype.beforeDestroy.call(this)
    },
    destroy: function () {
        Ext.container.Container.prototype.destroy.call(this);
        this.dockedItems = null
    },
    beforeRender: function () {
        var b = this, a;
        Ext.container.Container.prototype.beforeRender.call(this);
        b.initTools();
        if (!(b.preventHeader || (b.header === false)) || b.isViewportBorderChild) {
            b.updateHeader()
        }
        b.afterHeaderInit = true;
        if (b.collapsed) {
            if (b.isPlaceHolderCollapse()) {
                if (!b.hidden) {
                    b.setHiddenState(true);
                    b.preventCollapseFire = true;
                    b.placeholderCollapse();
                    delete b.preventCollapseFire;
                    a = b.collapsed;
                    b.collapsed = false
                }
            } else {
                b.beginCollapse();
                b.addClsWithUI(b.collapsedCls)
            }
        }
        if (a) {
            b.collapsed = a
        }
    },
    getMemento: function (a) {
        var b = this;
        if (a && typeof a === "string") {
            a += "Memento";
            return b[a] || (b[a] = new Ext.util.Memento(b))
        }
    },
    beginCollapse: function () {
        var e = this, c = e.lastBox, h = e.rendered, b = e.getMemento("collapse"), d = e.getSizeModel(), g = e.header,
            a;
        b.capture(["height", "minHeight", "width", "minWidth"]);
        if (c) {
            b.capture(e.restoreDimension(), c, "last.")
        }
        if (e.collapsedVertical()) {
            if (d.width.shrinkWrap) {
                e.width = h ? e.getWidth() : e.width || e.minWidth || 100
            }
            delete e.height;
            e.minHeight = 0
        } else {
            if (e.collapsedHorizontal()) {
                if (d.height.shrinkWrap) {
                    e.height = h ? e.getHeight() : e.height || e.minHeight || 100
                }
                delete e.width;
                e.minWidth = 0
            }
        }
        if (e.ownerCt) {
            e.ownerCt.getLayout().beginCollapse(e)
        }
        if (!e.isPlaceHolderCollapse() && g !== false) {
            if (g === (a = e.getReExpander())) {
                g.collapseImmune = true;
                g.getInherited().collapseImmune = true;
                g.addClsWithUI(e.getHeaderCollapsedClasses(g));
                if (g.rendered) {
                    g.updateFrame()
                }
            } else {
                if (a.el) {
                    a.el.show();
                    a.hidden = false
                }
            }
        }
        if (e.resizer) {
            e.resizer.disable()
        }
    },
    beginDrag: function () {
        if (this.floatingDescendants) {
            this.floatingDescendants.hide()
        }
    },
    beginExpand: function () {
        var e = this, d = e.lastBox, c = e.getMemento("collapse"), a = e.restoreDimension(), g = e.header, b;
        if (c) {
            c.restore(["minHeight", "minWidth", a]);
            if (d) {
                c.restore(a, true, d, "last.")
            }
        }
        if (e.ownerCt) {
            e.ownerCt.getLayout().beginExpand(e)
        }
        if (!e.isPlaceHolderCollapse() && g !== false) {
            if (g === (b = e.getReExpander())) {
                delete g.collapseImmune;
                delete g.getInherited().collapseImmune;
                g.removeClsWithUI(e.getHeaderCollapsedClasses(g));
                if (g.rendered) {
                    g.expanding = true;
                    g.updateFrame();
                    delete g.expanding
                }
            } else {
                b.hidden = true;
                b.el.hide()
            }
        }
        if (e.resizer) {
            e.resizer.enable()
        }
    },
    bridgeToolbars: function () {
        var a = this, g = [], e = a.minButtonWidth, c, b;

        function d(h, j, i) {
            if (Ext.isArray(h)) {
                h = {xtype: "toolbar", items: h}
            } else {
                if (!h.xtype) {
                    h.xtype = "toolbar"
                }
            }
            h.dock = j;
            if (i) {
                h.layout = Ext.applyIf(h.layout || {}, {
                    pack: {
                        left: "start",
                        center: "center"
                    }[a.buttonAlign] || "end"
                })
            }
            return h
        }

        if (a.tbar) {
            g.push(d(a.tbar, "top"));
            a.tbar = null
        }
        if (a.bbar) {
            g.push(d(a.bbar, "bottom"));
            a.bbar = null
        }
        if (a.buttons) {
            a.fbar = a.buttons;
            a.buttons = null
        }
        if (a.fbar) {
            c = d(a.fbar, "bottom", true);
            c.ui = "footer";
            if (e) {
                b = c.defaults;
                c.defaults = function (j) {
                    var k = b || {}, i = !j.xtype || j.isButton, h;
                    if (!i) {
                        h = Ext.ClassManager.getByAlias("widget." + j.xtype);
                        if (h) {
                            i = h.prototype.isButton
                        }
                    }
                    if (i && !("minWidth" in k)) {
                        k = Ext.apply({minWidth: e}, k)
                    }
                    return k
                }
            }
            g.push(c);
            a.fbar = null
        }
        if (a.lbar) {
            g.push(d(a.lbar, "left"));
            a.lbar = null
        }
        if (a.rbar) {
            g.push(d(a.rbar, "right"));
            a.rbar = null
        }
        if (a.dockedItems) {
            if (a.dockedItems.isMixedCollection) {
                a.addDocked(g)
            } else {
                if (!Ext.isArray(a.dockedItems)) {
                    a.dockedItems = [a.dockedItems]
                }
                a.dockedItems = a.dockedItems.concat(g)
            }
        } else {
            a.dockedItems = g
        }
    },
    close: function () {
        if (this.fireEvent("beforeclose", this) !== false) {
            this.doClose()
        }
    },
    collapse: function (e, a) {
        var d = this, g = e || d.collapseDirection, b = d.ownerCt, c = d.ownerLayout, h = d.rendered;
        if (d.isCollapsingOrExpanding) {
            return d
        }
        if (arguments.length < 2) {
            a = d.animCollapse
        }
        if (d.collapsed || d.fireEvent("beforecollapse", d, e, a) === false) {
            return d
        }
        if (c && c.onBeforeComponentCollapse) {
            if (c.onBeforeComponentCollapse(d) === false) {
                return d
            }
        }
        if (h && b && d.isPlaceHolderCollapse()) {
            return d.placeholderCollapse(e, a)
        }
        d.collapsed = g;
        if (h) {
            d.beginCollapse()
        }
        d.getInherited().collapsed = true;
        d.fireHierarchyEvent("collapse");
        if (h) {
            d.doCollapseExpand(1, a)
        }
        return d
    },
    collapsedHorizontal: function () {
        var a = this.getCollapsed();
        return a === "left" || a === "right"
    },
    collapsedVertical: function () {
        var a = this.getCollapsed();
        return a === "top" || a === "bottom"
    },
    convertCollapseDir: function (a) {
        return a.substr(0, 1)
    },
    createGhost: function (a) {
        var b = this, d = b.header, c = b.frame && !b.alwaysFramed;
        return {
            xtype: "panel",
            hidden: false,
            header: d ? {titleAlign: d.getTitleAlign()} : null,
            ui: c ? b.ui.replace(/-framed$/, "") : b.ui,
            id: b.id + "-ghost",
            renderTo: Ext.getBody(),
            resizable: false,
            draggable: false,
            closable: false,
            focusable: false,
            floating: true,
            shadow: false,
            frame: c,
            shim: b.shim,
            alwaysFramed: b.alwaysFramed,
            overlapHeader: b.overlapHeader,
            headerPosition: b.getHeaderPosition(),
            titleRotation: b.getTitleRotation(),
            baseCls: b.baseCls,
            getRefOwner: function () {
                return b.getRefOwner()
            },
            cls: b.baseCls + "-ghost " + (a || "")
        }
    },
    createReExpander: function (g, e) {
        var d = this, i = g === "left", c = g === "right", h = i || c, b = d.ownerCt, a = Ext.apply({
            hideMode: "offsets",
            title: d.getTitle(),
            titleAlign: d.getTitleAlign(),
            vertical: h,
            textCls: d.headerTextCls,
            icon: d.getIcon(),
            iconCls: d.getIconCls(),
            iconAlign: d.getIconAlign(),
            glyph: d.getGlyph(),
            baseCls: d.self.prototype.baseCls + "-header",
            ui: d.ui,
            frame: d.frame && d.frameHeader,
            ignoreParentFrame: d.frame || d.overlapHeader,
            ignoreBorderManagement: d.frame || d.ignoreHeaderBorderManagement,
            indicateDrag: d.draggable,
            collapseImmune: true,
            ariaRole: d.ariaRole,
            preventRefocus: true,
            ownerCt: (b && d.collapseMode === "placeholder") ? b : d,
            ownerLayout: d.componentLayout,
            forceOrientation: true,
            margin: d.margin
        }, e);
        if (d.collapseMode === "mini") {
            if (h) {
                a.width = 1
            } else {
                a.height = 1
            }
        }
        if (!d.hideCollapseTool) {
            if (i || (c && d.isPlaceHolderCollapse())) {
                a.titlePosition = 1
            }
            a.tools = [{
                xtype: "tool",
                type: "expand-" + d.getOppositeDirection(g),
                isDefaultExpandTool: true,
                uiCls: ["top"],
                handler: d.toggleCollapse,
                scope: d,
                tooltip: d.expandToolText
            }]
        }
        a = new Ext.panel.Header(a);
        a.addClsWithUI(d.getHeaderCollapsedClasses(a));
        a.expandTool = a.down("tool[isDefaultExpandTool=true]");
        return a
    },
    doClose: function () {
        this.fireEvent("close", this);
        this[this.closeAction]()
    },
    doCollapseExpand: function (a, b) {
        var d = this, c = d.animCollapse, e = d.ownerLayout;
        d.animCollapse = b;
        d.isCollapsingOrExpanding = a;
        if (b) {
            d.addCls("x-animating-size")
        }
        if (e && !b) {
            e.onContentChange(d)
        } else {
            d.updateLayout({isRoot: true})
        }
        d.animCollapse = c;
        return d
    },
    endDrag: function () {
        if (this.floatingDescendants) {
            this.floatingDescendants.show()
        }
    },
    expand: function (a) {
        var c = this, b = c.ownerLayout, d = c.rendered;
        if (c.isCollapsingOrExpanding) {
            return c
        }
        if (!arguments.length) {
            a = c.animCollapse
        }
        if (!c.collapsed && !c.floatedFromCollapse) {
            return c
        }
        if (c.fireEvent("beforeexpand", c, a) === false) {
            return c
        }
        if (b && b.onBeforeComponentExpand) {
            if (b.onBeforeComponentExpand(c) === false) {
                return c
            }
        }
        delete c.getInherited().collapsed;
        if (d && c.isPlaceHolderCollapse()) {
            return c.placeholderExpand(a)
        }
        c.restoreHiddenDocked();
        if (d) {
            c.beginExpand()
        }
        c.collapsed = false;
        if (c.rendered) {
            c.doCollapseExpand(2, a)
        }
        return c
    },
    findReExpander: function (h) {
        var g = this, j = Ext.Component, e = g.dockedItems.items, a = e.length, b, d;
        if (g.collapseMode === "mini") {
            return
        }
        switch (h) {
            case j.DIRECTION_TOP:
            case j.DIRECTION_BOTTOM:
                for (d = 0; d < a; d++) {
                    b = e[d];
                    if (!b.hidden) {
                        if (b.isHeader && (!b.dock || b.dock === "top" || b.dock === "bottom")) {
                            return b
                        }
                    }
                }
                break;
            case j.DIRECTION_LEFT:
            case j.DIRECTION_RIGHT:
                for (d = 0; d < a; d++) {
                    b = e[d];
                    if (!b.hidden) {
                        if (b.isHeader && (b.dock === "left" || b.dock === "right")) {
                            return b
                        }
                    }
                }
                break;
            default:
                throw ("Panel#findReExpander must be passed a valid collapseDirection")
        }
    },
    floatCollapsedPanel: function () {
        var h = this, i = h.placeholder, a = i.getSize(), g = Ext.panel.Panel.floatCls, d = h.collapsed,
            j = h.ownerCt || h, b, c, e;
        if (h.isSliding) {
            return
        }
        if (h.el.hasCls(g)) {
            h.slideOutFloatedPanel();
            return
        }
        h.isSliding = true;
        i.el.hide();
        i.hidden = true;
        h.el.show();
        h.setHiddenState(false);
        h.collapsed = false;
        j.updateLayout();
        i.el.show();
        i.hidden = false;
        h.el.hide();
        h.setHiddenState(true);
        h.collapsed = d;
        j.updateLayout();
        e = h.getBox(false, true);
        h.slideOutTask = h.slideOutTask || new Ext.util.DelayedTask(h.slideOutFloatedPanel, h);
        if (Ext.supports.Touch) {
            Ext.on("mousedown", c = function (k) {
                if (!k.within(h.el)) {
                    Ext.un("mousedown", c);
                    h.slideOutFloatedPanel()
                }
            })
        }
        if (!h.placeholderListener) {
            h.placeholderListener = i.on({resize: h.onPlaceholderResize, scope: h, destroyable: true})
        }
        i.el.on("mouseleave", h.onMouseLeaveFloated, h);
        h.el.on("mouseleave", h.onMouseLeaveFloated, h);
        i.el.on("mouseenter", h.onMouseEnterFloated, h);
        h.el.on("mouseenter", h.onMouseEnterFloated, h);
        h.el.addCls(g);
        h.floated = d;
        if (h.collapseTool) {
            h.collapseTool.el.hide()
        }
        switch (h.collapsed) {
            case"top":
                h.width = a.width;
                h.setLocalXY(e.x, e.y + a.height);
                break;
            case"right":
                h.height = a.height;
                h.setLocalXY(e.x - a.width, e.y);
                break;
            case"bottom":
                h.width = a.width;
                h.setLocalXY(e.x, e.y - a.height);
                break;
            case"left":
                h.height = a.height;
                h.setLocalXY(e.x + a.width, e.y);
                break
        }
        b = h.convertCollapseDir(h.collapsed);
        h.floatedFromCollapse = h.collapsed;
        h.collapsed = false;
        h.setHiddenState(false);
        h.el.slideIn(b, {
            preserveScroll: true,
            duration: Ext.Number.from(h.animCollapse, Ext.fx.Anim.prototype.duration),
            listeners: {
                afteranimate: function () {
                    h.isSliding = false;
                    h.fireEvent("float", h)
                }
            }
        })
    },
    onPlaceholderResize: function (e, c, a) {
        var b = this, d = b.getBox(false, true), g = e.getBox(false, true);
        switch (b.floated) {
            case"top":
                b.width = c;
                b.setLocalY(g.y + g.height);
                break;
            case"right":
                b.height = a;
                b.setLocalX(g.x - d.width);
                break;
            case"bottom":
                b.width = c;
                b.setLocalY(g.y - d.height);
                break;
            case"left":
                b.height = a;
                b.setLocalX(g.x + g.width);
                break
        }
        b.updateLayout({isRoot: true})
    },
    getAnimationProps: function () {
        var b = this, c = b.animCollapse, a;
        a = Ext.container.Container.prototype.getAnimationProps.call(this);
        if (typeof c === "number") {
            a.duration = c
        }
        return a
    },
    getCollapsed: function () {
        var a = this;
        if (a.collapsed === true) {
            return a.collapseDirection
        }
        return a.collapsed
    },
    getCollapsedDockedItems: function () {
        var a = this;
        return a.header === false || a.collapseMode === "placeholder" ? a.emptyArray : [a.getReExpander()]
    },
    getComponent: function (a) {
        var b = Ext.container.Container.prototype.getComponent.apply(this, arguments);
        if (b === undefined && !Ext.isNumber(a)) {
            b = this.getDockedComponent(a)
        }
        return b
    },
    getHeader: function () {
        return this.header
    },
    getHeaderCollapsedClasses: function (d) {
        var b = this, c = b.collapsedCls, a;
        a = [c, c + "-" + d.getDockName()];
        if (b.border && (!b.frame || (b.frame && Ext.supports.CSS3BorderRadius))) {
            a.push(c + "-border-" + d.getDockName())
        }
        return a
    },
    getKeyMap: function () {
        return this.keyMap || (this.keyMap = new Ext.util.KeyMap(Ext.apply({target: this.el}, this.keys)))
    },
    getOppositeDirection: function (a) {
        var b = Ext.Component;
        switch (a) {
            case b.DIRECTION_TOP:
                return b.DIRECTION_BOTTOM;
            case b.DIRECTION_RIGHT:
                return b.DIRECTION_LEFT;
            case b.DIRECTION_BOTTOM:
                return b.DIRECTION_TOP;
            case b.DIRECTION_LEFT:
                return b.DIRECTION_RIGHT
        }
    },
    getPlaceholder: function (e) {
        var d = this, h = e || d.collapseDirection, c = null, g = d.placeholder, b = d.floatable, a = d.titleCollapse;
        if (!g) {
            if (b || (d.collapsible && a)) {
                c = {click: {fn: (!a && b) ? d.floatCollapsedPanel : d.toggleCollapse, element: "el", scope: d}}
            }
            d.placeholder = g = Ext.widget(d.createReExpander(h, {id: d.id + "-placeholder", listeners: c}))
        }
        if (!g.placeholderFor) {
            if (!g.isComponent) {
                d.placeholder = g = d.lookupComponent(g)
            }
            Ext.applyIf(g, {margin: d.margin, placeholderFor: d, synthetic: true});
            g.addCls(["x-region-collapsed-placeholder", "x-region-collapsed-" + h + "-placeholder", d.collapsedCls])
        }
        return g
    },
    getProtoBody: function () {
        var b = this, a = b.protoBody;
        if (!a) {
            b.protoBody = a = new Ext.util.ProtoElement({
                cls: b.bodyCls,
                style: b.bodyStyle,
                clsProp: "bodyCls",
                styleProp: "bodyStyle",
                styleIsText: true
            })
        }
        return a
    },
    getReExpander: function (c) {
        var b = this, d = c || b.collapseDirection, a = b.reExpander || b.findReExpander(d);
        b.expandDirection = b.getOppositeDirection(d);
        if (!a) {
            b.reExpander = a = b.createReExpander(d, {
                dock: d,
                cls: "x-docked " + b.baseCls + "-" + b.ui + "-collapsed",
                isCollapsedExpander: true
            });
            b.dockedItems.insert(0, a)
        }
        return a
    },
    getRefItems: function (a) {
        var b = Ext.container.Container.prototype.getRefItems.apply(this, arguments);
        return this.getDockingRefItems(a, b)
    },
    getState: function () {
        var a = this, c = Ext.container.Container.prototype.getState.call(this) || {}, e = a.collapsed, b = a.floated,
            d;
        if (b) {
            a.collapsed = b
        }
        c = a.addPropertyToState(c, "collapsed");
        if (b) {
            a.collapsed = e
        }
        if (a.getCollapsed()) {
            d = a.getMemento("collapse").data;
            c = a.addPropertyToState(c, "collapsed", d);
            if (a.collapsedVertical()) {
                delete c.height;
                if (d) {
                    c = a.addPropertyToState(c, "height", d.height)
                }
            } else {
                delete c.width;
                if (d) {
                    c = a.addPropertyToState(c, "width", d.width)
                }
            }
        }
        return c
    },
    applyState: function (c) {
        var b = this, a = {}, d;
        if (c) {
            d = c.collapsed;
            if (d) {
                a = b.getMemento("collapse");
                Ext.Object.merge(a.data, d);
                c.collapsed = true
            }
            Ext.container.Container.prototype.applyState.apply(this, arguments)
        }
    },
    ghost: function (m) {
        var h = this, a = h.ghostPanel, d = h.getBox(), c = h.header, k, e, j, l, g, b;
        if (!a) {
            h.ghostPanel = a = Ext.widget(h.createGhost(m));
            a.el.dom.removeAttribute("tabIndex")
        } else {
            a.el.show()
        }
        a.setHiddenState(false);
        a.floatParent = h.floatParent;
        a.toFront();
        if (c && !h.preventHeader) {
            k = a.header;
            k.suspendLayouts();
            e = k.query("tool");
            for (b = e.length; b--;) {
                k.remove(e[b])
            }
            k.setTitlePosition(0);
            a.addTool(h.ghostTools());
            a.setTitle(h.getTitle());
            k.setTitlePosition(c.titlePosition);
            l = h.getIconCls();
            if (l) {
                a.setIconCls(l)
            } else {
                j = h.getIcon();
                if (j) {
                    a.setIcon(j)
                } else {
                    g = h.getGlyph();
                    if (g) {
                        a.setGlyph(g)
                    }
                }
            }
            k.addCls("x-header-ghost");
            k.resumeLayouts()
        }
        a.setPagePosition(d.x, d.y);
        a.setSize(d.width, d.height);
        h.el.hide();
        return a
    },
    ghostTools: function () {
        var e = [], g = this.header, d = g ? g.query("tool[hidden=false]") : [], c, a, b;
        if (d.length) {
            c = 0;
            a = d.length;
            for (; c < a; c++) {
                b = d[c];
                e.push({type: b.type, tooltip: b.tooltip})
            }
        } else {
            e = [{type: "placeholder"}]
        }
        return e
    },
    initBodyBorder: function () {
        var a = this;
        if (a.frame && a.bodyBorder) {
            if (!Ext.isNumber(a.bodyBorder)) {
                a.bodyBorder = 1
            }
            a.getProtoBody().setStyle("border-width", this.unitizeBox(a.bodyBorder))
        }
    },
    initBodyStyles: function () {
        var b = this, a = b.getProtoBody();
        if (b.bodyPadding !== undefined) {
            if (b.layout.managePadding) {
                a.setStyle("padding", 0)
            } else {
                a.setStyle("padding", this.unitizeBox((b.bodyPadding === true) ? 5 : b.bodyPadding))
            }
        }
        b.initBodyBorder()
    },
    initBorderProps: function () {
        var a = this;
        if (a.frame && a.border && a.bodyBorder === undefined) {
            a.bodyBorder = false
        }
        if (a.frame && a.border && (a.bodyBorder === false || a.bodyBorder === 0)) {
            a.manageBodyBorders = true
        }
    },
    initComponent: function () {
        var a = this;
        if (a.collapsible) {
            a.addStateEvents(["expand", "collapse"])
        }
        if (a.unstyled) {
            a.setUI("plain")
        }
        if (a.frame) {
            a.setUI(a.ui + "-framed")
        }
        a.bridgeToolbars();
        a.initBorderProps();
        Ext.container.Container.prototype.initComponent.call(this);
        a.collapseDirection = a.collapseDirection || a.getHeaderPosition() || Ext.Component.DIRECTION_TOP;
        a.hiddenOnCollapse = new Ext.dom.CompositeElement()
    },
    initItems: function () {
        Ext.container.Container.prototype.initItems.call(this);
        this.initDockingItems()
    },
    initRenderData: function () {
        var a = this, b = Ext.container.Container.prototype.initRenderData.call(this);
        a.initBodyStyles();
        a.protoBody.writeTo(b);
        delete a.protoBody;
        if (a.headingText) {
            b.headingText = a.headingText;
            a.addChildEl("headingEl")
        }
        if (a.bodyAriaRole) {
            b.bodyAriaAttributes = {role: a.bodyAriaRole};
            if (!a.ariaStaticRoles[a.bodyAriaRole] && a.bodyAriaRenderAttributes) {
                Ext.apply(b.bodyAriaAttributes, a.bodyAriaRenderAttributes)
            }
        }
        return b
    },
    calculateConstrainedPosition: function (g, b, e, a) {
        var h = this, i = h.header, d, c;
        if (h.constrainHeader) {
            d = i.lastBox;
            if (a) {
                if (!i.vertical) {
                    a = [a[0], d ? d.height : a[1]]
                } else {
                    a = [d ? d.width : a[0], a[1]]
                }
            } else {
                if (d) {
                    a = [d.width, d.height]
                }
            }
            c = h.floatParent;
            g = g || h.constrainTo || (c ? c.getTargetEl() : null) || h.container || h.el.parent()
        }
        return Ext.container.Container.prototype.calculateConstrainedPosition.call(this, g, b, e, a)
    },
    initTools: function () {
        var c = this, e = c.tools, b, d, a;
        c.tools = [];
        for (b = e && e.length; b;) {
            --b;
            c.tools[b] = a = e[b];
            a.toolOwner = c
        }
        if (c.collapsible && !(c.hideCollapseTool || c.header === false || c.preventHeader)) {
            c.updateCollapseTool();
            if (c.collapseFirst) {
                c.tools.unshift(c.collapseTool)
            }
        }
        c.addTools();
        if (c.pinnable) {
            c.initPinnable()
        }
        if (c.closable) {
            c.addClsWithUI("closable");
            d = {xtype: "tool", type: "close", scope: c, handler: c.close, tooltip: c.closeToolText};
            if (c.isAccordionPanel) {
                d.focusable = false;
                d.ariaRole = "presentation"
            }
            c.addTool(d)
        }
        if (c.collapseTool && !c.collapseFirst) {
            c.addTool(c.collapseTool)
        }
    },
    isLayoutRoot: function () {
        if (this.floatedFromCollapse) {
            return true
        }
        return Ext.container.Container.prototype.isLayoutRoot.call(this)
    },
    isPlaceHolderCollapse: function () {
        return this.collapseMode === "placeholder"
    },
    isVisible: function (a) {
        var b = this;
        if (b.collapsed && b.placeholder) {
            return b.placeholder.isVisible(a)
        }
        return Ext.container.Container.prototype.isVisible.apply(this, arguments)
    },
    onBoxReady: function () {
        var a = this, b;
        Ext.container.Container.prototype.onBoxReady.apply(this, arguments);
        if (a.collapsed) {
            a.setHiddenDocked()
        }
        if (a.isAccordionPanel) {
            a.ariaEl = a.header.titleCmp.el;
            a.ariaEl.dom.setAttribute("aria-expanded", !a.collapsed);
            a.body.dom.setAttribute("aria-labelledby", a.header.titleCmp.id);
            a.body.dom.setAttribute("aria-hidden", !!a.collapsed);
            a.accordionKeyNav = new Ext.util.KeyNav({
                target: a.header.titleCmp.el,
                scope: a,
                left: a.navigateAccordion,
                right: a.navigateAccordion,
                left: a.navigateAccordion,
                up: a.navigateAccordion,
                down: a.navigateAccordion,
                home: a.navigateAccordion,
                end: a.navigateAccordion,
                space: a.toggleCollapse,
                enter: a.toggleCollapse,
                del: {alt: true, fn: a.maybeClose}
            })
        }
        if (a.defaultButton) {
            b = a.defaultButtonTarget ? a[a.defaultButtonTarget] : a.body;
            a.defaultButtonKeyNav = new Ext.util.KeyNav({
                target: b,
                scope: a,
                defaultEventAction: "stopEvent",
                enter: a.fireDefaultButton
            })
        }
    },
    onHide: function (e, b, c) {
        var d = this, a = d.dd;
        if (d.floatedFromCollapse) {
            d.slideOutFloatedPanel(true)
        }
        if (d.draggable && a) {
            a.endDrag()
        }
        if (d.collapsed && d.placeholder) {
            if (d.splitter) {
                Ext.suspendLayouts();
                d.splitter.hide();
                Ext.resumeLayouts()
            }
            d.placeholder.hide()
        } else {
            Ext.container.Container.prototype.onHide.call(this, e, b, c)
        }
    },
    onMouseEnterFloated: function (a) {
        this.slideOutTask.cancel()
    },
    onMouseLeaveFloated: function (a) {
        this.slideOutTask.delay(500)
    },
    onRemoved: function (b) {
        var a = this;
        if (a.placeholder && !b) {
            a.ownerCt.remove(a.placeholder, false)
        }
        Ext.container.Container.prototype.onRemoved.apply(this, arguments)
    },
    onShow: function () {
        var a = this;
        if (a.collapsed && a.isPlaceHolderCollapse()) {
            if (a.splitter) {
                Ext.suspendLayouts();
                a.splitter.show();
                Ext.resumeLayouts()
            }
            a.setHiddenState(true);
            a.placeholderCollapse()
        } else {
            Ext.container.Container.prototype.onShow.apply(this, arguments)
        }
    },
    placeholderCollapse: function (g, a) {
        var e = this, b = e.ownerCt, j = g || e.collapseDirection, d = Ext.panel.Panel.floatCls, c = e.collapseTool,
            h = e.getPlaceholder(j), i;
        e.isCollapsingOrExpanding = 1;
        e.setHiddenState(true);
        e.collapsed = j;
        if (h.rendered) {
            if (h.el.dom.parentNode !== e.el.dom.parentNode) {
                e.el.dom.parentNode.insertBefore(h.el.dom, e.el.dom)
            }
            h.hidden = false;
            h.setHiddenState(false);
            h.el.show();
            b.updateLayout()
        } else {
            b.insert(b.items.indexOf(e), h)
        }
        if (e.rendered) {
            if (c && Ext.ComponentManager.getActiveComponent() === c) {
                e.focusPlaceholderExpandTool = true
            }
            e.el.setVisibilityMode(e.placeholderCollapseHideMode);
            if (a) {
                e.el.addCls(d);
                h.el.hide();
                i = e.convertCollapseDir(j);
                e.el.slideOut(i, {
                    preserveScroll: true,
                    duration: Ext.Number.from(a, Ext.fx.Anim.prototype.duration),
                    listeners: {
                        scope: e, afteranimate: function () {
                            var k = this;
                            k.el.removeCls(d);
                            k.placeholder.el.show().setStyle("display", "none").slideIn(i, {
                                easing: "linear",
                                duration: 100,
                                listeners: {afteranimate: k.doPlaceholderCollapse, scope: k}
                            })
                        }
                    }
                })
            } else {
                e.el.hide();
                e.doPlaceholderCollapse()
            }
        } else {
            e.isCollapsingOrExpanding = 0;
            if (!e.preventCollapseFire) {
                e.fireEvent("collapse", e)
            }
        }
        return e
    },
    doPlaceholderCollapse: function () {
        var a = this, b = a.placeholder, c = b.expandTool;
        if (a.focusPlaceholderExpandTool && c) {
            c.focus()
        } else {
            b.focus()
        }
        a.focusPlaceholderExpandTool = false;
        b.setHiddenState(false);
        b.ariaEl.dom.setAttribute("aria-hidden", false);
        b.ariaEl.dom.setAttribute("aria-expanded", false);
        a.ariaEl.dom.setAttribute("aria-hidden", true);
        a.ariaEl.dom.setAttribute("aria-expanded", false);
        a.isCollapsingOrExpanding = 0;
        a.fireEvent("collapse", a)
    },
    placeholderExpand: function (c) {
        var e = this, h = e.collapsed, i = e.placeholder.expandTool, d = Ext.panel.Panel.floatCls,
            b = e.ownerLayout ? e.ownerLayout.centerRegion : null, g, a;
        if (Ext.Component.layoutSuspendCount) {
            c = false
        }
        if (e.floatedFromCollapse) {
            a = e.getPosition(true);
            e.slideOutFloatedPanelBegin();
            e.slideOutFloatedPanelEnd();
            e.floated = false
        }
        if (i && Ext.ComponentManager.getActiveComponent() === i) {
            e.focusHeaderCollapseTool = true;
            i._ariaRole = i.ariaEl.dom.getAttribute("role");
            i._ariaLabel = i.ariaEl.dom.getAttribute("aria-label");
            i.ariaEl.dom.setAttribute("role", "presentation");
            i.ariaEl.dom.removeAttribute("aria-label")
        }
        if (c) {
            Ext.suspendLayouts();
            e.placeholder.hide();
            e.el.show();
            e.collapsed = false;
            e.setHiddenState(false);
            if (b && !a) {
                b.hidden = true
            }
            Ext.resumeLayouts(true);
            b.hidden = false;
            e.el.addCls(d);
            e.isCollapsingOrExpanding = 2;
            if (a) {
                g = e.getXY();
                e.setLocalXY(a[0], a[1]);
                e.setXY([g[0], g[1]], {
                    duration: Ext.Number.from(c, Ext.fx.Anim.prototype.duration),
                    listeners: {
                        scope: e, afteranimate: function () {
                            var j = this;
                            j.el.removeCls(d);
                            j.isCollapsingOrExpanding = 0;
                            j.fireEvent("expand", j)
                        }
                    }
                })
            } else {
                e.el.hide();
                e.placeholder.el.show();
                e.placeholder.hidden = false;
                e.setHiddenState(false);
                e.el.slideIn(e.convertCollapseDir(h), {
                    preserveScroll: true,
                    duration: Ext.Number.from(c, Ext.fx.Anim.prototype.duration),
                    listeners: {afteranimate: e.doPlaceholderExpand, scope: e}
                })
            }
        } else {
            e.floated = e.collapsed = false;
            e.doPlaceholderExpand(true)
        }
        return e
    },
    doPlaceholderExpand: function (b) {
        var c = this, d = c.placeholder, a = c.collapseTool, e = d.expandTool;
        if (b) {
            Ext.suspendLayouts();
            c.show()
        }
        c.el.removeCls(Ext.panel.Panel.floatCls);
        d.hide();
        if (b) {
            Ext.resumeLayouts(true)
        } else {
            c.updateLayout()
        }
        if (c.focusHeaderCollapseTool && a) {
            a.focus()
        }
        c.focusHeaderCollapseTool = false;
        d.ariaEl.dom.setAttribute("aria-expanded", true);
        c.ariaEl.dom.setAttribute("aria-expanded", true);
        if (e && e._ariaRole) {
            e.ariaEl.dom.setAttribute("role", e._ariaRole);
            e.ariaEl.dom.setAttribute("aria-label", e._ariaLabel);
            e._ariaRole = e._ariaLabel = null
        }
        c.isCollapsingOrExpanding = 0;
        c.fireEvent("expand", c)
    },
    remove: function (b, a) {
        var c = this.dockedItems;
        if (c && c.contains(b)) {
            this.removeDocked(b, a)
        } else {
            Ext.container.Container.prototype.remove.call(this, b, a)
        }
        return b
    },
    removeBodyCls: function (b) {
        var c = this, a = c.rendered ? c.body : c.getProtoBody();
        a.removeCls(b);
        return c
    },
    removeUIClsFromElement: function (b) {
        var c = this, a = Ext.container.Container.prototype.removeUIClsFromElement.apply(this, arguments);
        c.removeBodyCls(["x-" + b, c.baseCls + "-body-" + b, c.baseCls + "-body-" + c.ui + "-" + b]);
        return a
    },
    restoreDimension: function () {
        var a = this.collapseDirection;
        return (a === "top" || a === "bottom") ? "height" : "width"
    },
    restoreHiddenDocked: function () {
        var a = this.hiddenOnCollapse;
        a.setStyle("visibility", "");
        a.clear()
    },
    setBodyStyle: function (b, d) {
        var c = this, a = c.rendered ? c.body : c.getProtoBody();
        if (Ext.isFunction(b)) {
            b = b()
        }
        if (arguments.length === 1) {
            if (Ext.isString(b)) {
                b = Ext.Element.parseStyles(b)
            }
            a.setStyle(b)
        } else {
            a.setStyle(b, d)
        }
        return c
    },
    setBorder: function (a, c) {
        if (c) {
            return
        }
        var b = this, d = b.header;
        if (!a) {
            a = 0
        } else {
            if (a === true) {
                a = "1px"
            } else {
                a = b.unitizeBox(a)
            }
        }
        if (d) {
            if (d.isHeader) {
                d.setBorder(a)
            } else {
                d.border = a
            }
        }
        if (b.rendered && b.bodyBorder !== false) {
            b.body.setStyle("border-width", a)
        }
        b.updateLayout();
        b.border = a
    },
    setCollapsed: function (a) {
        this[a ? "collapse" : "expand"]()
    },
    setGlyph: function (c) {
        var b = this, a = b.glyph, e = b.header, d = b.placeholder;
        if (c !== a) {
            b.glyph = c;
            if (e) {
                if (e.isHeader) {
                    e.setGlyph(c)
                } else {
                    e.glyph = c
                }
            } else {
                if (b.rendered || b.afterHeaderInit) {
                    b.updateHeader()
                }
            }
            if (d && d.setGlyph) {
                d.setGlyph(c)
            }
            b.fireEvent("glyphchange", b, c, a)
        }
    },
    setIcon: function (a) {
        var b = this, c = b.icon, e = b.header, d = b.placeholder;
        if (a !== c) {
            b.icon = a;
            if (e) {
                if (e.isHeader) {
                    e.setIcon(a)
                } else {
                    e.icon = a
                }
            } else {
                if (b.rendered || b.afterHeaderInit) {
                    b.updateHeader()
                }
            }
            if (d && d.setIcon) {
                d.setIcon(a)
            }
            b.fireEvent("iconchange", b, a, c)
        }
    },
    setIconCls: function (b) {
        var c = this, a = c.iconCls, e = c.header, d = c.placeholder;
        if (b !== a) {
            c.iconCls = b;
            if (e) {
                if (e.isHeader) {
                    e.setIconCls(b)
                } else {
                    e.iconCls = b
                }
            } else {
                if (c.rendered || c.afterHeaderInit) {
                    c.updateHeader()
                }
            }
            if (d && d.setIconCls) {
                d.setIconCls(b)
            }
            c.fireEvent("iconclschange", c, b, a)
        }
    },
    setTitle: function (e) {
        var c = this, b = c.title, g = c.header, a = c.reExpander, d = c.placeholder;
        if (e !== b) {
            c.title = e;
            if (g) {
                if (g.isHeader) {
                    g.setTitle(e)
                }
            } else {
                if (c.rendered || c.afterHeaderInit) {
                    c.updateHeader()
                }
            }
            if (c.headingEl) {
                c.headingEl.setHtml(e)
            }
            if (a) {
                a.setTitle(e)
            }
            if (d && d.setTitle) {
                d.setTitle(e)
            }
            c.fireEvent("titlechange", c, e, b)
        }
    },
    setHiddenDocked: function () {
        var h = this, d = h.hiddenOnCollapse, c = h.getDockedItems(), a = c.length, e = 0, g, b;
        if (h.header !== false) {
            b = h.getReExpander()
        }
        d.add(h.body);
        for (; e < a; e++) {
            g = c[e];
            if (g && g !== b && g.el) {
                d.add(g.el)
            }
        }
        d.setStyle("visibility", "hidden")
    },
    setUI: function (b) {
        var a = this;
        Ext.container.Container.prototype.setUI.apply(this, arguments);
        if (a.header && a.header.rendered) {
            a.header.setUI(b)
        }
    },
    toggleCollapse: function () {
        return (this.collapsed || this.floatedFromCollapse) ? this.expand() : this.collapse()
    },
    updateCollapseTool: function () {
        var b = this, a = b.collapseTool, c;
        if (!a && b.collapsible) {
            b.collapseDirection = b.collapseDirection || b.getHeaderPosition() || "top";
            c = {xtype: "tool", handler: b.toggleCollapse, scope: b};
            if (b.isAccordionPanel) {
                c.focusable = false;
                c.ariaRole = "presentation"
            }
            b.collapseTool = b.expandTool = a = Ext.widget(c)
        }
        if (a) {
            if (b.collapsed && !b.isPlaceHolderCollapse()) {
                a.setType("expand-" + b.getOppositeDirection(b.collapseDirection));
                a.setTooltip(b.expandToolText)
            } else {
                a.setType("collapse-" + b.collapseDirection);
                a.setTooltip(b.collapseToolText)
            }
        }
    },
    navigateAccordion: function (i) {
        var g = this, b = g.accordionWrapOver, a = "[isAccordionPanel]", j = a + ":first", h = a + ":last", c, d;
        c = i.getKey();
        switch (c) {
            case i.UP:
            case i.LEFT:
                d = g.prev(a);
                if (!d && b) {
                    d = g.ownerCt.child(h)
                }
                break;
            case i.DOWN:
            case i.RIGHT:
                d = g.next(a);
                if (!d && b) {
                    d = g.ownerCt.child(j)
                }
                break;
            case i.HOME:
                d = g.ownerCt.child(j);
                break;
            case i.END:
                d = g.ownerCt.child(h);
                break;
            case i.DELETE:
                d = g.prev(a) || g.next(a);
                if (!d) {
                    i.doNotClose = true
                }
                break
        }
        if (d && d !== g) {
            d.header.titleCmp.focus()
        }
    },
    fireDefaultButton: function (c) {
        var b = this, d, a;
        d = b.lookupReferenceHolder() || b;
        a = d.lookupReference(b.defaultButton);
        if (a && a.click) {
            a.click(c);
            c.stopEvent();
            return false
        }
    },
    maybeClose: function (b) {
        var a = this;
        if (a.closable) {
            a.navigateAccordion(b);
            if (!b.doNotClose) {
                a.close()
            }
        }
    },
    onFocusEnter: function (c) {
        var b = this, a = b.ariaEl.dom;
        Ext.container.Container.prototype.onFocusEnter.call(this, c);
        if (b.isAccordionPanel && a) {
            a.setAttribute("aria-selected", true)
        }
    },
    onFocusLeave: function (c) {
        var b = this, a = b.ariaEl.dom;
        Ext.container.Container.prototype.onFocusLeave.call(this, c);
        if (b.isAccordionPanel && a) {
            a.removeAttribute("aria-selected")
        }
    },
    updateHeaderPosition: function (a) {
        var b = this.header;
        if (b && b.isHeader) {
            b.setDock(a)
        }
    },
    updateIconAlign: function (b) {
        var a = this.header;
        if (a && a.isHeader) {
            a.setIconAlign(b)
        }
    },
    updateTitleAlign: function (b) {
        var a = this.header;
        if (a && a.isHeader) {
            a.setTitleAlign(b)
        }
    },
    updateTitleRotation: function (a) {
        var b = this.header;
        if (b && b.isHeader) {
            b.setTitleRotation(a)
        }
    },
    unghost: function (c, a, b) {
        var e = this, d = e.ghostPanel;
        if (!d) {
            return
        }
        if (c !== false) {
            e.el.show();
            if (a !== false) {
                e.setPagePosition(d.getXY());
                if (e.hideMode === "offsets") {
                    delete e.el.hideModeStyles
                }
            }
            if (b) {
                e.focus(false, 10)
            }
        }
        d.el.hide();
        d.setHiddenState(true)
    },
    updateHeader: function (a) {
        var j = this, e = j.header, m = j.getTitle(), h = j.tools, l = j.getIcon(), k = j.getGlyph(),
            o = j.getIconCls(), d = k || l || o, i = j.ariaEl.dom, g = j.getHeaderPosition(),
            c = g === "left" || g === "right", n, b;
        if (Ext.isObject(e) || (e !== false && (a || (m || d) || (h && h.length) || (j.collapsible && !j.titleCollapse)))) {
            if (e && e.isHeader) {
                e.show()
            } else {
                e = j.header = Ext.widget(Ext.merge({
                    xtype: "header",
                    title: m,
                    titleAlign: j.getTitleAlign(),
                    vertical: c,
                    dock: j.getHeaderPosition() || "top",
                    titleRotation: j.getTitleRotation(),
                    textCls: j.headerTextCls,
                    iconCls: o,
                    iconAlign: j.getIconAlign(),
                    icon: l,
                    glyph: k,
                    baseCls: j.baseCls + "-header",
                    tools: h,
                    ui: j.ui,
                    id: j.id + "_header",
                    overCls: j.headerOverCls,
                    indicateDrag: j.draggable,
                    frame: (j.frame || j.alwaysFramed) && j.frameHeader,
                    ignoreParentFrame: j.frame || j.overlapHeader,
                    ignoreBorderManagement: j.frame || j.ignoreHeaderBorderManagement,
                    isAccordionHeader: j.isAccordionPanel,
                    ownerCt: j,
                    synthetic: true,
                    listeners: j.collapsible && j.titleCollapse ? {click: j.toggleCollapse, scope: j} : null
                }, j.header));
                j.addDocked(e, 0)
            }
            if (j.isAccordionPanel) {
                if (i) {
                    i.setAttribute("aria-labelledby", e.id + "-title");
                    i.removeAttribute("aria-label")
                } else {
                    b = j.ariaRenderAttributes || (j.ariaRenderAttributes = {});
                    b["aria-labelledby"] = e.id + "-title";
                    delete b["aria-label"]
                }
            } else {
                if (m) {
                    if (j.ariaRole !== "tabpanel") {
                        if (i) {
                            i.setAttribute("aria-labelledby", e.id + "-title-textEl");
                            i.removeAttribute("aria-label")
                        } else {
                            b = j.ariaRenderAttributes || (j.ariaRenderAttributes = {});
                            b["aria-labelledby"] = e.id + "-title-textEl";
                            delete b["aria-label"]
                        }
                    }
                } else {
                    if (j.ariaRenderAttributes) {
                        delete j.ariaRenderAttributes["aria-labelledby"];
                        delete j.ariaRenderAttributes["aria-label"]
                    }
                }
            }
        } else {
            if (e) {
                e.hide()
            }
            if (i) {
                i.removeAttribute("aria-labelledby");
                if (m) {
                    i.setAttribute("aria-label", m)
                } else {
                    i.removeAttribute("aria-label")
                }
            } else {
                b = j.ariaRenderAttributes || (j.ariaRenderAttributes = {});
                delete b["aria-labelledby"];
                if (m) {
                    b["aria-label"] = m
                } else {
                    delete b["aria-label"]
                }
            }
        }
        if (j.isViewportBorderChild && !j.hasOwnProperty("ariaRole")) {
            j.ariaRole = "region"
        }
        if (m && j.ariaRole === "region") {
            n = j.headingEl;
            if (n) {
                n.setHtml(m)
            } else {
                if (j.rendered) {
                    j.headingEl = Ext.dom.Helper.insertFirst(j.el, {
                        tag: "div",
                        id: j.id + "-headingEl",
                        role: "heading",
                        "class": "x-hidden-clip",
                        style: "height:0",
                        html: m
                    }, true);
                    i.removeAttribute("aria-label");
                    i.setAttribute("aria-labelledby", j.id + "-headingEl")
                } else {
                    j.headingText = j.title;
                    b = j.ariaRenderAttributes || (j.ariaRenderAttributes = {});
                    b["aria-labelledby"] = j.id + "-headingEl";
                    delete b["aria-label"]
                }
            }
        } else {
            if (j.headingEl) {
                j.headingEl.destroy();
                j.headingEl = null
            }
        }
    },
    statics: {floatCls: "x-border-region-slide-in"},
    privates: {
        addUIToElement: function () {
            var a = this;
            Ext.container.Container.prototype.addUIToElement.apply(this, arguments);
            a.addBodyCls(a.baseCls + "-body-" + a.ui)
        }, applyTargetCls: function (a) {
            this.getProtoBody().addCls(a)
        }, getDefaultContentTarget: function () {
            return this.body
        }, getTargetEl: function () {
            var a = this;
            return a.body || a.protoBody || a.frameBody || a.el
        }, initDraggable: function () {
            var a = this;
            if (a.simpleDrag) {
                a.initSimpleDraggable()
            } else {
                a.dd = new Ext.panel.DD(a, Ext.isBoolean(a.draggable) ? null : a.draggable)
            }
        }, initResizable: function () {
            Ext.container.Container.prototype.initResizable.apply(this, arguments);
            if (this.collapsed) {
                this.resizer.disable()
            }
        }, initSimpleDraggable: function () {
            var c = this, b, a;
            if (!c.header) {
                c.updateHeader(true)
            }
            if (c.header) {
                b = Ext.applyIf({el: c.el, delegate: "#" + c.header.id}, c.draggable);
                if (c.constrain || c.constrainHeader) {
                    b.constrain = c.constrain;
                    b.constrainDelegate = c.constrainHeader;
                    b.constrainTo = c.constrainTo || c.container
                }
                a = c.dd = new Ext.util.ComponentDragger(c, b);
                c.relayEvents(a, ["dragstart", "drag", "dragend"]);
                if (c.maximized) {
                    a.disable()
                }
            }
        }, removeUIFromElement: function () {
            var a = this;
            Ext.container.Container.prototype.removeUIFromElement.apply(this, arguments);
            a.removeBodyCls(a.baseCls + "-body-" + a.ui)
        }, setupRenderTpl: function (a) {
            Ext.container.Container.prototype.setupRenderTpl.apply(this, arguments);
            this.setupDockingRenderTpl(a)
        }, slideOutFloatedPanel: function (a) {
            var c = this, e = c.el, d, b = function () {
                c.slideOutFloatedPanelEnd();
                c.el.removeCls("x-border-region-slide-in")
            };
            if (c.isSliding || c.destroyed) {
                return
            }
            c.isSliding = true;
            c.floated = false;
            c.slideOutFloatedPanelBegin();
            if (a) {
                e.hide();
                return b()
            }
            if (typeof c.collapsed === "string") {
                d = c.convertCollapseDir(c.collapsed)
            }
            e.slideOut(d, {
                preserveScroll: true,
                duration: Ext.Number.from(c.animCollapse, Ext.fx.Anim.prototype.duration),
                listeners: {afteranimate: b}
            })
        }, slideOutFloatedPanelBegin: function () {
            var b = this, c = b.placeholder.el, a = b.el;
            b.collapsed = b.floatedFromCollapse;
            b.setHiddenState(true);
            b.floatedFromCollapse = null;
            c.un("mouseleave", b.onMouseLeaveFloated, b);
            a.un("mouseleave", b.onMouseLeaveFloated, b);
            c.un("mouseenter", b.onMouseEnterFloated, b);
            a.un("mouseenter", b.onMouseEnterFloated, b)
        }, slideOutFloatedPanelEnd: function (a) {
            var b = this;
            if (b.collapseTool) {
                b.collapseTool.el.show()
            }
            b.slideOutTask.cancel();
            b.isSliding = false;
            if (!a) {
                b.fireEvent("unfloat", b)
            }
        }
    }
}, 0, ["panel"], ["component", "box", "container", "panel"], {
    component: true,
    box: true,
    container: true,
    panel: true
}, ["widget.panel"], [["docking", Ext.container.DockingContainer]], [Ext.panel, "Panel", Ext, "Panel"], function () {
    var a = this.prototype;
    a.animCollapse = Ext.enableFx;
    a.placeholderCollapseHideMode = Ext.Element.VISIBILITY
}));
(Ext.cmd.derive("Ext.layout.container.Table", Ext.layout.container.Container, {
    alternateClassName: "Ext.layout.TableLayout",
    type: "table",
    createsInnerCt: true,
    targetCls: "x-table-layout-ct",
    tableCls: "x-table-layout",
    cellCls: "x-table-layout-cell",
    childEls: ["table", "tbody"],
    tableAttrs: null,
    getItemSizePolicy: function (a) {
        return this.autoSizePolicy
    },
    initInheritedState: function (b, a) {
        a.inShrinkWrapTable = true
    },
    getLayoutItems: function () {
        var g = this, b = [], c = Ext.layout.container.Container.prototype.getLayoutItems.call(this), a = c.length, e,
            d;
        for (d = 0; d < a; d++) {
            e = c[d];
            if (!e.hidden) {
                b.push(e)
            }
        }
        return b
    },
    getHiddenItems: function () {
        var b = [], c = this.owner.items.items, a = c.length, d, e;
        for (d = 0; d < a; ++d) {
            e = c[d];
            if (e.rendered && e.hidden) {
                b.push(e)
            }
        }
        return b
    },
    renderChildren: function () {
        var j = this, h = j.getLayoutItems(), e = j.tbody.dom, p = e.rows, g = h.length, c = j.getHiddenItems(), o, m,
            b, a, n, l, k, d;
        o = j.calculateCells(h);
        for (d = 0; d < g; d++) {
            m = o[d];
            b = m.rowIdx;
            a = m.cellIdx;
            n = h[d];
            l = p[b];
            if (!l) {
                l = e.insertRow(b);
                if (j.trAttrs) {
                    l.set(j.trAttrs)
                }
            }
            k = Ext.get(l.cells[a] || l.insertCell(a));
            if (!n.rendered) {
                j.renderItem(n, k, 0)
            } else {
                if (!j.isValidParent(n, k, b, a, e)) {
                    j.moveItem(n, k, 0)
                }
            }
            if (j.tdAttrs) {
                k.set(j.tdAttrs)
            }
            if (n.tdAttrs) {
                k.set(n.tdAttrs)
            }
            k.set({colSpan: n.colspan || 1, rowSpan: n.rowspan || 1, cls: j.cellCls + " " + (n.cellCls || "")});
            if (!o[d + 1] || o[d + 1].rowIdx !== b) {
                a++;
                while (l.cells[a]) {
                    l.deleteCell(a)
                }
            }
        }
        b++;
        while (e.rows[b]) {
            e.deleteRow(b)
        }
        for (d = 0, g = c.length; d < g; ++d) {
            j.ensureInDocument(c[d].getEl())
        }
    },
    ensureInDocument: function (a) {
        var b = a.dom.parentNode;
        while (b) {
            if (b.tagName.toUpperCase() === "BODY") {
                return
            }
            b = b.parentNode
        }
        Ext.getDetachedBody().appendChild(a)
    },
    calculate: function (g) {
        if (!g.hasDomProp("containerChildrenSizeDone")) {
            this.done = false
        } else {
            var c = g.targetContext, b = g.widthModel.shrinkWrap, a = g.heightModel.shrinkWrap, h = a || b,
                d = h && this.table.dom, e = h && c.getPaddingInfo();
            if (b) {
                g.setContentWidth(d.offsetWidth + e.width, true)
            }
            if (a) {
                g.setContentHeight(d.offsetHeight + e.height, true)
            }
        }
    },
    calculateCells: function (k) {
        var m = [], b = 0, e = 0, a = 0, g = this.columns || Infinity, n = [], h = k.length, l, d, c;
        for (d = 0; d < h; d++) {
            l = k[d];
            while (e >= g || n[e] > 0) {
                if (e >= g) {
                    e = 0;
                    a = 0;
                    b++;
                    for (c = 0; c < g; c++) {
                        if (n[c] > 0) {
                            n[c]--
                        }
                    }
                } else {
                    e++
                }
            }
            m.push({rowIdx: b, cellIdx: a});
            for (c = l.colspan || 1; c; --c) {
                n[e] = l.rowspan || 1;
                ++e
            }
            ++a
        }
        return m
    },
    getRenderTree: function () {
        var j = this, g = j.getLayoutItems(), o = [], p = Ext.apply({
            tag: "table",
            id: j.owner.id + "-table",
            "data-ref": "table",
            role: "presentation",
            cls: j.tableCls,
            cellspacing: 0,
            cellpadding: 0,
            cn: {tag: "tbody", id: j.owner.id + "-tbody", "data-ref": "tbody", role: "presentation", cn: o}
        }, j.tableAttrs), c = j.tdAttrs, d, e = g.length, n, l, h, b, a, k, m;
        m = j.calculateCells(g);
        for (d = 0; d < e; d++) {
            n = g[d];
            l = m[d];
            b = l.rowIdx;
            a = l.cellIdx;
            h = o[b];
            if (!h) {
                h = o[b] = {tag: "tr", role: "presentation", cn: []};
                if (j.trAttrs) {
                    Ext.apply(h, j.trAttrs)
                }
            }
            k = h.cn[a] = {tag: "td", role: "presentation"};
            if (c) {
                Ext.apply(k, c)
            }
            Ext.apply(k, {colSpan: n.colspan || 1, rowSpan: n.rowspan || 1, cls: j.cellCls + " " + (n.cellCls || "")});
            j.configureItem(n);
            k.cn = n.getRenderTree()
        }
        return p
    },
    isValidParent: function (c, d, b, a) {
        if (arguments.length === 3) {
            return this.table.isAncestor(c.el)
        }
        return c.el.dom.parentNode === this.tbody.dom.rows[b].cells[a]
    }
}, 0, 0, 0, 0, ["layout.table"], 0, [Ext.layout.container, "Table", Ext.layout, "TableLayout"], 0));
(Ext.cmd.derive("Ext.container.ButtonGroup", Ext.panel.Panel, {
    alternateClassName: "Ext.ButtonGroup",
    baseCls: "x-btn-group",
    layout: {type: "table"},
    defaultType: "button",
    frame: true,
    frameHeader: false,
    titleAlign: "center",
    noTitleCls: "notitle",
    bodyAriaRole: "toolbar",
    initComponent: function () {
        var a = this, b = a.columns;
        if (b) {
            a.layout = Ext.apply({}, {columns: b}, a.layout)
        }
        if (!a.title) {
            a.addClsWithUI(a.noTitleCls)
        }
        Ext.panel.Panel.prototype.initComponent.call(this)
    },
    onBeforeAdd: function (a) {
        if (a.isButton) {
            if (this.defaultButtonUI && a.ui === "default" && !a.hasOwnProperty("ui")) {
                a.ui = this.defaultButtonUI
            } else {
                a.ui = a.ui + "-toolbar"
            }
        }
        Ext.panel.Panel.prototype.onBeforeAdd.apply(this, arguments)
    },
    beforeRender: function () {
        var b = this, a;
        Ext.panel.Panel.prototype.beforeRender.call(this);
        if (b.afterHeaderInit && !b.header && b.title) {
            a = b.bodyAriaRenderAttributes || (b.bodyAriaRenderAttributes = {});
            a["aria-label"] = b.title
        }
    },
    updateHeader: function (d) {
        var c = this, a = c.body, e, b;
        Ext.panel.Panel.prototype.updateHeader.call(this, d);
        e = c.header;
        if (e) {
            if (a) {
                a.dom.setAttribute("aria-labelledby", e.id + "-title-textEl");
                a.dom.removeAttribute("aria-label")
            } else {
                b = c.bodyAriaRenderAttributes || (c.bodyAriaRenderAttributes = {});
                b["aria-labelledby"] = e.id + "-title-textEl";
                delete b["aria-label"]
            }
        } else {
            if (c.title) {
                if (a) {
                    a.dom.setAttribute("aria-label", c.title);
                    a.dom.removeAttribute("aria-labelledby")
                } else {
                    b = c.bodyAriaRenderAttributes || (c.bodyAriaRenderAttributes = {});
                    b["aria-label"] = c.title;
                    delete b["aria-labelledby"]
                }
            }
        }
    },
    privates: {
        applyDefaults: function (a) {
            if (!Ext.isString(a)) {
                a = Ext.panel.Panel.prototype.applyDefaults.apply(this, arguments)
            }
            return a
        }, getFocusableContainerEl: function () {
            return this.body
        }
    }
}, 0, ["buttongroup"], ["component", "box", "container", "panel", "buttongroup"], {
    component: true,
    box: true,
    container: true,
    panel: true,
    buttongroup: true
}, ["widget.buttongroup"], [[Ext.util.FocusableContainer.prototype.mixinId || Ext.util.FocusableContainer.$className, Ext.util.FocusableContainer]], [Ext.container, "ButtonGroup", Ext, "ButtonGroup"], 0));
(Ext.cmd.derive("Ext.container.Monitor", Ext.Base, {
    target: null,
    selector: "",
    scope: null,
    addHandler: null,
    removeHandler: null,
    invalidateHandler: null,
    disabled: 0,
    constructor: function (a) {
        Ext.apply(this, a)
    },
    bind: function (b) {
        var a = this;
        a.target = b;
        b.on("beforedestroy", a.disable, a);
        a.onContainerAdd(b)
    },
    unbind: function () {
        var a = this, b = a.target;
        if (b) {
            b.un("beforedestroy", a.disable, a)
        }
        a.items = null
    },
    disable: function () {
        ++this.disabled
    },
    enable: function () {
        if (this.disabled > 0) {
            --this.disabled
        }
    },
    handleAdd: function (b, a) {
        if (!this.disabled) {
            if (a.is(this.selector)) {
                this.onItemAdd(a.ownerCt, a)
            }
            if (a.isQueryable) {
                this.onContainerAdd(a)
            }
        }
    },
    onItemAdd: function (c, b) {
        var e = this, a = e.items, d = e.addHandler;
        if (!e.disabled) {
            if (d) {
                d.call(e.scope || b, b)
            }
            if (a) {
                a.add(b)
            }
        }
    },
    onItemRemove: function (c, b) {
        var e = this, a = e.items, d = e.removeHandler;
        if (!e.disabled) {
            if (d) {
                d.call(e.scope || b, b)
            }
            if (a) {
                a.remove(b)
            }
        }
    },
    onContainerAdd: function (g, b) {
        var k = this, j, h, c = k.handleAdd, a = k.handleRemove, d, e;
        if (g.isContainer) {
            g.on("add", c, k);
            g.on("dockedadd", c, k);
            g.on("remove", a, k);
            g.on("dockedremove", a, k)
        }
        if (b !== true) {
            j = g.query(k.selector);
            for (d = 0, h = j.length; d < h; ++d) {
                e = j[d];
                k.onItemAdd(e.ownerCt, e)
            }
        }
        j = g.query(">container");
        for (d = 0, h = j.length; d < h; ++d) {
            k.onContainerAdd(j[d], true)
        }
    },
    handleRemove: function (b, a) {
        var c = this;
        if (!c.disabled) {
            if (a.is(c.selector)) {
                c.onItemRemove(b, a)
            }
            if (a.isQueryable) {
                c.onContainerRemove(b, a)
            }
        }
    },
    onContainerRemove: function (e, c) {
        var h = this, b, d, a, g;
        if (!c.destroyed && !c.destroying && c.isContainer) {
            h.removeCtListeners(c);
            b = c.query(h.selector);
            for (d = 0, a = b.length; d < a; ++d) {
                g = b[d];
                h.onItemRemove(g.ownerCt, g)
            }
            b = c.query("container");
            for (d = 0, a = b.length; d < a; ++d) {
                h.removeCtListeners(b[d])
            }
        } else {
            h.invalidateItems(true)
        }
    },
    removeCtListeners: function (a) {
        var b = this;
        a.un("add", b.handleAdd, b);
        a.un("dockedadd", b.handleAdd, b);
        a.un("remove", b.handleRemove, b);
        a.un("dockedremove", b.handleRemove, b)
    },
    getItems: function () {
        var b = this, a = b.items;
        if (!a) {
            a = b.items = new Ext.util.MixedCollection();
            a.addAll(b.target.query(b.selector))
        }
        return a
    },
    invalidateItems: function (c) {
        var b = this, a = b.invalidateHandler;
        if (c && a) {
            a.call(b.scope || b, b)
        }
        b.items = null
    }
}, 1, 0, 0, 0, 0, 0, [Ext.container, "Monitor"], 0));
(Ext.cmd.derive("Ext.plugin.Responsive", Ext.mixin.Responsive, {
    pluginId: "responsive",
    isPlugin: true,
    constructor: function (a) {
        var d = this, b = a.cmp,
            e = Ext.apply({responsiveConfig: b.responsiveConfig, responsiveFormulas: b.responsiveFormulas}, a);
        delete e.cmp;
        d.cmp = b;
        d.initConfig(e);
        if (d.transformed) {
            b.setConfig(d.transformed);
            d.transformed = null
        }
    },
    init: Ext.emptyFn,
    privates: {
        transformInstanceConfig: function (c) {
            var b = Ext.mixin.Responsive.prototype.transformInstanceConfig.call(this, c);
            if (b.ptype) {
                b = Ext.apply({}, b);
                delete b.ptype
            }
            this.transformed = b;
            var a = Ext.apply({}, c);
            delete a.ptype;
            delete a.responsiveConfig;
            delete a.responsiveFormulas;
            return a
        }, updateResponsiveState: function () {
            var a = this.getResponsiveState();
            this.cmp.setConfig(a)
        }
    }
}, 1, 0, 0, 0, ["plugin.responsive"], 0, [Ext.plugin, "Responsive"], 0));
(Ext.cmd.derive("Ext.plugin.Viewport", Ext.plugin.Responsive, {
    setCmp: function (a) {
        this.cmp = a;
        if (a && !a.isViewport) {
            this.decorate(a);
            if (a.renderConfigs) {
                a.flushRenderConfigs()
            }
            a.setupViewport()
        }
    }, statics: {
        decorate: function (a) {
            Ext.applyIf(a.prototype || a, {ariaRole: "application", viewportCls: "x-viewport"});
            Ext.override(a, {
                isViewport: true, preserveElOnDestroy: true, initComponent: function () {
                    this.callParent();
                    this.setupViewport()
                }, getSizeModel: function () {
                    var b = Ext.layout.SizeModel.configured;
                    return b.pairsByHeightOrdinal[b.ordinal]
                }, handleViewportResize: function () {
                    var e = this, c = Ext.dom.Element, d = c.getViewportWidth(), b = c.getViewportHeight();
                    if (d !== e.width || b !== e.height) {
                        e.setSize(d, b)
                    }
                }, setupViewport: function () {
                    var c = this, b = document.body;
                    if (!b.id) {
                        b.id = c.id
                    }
                    b.setAttribute(Ext.Component.componentIdAttribute, c.id);
                    if (!c.ariaStaticRoles[c.ariaRole]) {
                        b.setAttribute("role", c.ariaRole)
                    }
                    b = c.el = Ext.getBody();
                    Ext.fly(document.documentElement).addCls(c.viewportCls);
                    b.setHeight = b.setWidth = Ext.emptyFn;
                    b.dom.scroll = "no";
                    c.allowDomMove = false;
                    c.renderTo = b;
                    if (Ext.supports.Touch) {
                        c.addMeta("apple-mobile-web-app-capable", "yes")
                    }
                    Ext.getScrollbarSize();
                    c.width = c.height = undefined;
                    c.initialViewportHeight = Ext.Element.getViewportHeight();
                    c.initialViewportWidth = Ext.Element.getViewportWidth()
                }, afterLayout: function (b) {
                    if (Ext.supports.Touch) {
                        document.body.scrollTop = 0
                    }
                    this.callParent([b])
                }, onRender: function () {
                    var b = this;
                    b.callParent(arguments);
                    b.width = b.initialViewportWidth;
                    b.height = b.initialViewportHeight;
                    b.initialViewportWidth = b.initialViewportHeight = null;
                    if (Ext.supports.TouchEvents) {
                        b.mon(Ext.getDoc(), {
                            touchmove: function (c) {
                                c.preventDefault()
                            }, translate: false, delegated: false
                        })
                    }
                }, initInheritedState: function (d, c) {
                    var e = this, b = Ext.rootInheritedState;
                    if (d !== b) {
                        e.initInheritedState(e.inheritedState = b, e.inheritedStateInner = Ext.Object.chain(b))
                    } else {
                        e.callParent([d, c])
                    }
                }, beforeDestroy: function () {
                    var d = this, b = Ext.rootInheritedState, c;
                    for (c in b) {
                        if (c !== "rtl") {
                            delete b[c]
                        }
                    }
                    d.removeUIFromElement();
                    d.el.removeCls(d.baseCls);
                    Ext.fly(document.body.parentNode).removeCls(d.viewportCls);
                    d.callParent()
                }, addMeta: function (b, c) {
                    var d = document.createElement("meta");
                    d.setAttribute("name", b);
                    d.setAttribute("content", c);
                    Ext.getHead().appendChild(d)
                }, privates: {
                    applyTargetCls: function (b) {
                        this.el.addCls(b)
                    }, disableTabbing: function () {
                        var b = this.el;
                        if (b) {
                            b.saveTabbableState({skipSelf: true})
                        }
                    }, enableTabbing: function () {
                        var b = this.el;
                        if (b) {
                            b.restoreTabbableState(true)
                        }
                    }, getOverflowEl: function () {
                        return Ext.get(document.documentElement)
                    }
                }
            })
        }
    }, privates: {
        updateResponsiveState: function () {
            this.cmp.handleViewportResize();
            Ext.plugin.Responsive.prototype.updateResponsiveState.call(this)
        }
    }
}, 0, 0, 0, 0, ["plugin.viewport"], 0, [Ext.plugin, "Viewport"], function (a) {
    a.prototype.decorate = a.decorate
}));
(Ext.cmd.derive("Ext.container.Viewport", Ext.container.Container, {
    alternateClassName: "Ext.Viewport",
    ariaRole: "application",
    privates: {
        updateResponsiveState: function () {
            this.handleViewportResize();
            this.mixins.responsive.updateResponsiveState.call(this)
        }
    }
}, 0, ["viewport"], ["component", "box", "container", "viewport"], {
    component: true,
    box: true,
    container: true,
    viewport: true
}, ["widget.viewport"], [[Ext.mixin.Responsive.prototype.mixinId || Ext.mixin.Responsive.$className, Ext.mixin.Responsive]], [Ext.container, "Viewport", Ext, "Viewport"], function () {
    Ext.plugin.Viewport.decorate(this)
}));
(Ext.cmd.derive("Ext.layout.container.Anchor", Ext.layout.container.Auto, {
    alternateClassName: "Ext.layout.AnchorLayout",
    type: "anchor",
    defaultAnchor: "100%",
    parseAnchorRE: /^(r|right|b|bottom)$/i,
    manageOverflow: true,
    setsItemSize: true,
    beginLayoutCycle: function (g) {
        var e = this, d = 0, j, a, h, b, c;
        Ext.layout.container.Auto.prototype.beginLayoutCycle.apply(this, arguments);
        h = g.childItems;
        c = h.length;
        for (b = 0; b < c; ++b) {
            a = h[b];
            j = a.target.anchorSpec;
            if (j) {
                if (a.widthModel.calculated && j.right) {
                    d |= 1
                }
                if (a.heightModel.calculated && j.bottom) {
                    d |= 2
                }
                if (d === 3) {
                    break
                }
            }
        }
        g.anchorDimensions = d
    },
    calculateItems: function (h, a) {
        var q = this, l = h.childItems, g = l.length, o = a.gotHeight, j = a.gotWidth, e = a.height, c = a.width,
            b = (j ? 1 : 0) | (o ? 2 : 0), p = h.anchorDimensions, m, s, n, r, k, d;
        if (!p) {
            return true
        }
        for (k = 0; k < g; k++) {
            s = l[k];
            n = s.getMarginInfo();
            m = s.target.anchorSpec;
            if (j && s.widthModel.calculated) {
                d = m.right(c) - n.width;
                d = q.adjustWidthAnchor(d, s);
                s.setWidth(d)
            }
            if (o && s.heightModel.calculated) {
                r = m.bottom(e) - n.height;
                r = q.adjustHeightAnchor(r, s);
                s.setHeight(r)
            }
        }
        return (b & p) === p
    },
    anchorFactory: {
        offset: function (a) {
            return function (b) {
                return b + a
            }
        }, ratio: function (a) {
            return function (b) {
                return Math.floor(b * a)
            }
        }, standard: function (a) {
            return function (b) {
                return b - a
            }
        }
    },
    parseAnchor: function (c, g, b) {
        if (c && c !== "none") {
            var d = this.anchorFactory, e;
            if (this.parseAnchorRE.test(c)) {
                return d.standard(b - g)
            }
            if (c.indexOf("%") !== -1) {
                return d.ratio(parseFloat(c.replace("%", "")) * 0.01)
            }
            e = parseInt(c, 10);
            if (!isNaN(e)) {
                return d.offset(e)
            }
        }
        return null
    },
    adjustWidthAnchor: function (b, a) {
        return b
    },
    adjustHeightAnchor: function (b, a) {
        return b
    },
    configureItem: function (g) {
        var e = this, a = e.owner, d = g.anchor, b, c, h;
        Ext.layout.container.Auto.prototype.configureItem.apply(this, arguments);
        if (!g.anchor && g.items && !Ext.isNumber(g.width)) {
            g.anchor = d = e.defaultAnchor
        }
        if (a.anchorSize) {
            if (typeof a.anchorSize === "number") {
                c = a.anchorSize
            } else {
                c = a.anchorSize.width;
                h = a.anchorSize.height
            }
        } else {
            c = a.initialConfig.width;
            h = a.initialConfig.height
        }
        if (d) {
            b = d.split(" ");
            g.anchorSpec = {
                right: e.parseAnchor(b[0], g.initialConfig.width, c),
                bottom: e.parseAnchor(b[1], g.initialConfig.height, h)
            }
        }
    },
    sizePolicy: {
        $: {readsWidth: 1, readsHeight: 1, setsWidth: 0, setsHeight: 0},
        b: {readsWidth: 1, readsHeight: 0, setsWidth: 0, setsHeight: 1},
        r: {
            $: {readsWidth: 0, readsHeight: 1, setsWidth: 1, setsHeight: 0},
            b: {readsWidth: 0, readsHeight: 0, setsWidth: 1, setsHeight: 1}
        }
    },
    getItemSizePolicy: function (c) {
        var e = c.anchorSpec, a = "$", d = this.sizePolicy, b;
        if (e) {
            b = this.owner.getSizeModel();
            if (e.right && !b.width.shrinkWrap) {
                d = d.r
            }
            if (e.bottom && !b.height.shrinkWrap) {
                a = "b"
            }
        }
        return d[a]
    }
}, 0, 0, 0, 0, ["layout.anchor"], 0, [Ext.layout.container, "Anchor", Ext.layout, "AnchorLayout"], 0));
(Ext.cmd.derive("Ext.dashboard.Panel", Ext.panel.Panel, {
    cls: "x-dashboard-panel",
    anchor: "100%",
    layout: "fit",
    frame: true,
    closable: true,
    collapsible: true,
    animCollapse: true,
    titleCollapse: true,
    stateful: true,
    draggable: {moveOnDrag: false},
    animateClose: true,
    loadMask: true,
    loadMessage: "Loading...",
    minHeight: 90,
    resizable: true,
    resizeHandles: "s",
    doClose: function () {
        var a = this;
        if (a.animateClose) {
            if (!a.closing) {
                a.closing = true;
                a.el.animate({opacity: 0, callback: a.finishClose, scope: a})
            }
        } else {
            a.finishClose()
        }
    },
    finishClose: function () {
        var b = this, a = b.closeAction;
        b.closing = false;
        b.fireEvent("close", b);
        Ext.suspendLayouts();
        b[a]();
        Ext.resumeLayouts(true);
        if (a === "hide") {
            b.el.setOpacity(1)
        }
    },
    afterRender: function () {
        Ext.panel.Panel.prototype.afterRender.call(this);
        if (this.loading) {
            this.onViewBeforeLoad()
        }
    },
    getLoadMask: function () {
        var c = this, b = c.rendered && c.loadMask, a;
        if (b && !b.isComponent) {
            a = {target: c};
            if (b === true) {
                b = a
            } else {
                Ext.apply(a, b)
            }
            c.loadMask = b = Ext.ComponentManager.create(a, "loadmask")
        }
        return b || null
    },
    onAdd: function (a) {
        Ext.panel.Panel.prototype.onAdd.apply(this, arguments);
        a.on({beforeload: "onViewBeforeLoad", load: "onViewLoaded", scope: this})
    },
    onViewBeforeLoad: function () {
        this.loading = true;
        var a = this.getLoadMask();
        if (a) {
            a.show()
        }
    },
    onViewLoaded: function () {
        this.loading = false;
        var b = this.getLoadMask();
        if (b) {
            b.hide()
        }
        var a = this.items.getAt(0);
        if (a.getTitle) {
            var c = a.getTitle();
            if (c) {
                this.setTitle(c)
            }
        }
    },
    setBox: function (a) {
        this.setSize(a.width, a.height)
    },
    getState: function () {
        var a = this, b = Ext.panel.Panel.prototype.getState.call(this) || {};
        if (!b.collapsed) {
            a.addPropertyToState(b, "height", a.rendered ? a.getHeight() : a.height || a.minHeight || 100)
        }
        return b
    }
}, 0, ["dashboard-panel"], ["component", "box", "container", "panel", "dashboard-panel"], {
    component: true,
    box: true,
    container: true,
    panel: true,
    "dashboard-panel": true
}, ["widget.dashboard-panel"], 0, [Ext.dashboard, "Panel"], 0));
(Ext.cmd.derive("Ext.dashboard.Column", Ext.container.Container, {
    layout: "anchor",
    isDashboardColumn: true,
    defaultType: "dashboard-panel",
    cls: "x-dashboard-column",
    synthetic: true,
    onRemove: function (c, g) {
        var h = this, e = h.ownerCt, d, a, j = 0, b;
        if (e && h.items.getCount() === 0) {
            d = Ext.Array.filter(e.query(">" + h.xtype + "[rowIndex=" + h.rowIndex + "]"), function (i) {
                return i !== h
            });
            a = d.length;
            if (!h.destroying && !h.destroyed) {
                e.remove(h);
                if (a === 1) {
                    d[0].columnWidth = 1
                } else {
                    for (b = 0; b < a; b++) {
                        j += d[b].columnWidth || 0
                    }
                    for (b = 0; b < a; b++) {
                        d[b].columnWidth = d[b].columnWidth / j
                    }
                }
                if (g) {
                    e.updateLayout()
                }
            }
        }
    }
}, 0, ["dashboard-column"], ["component", "box", "container", "dashboard-column"], {
    component: true,
    box: true,
    container: true,
    "dashboard-column": true
}, ["widget.dashboard-column"], 0, [Ext.dashboard, "Column"], 0));
(Ext.cmd.derive("Ext.layout.container.Column", Ext.layout.container.Auto, {
    alternateClassName: "Ext.layout.ColumnLayout",
    type: "column",
    itemCls: "x-column",
    targetCls: "x-column-layout-ct",
    clearSide: "left",
    columnWidthSizePolicy: {readsWidth: 0, readsHeight: 1, setsWidth: 1, setsHeight: 0},
    createsInnerCt: true,
    manageOverflow: true,
    setsItemSize: true,
    needsItemSize: true,
    isItemShrinkWrap: function (a) {
        return true
    },
    getItemSizePolicy: function (a, b) {
        if (a.columnWidth) {
            if (!b) {
                b = this.owner.getSizeModel()
            }
            if (!b.width.shrinkWrap) {
                return this.columnWidthSizePolicy
            }
        }
        return this.autoSizePolicy
    },
    calculateItems: function (d, a) {
        var p = this, n = p.columnCount, e = d.targetContext, o = d.childItems, l = o.length, b = 0, g = a.gotWidth, j,
            q, h, c, k, m;
        if (g === false) {
            e.domBlock(p, "width");
            j = true
        } else {
            if (g) {
                q = a.width
            } else {
                return true
            }
        }
        for (h = 0; h < l; ++h) {
            c = o[h];
            if (n) {
                if (h % n) {
                    c.setProp("clear", null)
                } else {
                    c.setProp("clear", p.clearSide)
                }
            }
            k = c.getMarginInfo().width;
            if (!c.widthModel.calculated) {
                m = c.getProp("width");
                if (typeof m !== "number") {
                    c.block(p, "width");
                    j = true
                }
                b += m + k
            }
        }
        if (!j) {
            q = (q < b) ? 0 : q - b;
            for (h = 0; h < l; ++h) {
                c = o[h];
                if (c.widthModel.calculated) {
                    k = c.marginInfo.width;
                    m = c.target.columnWidth;
                    m = Math.floor(m * q) - k;
                    m = c.setWidth(m);
                    b += m + k
                }
            }
            d.setContentWidth(b + d.paddingContext.getPaddingInfo().width)
        }
        return !j
    }
}, 0, 0, 0, 0, ["layout.column"], 0, [Ext.layout.container, "Column", Ext.layout, "ColumnLayout"], 0));
(Ext.cmd.derive("Ext.dd.DragTracker", Ext.Base, {
    active: false, trackOver: false, tolerance: 5, autoStart: false, constructor: function (a) {
        var b = this;
        Ext.apply(b, a);
        b.dragRegion = new Ext.util.Region(0, 0, 0, 0);
        if (b.el) {
            b.initEl(b.el)
        }
        b.mixins.observable.constructor.call(b);
        if (b.disabled) {
            b.disable()
        }
    }, initEl: function (b) {
        var c = this, a = c.delegate;
        c.el = b = Ext.get(b);
        if (a && a.isElement) {
            c.handle = a
        }
        c.delegate = c.handle ? undefined : c.delegate;
        if (!c.handle) {
            c.handle = b
        }
        c.handleListeners = {scope: c, delegate: c.delegate, mousedown: c.onMouseDown, dragstart: c.onDragStart};
        if (!Ext.supports.TouchEvents && (c.trackOver || c.overCls)) {
            Ext.apply(c.handleListeners, {mouseover: c.onMouseOver, mouseout: c.onMouseOut})
        }
        c.mon(c.handle, c.handleListeners);
        c.keyNav = new Ext.util.KeyNav({
            target: b,
            up: c.onResizeKeyDown,
            left: c.onResizeKeyDown,
            right: c.onResizeKeyDown,
            down: c.onResizeKeyDown,
            scope: c
        })
    }, disable: function () {
        this.disabled = true
    }, enable: function () {
        this.disabled = false
    }, destroy: function () {
        var a = this;
        a.endDrag({});
        a.el = a.handle = a.onBeforeStart = a.onStart = a.onDrag = a.onEnd = null;
        a.callParent()
    }, onMouseOver: function (k, j) {
        var g = this, h, d, c, a, b;
        if (!g.disabled) {
            if (k.within(k.target, true, true) || g.delegate) {
                h = g.handleCls;
                g.mouseIsOut = false;
                if (h) {
                    for (c = 0, a = g.handleEls.length; c < a; c++) {
                        d = g.handleEls[c];
                        b = d.delegateCls;
                        if (!b) {
                            b = d.delegateCls = [h, "-", d.region, "-over"].join("")
                        }
                        d.addCls([b, g.overCls])
                    }
                }
                g.fireEvent("mouseover", g, k, g.delegate ? k.getTarget(g.delegate, j) : g.handle)
            }
        }
    }, onMouseOut: function (g) {
        var d = this, c, b, a;
        if (d.mouseIsDown) {
            d.mouseIsOut = true
        } else {
            if (d.handleCls) {
                for (b = 0, a = d.handleEls.length; b < a; b++) {
                    c = d.handleEls[b];
                    c.removeCls([c.delegateCls, d.overCls])
                }
            }
            d.fireEvent("mouseout", d, g)
        }
    }, onMouseDown: function (c, b) {
        var a = this;
        if (a.disabled || c.dragTracked) {
            return
        }
        a.dragTarget = a.delegate ? b : a.handle.dom;
        a.startXY = a.lastXY = c.getXY();
        a.startRegion = Ext.fly(a.dragTarget).getRegion();
        if (a.fireEvent("mousedown", a, c) === false || a.fireEvent("beforedragstart", a, c) === false || a.onBeforeStart(c) === false) {
            return
        }
        a.mouseIsDown = true;
        c.dragTracked = true;
        a.el.setCapture();
        c.stopPropagation();
        if (a.preventDefault !== false) {
            c.preventDefault()
        }
        Ext.getDoc().on({
            scope: a,
            capture: true,
            mouseup: a.onMouseUp,
            mousemove: a.onMouseMove,
            selectstart: a.stopSelect
        });
        a.dragEnded = false;
        if (!a.tolerance) {
            a.triggerStart()
        } else {
            if (a.autoStart) {
                a.timer = Ext.defer(a.triggerStart, a.autoStart === true ? 1000 : a.autoStart, a, [c])
            }
        }
    }, onMouseMove: function (g, d) {
        var b = this, c = g.getXY(), a = b.startXY;
        g.stopPropagation();
        if (b.preventDefault !== false) {
            g.preventDefault()
        }
        if (b.dragEnded) {
            return
        }
        b.lastXY = c;
        if (!b.active) {
            if (Math.max(Math.abs(a[0] - c[0]), Math.abs(a[1] - c[1])) > b.tolerance) {
                b.triggerStart(g)
            } else {
                return
            }
        }
        if (b.fireEvent("mousemove", b, g) === false) {
            b.onMouseUp(g)
        } else {
            b.onDrag(g);
            b.fireEvent("drag", b, g)
        }
    }, onMouseUp: function (b) {
        var a = this;
        a.mouseIsDown = false;
        if (a.mouseIsOut) {
            a.mouseIsOut = false;
            a.onMouseOut(b)
        }
        if (a.preventDefault !== false) {
            b.preventDefault()
        }
        if (Ext.isIE && document.releaseCapture) {
            document.releaseCapture()
        }
        a.fireEvent("mouseup", a, b);
        a.endDrag(b)
    }, endDrag: function (c) {
        var b = this, a = b.active;
        Ext.getDoc().un({
            mousemove: b.onMouseMove,
            mouseup: b.onMouseUp,
            selectstart: b.stopSelect,
            capture: true,
            scope: b
        });
        b.clearStart();
        b.active = false;
        if (a) {
            b.dragEnded = true;
            b.onEnd(c);
            b.fireEvent("dragend", b, c)
        }
        b._constrainRegion = null
    }, triggerStart: function (b) {
        var a = this;
        a.clearStart();
        a.active = true;
        a.onStart(b);
        a.fireEvent("dragstart", a, b)
    }, clearStart: function () {
        var a = this.timer;
        if (a) {
            clearTimeout(a);
            this.timer = null
        }
    }, stopSelect: function (a) {
        a.stopEvent();
        return false
    }, onBeforeStart: function (a) {
    }, onStart: function (a) {
    }, onDrag: function (a) {
    }, onEnd: function (a) {
    }, getDragTarget: function () {
        return this.dragTarget
    }, getDragCt: function () {
        return this.el
    }, getConstrainRegion: function () {
        var a = this;
        if (a.constrainTo) {
            if (a.constrainTo instanceof Ext.util.Region) {
                return a.constrainTo
            }
            if (!a._constrainRegion) {
                a._constrainRegion = Ext.fly(a.constrainTo).getViewRegion()
            }
        } else {
            if (!a._constrainRegion) {
                a._constrainRegion = a.getDragCt().getViewRegion()
            }
        }
        return a._constrainRegion
    }, getXY: function (a) {
        return a ? this.constrainModes[a](this, this.lastXY) : this.lastXY
    }, getOffset: function (c) {
        var b = this.getXY(c), a = this.startXY;
        return [b[0] - a[0], b[1] - a[1]]
    }, onDragStart: function (a) {
        a.stopPropagation()
    }, constrainModes: {
        point: function (b, d) {
            var c = b.dragRegion, a = b.getConstrainRegion();
            if (!a) {
                return d
            }
            c.x = c.left = c[0] = c.right = d[0];
            c.y = c.top = c[1] = c.bottom = d[1];
            c.constrainTo(a);
            return [c.left, c.top]
        }, dragTarget: function (c, g) {
            var b = c.startXY, e = c.startRegion.copy(), a = c.getConstrainRegion(), d;
            if (!a) {
                return g
            }
            e.translateBy(g[0] - b[0], g[1] - b[1]);
            if (e.right > a.right) {
                g[0] += d = (a.right - e.right);
                e.left += d
            }
            if (e.left < a.left) {
                g[0] += (a.left - e.left)
            }
            if (e.bottom > a.bottom) {
                g[1] += d = (a.bottom - e.bottom);
                e.top += d
            }
            if (e.top < a.top) {
                g[1] += (a.top - e.top)
            }
            return g
        }
    }
}, 1, 0, 0, 0, 0, [["observable", Ext.util.Observable]], [Ext.dd, "DragTracker"], 0));
(Ext.cmd.derive("Ext.resizer.SplitterTracker", Ext.dd.DragTracker, {
    enabled: true, overlayCls: "x-resizable-overlay", createDragOverlay: function () {
        var a, b = Ext.dom.Element;
        a = this.overlay = Ext.getBody().createChild({role: "presentation", cls: this.overlayCls, html: "&#160;"});
        a.unselectable();
        a.setSize(b.getDocumentWidth(), b.getDocumentHeight());
        a.show()
    }, getPrevCmp: function () {
        var a = this.getSplitter();
        return a.previousSibling(":not([hidden])")
    }, getNextCmp: function () {
        var a = this.getSplitter();
        return a.nextSibling(":not([hidden])")
    }, onBeforeStart: function (i) {
        var d = this, g = d.getPrevCmp(), a = d.getNextCmp(), c = d.getSplitter().collapseEl, h = i.getTarget(), b;
        if (!g || !a) {
            return false
        }
        if (c && h === c.dom) {
            return false
        }
        if (a.collapsed || g.collapsed) {
            return false
        }
        d.prevBox = g.getEl().getBox();
        d.nextBox = a.getEl().getBox();
        d.constrainTo = b = d.calculateConstrainRegion();
        if (!b) {
            return false
        }
        return b
    }, onStart: function (b) {
        var a = this.getSplitter();
        this.createDragOverlay();
        a.addCls(a.baseCls + "-active")
    }, onResizeKeyDown: function (g) {
        var b = this, d = b.getSplitter(), a = g.getKey(), c = d.orientation === "vertical" ? 0 : 1,
            i = a === g.UP || a === g.LEFT ? -1 : 1, h;
        if (!b.active && b.onBeforeStart(g)) {
            Ext.fly(g.target).on("keyup", b.onResizeKeyUp, b);
            b.triggerStart(g);
            b.onMouseDown(g);
            b.startXY = d.getXY();
            b.lastKeyDownXY = Ext.Array.slice(b.startXY);
            h = b.easing = new Ext.fx.easing.Linear();
            h.setStartTime(Ext.Date.now());
            h.setStartValue(1);
            h.setEndValue(4);
            h.setDuration(2000)
        }
        if (b.active) {
            b.lastKeyDownXY[c] = Math.round(b.lastKeyDownXY[c] + (i * b.easing.getValue()));
            b.lastXY = b.lastKeyDownXY;
            d.setXY(b.getXY("dragTarget"))
        }
    }, onResizeKeyUp: function (a) {
        this.onMouseUp(a)
    }, calculateConstrainRegion: function () {
        var h = this, a = h.getSplitter(), i = a.getWidth(), j = a.defaultSplitMin, b = a.orientation, e = h.prevBox,
            k = h.getPrevCmp(), c = h.nextBox, g = h.getNextCmp(), m, l, d;
        if (b === "vertical") {
            d = {prevCmp: k, nextCmp: g, prevBox: e, nextBox: c, defaultMin: j, splitWidth: i};
            m = new Ext.util.Region(e.y, h.getVertPrevConstrainRight(d), e.bottom, h.getVertPrevConstrainLeft(d));
            l = new Ext.util.Region(c.y, h.getVertNextConstrainRight(d), c.bottom, h.getVertNextConstrainLeft(d))
        } else {
            m = new Ext.util.Region(e.y + (k.minHeight || j), e.right, (k.maxHeight ? e.y + k.maxHeight : c.bottom - (g.minHeight || j)) + i, e.x);
            l = new Ext.util.Region((g.maxHeight ? c.bottom - g.maxHeight : e.y + (k.minHeight || j)) - i, c.right, c.bottom - (g.minHeight || j), c.x)
        }
        return m.intersect(l)
    }, performResize: function (n, h) {
        var p = this, a = p.getSplitter(), j = a.orientation, q = p.getPrevCmp(), o = p.getNextCmp(), b = a.ownerCt,
            l = b.query(">[flex]"), m = l.length, c = j === "vertical", k = 0, g = c ? "width" : "height", d = 0, r, s;
        for (; k < m; k++) {
            r = l[k];
            s = c ? r.getWidth() : r.getHeight();
            d += s;
            r.flex = s
        }
        h = c ? h[0] : h[1];
        if (q) {
            s = p.prevBox[g] + h;
            if (q.flex) {
                q.flex = s
            } else {
                q[g] = s
            }
        }
        if (o) {
            s = p.nextBox[g] - h;
            if (o.flex) {
                o.flex = s
            } else {
                o[g] = s
            }
        }
        b.updateLayout()
    }, endDrag: function () {
        var a = this;
        if (a.overlay) {
            a.overlay.destroy();
            delete a.overlay
        }
        Ext.dd.DragTracker.prototype.endDrag.apply(this, arguments)
    }, onEnd: function (c) {
        var a = this, b = a.getSplitter();
        b.removeCls(b.baseCls + "-active");
        a.performResize(c, a.getResizeOffset())
    }, onDrag: function (g) {
        var c = this, h = c.getOffset("dragTarget"), d = c.getSplitter(), b = d.getEl(), a = d.orientation;
        if (a === "vertical") {
            b.setX(c.startRegion.left + h[0])
        } else {
            b.setY(c.startRegion.top + h[1])
        }
    }, getSplitter: function () {
        return this.splitter
    }, getVertPrevConstrainRight: function (a) {
        return (a.prevCmp.maxWidth ? a.prevBox.x + a.prevCmp.maxWidth : a.nextBox.right - (a.nextCmp.minWidth || a.defaultMin)) + a.splitWidth
    }, getVertPrevConstrainLeft: function (a) {
        return a.prevBox.x + (a.prevCmp.minWidth || a.defaultMin)
    }, getVertNextConstrainRight: function (a) {
        return a.nextBox.right - (a.nextCmp.minWidth || a.defaultMin)
    }, getVertNextConstrainLeft: function (a) {
        return (a.nextCmp.maxWidth ? a.nextBox.right - a.nextCmp.maxWidth : a.prevBox.x + (a.prevBox.minWidth || a.defaultMin)) - a.splitWidth
    }, getResizeOffset: function () {
        return this.getOffset("dragTarget")
    }
}, 0, 0, 0, 0, 0, 0, [Ext.resizer, "SplitterTracker"], 0));
(Ext.cmd.derive("Ext.layout.container.ColumnSplitterTracker", Ext.resizer.SplitterTracker, {
    onStart: function (a) {
        Ext.apply(this.getSplitter().el.dom.style, {top: 0, left: 0});
        Ext.resizer.SplitterTracker.prototype.onStart.apply(this, arguments)
    }, endDrag: function () {
        var a = this;
        Ext.resizer.SplitterTracker.prototype.endDrag.apply(this, arguments);
        a.getSplitter().el.dom.style.left = 0
    }, performResize: function (g, d) {
        var j = this, m = j.getPrevCmp(), i = j.getNextCmp(), b = j.getSplitter(), c = b.ownerCt, l = d[0], k, a, h;
        if (m && i) {
            m.width = k = j.prevBox.width + l;
            i.width = a = j.nextBox.width - l;
            h = (m.columnWidth + i.columnWidth) / (k + a);
            m.columnWidth = k * h;
            i.columnWidth = a * h
        }
        c.updateLayout()
    }
}, 0, 0, 0, 0, 0, 0, [Ext.layout.container, "ColumnSplitterTracker"], 0));
(Ext.cmd.derive("Ext.layout.container.ColumnSplitter", Ext.resizer.Splitter, {
    isSplitter: true,
    synthetic: true,
    cls: "x-splitter-vertical",
    orientation: "vertical",
    collapseDirection: "left",
    trackerClass: "Ext.layout.container.ColumnSplitterTracker",
    width: 7,
    height: 1,
    getTrackerConfig: function () {
        var a = Ext.resizer.Splitter.prototype.getTrackerConfig.call(this);
        a.xclass = this.trackerClass;
        return a
    }
}, 0, ["columnsplitter"], ["component", "box", "splitter", "columnsplitter"], {
    component: true,
    box: true,
    splitter: true,
    columnsplitter: true
}, ["widget.columnsplitter"], 0, [Ext.layout.container, "ColumnSplitter"], 0));
(Ext.cmd.derive("Ext.layout.container.Dashboard", Ext.layout.container.Column, {
    type: "dashboard",
    firstColumnCls: "x-dashboard-column-first",
    lastColumnCls: "x-dashboard-column-last",
    getSplitterConfig: function () {
        return {xtype: "columnsplitter"}
    },
    getColumns: function (a) {
        var b = Ext.Array;
        return b.filter(b.from(a), function (c) {
            return c.target && c.target.isSplitter !== true
        })
    },
    beginLayout: function (e) {
        var n = this;
        Ext.layout.container.Column.prototype.beginLayout.call(this, e);
        var k = e.childItems, q = (e.rows = []), d = k.length, l = 2, h = 0, r = 0, p = n.owner.getMaxColumns(), c, j,
            g, o, a, m, b;
        for (j = 0; j < d; ++j) {
            m = (c = k[j]).target;
            a = m && m.isSplitter;
            h += (a ? 0 : 1);
            b = a ? 0 : m.columnWidth || 1;
            if (l + b > 1 || (p && (h > p))) {
                if (g) {
                    g.orphan = 1;
                    g.el.setHeight(0)
                }
                l = 0;
                h = 1;
                if (q.length) {
                    r = q.length - 1;
                    n.syncFirstLast(n.getColumns(q[r].items))
                }
                q.push(o = {index: q.length, items: [], maxHeight: 0})
            }
            l += b;
            o.items.push(c);
            c.row = o;
            m.rowIndex = o.index;
            if (a) {
                c.el.setHeight(1)
            }
            g = c
        }
        if (q.length) {
            n.syncFirstLast(n.getColumns(q[q.length - 1].items))
        }
    },
    beforeLayoutCycle: function (c) {
        var b = this, a = b.owner.items;
        if (b.splitterGen !== a.generation) {
            b.syncSplitters();
            b.splitterGen = a.generation
        }
        Ext.layout.container.Column.prototype.beforeLayoutCycle.apply(this, arguments)
    },
    finishedLayout: function (e) {
        var b = e.childItems, a = b.length, d, j, c, g, h;
        Ext.layout.container.Column.prototype.finishedLayout.call(this, e);
        for (c = 0; c < a; c += 2) {
            g = (j = b[c]).target;
            d = g.lastBox;
            h = j.row;
            h.maxHeight = Math.max(h.maxHeight, d.height);
            g.width = d.width
        }
        for (c = 1; c < a; c += 2) {
            g = (j = b[c]).target;
            if (!j.orphan) {
                g.el.setHeight(j.row.maxHeight)
            }
        }
    },
    syncSplitters: function () {
        var h = this, a = h.owner, b = a.items.items, c = b.length, e = true, d = false, g, i;
        while (c-- > 0) {
            g = b[c];
            if (d) {
                if (g.isSplitter) {
                    d = false
                } else {
                    if (e) {
                        e = false;
                        a.suspendLayouts()
                    }
                    i = a.add(c + 1, h.getSplitterConfig())
                }
            } else {
                if (g.isSplitter) {
                    if (e) {
                        e = false;
                        a.suspendLayouts()
                    }
                    a.remove(g)
                } else {
                    d = true
                }
            }
        }
        while (b.length && (g = b[0]).isSplitter) {
            if (e) {
                e = false;
                a.suspendLayouts()
            }
            a.remove(g)
        }
        if (!e) {
            a.resumeLayouts()
        }
    },
    syncFirstLast: function (e) {
        var g = this, b = g.firstColumnCls, j = g.lastColumnCls, d, a = [b, j], c, k, h;
        e = Ext.Array.from(e);
        d = e.length;
        for (c = 0; c < d; ++c) {
            k = e[c].target;
            h = (c === d - 1);
            if (!c) {
                if (h) {
                    k.addCls(a)
                } else {
                    k.addCls(b);
                    k.removeCls(j)
                }
            } else {
                if (h) {
                    k.addCls(j);
                    k.removeCls(b)
                } else {
                    k.removeCls(a)
                }
            }
        }
    }
}, 0, 0, 0, 0, ["layout.dashboard"], 0, [Ext.layout.container, "Dashboard"], 0));
(Ext.cmd.derive("Ext.dd.DDTarget", Ext.dd.DragDrop, {
    constructor: function (c, a, b) {
        if (c) {
            this.initTarget(c, a, b)
        }
    },
    getDragEl: Ext.emptyFn,
    isValidHandleChild: Ext.emptyFn,
    startDrag: Ext.emptyFn,
    endDrag: Ext.emptyFn,
    onDrag: Ext.emptyFn,
    onDragDrop: Ext.emptyFn,
    onDragEnter: Ext.emptyFn,
    onDragOut: Ext.emptyFn,
    onDragOver: Ext.emptyFn,
    onInvalidDrop: Ext.emptyFn,
    onMouseDown: Ext.emptyFn,
    onMouseUp: Ext.emptyFn,
    setXConstraint: Ext.emptyFn,
    setYConstraint: Ext.emptyFn,
    resetConstraints: Ext.emptyFn,
    clearConstraints: Ext.emptyFn,
    clearTicks: Ext.emptyFn,
    setInitPosition: Ext.emptyFn,
    setDragElId: Ext.emptyFn,
    setHandleElId: Ext.emptyFn,
    setOuterHandleElId: Ext.emptyFn,
    addInvalidHandleClass: Ext.emptyFn,
    addInvalidHandleId: Ext.emptyFn,
    addInvalidHandleType: Ext.emptyFn,
    removeInvalidHandleClass: Ext.emptyFn,
    removeInvalidHandleId: Ext.emptyFn,
    removeInvalidHandleType: Ext.emptyFn,
    toString: function () {
        return ("DDTarget " + this.id)
    }
}, 3, 0, 0, 0, 0, 0, [Ext.dd, "DDTarget"], 0));
(Ext.cmd.derive("Ext.dd.ScrollManager", Ext.Base, {
    singleton: true,
    dirTrans: {up: -1, left: -1, down: 1, right: 1},
    constructor: function () {
        var a = Ext.dd.DragDropManager;
        a.fireEvents = Ext.Function.createSequence(a.fireEvents, this.onFire, this);
        a.stopDrag = Ext.Function.createSequence(a.stopDrag, this.onStop, this);
        this.doScroll = this.doScroll.bind(this);
        this.ddmInstance = a;
        this.els = {};
        this.dragEl = null;
        this.proc = {}
    },
    onStop: function (a) {
        var b = Ext.dd.ScrollManager;
        b.dragEl = null;
        b.clearProc()
    },
    triggerRefresh: function () {
        if (this.ddmInstance.dragCurrent) {
            this.ddmInstance.refreshCache(this.ddmInstance.dragCurrent.groups)
        }
    },
    doScroll: function () {
        var g = this;
        if (g.ddmInstance.dragCurrent) {
            var a = g.proc, e = a.el, c = a.component, h = a.el.ddScrollConfig,
                i = h && h.increment ? h.increment : g.increment, b = h && "animate" in h ? h.animate : g.animate,
                d = function () {
                    g.triggerRefresh()
                };
            if (b) {
                if (b === true) {
                    b = {callback: d}
                } else {
                    b.callback = b.callback ? Ext.Function.createSequence(b.callback, d) : d
                }
            }
            if (c) {
                i = i * g.dirTrans[a.dir];
                if (a.dir === "up" || a.dir === "down") {
                    c.scrollBy(0, i, b)
                } else {
                    c.scrollBy(i, 0, b)
                }
            } else {
                e.scroll(a.dir, i, b)
            }
            if (!b) {
                d()
            }
        }
    },
    clearProc: function () {
        var a = this.proc;
        if (a.id) {
            clearInterval(a.id)
        }
        a.id = 0;
        a.el = null;
        a.dir = ""
    },
    startProc: function (c, b) {
        var d = this, a = d.proc, g, e;
        d.clearProc();
        a.el = c;
        a.dir = b;
        g = c.ddScrollConfig ? c.ddScrollConfig.ddGroup : undefined;
        e = (c.ddScrollConfig && c.ddScrollConfig.frequency) ? c.ddScrollConfig.frequency : d.frequency;
        if (g === undefined || d.ddmInstance.dragCurrent.ddGroup === g) {
            a.id = Ext.interval(d.doScroll, e)
        }
    },
    onFire: function (h, k) {
        var j = this, l, i, d, a, b, g, c;
        if (k || !j.ddmInstance.dragCurrent) {
            return
        }
        if (!j.dragEl || j.dragEl !== j.ddmInstance.dragCurrent) {
            j.dragEl = j.ddmInstance.dragCurrent;
            j.refreshCache()
        }
        l = h.getPoint();
        i = j.proc;
        d = j.els;
        for (a in d) {
            b = d[a];
            g = b._region;
            c = b.ddScrollConfig || j;
            if (g && g.contains(l) && b.isScrollable()) {
                if (g.bottom - l.y <= c.vthresh) {
                    if (i.el !== b) {
                        j.startProc(b, "down")
                    }
                    return
                } else {
                    if (g.right - l.x <= c.hthresh) {
                        if (i.el !== b) {
                            j.startProc(b, "right")
                        }
                        return
                    } else {
                        if (l.y - g.top <= c.vthresh) {
                            if (i.el !== b) {
                                j.startProc(b, "up")
                            }
                            return
                        } else {
                            if (l.x - g.left <= c.hthresh) {
                                if (i.el !== b) {
                                    j.startProc(b, "left")
                                }
                                return
                            }
                        }
                    }
                }
            }
        }
        j.clearProc()
    },
    register: function (c) {
        if (Ext.isArray(c)) {
            for (var b = 0, a = c.length; b < a; b++) {
                this.register(c[b])
            }
        } else {
            c = Ext.get(c);
            this.els[c.id] = c
        }
    },
    unregister: function (c) {
        if (Ext.isArray(c)) {
            for (var b = 0, a = c.length; b < a; b++) {
                this.unregister(c[b])
            }
        } else {
            c = Ext.get(c);
            delete this.els[c.id]
        }
    },
    vthresh: 25 * (window.devicePixelRatio || 1),
    hthresh: 25 * (window.devicePixelRatio || 1),
    increment: 100,
    frequency: 500,
    animate: true,
    animDuration: 0.4,
    ddGroup: undefined,
    refreshCache: function () {
        var a = this.els, b;
        for (b in a) {
            if (typeof a[b] === "object") {
                a[b]._region = a[b].getRegion()
            }
        }
    }
}, 1, 0, 0, 0, 0, 0, [Ext.dd, "ScrollManager"], 0));
(Ext.cmd.derive("Ext.dd.DropTarget", Ext.dd.DDTarget, {
    constructor: function (b, a) {
        this.el = Ext.get(b);
        Ext.apply(this, a);
        if (this.containerScroll) {
            Ext.dd.ScrollManager.register(this.el)
        }
        Ext.dd.DDTarget.prototype.constructor.call(this, this.el.dom, this.ddGroup || this.group, {isTarget: true})
    },
    containerScroll: false,
    dropAllowed: "x-dd-drop-ok",
    dropNotAllowed: "x-dd-drop-nodrop",
    isTarget: true,
    isNotifyTarget: true,
    notifyEnter: function (a, c, b) {
        if (this.overClass) {
            this.el.addCls(this.overClass)
        }
        return this.dropAllowed
    },
    notifyOver: function (a, c, b) {
        return this.dropAllowed
    },
    notifyOut: function (a, c, b) {
        if (this.overClass) {
            this.el.removeCls(this.overClass)
        }
    },
    notifyDrop: function (a, c, b) {
        if (this.overClass) {
            this.el.removeCls(this.overClass)
        }
        return false
    },
    destroy: function () {
        Ext.dd.DDTarget.prototype.destroy.call(this);
        if (this.containerScroll) {
            Ext.dd.ScrollManager.unregister(this.el)
        }
    }
}, 1, 0, 0, 0, 0, 0, [Ext.dd, "DropTarget"], 0));
(Ext.cmd.derive("Ext.dashboard.DropZone", Ext.dd.DropTarget, {
    ddScrollConfig: {vthresh: 75, hthresh: -1, animate: true, increment: 200},
    containerScroll: true,
    overClass: "x-dashboard-dd-over",
    constructor: function (b, a) {
        this.dashboard = b;
        b.body.ddScrollConfig = this.ddScrollConfig;
        Ext.dd.DropTarget.prototype.constructor.call(this, b.body, a)
    },
    getOverEvent: function (A, v, C) {
        var p = this.dashboard, b = p.body, o = p.items.items, c = b.getBox(), g = o.length, d = v.getXY(),
            l = d[0] - c.x + b.getScrollLeft(), j = d[1] - c.y + b.getScrollTop(), r = {
                columnIndex: 0,
                column: null,
                dashboard: p,
                above: null,
                extensible: false,
                beforeAfter: 0,
                data: C,
                panel: C.panel,
                rawEvent: v,
                source: A,
                status: this.dropAllowed
            }, n, B, s, q, z, m, u, a, h;
        for (s = 0; s < g; s += 2) {
            z = o[s];
            m = z.lastBox.width;
            if (o[s + 1]) {
                m += o[s + 1].lastBox.width
            }
            if (v.within(z.el)) {
                r.columnIndex = s;
                r.column = z;
                r.extensible = this.isRowExtensible(z.rowIndex);
                n = Math.min(80, m * 0.2);
                r.beforeAfter = n = (r.extensible && ((l < n) ? -1 : ((l > m - n) ? 1 : 0)));
                if (!n || !r.extensible) {
                    a = z.items.items;
                    for (q = 0, u = a.length; q < u; ++q) {
                        h = a[q];
                        B = h.el.getHeight();
                        if (j < B / 2) {
                            r.above = h;
                            break
                        }
                        j -= B
                    }
                }
                break
            }
            l -= m
        }
        return r
    },
    notifyOver: function (p, i, h) {
        var m = this, n = m.dashboard, j = m.getOverEvent(p, i, h), c = j.column && j.column.el, l = p.proxy, b,
            d = j.above, g, a = 0, o, k = n.hasListeners;
        h.lastOver = j;
        if ((!k.validatedrop || n.fireEvent("validatedrop", j) !== false) && (!k.beforedragover || n.fireEvent("beforedragover", j) !== false)) {
            b = p.panelProxy.getProxy();
            l.getProxy().setWidth("auto");
            if (c) {
                a = g = c.getWidth();
                if (j.beforeAfter) {
                    p.panelProxy.moveProxy(c.dom, c.dom.firstChild);
                    a = g / 2;
                    b.setWidth(a)
                } else {
                    if (d) {
                        p.panelProxy.moveProxy(d.el.dom.parentNode, d.el.dom)
                    } else {
                        p.panelProxy.moveProxy(c.dom, null)
                    }
                    b.setWidth("auto")
                }
                if (a) {
                }
                b.setStyle({
                    "float": "none",
                    clear: "none",
                    "margin-left": (j.beforeAfter > 0) ? (g - a - c.getPadding("lr")) + "px" : "",
                    "margin-top": "7px"
                })
            } else {
                o = n.body.getPadding("lr");
                b.setStyle({"float": "left", clear: "left", margin: "0 7px 0 7px"});
                b.setWidth(n.body.getWidth() - o);
                p.panelProxy.moveProxy(n.body.dom.firstChild.firstChild, null)
            }
            this.scrollPos = n.body.getScroll();
            if (k.dragover) {
                n.fireEvent("dragover", j)
            }
        }
        return j.status
    },
    isRowExtensible: function (d) {
        var c = this, b = c.dashboard, a = b.getMaxColumns() || 1;
        return Ext.Array.from(b.query(">dashboard-column[rowIndex=" + d + "]")).length < a
    },
    notifyDrop: function (p, h, c) {
        Ext.dd.DropTarget.prototype.notifyDrop.apply(this, arguments);
        var l = this.dashboard, i = c.lastOver, a = i.panel, m = a.ownerCt, d = i.column, k = d ? i.beforeAfter : 1,
            g = m.items.indexOf(a), o = d ? (i.above ? d.items.indexOf(i.above) : d.items.getCount()) : 0, n, b,
            j = l.hasListeners;
        if (m === d) {
            if (m.items.getCount() === 1) {
                return
            }
            if (!k) {
                if (g < o) {
                    --o
                }
                if (g === o) {
                    return
                }
            }
        }
        if ((j.validatedrop && l.fireEvent("validatedrop", i) === false) || (j.beforedrop && l.fireEvent("beforedrop", i) === false)) {
            return
        }
        Ext.suspendLayouts();
        a.isMoving = true;
        if (k) {
            n = l.items.indexOf(d);
            if (n < 0) {
                n = l.items.getCount()
            } else {
                if (k > 0) {
                    ++n
                }
            }
            b = l.createColumn();
            if (d) {
                b.columnWidth = d.columnWidth = d.columnWidth / 2;
                delete d.width
            } else {
                b.columnWidth = 1
            }
            d = l.insert(n, b);
            o = 0
        }
        a.el.dom.style.display = "";
        d.insert(o, a);
        a.isMoving = false;
        d.updateLayout();
        Ext.resumeLayouts(true);
        if (j.drop) {
            l.fireEvent("drop", i)
        }
    }
}, 1, 0, 0, 0, 0, 0, [Ext.dashboard, "DropZone"], 0));
(Ext.cmd.derive("Ext.dashboard.Part", Ext.Base, {
    factoryConfig: {type: "part"},
    isPart: true,
    _lastId: 0,
    config: {
        id: null,
        dashboard: null,
        viewTemplate: {
            collapsed: "{collapsed}",
            columnIndex: "{columnIndex}",
            id: "{id}",
            title: "{title}",
            height: "{height}"
        }
    },
    viewTemplateOptions: {excludeProperties: {bind: 1}},
    valueRe: /^[{][a-z]*[}]$/i,
    constructor: function (a) {
        this.initConfig(a)
    },
    applyViewTemplate: function (a) {
        return Ext.util.ObjectTemplate.create(a, this.viewTemplateOptions)
    },
    displayForm: function (a, b, d, c) {
        d.call(c || this, {})
    },
    createView: function (b) {
        var d = this, c = d.getViewTemplate(), a = c.apply(b);
        a.dashboard = d.getDashboard();
        a.part = d;
        a._partConfig = b;
        return a
    }
}, 1, 0, 0, 0, ["part.part"], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable], [Ext.mixin.Identifiable.prototype.mixinId || Ext.mixin.Identifiable.$className, Ext.mixin.Identifiable]], [Ext.dashboard, "Part"], 0));
(Ext.cmd.derive("Ext.dashboard.Dashboard", Ext.panel.Panel, {
    isDashboard: true,
    cls: "x-dashboard",
    bodyCls: "x-dashboard-body",
    defaultType: "dashboard-column",
    scrollable: true,
    layout: null,
    stateful: false,
    idSeed: 1,
    config: {parts: null},
    renderConfig: {maxColumns: 4},
    initComponent: function () {
        var a = this;
        if (!a.layout) {
            a.layout = {type: "dashboard"}
        }
        Ext.panel.Panel.prototype.initComponent.call(this)
    },
    applyParts: function (b, c) {
        if (!c) {
            c = new Ext.util.Collection({decoder: Ext.Factory.part})
        }
        var d, a;
        for (d in b) {
            a = b[d];
            if (Ext.isString(a)) {
                a = {type: a}
            }
            a.id = d;
            a.dashboard = this;
            c.add(a)
        }
        return c
    },
    getPart: function (a) {
        var b = this.getParts();
        return b.getByKey(a)
    },
    addNew: function (c, b, e) {
        var d = this, a = d.getPart(c);
        a.displayForm(null, null, function (g) {
            g.type = c;
            d.addView(g, b, e)
        })
    },
    addView: function (k, e, i) {
        var h = this, g = h.query("dashboard-column"), c = g.length, d = e || 0, j = k.id ? k : h.createView(k),
            a = h.columnWidths, b;
        if (!c) {
            b = h.add(0, h.createColumn({columnWidth: (Ext.isArray(a) ? a[0] : 1)}));
            g = [b];
            c = 1
        }
        if (d >= c) {
            d = c - 1;
            i = 1
        }
        if (!i) {
            b = g[d];
            if (b) {
                return b.add(j)
            }
        }
        if (i > 0) {
            ++d
        }
        b = h.createColumn();
        if (a) {
            b.columnWidth = a[d] || (a[d] = 1)
        }
        if (!b.items) {
            b.items = []
        }
        b.items.push(j);
        b = h.add(b);
        return b.items.first()
    },
    createColumn: function (a) {
        var b = this.cycleLayout;
        return Ext.apply({
            items: [],
            bubbleEvents: ["add", "remove", "childmove", "resize"],
            listeners: {remove: this.onRemoveItem, expand: b, collapse: b, scope: this}
        }, a)
    },
    createView: function (c) {
        var e = this, d = c.type, b = e.getPart(d), a = b.createView(c);
        if (!a.id) {
            a.id = e.id + "_" + d + (e.idSeed++)
        }
        a.bubbleEvents = Ext.Array.from(a.bubbleEvents).concat(["expand", "collapse"]);
        a.stateful = e.stateful;
        return a
    },
    initEvents: function () {
        Ext.panel.Panel.prototype.initEvents.call(this);
        this.dd = new Ext.dashboard.DropZone(this, this.dropConfig)
    },
    cycleLayout: function () {
        this.updateLayout()
    },
    beforeDestroy: function () {
        if (this.dd) {
            Ext.destroy(this.dd)
        }
        Ext.panel.Panel.prototype.beforeDestroy.call(this)
    },
    applyState: function (g) {
        delete g.items;
        var e = this;
        Ext.panel.Panel.prototype.applyState.call(this, g);
        var b = g.columnWidths, a = e.items.items, d = a.length, c, h;
        if (b) {
            h = b.length;
            e.columnWidths = [];
            for (c = 0; c < d; ++c) {
                e.columnWidths.push(a[c].columnWidth = (c < h) ? b[c] : (1 / d))
            }
        }
    },
    getState: function () {
        var g = this, b = [], a = g.items.items, h = Ext.panel.Panel.prototype.getState.call(this) || {}, e = a.length,
            c, d;
        for (c = 0; c < e; ++c) {
            if (!(d = a[c]).isSplitter) {
                b.push(d.columnWidth)
            }
        }
        h.columnWidths = b;
        h.idSeed = g.idSeed;
        h.items = g.serializeItems();
        g.columnWidths = b;
        return h
    },
    initItems: function () {
        var b = this, a = b.defaultContent, c;
        if (b.stateful) {
            c = Ext.state.Manager.get(b.getStateId());
            a = (c && c.items) || a
        }
        if (!b.items && a) {
            b.items = b.deserializeItems(a)
        }
        Ext.panel.Panel.prototype.initItems.call(this)
    },
    deserializeItems: function (g) {
        var k = this, c = g.length, e = [], a = k.columnWidths, n = k.getMaxColumns(), d, j, b, h, m, l;
        for (h = 0; h < c; ++h) {
            l = g[h];
            j = Math.min(l.columnIndex || 0, n - 1);
            delete l.columnIndex;
            if (!(d = e[j])) {
                e[j] = d = k.createColumn();
                b = a && a[j];
                if (b) {
                    d.columnWidth = b
                }
            }
            m = k.createView(l);
            d.items.push(m)
        }
        for (h = 0, c = e.length; h < c; ++h) {
            d = e[h];
            if (!d.columnWidth) {
                d.columnWidth = 1 / c
            }
        }
        return e
    },
    serializeItem: function (a) {
        return Ext.apply({type: a.part.id, id: a.id, columnIndex: a.columnIndex}, a._partConfig)
    },
    serializeItems: function () {
        var n = this, m = n.items.items, b = m.length, l = [], h = 0, a, g, e, o, d, c;
        for (e = 0; e < b; ++e) {
            o = m[e];
            if (!o.isSplitter) {
                g = o.items.items;
                for (d = 0, c = g.length; d < c; ++d) {
                    a = g[d];
                    a.columnIndex = h;
                    l.push(n.serializeItem(a))
                }
                ++h
            }
        }
        return l
    },
    onRemoveItem: function (a, b) {
        if (b.stateful && !b.isMoving) {
            Ext.state.Manager.clear(b.getStateId())
        }
    }
}, 0, ["dashboard"], ["component", "box", "container", "panel", "dashboard"], {
    component: true,
    box: true,
    container: true,
    panel: true,
    dashboard: true
}, ["widget.dashboard"], 0, [Ext.dashboard, "Dashboard"], 0));
(Ext.cmd.derive("Ext.dd.DragZone", Ext.dd.DragSource, {
    constructor: function (c, b) {
        var d = this, a = d.containerScroll;
        Ext.dd.DragSource.prototype.constructor.call(this, c, b);
        if (a) {
            c = d.scrollEl || c;
            c = Ext.get(c);
            if (Ext.isObject(a)) {
                c.ddScrollConfig = a
            }
            Ext.dd.ScrollManager.register(c)
        }
    }, getDragData: function (a) {
        return Ext.dd.Registry.getHandleFromEvent(a)
    }, onInitDrag: function (a, b) {
        this.proxy.update(this.dragData.ddel.cloneNode(true));
        this.onStartDrag(a, b);
        return true
    }, getRepairXY: function (a) {
        return Ext.fly(this.dragData.ddel).getXY()
    }, destroy: function () {
        Ext.dd.DragSource.prototype.destroy.call(this);
        if (this.containerScroll) {
            Ext.dd.ScrollManager.unregister(this.scrollEl || this.el)
        }
    }
}, 1, 0, 0, 0, 0, 0, [Ext.dd, "DragZone"], 0));
(Ext.cmd.derive("Ext.dd.Registry", Ext.Base, {
    singleton: true, constructor: function () {
        this.elements = {};
        this.handles = {};
        this.autoIdSeed = 0
    }, getId: function (b, a) {
        if (typeof b === "string") {
            return b
        }
        var c = b.id;
        if (!c && a !== false) {
            c = "extdd-" + (++this.autoIdSeed);
            b.id = c
        }
        return c
    }, register: function (d, e) {
        e = e || {};
        if (typeof d === "string") {
            d = document.getElementById(d)
        }
        e.ddel = d;
        this.elements[this.getId(d)] = e;
        if (e.isHandle !== false) {
            this.handles[e.ddel.id] = e
        }
        if (e.handles) {
            var c = e.handles, b, a;
            for (b = 0, a = c.length; b < a; b++) {
                this.handles[this.getId(c[b])] = e
            }
        }
    }, unregister: function (d) {
        var g = this.getId(d, false), e = this.elements[g], c, b, a;
        if (e) {
            delete this.elements[g];
            if (e.handles) {
                c = e.handles;
                for (b = 0, a = c.length; b < a; b++) {
                    delete this.handles[this.getId(c[b], false)]
                }
            }
        }
    }, getHandle: function (a) {
        if (typeof a !== "string") {
            a = a.id
        }
        return this.handles[a]
    }, getHandleFromEvent: function (b) {
        var a = b.getTarget();
        return a ? this.handles[a.id] : null
    }, getTarget: function (a) {
        if (typeof a !== "string") {
            a = a.id
        }
        return this.elements[a]
    }, getTargetFromEvent: function (b) {
        var a = b.getTarget();
        return a ? this.elements[a.id] || this.handles[a.id] : null
    }
}, 1, 0, 0, 0, 0, 0, [Ext.dd, "Registry"], 0));
(Ext.cmd.derive("Ext.dd.DropZone", Ext.dd.DropTarget, {
    getTargetFromEvent: function (a) {
        return Ext.dd.Registry.getTargetFromEvent(a)
    }, onNodeEnter: function (d, a, c, b) {
    }, onNodeOver: function (d, a, c, b) {
        return this.dropAllowed
    }, onNodeOut: function (d, a, c, b) {
    }, onNodeDrop: function (d, a, c, b) {
        return false
    }, onContainerOver: function (a, c, b) {
        return this.dropNotAllowed
    }, onContainerDrop: function (a, c, b) {
        return false
    }, notifyEnter: function (a, c, b) {
        return this.dropNotAllowed
    }, notifyOver: function (a, d, c) {
        var b = this, g = b.getTargetFromEvent(d);
        if (!g) {
            if (b.lastOverNode) {
                b.onNodeOut(b.lastOverNode, a, d, c);
                b.lastOverNode = null
            }
            return b.onContainerOver(a, d, c)
        }
        if (b.lastOverNode !== g) {
            if (b.lastOverNode) {
                b.onNodeOut(b.lastOverNode, a, d, c)
            }
            b.onNodeEnter(g, a, d, c);
            b.lastOverNode = g
        }
        return b.onNodeOver(g, a, d, c)
    }, notifyOut: function (a, c, b) {
        if (this.lastOverNode) {
            this.onNodeOut(this.lastOverNode, a, c, b);
            this.lastOverNode = null
        }
    }, notifyDrop: function (b, g, d) {
        var c = this, h = c.getTargetFromEvent(g), a = h ? c.onNodeDrop(h, b, g, d) : c.onContainerDrop(b, g, d);
        if (c.lastOverNode) {
            c.onNodeOut(c.lastOverNode, b, g, d);
            c.lastOverNode = null
        }
        return a
    }, triggerCacheRefresh: function () {
        Ext.dd.DDM.refreshCache(this.groups)
    }
}, 0, 0, 0, 0, 0, 0, [Ext.dd, "DropZone"], 0));
(Ext.cmd.derive("Ext.dom.Layer", Ext.Element, {
    alternateClassName: "Ext.Layer",
    isLayer: true,
    constructor: function (c, h) {
        c = c || {};
        var k = this, j = Ext.DomHelper, i = c.parentEl, g = i ? Ext.getDom(i) : document.body, a = c.hideMode,
            m = "x-" + (c.fixed ? "fixed-layer" : "layer"), d, b, e, l;
        if (h) {
            d = Ext.getDom(h);
            if (!d.parentNode) {
                g.appendChild(d)
            }
        }
        if (!d) {
            d = j.append(g, c.dh || {tag: "div", cls: m})
        }
        if (c.id) {
            d.id = c.id
        }
        b = d.id;
        if (b) {
            e = Ext.cache[b];
            if (e) {
                delete Ext.cache[b];
                e.dom = null
            }
        }
        Ext.dom.Element.prototype.constructor.call(this, d);
        if (h) {
            k.addCls(m)
        }
        if (c.preventSync) {
            k.preventSync = true
        }
        if (c.cls) {
            k.addCls(c.cls)
        }
        k.constrain = c.constrain !== false;
        if (a) {
            k.setVisibilityMode(Ext.Element[a.toUpperCase()])
        } else {
            if (c.useDisplay) {
                k.setVisibilityMode(Ext.Element.DISPLAY)
            } else {
                k.setVisibilityMode(Ext.Element.VISIBILITY)
            }
        }
        if (c.shadow) {
            k.shadowOffset = c.shadowOffset || 4;
            l = {offset: k.shadowOffset, fixed: c.fixed};
            if (c.shadow !== true) {
                l.mode = c.shadow
            }
            k.enableShadow(l)
        } else {
            k.shadowOffset = 0
        }
        if (c.shim) {
            k.enableShim({fixed: c.fixed})
        }
        if (c.hidden === true) {
            k.hide()
        } else {
            if (c.hidden === false) {
                k.show()
            }
        }
    }
}, 1, 0, 0, 0, 0, 0, [Ext.dom, "Layer", Ext, "Layer"], 0));
(Ext.cmd.derive("Ext.event.publisher.MouseEnterLeave", Ext.event.publisher.Dom, {type: "mouseEnterLeave"}, 0, 0, 0, 0, 0, 0, [Ext.event.publisher, "MouseEnterLeave"], function (a) {
    var b = {mouseover: "mouseenter", mouseout: "mouseleave"};
    if (!Ext.supports.MouseEnterLeave) {
        a.override({
            handledDomEvents: ["mouseover", "mouseout"],
            handledEvents: ["mouseenter", "mouseleave"],
            doDelegatedEvent: function (j) {
                var i, c, k, g, d, h;
                j = this.callParent([j]);
                i = j.getTarget();
                c = j.getRelatedTarget();
                if (c && Ext.fly(i).contains(c)) {
                    return
                }
                k = i.id;
                if (k) {
                    g = Ext.cache[k];
                    if (g) {
                        d = b[j.type];
                        j = j.chain({type: d});
                        if (g.hasListeners[d]) {
                            h = g.events[d];
                            if (h) {
                                h = h.directs;
                                if (h) {
                                    j.setCurrentTarget(g.dom);
                                    h.fire(j, j.target)
                                }
                            }
                        }
                    }
                }
            }
        })
    }
    a.instance = new a()
}));
(Ext.cmd.derive("Ext.flash.Component", Ext.Component, {
    alternateClassName: "Ext.FlashComponent",
    flashVersion: "9.0.115",
    backgroundColor: "#ffffff",
    wmode: "opaque",
    swfWidth: "100%",
    swfHeight: "100%",
    expressInstall: false,
    renderTpl: ['<div id="{swfId}" role="application"></div>'],
    initComponent: function () {
        Ext.Component.prototype.initComponent.call(this)
    },
    beforeRender: function () {
        Ext.Component.prototype.beforeRender.call(this);
        Ext.applyIf(this.renderData, {swfId: this.getSwfId()})
    },
    afterRender: function () {
        var b = this, a = Ext.apply({}, b.flashParams), c = Ext.apply({}, b.flashVars);
        Ext.Component.prototype.afterRender.call(this);
        a = Ext.apply({allowScriptAccess: "always", bgcolor: b.backgroundColor, wmode: b.wmode}, a);
        c = Ext.apply({allowedDomain: document.location.hostname}, c);
        new swfobject.embedSWF(b.url, b.getSwfId(), b.swfWidth, b.swfHeight, b.flashVersion, b.expressInstall ? b.statics.EXPRESS_INSTALL_URL : undefined, c, a, b.flashAttributes, b.swfCallback.bind(b))
    },
    swfCallback: function (b) {
        var a = this;
        if (b.success) {
            a.swf = Ext.get(b.ref);
            a.onSuccess();
            a.fireEvent("success", a)
        } else {
            a.onFailure();
            a.fireEvent("failure", a)
        }
    },
    getSwfId: function () {
        return this.swfId || (this.swfId = "extswf" + this.getAutoId())
    },
    onSuccess: function () {
        this.swf.setStyle("visibility", "inherit")
    },
    onFailure: Ext.emptyFn,
    beforeDestroy: function () {
        var b = this, a = b.swf;
        if (a) {
            swfobject.removeSWF(b.getSwfId());
            Ext.destroy(a);
            delete b.swf
        }
        Ext.Component.prototype.beforeDestroy.call(this)
    },
    statics: {EXPRESS_INSTALL_URL: "http://swfobject.googlecode.com/svn/trunk/swfobject/expressInstall.swf"}
}, 0, ["flash"], ["component", "box", "flash"], {
    component: true,
    box: true,
    flash: true
}, ["widget.flash"], 0, [Ext.flash, "Component", Ext, "FlashComponent"], 0));
(Ext.cmd.derive("Ext.form.action.Action", Ext.Base, {
    alternateClassName: "Ext.form.Action",
    submitEmptyText: true,
    constructor: function (a) {
        if (a) {
            Ext.apply(this, a)
        }
        var b = a.params;
        if (Ext.isString(b)) {
            this.params = Ext.Object.fromQueryString(b)
        }
    },
    run: Ext.emptyFn,
    onFailure: function (a) {
        var c = this.form, b = c && !c.destroying && !c.destroyed;
        this.response = a;
        this.failureType = Ext.form.action.Action.CONNECT_FAILURE;
        if (b) {
            c.afterAction(this, false)
        }
    },
    processResponse: function (a) {
        this.response = a;
        if (!a.responseText && !a.responseXML) {
            return true
        }
        return (this.result = this.handleResponse(a))
    },
    getUrl: function () {
        return this.url || this.form.url
    },
    getMethod: function () {
        return (this.method || this.form.method || "POST").toUpperCase()
    },
    getParams: function () {
        return Ext.apply({}, this.params, this.form.baseParams)
    },
    createCallback: function () {
        var a = this;
        return {success: a.onSuccess, failure: a.onFailure, scope: a, timeout: (a.timeout || a.form.timeout) * 1000}
    },
    statics: {CLIENT_INVALID: "client", SERVER_INVALID: "server", CONNECT_FAILURE: "connect", LOAD_FAILURE: "load"}
}, 1, 0, 0, 0, 0, 0, [Ext.form.action, "Action", Ext.form, "Action"], 0));
(Ext.cmd.derive("Ext.form.action.Load", Ext.form.action.Action, {
    alternateClassName: "Ext.form.Action.Load",
    type: "load",
    run: function () {
        Ext.Ajax.request(Ext.apply(this.createCallback(), {
            method: this.getMethod(),
            url: this.getUrl(),
            headers: this.headers,
            params: this.getParams()
        }))
    },
    onSuccess: function (b) {
        var a = this.processResponse(b), d = this.form, c = d && !d.destroying && !d.destroyed;
        if (a === true || !a.success || !a.data) {
            this.failureType = Ext.form.action.Action.LOAD_FAILURE;
            if (c) {
                d.afterAction(this, false)
            }
            return
        }
        if (c) {
            d.clearInvalid();
            d.setValues(a.data);
            d.afterAction(this, true)
        }
    },
    handleResponse: function (c) {
        var a = this.form.reader, b, d;
        if (a) {
            b = a.read(c);
            d = b.records && b.records[0] ? b.records[0].data : null;
            return {success: b.success, data: d}
        }
        return Ext.decode(c.responseText)
    }
}, 0, 0, 0, 0, ["formaction.load"], 0, [Ext.form.action, "Load", Ext.form.Action, "Load"], 0));
(Ext.cmd.derive("Ext.form.action.Submit", Ext.form.action.Action, {
    alternateClassName: "Ext.form.Action.Submit", type: "submit", run: function () {
        var b = this, a = b.form;
        if (b.clientValidation === false || a.isValid()) {
            b.doSubmit()
        } else {
            b.failureType = Ext.form.action.Action.CLIENT_INVALID;
            a.afterAction(b, false)
        }
    }, doSubmit: function () {
        var d = this, b = Ext.apply(d.createCallback(), {url: d.getUrl(), method: d.getMethod(), headers: d.headers}),
            c = d.form, e = d.jsonSubmit || c.jsonSubmit, a = e ? "jsonData" : "params", g;
        if (c.hasUpload()) {
            g = d.buildForm();
            b.form = g.formEl;
            b.isUpload = true
        } else {
            b[a] = d.getParams(e)
        }
        Ext.Ajax.request(b);
        if (g) {
            d.cleanup(g)
        }
    }, cleanup: function (h) {
        var e = h.formEl, d = h.uploadEls, b = h.uploadFields, a = b.length, c, g;
        for (c = 0; c < a; ++c) {
            g = b[c];
            if (!g.clearOnSubmit) {
                g.restoreInput(d[c])
            }
        }
        if (e) {
            Ext.removeNode(e)
        }
    }, getParams: function (d) {
        var c = false, b = Ext.form.action.Action.prototype.getParams.call(this),
            a = this.form.getValues(c, c, this.submitEmptyText !== c, d, true);
        return Ext.apply({}, a, b)
    }, buildForm: function () {
        var k = this, n = [], l, s, h = k.form, d = k.getParams(), c = [], a = [], g = h.getFields().items, e,
            j = g.length, m, r, p, q, o, b;
        for (e = 0; e < j; ++e) {
            m = g[e];
            if (m.isFileUpload()) {
                c.push(m)
            }
        }
        for (r in d) {
            if (d.hasOwnProperty(r)) {
                p = d[r];
                if (Ext.isArray(p)) {
                    o = p.length;
                    for (q = 0; q < o; q++) {
                        n.push(k.getFieldConfig(r, p[q]))
                    }
                } else {
                    n.push(k.getFieldConfig(r, p))
                }
            }
        }
        l = {
            tag: "form",
            role: "presentation",
            action: k.getUrl(),
            method: k.getMethod(),
            target: k.target ? (Ext.isString(k.target) ? k.target : Ext.fly(k.target).dom.name) : "_self",
            style: "display:none",
            cn: n
        };
        if (c.length) {
            l.encoding = l.enctype = "multipart/form-data"
        }
        s = Ext.DomHelper.append(Ext.getBody(), l);
        j = c.length;
        for (e = 0; e < j; ++e) {
            b = c[e].extractFileInput();
            s.appendChild(b);
            a.push(b)
        }
        return {formEl: s, uploadFields: c, uploadEls: a}
    }, getFieldConfig: function (a, b) {
        return {tag: "input", type: "hidden", name: a, value: Ext.String.htmlEncode(b)}
    }, onSuccess: function (b) {
        var d = this.form, c = d && !d.destroying && !d.destroyed, e = true, a = this.processResponse(b);
        if (a !== true && !a.success) {
            if (a.errors && c) {
                d.markInvalid(a.errors)
            }
            this.failureType = Ext.form.action.Action.SERVER_INVALID;
            e = false
        }
        if (c) {
            d.afterAction(this, e)
        }
    }, handleResponse: function (d) {
        var a = this.form, c = a.errorReader, g, l, h, j, b, m;
        if (c) {
            g = c.read(d);
            b = g.records;
            l = [];
            if (b) {
                for (h = 0, j = b.length; h < j; h++) {
                    l[h] = b[h].data
                }
            }
            if (l.length < 1) {
                l = null
            }
            m = {success: g.success, errors: l}
        } else {
            try {
                m = Ext.decode(d.responseText)
            } catch (k) {
                m = {success: false, errors: []}
            }
        }
        return m
    }
}, 0, 0, 0, 0, ["formaction.submit"], 0, [Ext.form.action, "Submit", Ext.form.Action, "Submit"], 0));
(Ext.cmd.derive("Ext.util.ComponentDragger", Ext.dd.DragTracker, {
    autoStart: 500, constructor: function (a, b) {
        this.comp = a;
        this.initialConstrainTo = b.constrainTo;
        Ext.dd.DragTracker.prototype.constructor.call(this, b)
    }, onStart: function (c) {
        var b = this, a = b.comp;
        b.startPosition = a.getXY();
        if (a.ghost && !a.liveDrag) {
            b.proxy = a.ghost();
            b.dragTarget = b.proxy.header.el
        }
        if (b.constrain || b.constrainDelegate) {
            b.constrainTo = b.calculateConstrainRegion()
        }
        if (a.beginDrag) {
            a.beginDrag()
        }
    }, calculateConstrainRegion: function () {
        var i = this, g = i.comp, h = i.initialConstrainTo, e = g.constraintInsets, k, b, d,
            c = i.proxy ? i.proxy.el : g.el, j = c.shadow,
            a = (j && !i.constrainDelegate && g.constrainShadow && !j.disabled) ? j.getShadowSize() : 0;
        if (!(h instanceof Ext.util.Region)) {
            k = Ext.fly(h);
            h = k.getConstrainRegion()
        } else {
            h = h.copy()
        }
        if (e) {
            e = Ext.isObject(e) ? e : Ext.Element.parseBox(e);
            h.adjust(e.top, e.right, e.bottom, e.length)
        }
        if (a) {
            h.adjust(a[0], -a[1], -a[2], a[3])
        }
        if (!i.constrainDelegate) {
            b = Ext.fly(i.dragTarget).getRegion();
            d = c.getRegion();
            h.adjust(b.top - d.top, b.right - d.right, b.bottom - d.bottom, b.left - d.left)
        }
        return h
    }, onDrag: function (c) {
        var b = this, a = (b.proxy && !b.comp.liveDrag) ? b.proxy : b.comp,
            d = b.getOffset(b.constrain || b.constrainDelegate ? "dragTarget" : null);
        a.setPagePosition(b.startPosition[0] + d[0], b.startPosition[1] + d[1])
    }, onEnd: function (b) {
        var a = this.comp;
        if (a.destroyed || a.destroying) {
            return
        }
        if (this.proxy && !a.liveDrag) {
            a.unghost()
        }
        if (a.endDrag) {
            a.endDrag()
        }
    }
}, 1, 0, 0, 0, 0, 0, [Ext.util, "ComponentDragger"], 0));
(Ext.cmd.derive("Ext.util.FocusTrap", Ext.Mixin, {
    mixinConfig: {
        id: "focustrap",
        after: {
            afterRender: "initTabGuards",
            addTool: "initTabGuards",
            add: "initTabGuards",
            remove: "initTabGuards",
            addDocked: "initTabGuards",
            removeDocked: "initTabGuards",
            onShow: "initTabGuards",
            afterHide: "initTabGuards"
        }
    },
    config: {
        tabGuard: true,
        tabGuardTpl: '<div id="{id}-{tabGuardEl}" data-ref="{tabGuardEl}" role="button" data-tabguardposition="{tabGuard}" aria-busy="true" style="height:0"class="x-hidden-clip"></div>',
        tabGuardIndex: 0
    },
    tabGuardPositionAttribute: "data-tabguardposition",
    privates: {
        initTabGuards: function () {
            var e = this, c = e.tabGuardPositionAttribute, d = e.tabGuardBeforeEl, g = e.tabGuardAfterEl,
                a = e.tabGuardIndex, b;
            if (!e.rendered || !e.tabGuard) {
                return
            }
            b = e.el.findTabbableElements({skipSelf: true});
            if (b[0] && b[0].hasAttribute(c)) {
                b.shift()
            }
            if (b.length && b[b.length - 1].hasAttribute(c)) {
                b.pop()
            }
            if (b.length) {
                d.dom.setAttribute("tabIndex", a);
                d.on("focusenter", e.onTabGuardFocusEnter, e);
                g.dom.setAttribute("tabIndex", a);
                g.on("focusenter", e.onTabGuardFocusEnter, e)
            } else {
                d.dom.removeAttribute("tabIndex");
                d.un("focusenter", e.onTabGuardFocusEnter, e);
                g.dom.removeAttribute("tabIndex");
                g.un("focusenter", e.onTabGuardFocusEnter, e)
            }
        }, onTabGuardFocusEnter: function (g, h) {
            var i = this, b = i.el, j = i.tabGuardPositionAttribute, d = h.getAttribute(j), k = g.relatedTarget, a, c,
                l;
            if (!k.hasAttribute(j) && k !== b.dom && b.contains(k)) {
                c = d === "before" ? false : true
            } else {
                c = d === "before" ? true : false
            }
            a = b.findTabbableElements({skipSelf: true});
            a.shift();
            a.pop();
            l = c ? a[0] : a[a.length - 1];
            if (l) {
                l.focus()
            }
        }
    }
}, 0, 0, 0, 0, 0, 0, [Ext.util, "FocusTrap"], 0));
(Ext.cmd.derive("Ext.window.Window", Ext.panel.Panel, {
    alternateClassName: "Ext.Window",
    baseCls: "x-window",
    resizable: true,
    draggable: true,
    constrain: false,
    constrainHeader: false,
    plain: false,
    minimizable: false,
    maximizable: false,
    minHeight: 50,
    minWidth: 50,
    expandOnShow: true,
    collapsible: false,
    closable: true,
    hidden: true,
    autoRender: true,
    hideMode: "offsets",
    floating: true,
    itemCls: "x-window-item",
    overlapHeader: true,
    ignoreHeaderBorderManagement: true,
    alwaysFramed: true,
    isRootCfg: {isRoot: true},
    isWindow: true,
    ariaRole: "dialog",
    initComponent: function () {
        var a = this;
        a.frame = false;
        Ext.panel.Panel.prototype.initComponent.call(this);
        if (a.plain) {
            a.addClsWithUI("plain")
        }
        a.addStateEvents(["maximize", "restore", "resize", "dragend"])
    },
    getElConfig: function () {
        var b = this, a;
        a = Ext.panel.Panel.prototype.getElConfig.call(this);
        a.tabIndex = -1;
        return a
    },
    getFocusEl: function () {
        return this.getDefaultFocus() || this.el
    },
    getState: function () {
        var b = this, d = Ext.panel.Panel.prototype.getState.call(this) || {}, a = !!b.maximized, c = b.ghostBox, e;
        d.maximized = a;
        if (a) {
            e = b.restorePos
        } else {
            if (c) {
                e = [c.x, c.y]
            } else {
                e = b.getPosition()
            }
        }
        Ext.apply(d, {size: a ? b.restoreSize : b.getSize(), pos: e});
        return d
    },
    applyState: function (b) {
        var a = this;
        if (b) {
            a.maximized = b.maximized;
            if (a.maximized) {
                a.hasSavedRestore = true;
                a.restoreSize = b.size;
                a.restorePos = b.pos
            } else {
                Ext.apply(a, {width: b.size.width, height: b.size.height, x: b.pos[0], y: b.pos[1]})
            }
        }
    },
    onRender: function (b, a) {
        var c = this;
        Ext.panel.Panel.prototype.onRender.apply(this, arguments);
        if (c.header) {
            c.header.on({scope: c, click: c.onHeaderClick})
        }
        if (c.maximizable) {
            c.header.on({scope: c, dblclick: c.toggleMaximize})
        }
    },
    afterRender: function () {
        var a = this, c = a.header, b;
        if (a.maximized) {
            a.maximized = false;
            a.maximize();
            if (c) {
                c.removeCls(c.indicateDragCls)
            }
        }
        Ext.panel.Panel.prototype.afterRender.call(this);
        if (a.closable) {
            b = a.getKeyMap();
            b.on(27, a.onEsc, a)
        } else {
            b = a.keyMap
        }
        if (b && a.hidden) {
            b.disable()
        }
    },
    onEsc: function (a, b) {
        b.stopEvent();
        this.close()
    },
    beforeDestroy: function () {
        var a = this;
        if (a.rendered) {
            Ext.un("resize", a.onWindowResize, a);
            delete a.animateTarget;
            a.hide();
            Ext.destroy(a.keyMap)
        }
        Ext.panel.Panel.prototype.beforeDestroy.call(this)
    },
    addTools: function () {
        var a = this, b = [];
        Ext.panel.Panel.prototype.addTools.call(this);
        if (a.minimizable) {
            b.push({type: "minimize", handler: "minimize", scope: a})
        }
        if (a.maximizable) {
            b.push({type: a.maximized ? "restore" : "maximize", handler: "toggleMaximize", scope: a})
        }
        if (b.length) {
            a.addTool(b)
        }
    },
    onShow: function () {
        var a = this;
        Ext.panel.Panel.prototype.onShow.apply(this, arguments);
        if (a.expandOnShow) {
            a.expand(false)
        }
        a.syncMonitorWindowResize();
        if (a.keyMap) {
            a.keyMap.enable()
        }
    },
    doClose: function () {
        var a = this;
        if (a.hidden) {
            a.fireEvent("close", a);
            if (a.closeAction === "destroy") {
                a.destroy()
            }
        } else {
            a.hide(a.animateTarget, a.doClose, a)
        }
    },
    afterHide: function () {
        var a = this;
        a.syncMonitorWindowResize();
        if (a.keyMap) {
            a.keyMap.disable()
        }
        Ext.panel.Panel.prototype.afterHide.apply(this, arguments)
    },
    onWindowResize: function () {
        var b = this, a;
        if (!b.destroyed) {
            if (b.maximized) {
                b.fitContainer()
            } else {
                a = b.getSizeModel();
                if (a.width.natural || a.height.natural) {
                    b.updateLayout()
                }
                b.doConstrain()
            }
        }
    },
    minimize: function () {
        this.fireEvent("minimize", this);
        return this
    },
    resumeHeaderLayout: function (a) {
        this.header.resumeLayouts(a ? this.isRootCfg : null)
    },
    afterCollapse: function () {
        var a = this, c = a.header, b = a.tools;
        if (c && a.maximizable) {
            c.suspendLayouts();
            b.maximize.hide();
            this.resumeHeaderLayout(true)
        }
        if (a.resizer) {
            a.resizer.disable()
        }
        Ext.panel.Panel.prototype.afterCollapse.apply(this, arguments)
    },
    afterExpand: function () {
        var a = this, d = a.header, b = a.tools, c;
        if (d) {
            d.suspendLayouts();
            if (a.maximizable) {
                b.maximize.show();
                c = true
            }
            this.resumeHeaderLayout(c)
        }
        if (a.resizer) {
            a.resizer.enable()
        }
        Ext.panel.Panel.prototype.afterExpand.apply(this, arguments)
    },
    maximize: function (b) {
        var e = this, i = e.header, g = e.tools, d = e.width, a = e.height, c, h;
        if (!e.maximized) {
            e.expand(false);
            if (!e.hasSavedRestore) {
                c = e.restoreSize = {width: d ? d : null, height: a ? a : null};
                e.restorePos = e.getPosition()
            }
            if (i) {
                i.suspendLayouts();
                if (g.maximize) {
                    g.maximize.setType("restore")
                }
                if (e.collapseTool) {
                    e.collapseTool.hide();
                    h = true
                }
                e.resumeHeaderLayout(h)
            }
            e.el.disableShadow();
            if (e.dd) {
                e.dd.disable();
                if (i) {
                    i.removeCls(i.indicateDragCls)
                }
            }
            if (e.resizer) {
                e.resizer.disable()
            }
            e.el.addCls("x-window-maximized");
            e.container.addCls("x-window-maximized-ct");
            e.syncMonitorWindowResize();
            e.fitContainer(b = (b || !!e.animateTarget) ? {
                callback: function () {
                    e.maximized = true;
                    e.fireEvent("maximize", e)
                }
            } : null);
            if (!b) {
                e.maximized = true;
                e.fireEvent("maximize", e)
            }
        }
        return e
    },
    restore: function (b) {
        var c = this, d = c.tools, g = c.header, a = c.restoreSize, e;
        if (c.maximized) {
            c.hasSavedRestore = null;
            c.removeCls("x-window-maximized");
            if (g) {
                g.suspendLayouts();
                if (d.maximize) {
                    d.maximize.setType("maximize")
                }
                if (c.collapseTool) {
                    c.collapseTool.show();
                    e = true
                }
                c.resumeHeaderLayout(e)
            }
            a.x = c.restorePos[0];
            a.y = c.restorePos[1];
            c.setBox(a, b = (b || !!c.animateTarget) ? {
                callback: function () {
                    c.el.enableShadow(null, true);
                    c.maximized = false;
                    c.fireEvent("restore", c)
                }
            } : null);
            c.restorePos = c.restoreSize = null;
            if (c.dd) {
                c.dd.enable();
                if (g) {
                    g.addCls(g.indicateDragCls)
                }
            }
            if (c.resizer) {
                c.resizer.enable()
            }
            c.container.removeCls("x-window-maximized-ct");
            c.syncMonitorWindowResize();
            if (!b) {
                c.el.enableShadow(null, true);
                c.maximized = false;
                c.fireEvent("restore", c)
            }
        }
        return c
    },
    syncMonitorWindowResize: function () {
        var b = this, c = b._monitoringResize, d = b.monitorResize || b.constrain || b.constrainHeader || b.maximized,
            a = b.hidden || b.destroying || b.destroyed;
        if (d && !a) {
            if (!c) {
                Ext.on("resize", b.onWindowResize, b, {buffer: 1});
                b._monitoringResize = true
            }
        } else {
            if (c) {
                Ext.un("resize", b.onWindowResize, b);
                b._monitoringResize = false
            }
        }
    },
    toggleMaximize: function () {
        return this[this.maximized ? "restore" : "maximize"]()
    },
    createGhost: function () {
        var a = Ext.panel.Panel.prototype.createGhost.apply(this, arguments);
        a.xtype = "window";
        a.focusOnToFront = false;
        return a
    },
    getDefaultFocus: function () {
        var c = this, b, d = c.defaultFocus, a;
        if (d !== undefined) {
            if (Ext.isNumber(d)) {
                b = c.query("button")[d]
            } else {
                if (Ext.isString(d)) {
                    a = d;
                    if (Ext.validIdRe.test(a)) {
                        b = c.down(Ext.makeIdSelector(a))
                    }
                    if (!b) {
                        b = c.down(a)
                    }
                } else {
                    if (d.focus) {
                        b = d
                    }
                }
            }
        }
        return b
    },
    privates: {
        initDraggable: function () {
            this.initSimpleDraggable()
        }, onHeaderClick: function (c, b) {
            var a;
            if (c.el.contains(b.getTarget())) {
                a = this.getDefaultFocus();
                if (a) {
                    a.focus()
                }
            }
        }, initResizable: function () {
            Ext.panel.Panel.prototype.initResizable.apply(this, arguments);
            if (this.maximized) {
                this.resizer.disable()
            }
        }
    }
}, 0, ["window"], ["component", "box", "container", "panel", "window"], {
    component: true,
    box: true,
    container: true,
    panel: true,
    window: true
}, ["widget.window"], [[Ext.util.FocusTrap.prototype.mixinId || Ext.util.FocusTrap.$className, Ext.util.FocusTrap]], [Ext.window, "Window", Ext, "Window"], 0));
(Ext.cmd.derive("Ext.form.Labelable", Ext.Mixin, {
    isLabelable: true,
    mixinConfig: {id: "labelable", on: {beforeRender: "beforeLabelRender", onRender: "onLabelRender"}},
    config: {childEls: ["labelEl", "bodyEl", "errorEl", "errorWrapEl", "ariaErrorEl"]},
    labelableRenderTpl: ["{beforeLabelTpl}", '<label id="{id}-labelEl" data-ref="labelEl" class="{labelCls} {labelCls}-{ui} {labelClsExtra} ', '{unselectableCls}" style="{labelStyle}"<tpl if="inputId">', ' for="{inputId}"</tpl> {labelAttrTpl}>', '<span class="{labelInnerCls} {labelInnerCls}-{ui}" style="{labelInnerStyle}">', "{beforeLabelTextTpl}", '<tpl if="fieldLabel">{fieldLabel}', '<tpl if="labelSeparator">{labelSeparator}</tpl>', "</tpl>", "{afterLabelTextTpl}", "</span>", "</label>", "{afterLabelTpl}", '<div id="{id}-bodyEl" data-ref="bodyEl" role="presentation"', ' class="{baseBodyCls} {baseBodyCls}-{ui}<tpl if="fieldBodyCls">', ' {fieldBodyCls} {fieldBodyCls}-{ui}</tpl> {growCls} {extraFieldBodyCls}"', '<tpl if="bodyStyle"> style="{bodyStyle}"</tpl>>', "{beforeBodyEl}", "{beforeSubTpl}", "{[values.$comp.getSubTplMarkup(values)]}", "{afterSubTpl}", "{afterBodyEl}", '<div id="{id}-ariaErrorEl" data-ref="ariaErrorEl" role="alert" aria-live="polite"', ' class="x-hidden-clip">', "</div>", "</div>", '<tpl if="renderError">', '<div id="{id}-errorWrapEl" data-ref="errorWrapEl" class="{errorWrapCls} {errorWrapCls}-{ui}', ' {errorWrapExtraCls}" style="{errorWrapStyle}">', '<div role="presentation" id="{id}-errorEl" data-ref="errorEl" ', 'class="{errorMsgCls} {invalidMsgCls} {invalidMsgCls}-{ui}" ', 'data-anchorTarget="{tipAnchorTarget}">', "</div>", "</div>", "</tpl>", {disableFormats: true}],
    activeErrorsTpl: undefined,
    htmlActiveErrorsTpl: ['<tpl if="errors && errors.length">', '<ul class="{listCls}">', '<tpl for="errors"><li>{.}</li></tpl>', "</ul>", "</tpl>"],
    plaintextActiveErrorsTpl: ['<tpl if="errors && errors.length">', '<tpl for="errors"><tpl if="xindex &gt; 1">\\n</tpl>{.}</tpl>', "</tpl>"],
    isFieldLabelable: true,
    formItemCls: "x-form-item",
    labelCls: "x-form-item-label",
    topLabelCls: "x-form-item-label-top",
    rightLabelCls: "x-form-item-label-right",
    labelInnerCls: "x-form-item-label-inner",
    topLabelSideErrorCls: "x-form-item-label-top-side-error",
    errorMsgCls: "x-form-error-msg",
    errorWrapCls: "x-form-error-wrap",
    errorWrapSideCls: "x-form-error-wrap-side",
    errorWrapUnderCls: "x-form-error-wrap-under",
    errorWrapUnderSideLabelCls: "x-form-error-wrap-under-side-label",
    baseBodyCls: "x-form-item-body",
    invalidIconCls: "x-form-invalid-icon",
    invalidUnderCls: "x-form-invalid-under",
    noLabelCls: "x-form-item-no-label",
    fieldBodyCls: "",
    invalidCls: "x-form-invalid",
    fieldLabel: undefined,
    labelAlign: "left",
    labelWidth: 100,
    labelPad: 5,
    labelSeparator: ":",
    hideLabel: false,
    hideEmptyLabel: true,
    preventMark: false,
    autoFitErrors: true,
    msgTarget: "qtip",
    msgTargets: {qtip: 1, title: 1, under: 1, side: 1, none: 1},
    noWrap: true,
    labelableInsertions: ["beforeBodyEl", "afterBodyEl", "beforeLabelTpl", "afterLabelTpl", "beforeSubTpl", "afterSubTpl", "beforeLabelTextTpl", "afterLabelTextTpl", "labelAttrTpl"],
    statics: {
        initTip: function () {
            var b = this.tip, a, c;
            if (b) {
                return
            }
            a = {id: "ext-form-error-tip", ui: "form-invalid"};
            if (Ext.supports.Touch) {
                a.dismissDelay = 0;
                a.anchor = "top";
                a.showDelay = 0;
                a.listeners = {
                    beforeshow: function () {
                        this.minWidth = Ext.fly(this.anchorTarget).getWidth()
                    }
                }
            }
            b = this.tip = Ext.create("Ext.tip.QuickTip", a);
            c = Ext.apply({}, b.tagConfig);
            c.attribute = "errorqtip";
            b.setTagConfig(c)
        }, destroyTip: function () {
            this.tip = Ext.destroy(this.tip)
        }
    },
    initLabelable: function () {
        var a = this, b = a.padding;
        if (b) {
            a.padding = undefined;
            a.extraMargins = Ext.Element.parseBox(b)
        }
        if (Ext.isIE8) {
            a.restoreDisplay = Ext.Function.createDelayed(a.doRestoreDisplay, 0, a)
        }
        if (!a.activeErrorsTpl) {
            if (a.msgTarget === "title") {
                a.activeErrorsTpl = a.plaintextActiveErrorsTpl
            } else {
                a.activeErrorsTpl = a.htmlActiveErrorsTpl
            }
        }
        a.addCls([a.formItemCls, a.formItemCls + "-" + a.ui]);
        a.lastActiveError = "";
        a.enableBubble("errorchange")
    },
    trimLabelSeparator: function () {
        var c = this, d = c.labelSeparator, a = c.fieldLabel || "", b = a.substr(a.length - 1);
        return b === d ? a.slice(0, -1) : a
    },
    getFieldLabel: function () {
        return this.trimLabelSeparator()
    },
    setFieldLabel: function (d) {
        d = d || "";
        var e = this, g = e.labelSeparator, c = e.labelEl, b = e.errorWrapEl, i = (e.labelAlign !== "top"),
            a = e.noLabelCls, h = e.errorWrapUnderSideLabelCls;
        e.fieldLabel = d;
        if (e.rendered) {
            if (Ext.isEmpty(d) && e.hideEmptyLabel) {
                e.addCls(a);
                if (i && b) {
                    b.removeCls(h)
                }
            } else {
                if (g) {
                    d = e.trimLabelSeparator() + g
                }
                c.dom.firstChild.innerHTML = d;
                e.removeCls(a);
                if (i && b) {
                    b.addCls(h)
                }
            }
            e.updateLayout()
        }
    },
    setHideLabel: function (a) {
        var b = this;
        if (a !== b.hideLabel) {
            b.hideLabel = a;
            if (b.rendered) {
                b[a ? "addCls" : "removeCls"](b.noLabelCls);
                b.updateLayout()
            }
        }
    },
    setHideEmptyLabel: function (a) {
        var c = this, b;
        if (a !== c.hideEmptyLabel) {
            c.hideEmptyLabel = a;
            if (c.rendered && !c.hideLabel) {
                b = a && !c.getFieldLabel();
                c[b ? "addCls" : "removeCls"](c.noLabelCls);
                c.updateLayout()
            }
        }
    },
    getInsertionRenderData: function (d, e) {
        var b = e.length, a, c;
        while (b--) {
            a = e[b];
            c = this[a];
            if (c) {
                if (typeof c !== "string") {
                    if (!c.isTemplate) {
                        c = Ext.XTemplate.getTpl(this, a)
                    }
                    c = c.apply(d)
                }
            }
            d[a] = c || ""
        }
        return d
    },
    getLabelableRenderData: function () {
        var p = this, s = p.labelAlign, e = (s === "top"), m = (s === "right"), j = (p.msgTarget === "side"),
            g = (p.msgTarget === "under"), r = p.errorMsgCls, h = p.labelPad, o = p.labelWidth,
            b = p.labelClsExtra || "", i = j ? p.errorWrapSideCls : p.errorWrapUnderCls, a = "", l = "",
            d = p.hasVisibleLabel(), n = p.autoFitErrors, k = p.defaultBodyWidth, c, q;
        if (e) {
            b += " " + p.topLabelCls;
            if (h) {
                l = "padding-bottom:" + h + "px;"
            }
            if (j && !n) {
                b += " " + p.topLabelSideErrorCls
            }
        } else {
            if (m) {
                b += " " + p.rightLabelCls
            }
            if (h) {
                a += p.getHorizontalPaddingStyle() + h + "px;"
            }
            a += "width:" + (o + (h ? h : 0)) + "px;";
            l = "width:" + o + "px"
        }
        if (d) {
            if (!e && g) {
                i += " " + p.errorWrapUnderSideLabelCls
            }
        }
        if (k) {
            c = "min-width:" + k + "px;max-width:" + k + "px;"
        }
        q = {
            id: p.id,
            inputId: p.getInputId(),
            labelCls: p.labelCls,
            labelClsExtra: b,
            labelStyle: a + (p.labelStyle || ""),
            labelInnerStyle: l,
            labelInnerCls: p.labelInnerCls,
            unselectableCls: Ext.Element.unselectableCls,
            bodyStyle: c,
            baseBodyCls: p.baseBodyCls,
            fieldBodyCls: p.fieldBodyCls,
            extraFieldBodyCls: p.extraFieldBodyCls,
            errorWrapCls: p.errorWrapCls,
            errorWrapExtraCls: i,
            renderError: j || g,
            invalidMsgCls: j ? p.invalidIconCls : g ? p.invalidUnderCls : "",
            errorMsgCls: r,
            growCls: p.grow ? p.growCls : "",
            tipAnchorTarget: p.id + "-inputEl",
            errorWrapStyle: (j && !n) ? "visibility:hidden" : "display:none",
            fieldLabel: p.getFieldLabel(),
            labelSeparator: p.labelSeparator
        };
        p.getInsertionRenderData(q, p.labelableInsertions);
        return q
    },
    getHorizontalPaddingStyle: function () {
        return "padding-right:"
    },
    beforeLabelRender: function () {
        var a = this;
        a.setFieldDefaults(a.getInherited().fieldDefaults);
        if (a.ownerLayout) {
            a.addCls("x-" + a.ownerLayout.type + "-form-item")
        }
        if (!a.hasVisibleLabel()) {
            a.addCls(a.noLabelCls)
        }
    },
    onLabelRender: function () {
        var d = this, c = {}, g = Ext.Element, a = d.errorWrapEl, e, b;
        if (a) {
            a.setVisibilityMode((d.msgTarget === "side" && !d.autoFitErrors) ? g.VISIBILITY : g.DISPLAY)
        }
        if (d.extraMargins) {
            e = d.el.getMargin();
            for (b in e) {
                if (e.hasOwnProperty(b)) {
                    c["margin-" + b] = (e[b] + d.extraMargins[b]) + "px"
                }
            }
            d.el.setStyle(c)
        }
    },
    hasVisibleLabel: function () {
        if (this.hideLabel) {
            return false
        }
        return !(this.hideEmptyLabel && !this.getFieldLabel())
    },
    getSubTplMarkup: function () {
        return ""
    },
    getInputId: function () {
        return ""
    },
    getActiveError: function () {
        return this.activeError || ""
    },
    hasActiveError: function () {
        return !!this.getActiveError()
    },
    setActiveError: function (a) {
        this.setActiveErrors(a)
    },
    getActiveErrors: function () {
        return this.activeErrors || []
    },
    setActiveErrors: function (i) {
        var g = this, h = g.errorWrapEl, d = g.msgTarget, c = d === "side", k = d === "qtip", a, b, e, j;
        i = Ext.Array.from(i);
        e = g.getTpl("activeErrorsTpl");
        g.activeErrors = i;
        b = g.activeError = e.apply({fieldLabel: g.fieldLabel, errors: i, listCls: "x-list-plain"});
        g.renderActiveError();
        if (g.rendered) {
            a = g.getActionEl();
            if (c) {
                g.errorEl.dom.setAttribute("data-errorqtip", b)
            } else {
                if (k) {
                    a.dom.setAttribute("data-errorqtip", b)
                } else {
                    if (d === "title") {
                        a.dom.setAttribute("title", b)
                    }
                }
            }
            if (d !== "title") {
                g.ariaErrorEl.dom.innerHTML = i.join(". ");
                a.dom.setAttribute("aria-describedby", g.ariaErrorEl.id)
            }
            if (c || k) {
                Ext.form.Labelable.initTip()
            }
            if (!g.msgTargets[d]) {
                j = Ext.get(d);
                if (j) {
                    j.dom.innerHTML = b
                }
            }
        }
        if (h) {
            h.setVisible(i.length > 0);
            if (c && g.autoFitErrors) {
                g.labelEl.addCls(g.topLabelSideErrorCls)
            }
            g.updateLayout()
        }
    },
    unsetActiveError: function () {
        var e = this, b = e.errorWrapEl, c = e.msgTarget, a = e.restoreDisplay, d, g;
        if (e.hasActiveError()) {
            delete e.activeError;
            delete e.activeErrors;
            e.renderActiveError();
            if (e.rendered) {
                d = e.getActionEl();
                if (c === "qtip") {
                    d.dom.removeAttribute("data-errorqtip")
                } else {
                    if (c === "title") {
                        d.dom.removeAttribute("title")
                    }
                }
                if (c !== "title") {
                    e.ariaErrorEl.dom.innerHTML = "";
                    d.dom.removeAttribute("aria-describedby")
                }
                if (!e.msgTargets[c]) {
                    g = Ext.get(c);
                    if (g) {
                        g.dom.innerHTML = ""
                    }
                }
                if (b) {
                    b.hide();
                    if (c === "side" && e.autoFitErrors) {
                        e.labelEl.removeCls(e.topLabelSideErrorCls)
                    }
                    e.updateLayout();
                    if (a) {
                        e.el.dom.style.display = "block";
                        e.restoreDisplay()
                    }
                }
            }
        }
    },
    doRestoreDisplay: function () {
        var a = this.el;
        if (a && a.dom) {
            a.dom.style.display = ""
        }
    },
    renderActiveError: function () {
        var c = this, b = c.getActiveError(), a = !!b;
        if (b !== c.lastActiveError) {
            c.lastActiveError = b;
            c.fireEvent("errorchange", c, b)
        }
        if (c.rendered && !c.destroyed && !c.preventMark) {
            c.toggleInvalidCls(a);
            if (c.errorEl) {
                c.errorEl.dom.innerHTML = b
            }
        }
    },
    toggleInvalidCls: function (a) {
        this.el[a ? "addCls" : "removeCls"](this.invalidCls)
    },
    setFieldDefaults: function (b) {
        var a;
        for (a in b) {
            if (!this.hasOwnProperty(a)) {
                this[a] = b[a]
            }
        }
    }
}, 0, 0, 0, 0, 0, 0, [Ext.form, "Labelable"], function () {
    if (Ext.supports.Touch) {
        this.prototype.msgTarget = "side"
    }
}));
(Ext.cmd.derive("Ext.form.field.Field", Ext.Base, {
    mixinId: "field",
    isFormField: true,
    config: {validation: null, validationField: null},
    disabled: false,
    submitValue: true,
    validateOnChange: true,
    valuePublishEvent: "change",
    suspendCheckChange: 0,
    dirty: false,
    initField: function () {
        var d = this, c = d.valuePublishEvent, a, b;
        d.initValue();
        if (Ext.isString(c)) {
            d.on(c, d.publishValue, d)
        } else {
            for (b = 0, a = c.length; b < a; ++b) {
                d.on(c[b], d.publishValue, d)
            }
        }
    },
    initValue: function () {
        var a = this;
        if ("value" in a) {
            a.suspendCheckChange++;
            a.setValue(a.value);
            a.suspendCheckChange--
        }
        a.initialValue = a.originalValue = a.lastValue = a.getValue()
    },
    getFieldIdentifier: function () {
        return this.isEditorComponent ? this.dataIndex : this.name
    },
    getName: function () {
        return this.name
    },
    getValue: function () {
        return this.value
    },
    setValue: function (b) {
        var a = this;
        a.value = b;
        a.checkChange();
        return a
    },
    isEqual: function (b, a) {
        return String(b) === String(a)
    },
    isEqualAsString: function (b, a) {
        return String(Ext.valueFrom(b, "")) === String(Ext.valueFrom(a, ""))
    },
    getSubmitData: function () {
        var a = this, b = null;
        if (!a.disabled && a.submitValue) {
            b = {};
            b[a.getName()] = "" + a.getValue()
        }
        return b
    },
    getModelData: function (a, b) {
        var c = this, d = null;
        if (!c.disabled && (c.submitValue || !b)) {
            d = {};
            d[c.getFieldIdentifier()] = c.getValue()
        }
        return d
    },
    reset: function () {
        var a = this;
        a.beforeReset();
        a.setValue(a.originalValue);
        a.clearInvalid();
        delete a.wasValid
    },
    beforeReset: Ext.emptyFn,
    resetOriginalValue: function () {
        this.originalValue = this.getValue();
        this.checkDirty()
    },
    checkChange: function () {
        var c = this, b, a;
        if (!c.suspendCheckChange) {
            b = c.getValue();
            a = c.lastValue;
            if (!c.destroyed && c.didValueChange(b, a)) {
                c.lastValue = b;
                c.fireEvent("change", c, b, a);
                c.onChange(b, a)
            }
        }
    },
    didValueChange: function (b, a) {
        return !this.isEqual(b, a)
    },
    onChange: function (a) {
        var b = this;
        if (b.validateOnChange) {
            b.validate()
        }
        b.checkDirty()
    },
    publishValue: function () {
        var a = this;
        if (a.rendered && !a.getErrors().length) {
            a.publishState("value", a.getValue())
        }
    },
    isDirty: function () {
        var a = this;
        return !a.disabled && !a.isEqual(a.getValue(), a.originalValue)
    },
    checkDirty: function () {
        var a = this, b = a.isDirty();
        if (b !== a.wasDirty) {
            a.dirty = b;
            a.fireEvent("dirtychange", a, b);
            a.onDirtyChange(b);
            a.wasDirty = b
        }
    },
    onDirtyChange: Ext.emptyFn,
    getErrors: function (d) {
        var e = [], c = this.getValidationField(), b = this.getValidation(), a;
        if (c) {
            a = c.validate(d);
            if (a !== true) {
                e.push(a)
            }
        }
        if (b && b !== true) {
            e.push(b)
        }
        return e
    },
    isValid: function () {
        var a = this;
        return a.disabled || Ext.isEmpty(a.getErrors())
    },
    validate: function () {
        return this.checkValidityChange(this.isValid())
    },
    checkValidityChange: function (b) {
        var a = this;
        if (b !== a.wasValid) {
            a.wasValid = b;
            a.fireEvent("validitychange", a, b)
        }
        return b
    },
    batchChanges: function (a) {
        try {
            this.suspendCheckChange++;
            a()
        } catch (b) {
            throw b
        } finally {
            this.suspendCheckChange--
        }
        this.checkChange()
    },
    isFileUpload: function () {
        return false
    },
    extractFileInput: function () {
        return null
    },
    markInvalid: Ext.emptyFn,
    clearInvalid: Ext.emptyFn,
    updateValidation: function (a, b) {
        if (b) {
            this.validate()
        }
    },
    privates: {
        resetToInitialValue: function () {
            var b = this, a = b.originalValue;
            b.originalValue = b.initialValue;
            b.reset();
            b.originalValue = a
        }
    }
}, 0, 0, 0, 0, 0, 0, [Ext.form.field, "Field"], 0));
(Ext.cmd.derive("Ext.form.field.Base", Ext.Component, {
    alternateClassName: ["Ext.form.Field", "Ext.form.BaseField"],
    focusable: true,
    shrinkWrap: true,
    fieldSubTpl: ['<input id="{id}" data-ref="inputEl" type="{type}" {inputAttrTpl}', ' size="1"', '<tpl if="name"> name="{name}"</tpl>', '<tpl if="value"> value="{[Ext.util.Format.htmlEncode(values.value)]}"</tpl>', '<tpl if="placeholder"> placeholder="{placeholder}"</tpl>', '{%if (values.maxLength !== undefined){%} maxlength="{maxLength}"{%}%}', '<tpl if="readOnly"> readonly="readonly"</tpl>', '<tpl if="disabled"> disabled="disabled"</tpl>', '<tpl if="tabIdx != null"> tabindex="{tabIdx}"</tpl>', '<tpl if="fieldStyle"> style="{fieldStyle}"</tpl>', '<tpl foreach="inputElAriaAttributes"> {$}="{.}"</tpl>', ' class="{fieldCls} {typeCls} {typeCls}-{ui} {editableCls} {inputCls}" autocomplete="off"/>', {disableFormats: true}],
    defaultBindProperty: "value",
    autoEl: {role: "presentation"},
    subTplInsertions: ["inputAttrTpl"],
    childEls: ["inputEl"],
    inputType: "text",
    isTextInput: true,
    invalidText: "The value in this field is invalid",
    fieldCls: "x-form-field",
    focusCls: "form-focus",
    dirtyCls: "x-form-dirty",
    checkChangeEvents: Ext.isIE && (!document.documentMode || document.documentMode <= 9) ? ["change", "propertychange", "keyup"] : ["change", "input", "textInput", "keyup", "dragdrop"],
    ignoreChangeRe: /data\\-errorqtip|style\\.|className/,
    checkChangeBuffer: 50,
    liquidLayout: true,
    readOnly: false,
    readOnlyCls: "x-form-readonly",
    validateOnBlur: true,
    hasFocus: false,
    baseCls: "x-field",
    fieldBodyCls: "x-field-body",
    maskOnDisable: false,
    stretchInputElFixed: true,
    ariaEl: "inputEl",
    initComponent: function () {
        var a = this;
        Ext.Component.prototype.initComponent.call(this);
        a.subTplData = a.subTplData || {};
        a.initLabelable();
        a.initField();
        a.initDefaultName();
        if (a.readOnly) {
            a.addCls(a.readOnlyCls)
        }
        a.addCls("x-form-type-" + a.inputType)
    },
    initDefaultName: function () {
        var a = this;
        if (!a.name) {
            a.name = a.getInputId()
        }
    },
    getInputId: function () {
        return this.inputId || (this.inputId = this.id + "-inputEl")
    },
    getSubTplData: function (c) {
        var e = this, d = e.inputType, a = e.getInputId(), g, b;
        g = Ext.apply({
            ui: e.ui,
            id: a,
            cmpId: e.id,
            name: e.name || a,
            disabled: e.disabled,
            readOnly: e.readOnly,
            value: e.getRawValue(),
            type: d,
            fieldCls: e.fieldCls,
            fieldStyle: e.getFieldStyle(),
            childElCls: c.childElCls,
            tabIdx: e.tabIndex,
            inputCls: e.inputCls,
            typeCls: "x-form-" + (e.isTextInput ? "text" : d)
        }, e.subTplData);
        if (e.ariaRole) {
            b = {
                role: e.ariaRole,
                "aria-hidden": !!e.hidden,
                "aria-disabled": !!e.disabled,
                "aria-readonly": !!e.readOnly,
                "aria-invalid": false
            };
            if (e.ariaLabel) {
                b["aria-label"] = e.ariaLabel
            }
            if (e.format && e.formatText && !g.title) {
                b.title = Ext.String.formatEncode(e.formatText, e.format)
            }
            g.inputElAriaAttributes = Ext.apply(b, e.getAriaAttributes())
        }
        e.getInsertionRenderData(g, e.subTplInsertions);
        return g
    },
    getSubTplMarkup: function (b) {
        var c = this, d = c.getSubTplData(b), e = c.getTpl("preSubTpl"), g = c.getTpl("postSubTpl"), a = "";
        if (e) {
            a += e.apply(d)
        }
        a += c.getTpl("fieldSubTpl").apply(d);
        if (g) {
            a += g.apply(d)
        }
        return a
    },
    initRenderData: function () {
        return Ext.applyIf(Ext.Component.prototype.initRenderData.call(this), this.getLabelableRenderData())
    },
    setFieldStyle: function (a) {
        var b = this, c = b.inputEl;
        if (c) {
            c.applyStyles(a)
        }
        b.fieldStyle = a
    },
    getFieldStyle: function () {
        var a = this.fieldStyle;
        return Ext.isObject(a) ? Ext.DomHelper.generateStyles(a, null, true) : a || ""
    },
    onRender: function () {
        this.callParent(arguments);
        this.mixins.labelable.self.initTip();
        this.renderActiveError()
    },
    onFocusLeave: function (a) {
        Ext.Component.prototype.onFocusLeave.call(this, a);
        this.completeEdit()
    },
    completeEdit: Ext.emptyFn,
    isFileUpload: function () {
        return this.inputType === "file"
    },
    getSubmitData: function () {
        var a = this, b = null, c;
        if (!a.disabled && a.submitValue) {
            c = a.getSubmitValue();
            if (c !== null) {
                b = {};
                b[a.getName()] = c
            }
        }
        return b
    },
    getSubmitValue: function () {
        return this.processRawValue(this.getRawValue())
    },
    getRawValue: function () {
        var b = this, a = (b.inputEl ? b.inputEl.getValue() : Ext.valueFrom(b.rawValue, ""));
        b.rawValue = a;
        return a
    },
    setRawValue: function (c) {
        var a = this, b = a.rawValue;
        if (!a.transformRawValue.$nullFn) {
            c = a.transformRawValue(c)
        }
        c = Ext.valueFrom(c, "");
        if (b === undefined || b !== c || a.valueContainsPlaceholder) {
            a.rawValue = c;
            if (a.inputEl) {
                a.bindChangeEvents(false);
                a.inputEl.dom.value = c;
                a.bindChangeEvents(true)
            }
            if (a.rendered && a.reference) {
                a.publishState("rawValue", c)
            }
        }
        return c
    },
    transformRawValue: Ext.identityFn,
    valueToRaw: function (a) {
        return "" + Ext.valueFrom(a, "")
    },
    rawToValue: Ext.identityFn,
    processRawValue: Ext.identityFn,
    getValue: function () {
        var a = this, b = a.rawToValue(a.processRawValue(a.getRawValue()));
        a.value = b;
        return b
    },
    setValue: function (b) {
        var a = this;
        a.setRawValue(a.valueToRaw(b));
        return a.mixins.field.setValue.call(a, b)
    },
    onBoxReady: function () {
        var a = this;
        Ext.Component.prototype.onBoxReady.apply(this, arguments);
        if (a.setReadOnlyOnBoxReady) {
            a.setReadOnly(a.readOnly)
        }
    },
    onDisable: function () {
        var a = this, b = a.inputEl;
        Ext.Component.prototype.onDisable.call(this);
        if (b) {
            b.dom.disabled = true;
            if (a.hasActiveError()) {
                a.clearInvalid();
                a.hadErrorOnDisable = true
            }
        }
        if (a.wasValid === false) {
            a.checkValidityChange(true)
        }
    },
    onEnable: function () {
        var b = this, c = b.inputEl, d = b.preventMark, a;
        Ext.Component.prototype.onEnable.call(this);
        if (c) {
            c.dom.disabled = false
        }
        if (b.wasValid !== undefined) {
            b.forceValidation = true;
            b.preventMark = !b.hadErrorOnDisable;
            a = b.isValid();
            b.forceValidation = false;
            b.preventMark = d;
            b.checkValidityChange(a)
        }
        delete b.hadErrorOnDisable
    },
    setReadOnly: function (d) {
        var b = this, c = b.inputEl, a = b.readOnly;
        d = !!d;
        b[d ? "addCls" : "removeCls"](b.readOnlyCls);
        b.readOnly = d;
        if (c) {
            c.dom.readOnly = d;
            b.ariaEl.dom.setAttribute("aria-readonly", d)
        } else {
            if (b.rendering) {
                b.setReadOnlyOnBoxReady = true
            }
        }
        if (d !== a) {
            b.fireEvent("writeablechange", b, d)
        }
    },
    fireKey: function (a) {
        if (a.isSpecialKey()) {
            this.fireEvent("specialkey", this, a)
        }
    },
    initEvents: function () {
        var e = this, h = e.inputEl, g = e.onFieldMutation, c = e.checkChangeEvents, a = c.length, b, d;
        if (h) {
            e.mon(h, Ext.supports.SpecialKeyDownRepeat ? "keydown" : "keypress", e.fireKey, e);
            for (b = 0; b < a; ++b) {
                d = c[b];
                if (d === "propertychange") {
                    e.usesPropertychange = true
                }
                if (d === "textInput") {
                    e.usesTextInput = true
                }
                e.mon(h, d, g, e)
            }
        }
        Ext.Component.prototype.initEvents.call(this)
    },
    onFieldMutation: function (c) {
        var b = this, a = b.checkChangeTask;
        if (!b.readOnly && !(c.type === "propertychange" && b.ignoreChangeRe.test(c.browserEvent.propertyName))) {
            if (!a) {
                b.checkChangeTask = a = new Ext.util.DelayedTask(b.doCheckChangeTask, b)
            }
            if (!b.bindNotifyListener) {
                b.bindNotifyListener = Ext.on("beforebindnotify", b.onBeforeNotify, b, {destroyable: true})
            }
            a.delay(b.checkChangeBuffer)
        }
    },
    doCheckChangeTask: function () {
        var a = this.bindNotifyListener;
        if (a) {
            a.destroy();
            this.bindNotifyListener = null
        }
        this.checkChange()
    },
    publishValue: function () {
        var a = this;
        if (a.rendered && !a.getErrors().length) {
            a.publishState("value", a.getValue())
        }
    },
    onDirtyChange: function (b) {
        var a = this;
        a[b ? "addCls" : "removeCls"](a.dirtyCls);
        if (a.rendered && a.reference) {
            a.publishState("dirty", b)
        }
    },
    isValid: function () {
        var b = this, a = b.disabled, c = b.forceValidation || !a;
        return c ? b.validateValue(b.processRawValue(b.getRawValue())) : a
    },
    validateValue: function (b) {
        var a = this, d = a.getErrors(b), c = Ext.isEmpty(d);
        if (!a.preventMark) {
            if (c) {
                a.clearInvalid()
            } else {
                a.markInvalid(d)
            }
        }
        return c
    },
    markInvalid: function (e) {
        var c = this, a = c.ariaEl.dom, b = c.getActiveError(), d;
        c.setActiveErrors(Ext.Array.from(e));
        d = c.getActiveError();
        if (b !== d) {
            c.setError(d);
            if (!c.ariaStaticRoles[c.ariaRole] && a) {
                a.setAttribute("aria-invalid", true)
            }
        }
    },
    clearInvalid: function () {
        var c = this, a = c.ariaEl.dom, b = c.hasActiveError();
        delete c.hadErrorOnDisable;
        c.unsetActiveError();
        if (b) {
            c.setError("");
            if (!c.ariaStaticRoles[c.ariaRole] && a) {
                a.setAttribute("aria-invalid", false)
            }
        }
    },
    setError: function (a) {
        var c = this, b = c.msgTarget, d;
        if (c.rendered) {
            if (b === "title" || b === "qtip") {
                d = b === "qtip" ? "data-errorqtip" : "title";
                c.getActionEl().dom.setAttribute(d, a || "")
            } else {
                c.updateLayout()
            }
        }
    },
    renderActiveError: function () {
        var c = this, b = c.hasActiveError(), a = c.invalidCls + "-field";
        if (c.inputEl) {
            c.inputEl[b ? "addCls" : "removeCls"]([a, a + "-" + c.ui])
        }
        c.mixins.labelable.renderActiveError.call(c)
    },
    beforeDestroy: function () {
        var b = this, a = b.checkChangeTask;
        if (a) {
            a.cancel()
        }
        b.checkChangeTask = b.bindNotifyListener = Ext.destroy(b.bindNotifyListener);
        Ext.Component.prototype.beforeDestroy.call(this)
    },
    privates: {
        applyBind: function (g, c) {
            var b = this, a = c && c.value, e, d;
            e = Ext.Component.prototype.applyBind.call(this, g, c);
            if (e) {
                d = e.value;
                b.hasBindingValue = !!d;
                if (d !== a && b.getInherited().modelValidation) {
                    b.updateValueBinding(e)
                }
            }
            return e
        }, applyRenderSelectors: function () {
            var a = this;
            Ext.Component.prototype.applyRenderSelectors.call(this);
            if (!a.inputEl) {
                a.inputEl = a.el.getById(a.getInputId())
            }
        }, bindChangeEvents: function (b) {
            var c = b ? "resumeEvent" : "suspendEvent", a = this.inputEl;
            if (this.usesPropertychange) {
                a[c]("propertychange")
            }
            if (this.usesTextInput) {
                a[c]("textInput")
            }
        }, getActionEl: function () {
            return this.inputEl || this.el
        }, getFocusEl: function () {
            return this.inputEl
        }, initRenderTpl: function () {
            var a = this;
            if (!a.hasOwnProperty("renderTpl")) {
                a.renderTpl = a.getTpl("labelableRenderTpl")
            }
            return Ext.Component.prototype.initRenderTpl.call(this)
        }, onBeforeNotify: function () {
            this.checkChangeTask.cancel();
            this.checkChange()
        }, updateValueBinding: function (d) {
            var c = this, b = d.value, a = d.$fieldBinding;
            if (a) {
                a.destroy();
                d.$fieldBinding = null
            }
            if (b && b.bindValidationField) {
                c.fieldBinding = b.bindValidationField("setValidationField", c)
            }
        }
    },
    deprecated: {
        "5": {
            methods: {
                doComponentLayout: function () {
                    this.bindChangeEvents(false);
                    this.callParent(arguments);
                    this.bindChangeEvents(true)
                }
            }
        }
    }
}, 0, ["field"], ["component", "box", "field"], {
    component: true,
    box: true,
    field: true
}, ["widget.field"], [[Ext.form.Labelable.prototype.mixinId || Ext.form.Labelable.$className, Ext.form.Labelable], [Ext.form.field.Field.prototype.mixinId || Ext.form.field.Field.$className, Ext.form.field.Field]], [Ext.form.field, "Base", Ext.form, "Field", Ext.form, "BaseField"], 0));
(Ext.cmd.derive("Ext.form.field.VTypes", Ext.Base, (function () {
    var c = /^[a-zA-Z_]+$/, d = /^[a-zA-Z0-9_]+$/,
        b = /^(")?(?:[^\\."])(?:(?:[\\.])?(?:[\\w\\-!#$%&'*+/=?^_`{|}~]))*\\1@(\\w[\\-\\w]*\\.){1,5}([A-Za-z]){2,6}$/,
        a = /(((^https?)|(^ftp)):\\/\\/((([\\-\\w]+\\.)+\\w{2,3}(\\/[%\\-\\w]+(\\.\\w{2,})?)*(([\\w\\-\\.\\?\\\\\\/+@&#;`~=%!]*)(\\.\\w{2,})?)*)|(localhost|LOCALHOST))\\/?)/i;
    return {
        singleton: true,
        alternateClassName: "Ext.form.VTypes",
        email: function (e) {
            return b.test(e)
        },
        emailText: 'This field should be an e-mail address in the format "user@example.com"',
        emailMask: /[\\w.\\-@'"!#$%&'*+/=?^_`{|}~]/i,
        url: function (e) {
            return a.test(e)
        },
        urlText: 'This field should be a URL in the format "http://www.example.com"',
        alpha: function (e) {
            return c.test(e)
        },
        alphaText: "This field should only contain letters and _",
        alphaMask: /[a-z_]/i,
        alphanum: function (e) {
            return d.test(e)
        },
        alphanumText: "This field should only contain letters, numbers and _",
        alphanumMask: /[a-z0-9_]/i
    }
}()), 0, 0, 0, 0, 0, 0, [Ext.form.field, "VTypes", Ext.form, "VTypes"], 0));
(Ext.cmd.derive("Ext.form.trigger.Trigger", Ext.Base, {
    factoryConfig: {defaultType: "trigger"},
    repeatClick: false,
    hidden: false,
    hideOnReadOnly: undefined,
    weight: 0,
    preventMouseDown: true,
    baseCls: "x-form-trigger",
    focusCls: "x-form-trigger-focus",
    overCls: "x-form-trigger-over",
    clickCls: "x-form-trigger-click",
    validIdRe: Ext.validIdRe,
    renderTpl: ['<div id="{triggerId}" class="{baseCls} {baseCls}-{ui} {cls} {cls}-{ui} {extraCls} ', '{childElCls}"<tpl if="triggerStyle"> style="{triggerStyle}"</tpl>>', "{[values.$trigger.renderBody(values)]}", "</div>"],
    statics: {
        weightComparator: function (a, b) {
            return a.weight - b.weight
        }
    },
    constructor: function (b) {
        var c = this, a;
        Ext.apply(c, b);
        if (c.compat4Mode) {
            a = c.cls;
            c.focusCls = [c.focusCls, a + "-focus"];
            c.overCls = [c.overCls, a + "-over"];
            c.clickCls = [c.clickCls, a + "-click"]
        }
    },
    afterFieldRender: function () {
        this.initEvents()
    },
    destroy: function () {
        var a = this;
        a.clickRepeater = a.el = Ext.destroy(a.clickRepeater, a.el);
        a.callParent()
    },
    getBodyRenderData: Ext.emptyFn,
    getEl: function () {
        return this.el || null
    },
    getStateEl: function () {
        return this.el
    },
    hide: function () {
        var b = this, a = b.el;
        b.hidden = true;
        if (a) {
            a.hide()
        }
    },
    initEvents: function () {
        var d = this, a = d.isFieldEnabled, c = d.getStateEl(), b = d.el;
        c.addClsOnOver(d.overCls, a, d);
        c.addClsOnClick(d.clickCls, a, d);
        if (d.repeatClick) {
            d.clickRepeater = new Ext.util.ClickRepeater(b, {
                preventDefault: true,
                handler: d.onClick,
                listeners: {mousedown: d.onClickRepeaterMouseDown, scope: d},
                scope: d
            })
        } else {
            d.field.mon(b, {click: d.onClick, mousedown: d.onMouseDown, scope: d})
        }
    },
    isFieldEnabled: function () {
        return !this.field.disabled
    },
    isVisible: function () {
        var a = this, c = a.field, b = false;
        if (a.hidden || !c || !a.rendered || a.destroyed) {
            b = true
        }
        return !b
    },
    onClick: function () {
        var c = this, a = arguments, g = c.clickRepeater ? a[1] : a[0], b = c.handler, d = c.field;
        if (b && !d.readOnly && c.isFieldEnabled()) {
            Ext.callback(c.handler, c.scope, [d, c, g], 0, d)
        }
    },
    resolveListenerScope: function (a) {
        return this.field.resolveSatelliteListenerScope(this, a)
    },
    onMouseDown: function (a) {
        if (a.pointerType !== "touch" && !this.field.owns(Ext.Element.getActiveElement())) {
            this.field.inputEl.focus()
        }
        if (this.preventMouseDown) {
            a.preventDefault()
        }
    },
    onClickRepeaterMouseDown: function (b, a) {
        if (!a.parentEvent || a.parentEvent.type === "mousedown") {
            this.field.inputEl.focus()
        }
        a.preventDefault()
    },
    onFieldBlur: function () {
        this.getStateEl().removeCls(this.focusCls)
    },
    onFieldFocus: function () {
        this.getStateEl().addCls(this.focusCls)
    },
    onFieldRender: function () {
        var b = this, a = b.el = b.field.triggerWrap.selectNode("#" + b.domId, false);
        a.setVisibilityMode(Ext.Element.DISPLAY);
        b.rendered = true
    },
    renderBody: function (b) {
        var a = this, c = a.bodyTpl;
        Ext.apply(b, a.getBodyRenderData());
        return c ? Ext.XTemplate.getTpl(a, "bodyTpl").apply(b) : ""
    },
    renderTrigger: function (a) {
        var c = this, b = c.width, d = c.hidden ? "display:none;" : "";
        if (b) {
            d += "width:" + b
        }
        return Ext.XTemplate.getTpl(c, "renderTpl").apply({
            $trigger: c,
            fieldData: a,
            ui: a.ui,
            childElCls: a.childElCls,
            triggerId: c.domId = c.field.id + "-trigger-" + c.id,
            cls: c.cls,
            triggerStyle: d,
            extraCls: c.extraCls,
            baseCls: c.baseCls
        })
    },
    setHidden: function (a) {
        if (a !== this.hidden) {
            this[a ? "hide" : "show"]()
        }
    },
    setVisible: function (a) {
        this.setHidden(!a)
    },
    show: function () {
        var b = this, a = b.el;
        b.hidden = false;
        if (a) {
            a.show()
        }
    }
}, 1, 0, 0, 0, ["trigger.trigger"], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.form.trigger, "Trigger"], 0));
(Ext.cmd.derive("Ext.form.field.Text", Ext.form.field.Base, {
    alternateClassName: ["Ext.form.TextField", "Ext.form.Text"],
    config: {hideTrigger: false, triggers: undefined},
    growMin: 30,
    growMax: 800,
    growAppend: "W",
    allowBlank: true,
    validateBlank: false,
    allowOnlyWhitespace: true,
    minLength: 0,
    maxLength: Number.MAX_VALUE,
    minLengthText: "The minimum length for this field is {0}",
    maxLengthText: "The maximum length for this field is {0}",
    blankText: "This field is required",
    regexText: "",
    emptyCls: "x-form-empty-field",
    requiredCls: "x-form-required-field",
    valueContainsPlaceholder: false,
    ariaRole: "textbox",
    editable: true,
    repeatTriggerClick: false,
    triggerWrapCls: "x-form-trigger-wrap",
    triggerWrapFocusCls: "x-form-trigger-wrap-focus",
    triggerWrapInvalidCls: "x-form-trigger-wrap-invalid",
    fieldBodyCls: "x-form-text-field-body",
    inputWrapCls: "x-form-text-wrap",
    inputWrapFocusCls: "x-form-text-wrap-focus",
    inputWrapInvalidCls: "x-form-text-wrap-invalid",
    growCls: "x-form-text-grow",
    needArrowKeys: true,
    squashMouseUp: {
        mouseup: function () {
        }, translate: false, single: true, preventDefault: true
    },
    childEls: ["triggerWrap", "inputWrap"],
    preSubTpl: ['<div id="{cmpId}-triggerWrap" data-ref="triggerWrap"', ' role="presentation" class="{triggerWrapCls} {triggerWrapCls}-{ui}">', '<div id={cmpId}-inputWrap data-ref="inputWrap"', ' role="presentation" class="{inputWrapCls} {inputWrapCls}-{ui}">'],
    postSubTpl: ["</div>", '<tpl for="triggers">{[values.renderTrigger(parent)]}</tpl>', "</div>"],
    initComponent: function () {
        var b = this, a = b.emptyCls;
        if (b.allowOnlyWhitespace === false) {
            b.allowBlank = false
        }
        if (b.size) {
            b.defaultBodyWidth = b.size * 6.5 + 20
        }
        if (!b.onTrigger1Click) {
            b.onTrigger1Click = b.onTriggerClick
        }
        Ext.form.field.Base.prototype.initComponent.call(this);
        if (b.readOnly) {
            b.setReadOnly(b.readOnly)
        }
        b.fieldFocusCls = b.baseCls + "-focus";
        b.emptyUICls = a + " " + a + "-" + b.ui;
        b.addStateEvents("change")
    },
    initEvents: function () {
        var b = this, a = b.inputEl;
        Ext.form.field.Base.prototype.initEvents.call(this);
        if (b.selectOnFocus || b.emptyText) {
            b.mon(a, "mousedown", b.onMouseDown, b)
        }
        if (b.maskRe || (b.vtype && b.disableKeyFilter !== true && (b.maskRe = Ext.form.field.VTypes[b.vtype + "Mask"]))) {
            b.mon(a, "keypress", b.filterKeys, b)
        }
        if (b.enableKeyEvents) {
            b.mon(a, {scope: b, keyup: b.onKeyUp, keydown: b.onKeyDown, keypress: b.onKeyPress})
        }
    },
    isEqual: function (b, a) {
        return this.isEqualAsString(b, a)
    },
    onChange: function (b, a) {
        Ext.form.field.Base.prototype.onChange.apply(this, arguments);
        this.autoSize()
    },
    getSubTplData: function (c) {
        var d = this, g = d.getRawValue(), i = d.emptyText && g.length < 1, a = d.maxLength, h, e, b;
        if (d.enforceMaxLength) {
            if (a === Number.MAX_VALUE) {
                a = undefined
            }
        } else {
            a = undefined
        }
        if (i) {
            if (Ext.supports.Placeholder) {
                h = d.emptyText
            } else {
                g = d.emptyText;
                d.valueContainsPlaceholder = true
            }
        }
        e = Ext.apply(Ext.form.field.Base.prototype.getSubTplData.call(this, c), {
            triggerWrapCls: d.triggerWrapCls,
            inputWrapCls: d.inputWrapCls,
            triggers: d.orderedTriggers,
            maxLength: a,
            readOnly: !d.editable || d.readOnly,
            placeholder: h,
            value: g,
            fieldCls: d.fieldCls + ((i && (h || g)) ? " " + d.emptyUICls : "") + (d.allowBlank ? "" : " " + d.requiredCls)
        });
        b = e.inputElAriaAttributes;
        if (b) {
            b["aria-required"] = !d.allowBlank
        }
        return e
    },
    onRender: function () {
        var c = this, b = c.getTriggers(), d = [], e, a;
        if (Ext.supports.FixedTableWidthBug) {
            c.el._needsTableWidthFix = true
        }
        (arguments.callee.$previous || Ext.form.field.Base.prototype.onRender).call(this);
        if (b) {
            this.invokeTriggers("onFieldRender");
            for (e in b) {
                d.push(b[e].el)
            }
            a = c.triggerEl = c.triggerCell = new Ext.CompositeElement(d, true)
        }
        c.inputCell = c.inputWrap
    },
    afterRender: function () {
        var a = this;
        a.autoSize();
        Ext.form.field.Base.prototype.afterRender.call(this);
        a.invokeTriggers("afterFieldRender")
    },
    onMouseDown: function () {
        if (!this.hasFocus) {
            Ext.getDoc().on(this.squashMouseUp)
        }
    },
    applyTriggers: function (h) {
        var j = this, c = j.getHideTrigger(), l = j.readOnly, m = j.orderedTriggers = [], k = j.repeatTriggerClick, b,
            g, d, a, e;
        if (!h) {
            h = {};
            if (j.triggerCls && !j.trigger1Cls) {
                j.trigger1Cls = j.triggerCls
            }
            for (e = 1; a = j["trigger" + e + "Cls"]; e++) {
                h["trigger" + e] = {
                    cls: a,
                    extraCls: "x-trigger-index-" + e,
                    handler: "onTrigger" + e + "Click",
                    compat4Mode: true,
                    scope: j
                }
            }
        }
        for (b in h) {
            if (h.hasOwnProperty(b)) {
                g = h[b];
                g.field = j;
                g.id = b;
                if ((l && g.hideOnReadOnly !== false) || (c && g.hidden !== false)) {
                    g.hidden = true
                }
                if (k && (g.repeatClick !== false)) {
                    g.repeatClick = true
                }
                d = h[b] = Ext.form.trigger.Trigger.create(g);
                m.push(d)
            }
        }
        Ext.Array.sort(m, Ext.form.trigger.Trigger.weightComparator);
        return h
    },
    invokeTriggers: function (a, c) {
        var e = this, d = e.getTriggers(), g, b;
        if (d) {
            for (g in d) {
                if (d.hasOwnProperty(g)) {
                    b = d[g];
                    b[a].apply(b, c || [])
                }
            }
        }
    },
    getTrigger: function (a) {
        return this.getTriggers()[a]
    },
    updateHideTrigger: function (a) {
        this.invokeTriggers(a ? "hide" : "show")
    },
    setEditable: function (a) {
        var b = this;
        b.editable = a;
        if (b.rendered) {
            b.setReadOnlyAttr(!a || b.readOnly)
        }
    },
    setReadOnly: function (g) {
        var d = this, c = d.getTriggers(), b = d.getHideTrigger(), a, e;
        g = !!g;
        Ext.form.field.Base.prototype.setReadOnly.call(this, g);
        if (d.rendered) {
            d.setReadOnlyAttr(g || !d.editable)
        }
        if (c) {
            for (e in c) {
                a = c[e];
                if (a.hideOnReadOnly === true || (a.hideOnReadOnly !== false && !b)) {
                    a.setVisible(!g)
                }
            }
        }
    },
    setReadOnlyAttr: function (d) {
        var b = this, a = "readonly", c = b.inputEl.dom;
        if (d) {
            c.setAttribute(a, a)
        } else {
            c.removeAttribute(a)
        }
        if (b.ariaRole) {
            b.ariaEl.dom.setAttribute("aria-readonly", !!d)
        }
    },
    processRawValue: function (b) {
        var a = this, d = a.stripCharsRe, c;
        if (d) {
            c = b.replace(d, "");
            if (c !== b) {
                a.setRawValue(c);
                b = c
            }
        }
        return b
    },
    onDisable: function () {
        Ext.form.field.Base.prototype.onDisable.call(this);
        if (Ext.isIE) {
            this.inputEl.dom.unselectable = "on"
        }
    },
    onEnable: function () {
        Ext.form.field.Base.prototype.onEnable.call(this);
        if (Ext.isIE) {
            this.inputEl.dom.unselectable = ""
        }
    },
    onKeyDown: function (a) {
        this.fireEvent("keydown", this, a)
    },
    onKeyUp: function (a) {
        this.fireEvent("keyup", this, a)
    },
    onKeyPress: function (a) {
        this.fireEvent("keypress", this, a)
    },
    reset: function () {
        Ext.form.field.Base.prototype.reset.call(this);
        this.applyEmptyText()
    },
    applyEmptyText: function () {
        var b = this, a = b.emptyText, c;
        if (b.rendered && a) {
            c = b.getRawValue().length < 1 && !b.hasFocus;
            if (Ext.supports.Placeholder) {
                b.inputEl.dom.placeholder = a
            } else {
                if (c) {
                    b.setRawValue(a);
                    b.valueContainsPlaceholder = true
                }
            }
            if (c) {
                b.inputEl.addCls(b.emptyUICls)
            } else {
                b.inputEl.removeCls(b.emptyUICls)
            }
            b.autoSize()
        }
    },
    afterFirstLayout: function () {
        Ext.form.field.Base.prototype.afterFirstLayout.call(this);
        if (Ext.isIE && this.disabled) {
            var a = this.inputEl;
            if (a) {
                a.dom.unselectable = "on"
            }
        }
    },
    toggleInvalidCls: function (a) {
        var b = a ? "addCls" : "removeCls";
        Ext.form.field.Base.prototype.toggleInvalidCls.call(this);
        this.triggerWrap[b](this.triggerWrapInvalidCls);
        this.inputWrap[b](this.inputWrapInvalidCls)
    },
    beforeFocus: function () {
        var b = this, c = b.inputEl, a = b.emptyText, d;
        Ext.form.field.Base.prototype.beforeFocus.apply(this, arguments);
        if ((a && !Ext.supports.Placeholder) && (c.dom.value === b.emptyText && b.valueContainsPlaceholder)) {
            b.setRawValue("");
            d = true;
            c.removeCls(b.emptyUICls);
            b.valueContainsPlaceholder = false
        } else {
            if (Ext.supports.Placeholder) {
                c.removeCls(b.emptyUICls)
            }
        }
    },
    onFocus: function (b) {
        var a = this;
        Ext.form.field.Base.prototype.onFocus.apply(this, arguments);
        if (a.selectOnFocus) {
            a.inputEl.dom.select()
        }
        if (a.emptyText) {
            a.autoSize()
        }
        a.addCls(a.fieldFocusCls);
        a.triggerWrap.addCls(a.triggerWrapFocusCls);
        a.inputWrap.addCls(a.inputWrapFocusCls);
        a.invokeTriggers("onFieldFocus", [b])
    },
    onBlur: function (b) {
        var a = this;
        Ext.form.field.Base.prototype.onBlur.apply(this, arguments);
        a.removeCls(a.fieldFocusCls);
        a.triggerWrap.removeCls(a.triggerWrapFocusCls);
        a.inputWrap.removeCls(a.inputWrapFocusCls);
        a.invokeTriggers("onFieldBlur", [b])
    },
    completeEdit: function (a) {
        Ext.form.field.Base.prototype.completeEdit.call(this, a);
        this.applyEmptyText()
    },
    filterKeys: function (b) {
        if ((b.ctrlKey && !b.altKey) || b.isSpecialKey()) {
            return
        }
        var a = String.fromCharCode(b.getCharCode());
        if (!this.maskRe.test(a)) {
            b.stopEvent()
        }
    },
    getState: function () {
        return this.addPropertyToState(Ext.form.field.Base.prototype.getState.call(this), "value")
    },
    applyState: function (a) {
        Ext.form.field.Base.prototype.applyState.apply(this, arguments);
        if (a.hasOwnProperty("value")) {
            this.setValue(a.value)
        }
    },
    getRawValue: function () {
        var b = this, a = Ext.form.field.Base.prototype.getRawValue.call(this);
        if (a === b.emptyText && b.valueContainsPlaceholder) {
            a = ""
        }
        return a
    },
    setValue: function (b) {
        var a = this, c = a.inputEl;
        if (c && a.emptyText && !Ext.isEmpty(b)) {
            c.removeCls(a.emptyUICls);
            a.valueContainsPlaceholder = false
        }
        Ext.form.field.Base.prototype.setValue.apply(this, arguments);
        a.applyEmptyText();
        return a
    },
    getErrors: function (l) {
        l = arguments.length ? (l == null ? "" : l) : this.processRawValue(this.getRawValue());
        var g = this, j = Ext.form.field.Base.prototype.getErrors.call(this, l), a = g.validator, d = g.vtype,
            h = Ext.form.field.VTypes, i = g.regex, k = Ext.String.format, b, e, c;
        if (Ext.isFunction(a)) {
            b = a.call(g, l);
            if (b !== true) {
                j.push(b)
            }
        }
        e = g.allowOnlyWhitespace ? l : Ext.String.trim(l);
        if (e.length < 1 || (l === g.emptyText && g.valueContainsPlaceholder)) {
            if (!g.allowBlank) {
                j.push(g.blankText)
            }
            if (!g.validateBlank) {
                return j
            }
            c = true
        }
        if (!c && l.length < g.minLength) {
            j.push(k(g.minLengthText, g.minLength))
        }
        if (l.length > g.maxLength) {
            j.push(k(g.maxLengthText, g.maxLength))
        }
        if (d) {
            if (!h[d](l, g)) {
                j.push(g.vtypeText || h[d + "Text"])
            }
        }
        if (i && !i.test(l)) {
            j.push(g.regexText || g.invalidText)
        }
        return j
    },
    selectText: function (h, b) {
        var g = this, d = g.getRawValue(), a = d.length, e = g.inputEl.dom, c;
        if (a > 0) {
            h = h === undefined ? 0 : Math.min(h, a);
            b = b === undefined ? a : Math.min(b, a);
            if (e.setSelectionRange) {
                e.setSelectionRange(h, b)
            } else {
                if (e.createTextRange) {
                    c = e.createTextRange();
                    c.moveStart("character", h);
                    c.moveEnd("character", b - a);
                    c.select()
                }
            }
        }
    },
    getGrowWidth: function () {
        return this.inputEl.dom.value
    },
    autoSize: function () {
        var c = this, b, h, e, g, a, d;
        if (c.grow && c.rendered && c.getSizeModel().width.auto) {
            g = c.inputEl;
            b = c.getTriggers();
            e = 0;
            d = Ext.util.Format.htmlEncode(c.getGrowWidth() || (c.hasFocus ? "" : c.emptyText) || "");
            d += c.growAppend;
            for (h in b) {
                e += b[h].el.getWidth()
            }
            a = g.getTextWidth(d) + e + c.inputWrap.getBorderWidth("lr") + c.triggerWrap.getBorderWidth("lr");
            a = Math.min(Math.max(a, c.growMin), c.growMax);
            c.bodyEl.setWidth(a);
            c.updateLayout();
            c.fireEvent("autosize", c, a)
        }
    },
    onDestroy: function () {
        var a = this;
        a.invokeTriggers("destroy");
        Ext.destroy(a.triggerRepeater);
        Ext.form.field.Base.prototype.onDestroy.call(this)
    },
    onTriggerClick: Ext.emptyFn,
    privates: {
        getTdType: function () {
            return "textfield"
        }
    },
    deprecated: {
        5: {
            methods: {
                getTriggerWidth: function () {
                    var b = this.getTriggers(), a = 0, c;
                    if (b && this.rendered) {
                        for (c in b) {
                            if (b.hasOwnProperty(c)) {
                                a += b[c].el.getWidth()
                            }
                        }
                    }
                    return a
                }
            }
        }
    }
}, 0, ["textfield"], ["component", "box", "field", "textfield"], {
    component: true,
    box: true,
    field: true,
    textfield: true
}, ["widget.textfield"], 0, [Ext.form.field, "Text", Ext.form, "TextField", Ext.form, "Text"], 0));
(Ext.cmd.derive("Ext.form.field.TextArea", Ext.form.field.Text, {
    alternateClassName: "Ext.form.TextArea",
    fieldSubTpl: ['<textarea id="{id}" data-ref="inputEl" {inputAttrTpl}', '<tpl if="name"> name="{name}"</tpl>', '<tpl if="placeholder"> placeholder="{placeholder}"</tpl>', '<tpl if="maxLength !== undefined"> maxlength="{maxLength}"</tpl>', '<tpl if="readOnly"> readonly="readonly"</tpl>', '<tpl if="disabled"> disabled="disabled"</tpl>', '<tpl if="tabIdx != null"> tabindex="{tabIdx}"</tpl>', ' class="{fieldCls} {typeCls} {typeCls}-{ui} {inputCls}" ', '<tpl if="fieldStyle"> style="{fieldStyle}"</tpl>', '<tpl foreach="inputElAriaAttributes"> {$}="{.}"</tpl>', ' autocomplete="off">\\n', '<tpl if="value">{[Ext.util.Format.htmlEncode(values.value)]}</tpl>', "</textarea>", {disableFormats: true}],
    growMin: 60,
    growMax: 1000,
    growAppend: "\\n-",
    enterIsSpecial: false,
    preventScrollbars: false,
    returnRe: /\\r/g,
    inputCls: "x-form-textarea",
    extraFieldBodyCls: "x-form-textarea-body",
    ariaAttributes: {"aria-multiline": true},
    getSubTplData: function (b) {
        var d = this, c = d.getFieldStyle(), a = Ext.form.field.Text.prototype.getSubTplData.apply(this, arguments);
        if (d.grow) {
            if (d.preventScrollbars) {
                a.fieldStyle = (c || "") + ";overflow:hidden;height:" + d.growMin + "px"
            }
        }
        return a
    },
    afterRender: function () {
        var a = this;
        Ext.form.field.Text.prototype.afterRender.apply(this, arguments);
        a.needsMaxCheck = a.enforceMaxLength && a.maxLength !== Number.MAX_VALUE && !Ext.supports.TextAreaMaxLength;
        if (a.needsMaxCheck) {
            a.inputEl.on("paste", a.onPaste, a)
        }
    },
    transformRawValue: function (a) {
        return this.stripReturns(a)
    },
    getValue: function () {
        return this.stripReturns(Ext.form.field.Text.prototype.getValue.call(this))
    },
    valueToRaw: function (a) {
        a = this.stripReturns(a);
        return Ext.form.field.Text.prototype.valueToRaw.call(this, a)
    },
    stripReturns: function (a) {
        if (a && typeof a === "string") {
            a = a.replace(this.returnRe, "")
        }
        return a
    },
    onPaste: function () {
        var a = this;
        if (!a.pasteTask) {
            a.pasteTask = new Ext.util.DelayedTask(a.pasteCheck, a)
        }
        a.pasteTask.delay(1)
    },
    pasteCheck: function () {
        var b = this, c = b.getValue(), a = b.maxLength;
        if (c.length > a) {
            c = c.substr(0, a);
            b.setValue(c)
        }
    },
    fireKey: function (d) {
        var b = this, a = d.getKey(), c;
        if (d.isSpecialKey() && (b.enterIsSpecial || (a !== d.ENTER || d.hasModifier()))) {
            b.fireEvent("specialkey", b, d)
        }
        if (b.needsMaxCheck && a !== d.BACKSPACE && a !== d.DELETE && !d.isNavKeyPress() && !b.isCutCopyPasteSelectAll(d, a)) {
            c = b.getValue();
            if (c.length >= b.maxLength) {
                d.stopEvent()
            }
        }
    },
    isCutCopyPasteSelectAll: function (b, a) {
        if (b.ctrlKey) {
            return a === b.A || a === b.C || a === b.V || a === b.X
        }
        return false
    },
    autoSize: function () {
        var c = this, e, a, b, d;
        if (c.grow && c.rendered && c.getSizeModel().height.auto) {
            e = c.inputEl;
            b = e.getWidth(true);
            d = Ext.util.Format.htmlEncode(e.dom.value) || "&#160;";
            d += c.growAppend;
            d = d.replace(/\\n/g, "<br/>");
            a = Ext.util.TextMetrics.measure(e, d, b).height + e.getPadding("tb") + c.inputWrap.getBorderWidth("tb") + c.triggerWrap.getBorderWidth("tb");
            a = Math.min(Math.max(a, c.growMin), c.growMax);
            c.bodyEl.setHeight(a);
            c.updateLayout();
            c.fireEvent("autosize", c, a)
        }
    },
    beforeDestroy: function () {
        var a = this.pasteTask;
        if (a) {
            a.cancel();
            this.pasteTask = null
        }
        Ext.form.field.Text.prototype.beforeDestroy.call(this)
    }
}, 0, ["textarea", "textareafield"], ["component", "box", "field", "textfield", "textareafield", "textarea"], {
    component: true,
    box: true,
    field: true,
    textfield: true,
    textareafield: true,
    textarea: true
}, ["widget.textarea", "widget.textareafield"], 0, [Ext.form.field, "TextArea", Ext.form, "TextArea"], 0));
(Ext.cmd.derive("Ext.window.MessageBox", Ext.window.Window, {
    OK: 1,
    YES: 2,
    NO: 4,
    CANCEL: 8,
    OKCANCEL: 9,
    YESNO: 6,
    YESNOCANCEL: 14,
    INFO: "x-message-box-info",
    WARNING: "x-message-box-warning",
    QUESTION: "x-message-box-question",
    ERROR: "x-message-box-error",
    hideMode: "offsets",
    closeAction: "hide",
    resizable: false,
    scrollable: true,
    title: "&#160;",
    defaultMinWidth: 250,
    defaultMaxWidth: 600,
    defaultMinHeight: 110,
    defaultMaxHeight: 500,
    minWidth: null,
    maxWidth: null,
    minHeight: null,
    maxHeight: null,
    constrain: true,
    cls: ["x-message-box", "x-hidden-offsets"],
    layout: {type: "vbox", align: "stretch"},
    shrinkWrapDock: true,
    defaultTextHeight: 75,
    minProgressWidth: 250,
    minPromptWidth: 250,
    buttonText: {ok: "OK", yes: "Yes", no: "No", cancel: "Cancel"},
    buttonIds: ["ok", "yes", "no", "cancel"],
    titleText: {confirm: "Confirm", prompt: "Prompt", wait: "Loading...", alert: "Attention"},
    baseIconCls: "x-message-box-icon",
    ariaRole: "alertdialog",
    makeButton: function (a) {
        var b = this.buttonIds[a];
        return new Ext.button.Button({
            handler: this.btnCallback,
            itemId: b,
            scope: this,
            text: this.buttonText[b],
            minWidth: 75
        })
    },
    btnCallback: function (a, c) {
        var b = this, d, e;
        if (c && c.type === "keydown" && !c.isSpecialKey()) {
            c.getTarget(null, null, true).on({
                keyup: function (g) {
                    b.btnCallback(a, g)
                }, single: true
            });
            return
        }
        if (b.cfg.prompt || b.cfg.multiline) {
            if (b.cfg.multiline) {
                e = b.textArea
            } else {
                e = b.textField
            }
            d = e.getValue();
            e.reset()
        }
        b.hide();
        b.userCallback(a.itemId, d, b.cfg)
    },
    hide: function () {
        var b = this, a = b.cfg ? b.cfg.cls : "";
        b.progressBar.reset();
        if (a) {
            b.removeCls(a)
        }
        Ext.window.Window.prototype.hide.apply(this, arguments)
    },
    constructor: function (a) {
        var b = this;
        Ext.window.Window.prototype.constructor.apply(this, arguments);
        b.minWidth = b.defaultMinWidth = (b.minWidth || b.defaultMinWidth);
        b.maxWidth = b.defaultMaxWidth = (b.maxWidth || b.defaultMaxWidth);
        b.minHeight = b.defaultMinHeight = (b.minHeight || b.defaultMinHeight);
        b.maxHeight = b.defaultMaxHeight = (b.maxHeight || b.defaultMaxHeight)
    },
    initComponent: function (a) {
        var e = this, b = e.id, d, c;
        e.title = e.title || "&#160;";
        e.iconCls = e.iconCls || "";
        e.topContainer = new Ext.container.Container({
            layout: "hbox",
            padding: 10,
            style: {overflow: "hidden"},
            items: [e.iconComponent = new Ext.Component({cls: e.baseIconCls}), e.promptContainer = new Ext.container.Container({
                flex: 1,
                layout: {type: "vbox", align: "stretch"},
                items: [e.msg = new Ext.Component({
                    id: b + "-msg",
                    cls: e.baseCls + "-text"
                }), e.textField = new Ext.form.field.Text({
                    id: b + "-textfield",
                    enableKeyEvents: true,
                    listeners: {keydown: e.onPromptKey, scope: e}
                }), e.textArea = new Ext.form.field.TextArea({id: b + "-textarea", height: 75})]
            })]
        });
        e.progressBar = new Ext.ProgressBar({id: b + "-progressbar", margin: "0 10 10 10"});
        e.items = [e.topContainer, e.progressBar];
        e.msgButtons = [];
        for (d = 0; d < 4; d++) {
            c = e.makeButton(d);
            e.msgButtons[c.itemId] = c;
            e.msgButtons.push(c)
        }
        e.bottomTb = new Ext.toolbar.Toolbar({
            id: b + "-toolbar",
            ui: "footer",
            dock: "bottom",
            layout: {pack: "center"},
            items: [e.msgButtons[0], e.msgButtons[1], e.msgButtons[2], e.msgButtons[3]]
        });
        e.dockedItems = [e.bottomTb];
        e.on("close", e.onClose, e);
        Ext.window.Window.prototype.initComponent.call(this)
    },
    onClose: function () {
        var a = this.header.child("[type=close]");
        if (a) {
            a.itemId = "cancel";
            this.btnCallback(a);
            delete a.itemId
        }
    },
    onPromptKey: function (a, c) {
        var b = this;
        if (c.keyCode === c.RETURN || c.keyCode === 10) {
            if (b.msgButtons.ok.isVisible()) {
                b.msgButtons.ok.handler.call(b, b.msgButtons.ok)
            } else {
                if (b.msgButtons.yes.isVisible()) {
                    b.msgButtons.yes.handler.call(b, b.msgButtons.yes)
                }
            }
        }
    },
    reconfigure: function (c) {
        var t = this, q = 0, g = true, u = t.buttonText, e = t.resizer, o = t.header, s = o && !o.isHeader,
            d = c && (c.message || c.msg), v, m, j, p, r, h, b, k, n, l, a;
        t.updateButtonText();
        t.cfg = c = c || {};
        l = c.wait;
        if (c.width) {
            m = c.width
        }
        if (c.height) {
            j = c.height
        }
        t.minWidth = c.minWidth || t.defaultMinWidth;
        t.maxWidth = c.maxWidth || t.defaultMaxWidth;
        t.minHeight = c.minHeight || t.defaultMinHeight;
        t.maxHeight = c.maxHeight || t.defaultMaxHeight;
        if (e) {
            v = e.resizeTracker;
            e.minWidth = v.minWidth = t.minWidth;
            e.maxWidth = v.maxWidth = t.maxWidth;
            e.minHeight = v.minHeight = t.minHeight;
            e.maxHeight = v.maxHeight = t.maxHeight
        }
        delete t.defaultFocus;
        if (c.defaultFocus) {
            t.defaultFocus = c.defaultFocus
        }
        t.animateTarget = c.animateTarget || undefined;
        t.modal = c.modal !== false;
        t.setTitle(c.title || (s && o.title) || t.title);
        t.setIconCls(c.iconCls || (s && o.iconCls) || t.iconCls);
        if (Ext.isObject(c.buttons)) {
            t.buttonText = c.buttons;
            q = 0
        } else {
            t.buttonText = c.buttonText || t.buttonText;
            q = Ext.isNumber(c.buttons) ? c.buttons : 0
        }
        q = q | t.updateButtonText();
        t.buttonText = u;
        Ext.suspendLayouts();
        t.width = t.height = null;
        if (m || j) {
            if (m) {
                t.setWidth(m)
            }
            if (j) {
                t.setHeight(j)
            }
        }
        t.hidden = false;
        if (!t.rendered) {
            t.render(Ext.getBody())
        }
        t.closable = c.closable !== false && !l;
        o = t.header;
        if (o) {
            a = o.child("[type=close]");
            if (a) {
                a.setVisible(t.closable)
            }
            if (!c.title && !t.closable && !c.iconCls) {
                o.hide()
            } else {
                o.show()
            }
        }
        t.liveDrag = !c.proxyDrag;
        t.userCallback = Ext.Function.bindCallback(c.callback || c.fn || Ext.emptyFn, c.scope || Ext.global);
        t.setIcon(c.icon);
        b = t.msg;
        if (d) {
            b.setHtml(d);
            b.show()
        } else {
            b.hide()
        }
        r = t.textArea;
        h = t.textField;
        if (c.prompt || c.multiline) {
            t.multiline = c.multiline;
            if (c.multiline) {
                r.setValue(c.value);
                r.setHeight(c.defaultTextHeight || t.defaultTextHeight);
                r.show();
                h.hide();
                t.defaultFocus = r
            } else {
                h.setValue(c.value);
                r.hide();
                h.show();
                t.defaultFocus = h
            }
        } else {
            r.hide();
            h.hide()
        }
        k = t.progressBar;
        if (c.progress || l) {
            k.show();
            t.updateProgress(0, c.progressText);
            if (l) {
                k.wait(l === true ? c.waitConfig : l)
            }
        } else {
            k.hide()
        }
        n = t.msgButtons;
        for (p = 0; p < 4; p++) {
            if (q & Math.pow(2, p)) {
                if (!t.defaultFocus) {
                    t.defaultFocus = n[p]
                }
                n[p].show();
                g = false
            } else {
                n[p].hide()
            }
        }
        if (g) {
            t.bottomTb.hide()
        } else {
            t.bottomTb.show()
        }
        Ext.resumeLayouts(true)
    },
    updateButtonText: function () {
        var d = this, c = d.buttonText, b = 0, e, a;
        for (e in c) {
            if (c.hasOwnProperty(e)) {
                a = d.msgButtons[e];
                if (a) {
                    if (d.cfg && d.cfg.buttonText) {
                        b = b | Math.pow(2, Ext.Array.indexOf(d.buttonIds, e))
                    }
                    if (a.text !== c[e]) {
                        a.setText(c[e])
                    }
                }
            }
        }
        return b
    },
    show: function (a) {
        var c = this, b;
        a = a || {};
        if (Ext.Component.layoutSuspendCount) {
            Ext.on({
                resumelayouts: function () {
                    c.show(a)
                }, single: true
            });
            return c
        }
        c.reconfigure(a);
        if (a.cls) {
            c.addCls(a.cls)
        }
        b = c.query("textfield:not([hidden]),textarea:not([hidden]),button:not([hidden])");
        c.preventFocusOnActivate = !b.length;
        c.hidden = true;
        Ext.window.Window.prototype.show.call(this);
        return c
    },
    onShow: function () {
        Ext.window.Window.prototype.onShow.apply(this, arguments);
        this.center()
    },
    updateText: function (a) {
        this.msg.setHtml(a)
    },
    setIcon: function (d, c, a) {
        var e = this, g = e.iconComponent, b = e.messageIconCls;
        if (b) {
            g.removeCls(b)
        }
        if (d) {
            g.show();
            if (c || a) {
                g.setSize(c || g.getWidth(), a || g.getHeight())
            }
            g.addCls("x-dlg-icon");
            g.addCls(e.messageIconCls = d)
        } else {
            g.removeCls("x-dlg-icon");
            g.hide()
        }
        return e
    },
    updateProgress: function (c, a, b) {
        this.progressBar.updateProgress(c, a);
        if (b) {
            this.updateText(b)
        }
        return this
    },
    onEsc: function () {
        if (this.closable !== false) {
            Ext.window.Window.prototype.onEsc.apply(this, arguments)
        }
    },
    confirm: function (a, d, c, b) {
        if (Ext.isString(a)) {
            a = {title: a, icon: this.QUESTION, message: d, buttons: this.YESNO, callback: c, scope: b}
        }
        return this.show(a)
    },
    prompt: function (g, d, c, b, a, e) {
        if (Ext.isString(g)) {
            g = {
                prompt: true,
                title: g,
                minWidth: this.minPromptWidth,
                message: d,
                buttons: this.OKCANCEL,
                callback: c,
                scope: b,
                multiline: a,
                value: e
            }
        }
        return this.show(g)
    },
    wait: function (b, c, a) {
        if (Ext.isString(b)) {
            b = {
                title: c,
                message: b,
                closable: false,
                wait: true,
                modal: true,
                minWidth: this.minProgressWidth,
                waitConfig: a
            }
        }
        return this.show(b)
    },
    alert: function (d, c, b, a) {
        if (Ext.isString(d)) {
            d = {title: d, message: c, buttons: this.OK, fn: b, scope: a, minWidth: this.minWidth}
        }
        return this.show(d)
    },
    progress: function (c, b, a) {
        if (Ext.isString(c)) {
            c = {title: c, message: b, progress: true, progressText: a}
        }
        return this.show(c)
    }
}, 1, ["messagebox"], ["component", "box", "container", "panel", "window", "messagebox"], {
    component: true,
    box: true,
    container: true,
    panel: true,
    window: true,
    messagebox: true
}, ["widget.messagebox"], 0, [Ext.window, "MessageBox"], function (a) {
    Ext.onInternalReady(function () {
        Ext.MessageBox = Ext.Msg = new a()
    })
}));
(Ext.cmd.derive("Ext.form.Basic", Ext.util.Observable, {
    alternateClassName: "Ext.form.BasicForm",
    taskDelay: 10,
    constructor: function (b, c) {
        var d = this, a;
        d.owner = b;
        d.fieldMonitors = {
            validitychange: d.checkValidityDelay,
            enable: d.checkValidityDelay,
            disable: d.checkValidityDelay,
            dirtychange: d.checkDirtyDelay,
            errorchange: d.checkErrorDelay,
            scope: d
        };
        d.checkValidityTask = new Ext.util.DelayedTask(d.checkValidity, d);
        d.checkDirtyTask = new Ext.util.DelayedTask(d.checkDirty, d);
        d.checkErrorTask = new Ext.util.DelayedTask(d.checkError, d);
        d.monitor = new Ext.container.Monitor({
            selector: "[isFormField]:not([excludeForm])",
            scope: d,
            addHandler: d.onFieldAdd,
            removeHandler: d.onFieldRemove,
            invalidateHandler: d.onMonitorInvalidate
        });
        d.monitor.bind(b);
        Ext.apply(d, c);
        if (Ext.isString(d.paramOrder)) {
            d.paramOrder = d.paramOrder.split(/[\\s,|]/)
        }
        a = d.reader;
        if (a && !a.isReader) {
            if (typeof a === "string") {
                a = {type: a}
            }
            d.reader = Ext.createByAlias("reader." + a.type, a)
        }
        a = d.errorReader;
        if (a && !a.isReader) {
            if (typeof a === "string") {
                a = {type: a}
            }
            d.errorReader = Ext.createByAlias("reader." + a.type, a)
        }
        Ext.util.Observable.prototype.constructor.call(this)
    },
    initialize: function () {
        this.initialized = true;
        this.onValidityChange(!this.hasInvalidField())
    },
    timeout: 30,
    paramsAsHash: false,
    waitTitle: "Please Wait...",
    trackResetOnLoad: false,
    wasDirty: false,
    destroy: function () {
        var b = this, a = b.monitor;
        if (a) {
            a.unbind();
            b.monitor = null
        }
        b.clearListeners();
        b.checkValidityTask.cancel();
        b.checkDirtyTask.cancel();
        b.checkErrorTask.cancel();
        b.checkValidityTask = b.checkDirtyTask = b.checkErrorTask = null;
        Ext.util.Observable.prototype.destroy.call(this)
    },
    onFieldAdd: function (a) {
        a.on(this.fieldMonitors);
        this.onMonitorInvalidate()
    },
    onFieldRemove: function (a) {
        a.un(this.fieldMonitors);
        this.onMonitorInvalidate()
    },
    onMonitorInvalidate: function () {
        if (this.initialized) {
            this.checkValidityDelay()
        }
    },
    getFields: function () {
        return this.monitor.getItems()
    },
    getBoundItems: function () {
        var a = this._boundItems;
        if (!a || a.getCount() === 0) {
            a = this._boundItems = new Ext.util.MixedCollection();
            a.addAll(this.owner.query("[formBind]"))
        }
        return a
    },
    hasInvalidField: function () {
        return !!this.getFields().findBy(function (c) {
            var a = c.preventMark, b;
            c.preventMark = true;
            b = c.isValid();
            c.preventMark = a;
            return !b
        })
    },
    isValid: function () {
        var a = this, b;
        Ext.suspendLayouts();
        b = a.getFields().filterBy(function (c) {
            return !c.validate()
        });
        Ext.resumeLayouts(true);
        return b.length < 1
    },
    checkValidity: function () {
        var b = this, a;
        if (b.destroyed) {
            return
        }
        a = !b.hasInvalidField();
        if (a !== b.wasValid) {
            b.onValidityChange(a);
            b.fireEvent("validitychange", b, a);
            b.wasValid = a
        }
    },
    checkValidityDelay: function () {
        var a = this.taskDelay;
        if (a) {
            this.checkValidityTask.delay(a)
        } else {
            this.checkValidity()
        }
    },
    checkError: function () {
        this.fireEvent("errorchange", this)
    },
    checkErrorDelay: function () {
        var a = this.taskDelay;
        if (a) {
            this.checkErrorTask.delay(a)
        } else {
            this.checkError()
        }
    },
    onValidityChange: function (g) {
        var d = this.getBoundItems(), b, c, a, e;
        if (d) {
            b = d.items;
            a = b.length;
            for (c = 0; c < a; c++) {
                e = b[c];
                if (e.disabled === g) {
                    e.setDisabled(!g)
                }
            }
        }
    },
    isDirty: function () {
        return !!this.getFields().findBy(function (a) {
            return a.isDirty()
        })
    },
    checkDirtyDelay: function () {
        var a = this.taskDelay;
        if (a) {
            this.checkDirtyTask.delay(a)
        } else {
            this.checkDirty()
        }
    },
    checkDirty: function () {
        var b = this, a;
        if (b.destroyed) {
            return
        }
        a = this.isDirty();
        if (a !== this.wasDirty) {
            this.fireEvent("dirtychange", this, a);
            this.wasDirty = a
        }
    },
    hasUpload: function () {
        return !!this.getFields().findBy(function (a) {
            return a.isFileUpload()
        })
    },
    doAction: function (b, a) {
        if (Ext.isString(b)) {
            b = Ext.ClassManager.instantiateByAlias("formaction." + b, Ext.apply({}, a, {form: this}))
        }
        if (this.fireEvent("beforeaction", this, b) !== false) {
            this.beforeAction(b);
            Ext.defer(b.run, 100, b)
        }
        return this
    },
    submit: function (a) {
        a = a || {};
        var b = this, c;
        if (a.standardSubmit || b.standardSubmit) {
            c = "standardsubmit"
        } else {
            c = b.api ? "directsubmit" : "submit"
        }
        return b.doAction(c, a)
    },
    load: function (a) {
        return this.doAction(this.api ? "directload" : "load", a)
    },
    updateRecord: function (c) {
        c = c || this._record;
        if (!c) {
            return this
        }
        var b = c.self.fields, d = this.getFieldValues(), h = {}, g = 0, a = b.length, e;
        for (; g < a; ++g) {
            e = b[g].name;
            if (d.hasOwnProperty(e)) {
                h[e] = d[e]
            }
        }
        c.beginEdit();
        c.set(h);
        c.endEdit();
        return this
    },
    loadRecord: function (a) {
        this._record = a;
        return this.setValues(a.getData())
    },
    getRecord: function () {
        return this._record
    },
    beforeAction: function (c) {
        var g = this, b = c.waitMsg, j = "x-mask-loading", d = g.getFields().items, e, i = d.length, h, a;
        for (e = 0; e < i; e++) {
            h = d[e];
            if (h.isFormField && h.syncValue) {
                h.syncValue()
            }
        }
        if (b) {
            a = g.waitMsgTarget;
            if (a === true) {
                g.owner.el.mask(b, j)
            } else {
                if (a) {
                    a = g.waitMsgTarget = Ext.get(a);
                    a.mask(b, j)
                } else {
                    g.floatingAncestor = g.owner.up("[floating]");
                    if (g.floatingAncestor) {
                        g.savePreventFocusOnActivate = g.floatingAncestor.preventFocusOnActivate;
                        g.floatingAncestor.preventFocusOnActivate = true
                    }
                    Ext.MessageBox.wait(b, c.waitTitle || g.waitTitle)
                }
            }
        }
    },
    afterAction: function (c, e) {
        var a = this;
        if (c.waitMsg) {
            var b = Ext.MessageBox, d = a.waitMsgTarget;
            if (d === true) {
                a.owner.el.unmask()
            } else {
                if (d) {
                    d.unmask()
                } else {
                    b.hide()
                }
            }
        }
        if (a.floatingAncestor) {
            a.floatingAncestor.preventFocusOnActivate = a.savePreventFocusOnActivate
        }
        if (e) {
            if (c.reset) {
                a.reset()
            }
            Ext.callback(c.success, c.scope || c, [a, c]);
            a.fireEvent("actioncomplete", a, c)
        } else {
            Ext.callback(c.failure, c.scope || c, [a, c]);
            a.fireEvent("actionfailed", a, c)
        }
    },
    findField: function (a) {
        return this.getFields().findBy(function (b) {
            return b.id === a || b.name === a || b.dataIndex === a
        })
    },
    markInvalid: function (j) {
        var d = this, h, a, b, g, c;

        function i(e, l) {
            var k = d.findField(e);
            if (k) {
                k.markInvalid(l)
            }
        }

        if (Ext.isArray(j)) {
            a = j.length;
            for (h = 0; h < a; h++) {
                b = j[h];
                i(b.id || b.field, b.msg || b.message)
            }
        } else {
            if (j instanceof Ext.data.ErrorCollection) {
                a = j.items.length;
                for (h = 0; h < a; h++) {
                    b = j.items[h];
                    i(b.field, b.message)
                }
            } else {
                for (c in j) {
                    if (j.hasOwnProperty(c)) {
                        g = j[c];
                        i(c, g, j)
                    }
                }
            }
        }
        return this
    },
    setValues: function (b) {
        var d = this, a, c, g;

        function e(h, j) {
            var i = d.findField(h);
            if (i) {
                i.setValue(j);
                if (d.trackResetOnLoad) {
                    i.resetOriginalValue()
                }
            }
        }

        Ext.suspendLayouts();
        if (Ext.isArray(b)) {
            c = b.length;
            for (a = 0; a < c; a++) {
                g = b[a];
                e(g.id, g.value)
            }
        } else {
            Ext.iterate(b, e)
        }
        Ext.resumeLayouts(true);
        return this
    },
    getValues: function (j, k, o, m, c) {
        var n = {}, h = this.getFields().items, p = h.length, g = Ext.isArray, l, e, d, b, a, i;
        for (i = 0; i < p; i++) {
            l = h[i];
            if (!k || l.isDirty()) {
                e = l[m ? "getModelData" : "getSubmitData"](o, c);
                if (Ext.isObject(e)) {
                    for (a in e) {
                        if (e.hasOwnProperty(a)) {
                            d = e[a];
                            if (o && d === "") {
                                d = l.emptyText || ""
                            }
                            if (!l.isRadio) {
                                if (n.hasOwnProperty(a)) {
                                    b = n[a];
                                    if (!g(b)) {
                                        b = n[a] = [b]
                                    }
                                    if (g(d)) {
                                        n[a] = b.concat(d)
                                    } else {
                                        b.push(d)
                                    }
                                } else {
                                    n[a] = d
                                }
                            } else {
                                n[a] = n[a] || d
                            }
                        }
                    }
                }
            }
        }
        if (j) {
            n = Ext.Object.toQueryString(n)
        }
        return n
    },
    getFieldValues: function (a) {
        return this.getValues(false, a, false, true)
    },
    clearInvalid: function () {
        Ext.suspendLayouts();
        var b = this, a = b.getFields().items, c, d = a.length;
        for (c = 0; c < d; c++) {
            a[c].clearInvalid()
        }
        Ext.resumeLayouts(true);
        return b
    },
    reset: function (b) {
        Ext.suspendLayouts();
        var c = this, a = c.getFields().items, d, e = a.length;
        for (d = 0; d < e; d++) {
            a[d].reset()
        }
        Ext.resumeLayouts(true);
        if (b === true) {
            delete c._record
        }
        return c
    },
    applyToFields: function (c) {
        var a = this.getFields().items, b, d = a.length;
        for (b = 0; b < d; b++) {
            Ext.apply(a[b], c)
        }
        return this
    },
    applyIfToFields: function (c) {
        var a = this.getFields().items, b, d = a.length;
        for (b = 0; b < d; b++) {
            Ext.applyIf(a[b], c)
        }
        return this
    }
}, 1, 0, 0, 0, 0, 0, [Ext.form, "Basic", Ext.form, "BasicForm"], 0));
(Ext.cmd.derive("Ext.form.FieldAncestor", Ext.Mixin, {
    mixinConfig: {
        id: "fieldAncestor",
        after: {initInheritedState: "initFieldInheritedState"},
        before: {destroy: "onBeforeDestroy"}
    }, initFieldAncestor: function () {
        var a = this;
        a.monitor = new Ext.container.Monitor({
            scope: a,
            selector: "[isFormField]:not([excludeForm])",
            addHandler: a.onChildFieldAdd,
            removeHandler: a.onChildFieldRemove
        });
        a.initFieldDefaults()
    }, initMonitor: function () {
        this.monitor.bind(this)
    }, initFieldInheritedState: function (b) {
        var a = b.fieldDefaults, c = this.fieldDefaults;
        if (c) {
            if (a) {
                b.fieldDefaults = Ext.apply(Ext.Object.chain(a), c)
            } else {
                b.fieldDefaults = c
            }
        }
    }, onChildFieldAdd: function (b) {
        var a = this;
        a.mon(b, "errorchange", a.handleFieldErrorChange, a);
        a.mon(b, "validitychange", a.handleFieldValidityChange, a)
    }, onChildFieldRemove: function (b) {
        var a = this;
        a.mun(b, "errorchange", a.handleFieldErrorChange, a);
        a.mun(b, "validitychange", a.handleFieldValidityChange, a)
    }, initFieldDefaults: function () {
        if (!this.fieldDefaults) {
            this.fieldDefaults = {}
        }
    }, handleFieldValidityChange: function (c, b) {
        var a = this;
        if (c !== a) {
            a.fireEvent("fieldvaliditychange", a, c, b);
            a.onFieldValidityChange(c, b)
        }
    }, handleFieldErrorChange: function (b, a) {
        var c = this;
        if (b !== c) {
            c.fireEvent("fielderrorchange", c, b, a);
            c.onFieldErrorChange(b, a)
        }
    }, onFieldValidityChange: Ext.emptyFn, onFieldErrorChange: Ext.emptyFn, onBeforeDestroy: function () {
        this.monitor.unbind()
    }
}, 0, 0, 0, 0, 0, 0, [Ext.form, "FieldAncestor"], 0));
(Ext.cmd.derive("Ext.layout.component.field.FieldContainer", Ext.layout.component.Auto, {
    type: "fieldcontainer", waitForOuterHeightInDom: true, waitForOuterWidthInDom: true, beginLayout: function (b) {
        var a = this.owner.containerEl;
        Ext.layout.component.Auto.prototype.beginLayout.apply(this, arguments);
        b.hasRawContent = true;
        a.setStyle("width", "");
        a.setStyle("height", "");
        b.containerElContext = b.getEl("containerEl")
    }, measureContentHeight: function (a) {
        return a.hasDomProp("containerLayoutDone") ? Ext.layout.component.Auto.prototype.measureContentHeight.apply(this, arguments) : NaN
    }, measureContentWidth: function (a) {
        return a.hasDomProp("containerLayoutDone") ? Ext.layout.component.Auto.prototype.measureContentWidth.apply(this, arguments) : NaN
    }, publishInnerHeight: function (c, b) {
        var a = this.owner;
        if (a.labelAlign === "top" && a.hasVisibleLabel()) {
            b -= a.labelEl.getHeight()
        }
        if (a.msgTarget === "under" && a.hasActiveError()) {
            b -= a.errorWrapEl.getHeight()
        }
        b -= a.bodyEl.getPadding("tb");
        c.containerElContext.setHeight(b)
    }, publishInnerWidth: function (c, b) {
        var a = this.owner;
        if (a.labelAlign !== "top" && a.hasVisibleLabel()) {
            b -= (a.labelWidth + (a.labelPad || 0))
        }
        if (a.msgTarget === "side" && a.hasActiveError()) {
            b -= a.errorWrapEl.getWidth()
        }
        b -= a.bodyEl.getPadding("lr");
        c.containerElContext.setWidth(b)
    }
}, 0, 0, 0, 0, ["layout.fieldcontainer"], 0, [Ext.layout.component.field, "FieldContainer"], 0));
(Ext.cmd.derive("Ext.form.FieldContainer", Ext.container.Container, {
    componentLayout: "fieldcontainer",
    componentCls: "x-form-fieldcontainer",
    shrinkWrap: true,
    autoEl: {tag: "div", role: "presentation"},
    childEls: ["containerEl"],
    combineLabels: false,
    labelConnector: ", ",
    combineErrors: false,
    maskOnDisable: false,
    invalidCls: "",
    fieldSubTpl: ['<div id="{id}-containerEl" data-ref="containerEl" class="{containerElCls}"', '<tpl if="ariaAttributes">', '<tpl foreach="ariaAttributes"> {$}="{.}"</tpl>', "<tpl else>", ' role="presentation"', "</tpl>", ">", "{%this.renderContainer(out,values)%}", "</div>"],
    initComponent: function () {
        var a = this;
        a.initLabelable();
        a.initFieldAncestor();
        Ext.container.Container.prototype.initComponent.call(this);
        a.initMonitor()
    },
    onAdd: function (a) {
        var b = this;
        if (a.isLabelable && Ext.isGecko && Ext.firefoxVersion < 37 && b.layout.type === "absolute" && !b.hideLabel && b.labelAlign !== "top") {
            a.x += (b.labelWidth + b.labelPad)
        }
        Ext.container.Container.prototype.onAdd.apply(this, arguments);
        if (a.isLabelable && b.combineLabels) {
            a.oldHideLabel = a.hideLabel;
            a.hideLabel = true
        }
        b.updateLabel()
    },
    onRemove: function (a, b) {
        var c = this;
        Ext.container.Container.prototype.onRemove.apply(this, arguments);
        if (!b) {
            if (a.isLabelable && c.combineLabels) {
                a.hideLabel = a.oldHideLabel
            }
            c.updateLabel()
        }
    },
    initRenderData: function () {
        var a = this, b = Ext.container.Container.prototype.initRenderData.call(this);
        b = Ext.applyIf(b, a.getLabelableRenderData());
        b.tipAnchorTarget = a.id + "-containerEl";
        return b
    },
    getFieldLabel: function () {
        var a = this.fieldLabel || "";
        if (!a && this.combineLabels) {
            a = Ext.Array.map(this.query("[isFieldLabelable]"), function (b) {
                return b.getFieldLabel()
            }).join(this.labelConnector)
        }
        return a
    },
    getSubTplData: function () {
        var a = this.initRenderData();
        Ext.apply(a, this.subTplData);
        return a
    },
    getSubTplMarkup: function (b) {
        var d = this, a = d.getTpl("fieldSubTpl"), c;
        if (!a.renderContent) {
            d.setupRenderTpl(a)
        }
        c = a.apply(d.getSubTplData(b));
        return c
    },
    updateLabel: function () {
        var b = this, a = b.labelEl;
        if (a) {
            b.setFieldLabel(b.getFieldLabel())
        }
    },
    onFieldErrorChange: function () {
        if (this.combineErrors) {
            var c = this, d = c.getActiveError(), b = Ext.Array.filter(c.query("[isFormField]"), function (e) {
                return e.hasActiveError()
            }), a = c.getCombinedErrors(b);
            if (a) {
                c.setActiveErrors(a)
            } else {
                c.unsetActiveError()
            }
            if (d !== c.getActiveError()) {
                c.updateLayout()
            }
        }
    },
    getCombinedErrors: function (e) {
        var k = [], c, l = e.length, i, d, j, b, g, h;
        for (c = 0; c < l; c++) {
            i = e[c];
            d = i.getActiveErrors();
            b = d.length;
            for (j = 0; j < b; j++) {
                g = d[j];
                h = i.getFieldLabel();
                k.push((h ? h + ": " : "") + g)
            }
        }
        return k
    },
    privates: {
        applyTargetCls: function (b) {
            var a = this.containerElCls;
            this.containerElCls = a ? a + " " + b : b
        }, getTargetEl: function () {
            return this.containerEl
        }, initRenderTpl: function () {
            var a = this;
            if (!a.hasOwnProperty("renderTpl")) {
                a.renderTpl = a.getTpl("labelableRenderTpl")
            }
            return Ext.container.Container.prototype.initRenderTpl.call(this)
        }
    }
}, 0, ["fieldcontainer"], ["component", "box", "container", "fieldcontainer"], {
    component: true,
    box: true,
    container: true,
    fieldcontainer: true
}, ["widget.fieldcontainer"], [["labelable", Ext.form.Labelable], ["fieldAncestor", Ext.form.FieldAncestor]], [Ext.form, "FieldContainer"], 0));
(Ext.cmd.derive("Ext.layout.container.CheckboxGroup", Ext.layout.container.Container, {
    autoFlex: true,
    type: "checkboxgroup",
    createsInnerCt: true,
    childEls: ["innerCt"],
    renderTpl: ['<table id="{ownerId}-innerCt" data-ref="innerCt" class="x-table-plain" cellpadding="0"', 'role="presentation" style="{tableStyle}"><tr role="presentation">', '<tpl for="columns">', '<td class="{parent.colCls}" valign="top" style="{style}" role="presentation">', "{% this.renderColumn(out,parent,xindex-1) %}", "</td>", "</tpl>", "</tr></table>"],
    lastOwnerItemsGeneration: null,
    beginLayout: function (b) {
        var k = this, e, d, h, a, j, g = 0, m = 0, l = k.autoFlex, c = k.innerCt.dom.style;
        Ext.layout.container.Container.prototype.beginLayout.apply(this, arguments);
        e = k.columnNodes;
        b.innerCtContext = b.getEl("innerCt", k);
        if (!b.widthModel.shrinkWrap) {
            d = e.length;
            if (k.columnsArray) {
                for (h = 0; h < d; h++) {
                    a = k.owner.columns[h];
                    if (a < 1) {
                        g += a;
                        m++
                    }
                }
                for (h = 0; h < d; h++) {
                    a = k.owner.columns[h];
                    if (a < 1) {
                        j = ((a / g) * 100) + "%"
                    } else {
                        j = a + "px"
                    }
                    e[h].style.width = j
                }
            } else {
                for (h = 0; h < d; h++) {
                    j = l ? (1 / d * 100) + "%" : "";
                    e[h].style.width = j;
                    m++
                }
            }
            if (!m) {
                c.tableLayout = "fixed";
                c.width = ""
            } else {
                if (m < d) {
                    c.tableLayout = "fixed";
                    c.width = "100%"
                } else {
                    c.tableLayout = "auto";
                    if (l) {
                        c.width = "100%"
                    } else {
                        c.width = ""
                    }
                }
            }
        } else {
            c.tableLayout = "auto";
            c.width = ""
        }
    },
    cacheElements: function () {
        var a = this;
        Ext.layout.container.Container.prototype.cacheElements.call(this);
        a.rowEl = a.innerCt.down("tr");
        a.columnNodes = a.rowEl.dom.childNodes
    },
    calculate: function (h) {
        var e = this, c, b, a, i, d, g;
        if (!h.getDomProp("containerChildrenSizeDone")) {
            e.done = false
        } else {
            c = h.innerCtContext;
            b = h.widthModel.shrinkWrap;
            a = h.heightModel.shrinkWrap;
            i = a || b;
            d = c.el.dom;
            g = i && c.getPaddingInfo();
            if (b) {
                h.setContentWidth(d.offsetWidth + g.width, true)
            }
            if (a) {
                h.setContentHeight(d.offsetHeight + g.height, true)
            }
        }
    },
    doRenderColumn: function (d, l, g) {
        var i = l.$layout, c = i.owner, e = l.columnCount, h = c.items.items, b = h.length, m, a, j, k, n;
        if (c.vertical) {
            j = Math.ceil(b / e);
            a = g * j;
            b = Math.min(b, a + j);
            k = 1
        } else {
            a = g;
            k = e
        }
        for (; a < b; a += k) {
            m = h[a];
            i.configureItem(m);
            n = m.getRenderTree();
            Ext.DomHelper.generateMarkup(n, d)
        }
    },
    getColumnCount: function () {
        var b = this, a = b.owner, c = a.columns;
        if (b.columnsArray) {
            return c.length
        }
        if (Ext.isNumber(c)) {
            return c
        }
        return a.items.length
    },
    getItemSizePolicy: function (a) {
        return this.autoSizePolicy
    },
    getRenderData: function () {
        var k = this, g = Ext.layout.container.Container.prototype.getRenderData.call(this), b = k.owner, h,
            d = k.getColumnCount(), a, c, j, l = k.autoFlex, e = 0, m = 0;
        if (k.columnsArray) {
            for (h = 0; h < d; h++) {
                a = k.owner.columns[h];
                if (a < 1) {
                    e += a;
                    m++
                }
            }
        }
        g.colCls = b.groupCls;
        g.columnCount = d;
        g.columns = [];
        for (h = 0; h < d; h++) {
            c = (g.columns[h] = {});
            if (k.columnsArray) {
                a = k.owner.columns[h];
                if (a < 1) {
                    j = ((a / e) * 100) + "%"
                } else {
                    j = a + "px"
                }
                c.style = "width:" + j
            } else {
                c.style = "width:" + (1 / d * 100) + "%";
                m++
            }
        }
        g.tableStyle = !m ? "table-layout:fixed;" : (m < d) ? "table-layout:fixed;width:100%" : (l) ? "table-layout:auto;width:100%" : "table-layout:auto;";
        return g
    },
    initLayout: function () {
        var b = this, a = b.owner;
        b.columnsArray = Ext.isArray(a.columns);
        b.autoColumns = !a.columns || a.columns === "auto";
        b.vertical = a.vertical;
        Ext.layout.container.Container.prototype.initLayout.call(this)
    },
    isValidParent: Ext.returnTrue,
    setupRenderTpl: function (a) {
        Ext.layout.container.Container.prototype.setupRenderTpl.apply(this, arguments);
        a.renderColumn = this.doRenderColumn
    },
    renderChildren: function () {
        var a = this, b = a.owner.items.generation;
        if (a.lastOwnerItemsGeneration !== b) {
            a.lastOwnerItemsGeneration = b;
            a.renderItems(a.getLayoutItems())
        }
    },
    renderItems: function (e) {
        var g = this, a = e.length, b, k, j, d, h, c;
        if (a) {
            Ext.suspendLayouts();
            if (g.autoColumns) {
                g.addMissingColumns(a)
            }
            d = g.columnNodes.length;
            j = Math.ceil(a / d);
            for (b = 0; b < a; b++) {
                k = e[b];
                h = g.getRenderRowIndex(b, j, d);
                c = g.getRenderColumnIndex(b, j, d);
                if (!k.rendered) {
                    g.renderItem(k, h, c)
                } else {
                    if (!g.isItemAtPosition(k, h, c)) {
                        g.moveItem(k, h, c)
                    }
                }
            }
            if (g.autoColumns) {
                g.removeExceedingColumns(a)
            }
            Ext.resumeLayouts(true)
        }
    },
    isItemAtPosition: function (b, c, a) {
        return b.el.dom === this.getNodeAt(c, a)
    },
    getRenderColumnIndex: function (b, a, c) {
        if (this.vertical) {
            return Math.floor(b / a)
        } else {
            return b % c
        }
    },
    getRenderRowIndex: function (b, a, d) {
        var c = this;
        if (c.vertical) {
            return b % a
        } else {
            return Math.floor(b / d)
        }
    },
    getNodeAt: function (b, a) {
        return this.columnNodes[a].childNodes[b]
    },
    addMissingColumns: function (a) {
        var g = this, c = g.columnNodes.length, e, h, b, d;
        if (c < a) {
            e = a - c;
            h = g.rowEl;
            b = g.owner.groupCls;
            for (d = 0; d < e; d++) {
                h.createChild({cls: b, tag: "td", vAlign: "top", role: "presentation"})
            }
        }
    },
    removeExceedingColumns: function (a) {
        var e = this, b = e.columnNodes.length, d, g, c;
        if (b > a) {
            d = b - a;
            g = e.rowEl;
            for (c = 0; c < d; c++) {
                g.last().destroy()
            }
        }
    },
    renderItem: function (c, d, a) {
        var b = this;
        b.configureItem(c);
        c.render(Ext.get(b.columnNodes[a]), d)
    },
    moveItem: function (d, g, b) {
        var c = this, a = c.columnNodes[b], e = a.childNodes[g];
        a.insertBefore(d.el.dom, e || null)
    }
}, 0, 0, 0, 0, ["layout.checkboxgroup"], 0, [Ext.layout.container, "CheckboxGroup"], 0));
(Ext.cmd.derive("Ext.form.CheckboxManager", Ext.util.MixedCollection, {
    singleton: true, getByName: function (a, b) {
        return this.filterBy(function (c) {
            return c.name === a && c.getFormId() === b
        })
    }
}, 0, 0, 0, 0, 0, 0, [Ext.form, "CheckboxManager"], 0));
(Ext.cmd.derive("Ext.form.field.Checkbox", Ext.form.field.Base, {
    alternateClassName: "Ext.form.Checkbox",
    stretchInputElFixed: false,
    childEls: ["boxLabelEl", "innerWrapEl", "displayEl"],
    fieldSubTpl: ['<div id="{cmpId}-innerWrapEl" data-ref="innerWrapEl" role="presentation"', ' class="{wrapInnerCls}">', '<tpl if="labelAlignedBefore">', "{beforeBoxLabelTpl}", '<label id="{cmpId}-boxLabelEl" data-ref="boxLabelEl" {boxLabelAttrTpl} class="{boxLabelCls} ', '{boxLabelCls}-{ui} {boxLabelCls}-{boxLabelAlign} {noBoxLabelCls} {childElCls}" for="{id}">', "{beforeBoxLabelTextTpl}", "{boxLabel}", "{afterBoxLabelTextTpl}", "</label>", "{afterBoxLabelTpl}", "</tpl>", '<input type="button" id="{id}" name="{inputName}" data-ref="inputEl" {inputAttrTpl}', '<tpl if="tabIdx != null"> tabindex="{tabIdx}"</tpl>', '<tpl if="disabled"> disabled="disabled"</tpl>', '<tpl if="fieldStyle"> style="{fieldStyle}"</tpl>', ' class="{checkboxCls} {clipCls}" autocomplete="off" hidefocus="true" ', '<tpl foreach="inputElAriaAttributes"> {$}="{.}"</tpl>', "/>", '<span id="{cmpId}-displayEl" data-ref="displayEl" class="{fieldCls} {typeCls} ', '{typeCls}-{ui} {inputCls} {inputCls}-{ui} {childElCls} {afterLabelCls}"></span>', '<tpl if="!labelAlignedBefore">', "{beforeBoxLabelTpl}", '<label id="{cmpId}-boxLabelEl" data-ref="boxLabelEl" {boxLabelAttrTpl} class="{boxLabelCls} ', '{boxLabelCls}-{ui} {boxLabelCls}-{boxLabelAlign} {noBoxLabelCls} {childElCls}" for="{id}">', "{beforeBoxLabelTextTpl}", "{boxLabel}", "{afterBoxLabelTextTpl}", "</label>", "{afterBoxLabelTpl}", "</tpl>", "</div>", {
        disableFormats: true,
        compiled: true
    }],
    publishes: {checked: 1},
    subTplInsertions: ["beforeBoxLabelTpl", "afterBoxLabelTpl", "beforeBoxLabelTextTpl", "afterBoxLabelTextTpl", "boxLabelAttrTpl", "inputAttrTpl"],
    isCheckbox: true,
    focusCls: "form-checkbox-focus",
    fieldBodyCls: "x-form-cb-wrap",
    checked: false,
    checkedCls: "x-form-cb-checked",
    boxLabelCls: "x-form-cb-label",
    boxLabelAlign: "after",
    afterLabelCls: "x-form-cb-after",
    wrapInnerCls: "x-form-cb-wrap-inner",
    noBoxLabelCls: "x-form-cb-no-box-label",
    inputValue: "on",
    checkChangeEvents: [],
    inputType: "checkbox",
    isTextInput: false,
    ariaRole: "checkbox",
    onRe: /^on$/i,
    inputCls: "x-form-cb",
    _checkboxCls: "x-form-cb-input",
    _clipCls: "x-hidden-clip",
    initComponent: function () {
        var a = this, b = a.value;
        if (b !== undefined) {
            a.checked = a.isChecked(b, a.inputValue)
        }
        Ext.form.field.Base.prototype.initComponent.call(this);
        a.getManager().add(a)
    },
    initDefaultName: Ext.emptyFn,
    initValue: function () {
        var b = this, a = !!b.checked;
        b.originalValue = b.lastValue = a;
        b.setValue(a)
    },
    getElConfig: function () {
        var a = this;
        if (a.isChecked(a.rawValue, a.inputValue)) {
            a.addCls(a.checkedCls)
        }
        return Ext.form.field.Base.prototype.getElConfig.call(this)
    },
    getSubTplData: function (b) {
        var d = this, c = d.boxLabel, h = d.boxLabelAlign, g = h === "before", e, a;
        e = Ext.apply(Ext.form.field.Base.prototype.getSubTplData.call(this, b), {
            clipCls: d._clipCls,
            checkboxCls: d._checkboxCls,
            disabled: d.readOnly || d.disabled,
            wrapInnerCls: d.wrapInnerCls,
            boxLabel: c,
            boxLabelCls: d.boxLabelCls,
            boxLabelAlign: h,
            labelAlignedBefore: g,
            afterLabelCls: g ? d.afterLabelCls : "",
            noBoxLabelCls: !c ? d.noBoxLabelCls : "",
            inputName: d.name || d.id
        });
        a = e.inputElAriaAttributes;
        if (a) {
            a["aria-checked"] = !!d.checked;
            a["aria-labelledby"] = d.id + "-boxLabelEl"
        }
        return e
    },
    initEvents: function () {
        var a = this;
        Ext.form.field.Base.prototype.initEvents.call(this);
        a.inputEl.on({click: "onBoxClick", scope: a, translate: false});
        a.displayEl.on({click: "onBoxClick", mousedown: "_onDisplayElMouseDown", scope: a})
    },
    setBoxLabel: function (a) {
        var b = this;
        b.boxLabel = a;
        if (b.rendered) {
            b.boxLabelEl.setHtml(a);
            b.boxLabelEl[a ? "removeCls" : "addCls"](b.noBoxLabelCls);
            b.updateLayout()
        }
    },
    onBoxClick: function () {
        var a = this;
        if (!a.disabled && !a.readOnly) {
            a.setValue(!a.checked)
        }
    },
    getRawValue: function () {
        return this.checked
    },
    getValue: function () {
        return this.checked
    },
    getSubmitValue: function () {
        var a = this.uncheckedValue, b = Ext.isDefined(a) ? a : null;
        return this.checked ? this.inputValue : b
    },
    isChecked: function (b, a) {
        return (b === true || b === "true" || b === "1" || b === 1 || (((Ext.isString(b) || Ext.isNumber(b)) && a) ? b == a : this.onRe.test(b)))
    },
    setRawValue: function (c) {
        var b = this, d = b.inputEl, e = b.displayEl, a = b.isChecked(c, b.inputValue);
        if (d) {
            b[a ? "addCls" : "removeCls"](b.checkedCls);
            if (b.ariaRole) {
                b.ariaEl.dom.setAttribute("aria-checked", a)
            }
        }
        if (Ext.isIE8 && e && a !== b.lastValue) {
            e.repaint()
        }
        b.checked = b.rawValue = a;
        if (!b.duringSetValue) {
            b.lastValue = a
        }
        return a
    },
    setValue: function (g) {
        var e = this, c, b, a, d;
        if (Ext.isArray(g)) {
            c = e.getManager().getByName(e.name, e.getFormId()).items;
            a = c.length;
            for (b = 0; b < a; ++b) {
                d = c[b];
                d.setValue(Ext.Array.contains(g, d.inputValue))
            }
        } else {
            e.duringSetValue = true;
            Ext.form.field.Base.prototype.setValue.apply(this, arguments);
            delete e.duringSetValue
        }
        return e
    },
    valueToRaw: Ext.identityFn,
    onChange: function (b, a) {
        var d = this, c = d.handler;
        if (c) {
            Ext.callback(c, d.scope, [d, b], 0, d)
        }
        Ext.form.field.Base.prototype.onChange.apply(this, arguments);
        if (d.reference && d.publishState) {
            d.publishState("checked", b)
        }
    },
    resetOriginalValue: function (b) {
        var g = this, d, e, a, c;
        if (!b) {
            d = g.getManager().getByName(g.name, g.getFormId()).items;
            a = d.length;
            for (c = 0; c < a; ++c) {
                e = d[c];
                if (e !== g) {
                    d[c].resetOriginalValue(true)
                }
            }
        }
        Ext.form.field.Base.prototype.resetOriginalValue.call(this)
    },
    beforeDestroy: function () {
        Ext.form.field.Base.prototype.beforeDestroy.call(this);
        this.getManager().removeAtKey(this.id)
    },
    getManager: function () {
        return Ext.form.CheckboxManager
    },
    onEnable: function () {
        var a = this, b = a.inputEl;
        Ext.form.field.Base.prototype.onEnable.call(this);
        if (b) {
            b.dom.disabled = a.readOnly
        }
    },
    setReadOnly: function (c) {
        var a = this, b = a.inputEl;
        if (b) {
            b.dom.disabled = !!c || a.disabled
        }
        Ext.form.field.Base.prototype.setReadOnly.apply(this, arguments)
    },
    getFormId: function () {
        var b = this, a;
        if (!b.formId) {
            a = b.up("form");
            if (a) {
                b.formId = a.id
            }
        }
        return b.formId
    },
    getFocusClsEl: function () {
        return this.displayEl
    },
    privates: {
        _onDisplayElMouseDown: function (a) {
            a.preventDefault();
            this.inputEl.focus(1)
        }
    }
}, 0, ["checkbox", "checkboxfield"], ["component", "box", "field", "checkboxfield", "checkbox"], {
    component: true,
    box: true,
    field: true,
    checkboxfield: true,
    checkbox: true
}, ["widget.checkbox", "widget.checkboxfield"], 0, [Ext.form.field, "Checkbox", Ext.form, "Checkbox"], 0));
(Ext.cmd.derive("Ext.form.CheckboxGroup", Ext.form.FieldContainer, {
    columns: "auto",
    vertical: false,
    allowBlank: true,
    blankText: "You must select at least one item in this group",
    defaultType: "checkboxfield",
    groupCls: "x-form-check-group",
    extraFieldBodyCls: "x-form-checkboxgroup-body",
    layout: "checkboxgroup",
    componentCls: "x-form-checkboxgroup",
    ariaRole: "group",
    ariaEl: "containerEl",
    ariaRenderAttributes: {"aria-invalid": false},
    initComponent: function () {
        var a = this;
        a.name = a.name || a.id;
        Ext.form.FieldContainer.prototype.initComponent.call(this);
        a.initField()
    },
    initRenderData: function () {
        var g = this, h, b, d, c, a, e;
        h = Ext.form.FieldContainer.prototype.initRenderData.call(this);
        h.inputId = g.id + "-" + g.ariaEl;
        b = h.ariaAttributes;
        if (b) {
            d = g.getBoxes();
            e = [];
            for (c = 0, a = d.length; c < a; c++) {
                e.push(d[c].id + "-inputEl")
            }
            b["aria-owns"] = e.join(" ")
        }
        return h
    },
    initValue: function () {
        var b = this, a = b.value;
        b.originalValue = b.lastValue = a || b.getValue();
        if (a) {
            b.setValue(a)
        }
    },
    onAdd: function (e) {
        var d = this, b, a, c;
        if (e.isCheckbox) {
            if (!e.name) {
                e.name = d.name
            }
            d.mon(e, "change", d.checkChange, d)
        } else {
            if (e.isContainer) {
                b = e.items.items;
                for (c = 0, a = b.length; c < a; c++) {
                    d.onAdd(b[c])
                }
            }
        }
        Ext.form.FieldContainer.prototype.onAdd.apply(this, arguments)
    },
    onRemove: function (e) {
        var d = this, b, a, c;
        if (e.isCheckbox) {
            d.mun(e, "change", d.checkChange, d)
        } else {
            if (e.isContainer) {
                b = e.items.items;
                for (c = 0, a = b.length; c < a; c++) {
                    d.onRemove(b[c])
                }
            }
        }
        Ext.form.FieldContainer.prototype.onRemove.apply(this, arguments)
    },
    isEqual: function (b, a) {
        var c = Ext.Object.toQueryString;
        return c(b) === c(a)
    },
    getErrors: function () {
        var a = [];
        if (!this.allowBlank && Ext.isEmpty(this.getChecked())) {
            a.push(this.blankText)
        }
        return a
    },
    getBoxes: function (a) {
        return this.query("[isCheckbox]" + (a || ""))
    },
    eachBox: function (b, a) {
        Ext.Array.forEach(this.getBoxes(), b, a || this)
    },
    getChecked: function () {
        return this.getBoxes("[checked]")
    },
    isDirty: function () {
        var c = this.getBoxes(), a, d = c.length;
        for (a = 0; a < d; a++) {
            if (c[a].isDirty()) {
                return true
            }
        }
    },
    setReadOnly: function (e) {
        var c = this.getBoxes(), a, d = c.length;
        for (a = 0; a < d; a++) {
            c[a].setReadOnly(e)
        }
        this.readOnly = e
    },
    reset: function () {
        var c = this, b = c.hasActiveError(), a = c.preventMark;
        c.preventMark = true;
        c.batchChanges(function () {
            var e = c.getBoxes(), d, g = e.length;
            for (d = 0; d < g; d++) {
                e[d].reset()
            }
        });
        c.preventMark = a;
        c.unsetActiveError();
        if (b) {
            c.updateLayout()
        }
    },
    resetOriginalValue: function () {
        var d = this, c = d.getBoxes(), a, e = c.length;
        for (a = 0; a < e; a++) {
            c[a].resetOriginalValue()
        }
        d.originalValue = d.getValue();
        d.checkDirty()
    },
    setValue: function (h) {
        var g = this, d = g.getBoxes(), a, j = d.length, e, c, i;
        g.batchChanges(function () {
            Ext.suspendLayouts();
            for (a = 0; a < j; a++) {
                e = d[a];
                c = e.getName();
                i = false;
                if (h) {
                    if (Ext.isArray(h[c])) {
                        i = Ext.Array.contains(h[c], e.inputValue)
                    } else {
                        i = h[c]
                    }
                }
                e.setValue(i)
            }
            Ext.resumeLayouts(true)
        });
        return g
    },
    getValue: function () {
        var d = {}, g = this.getBoxes(), c, j = g.length, h, e, a, i;
        for (c = 0; c < j; c++) {
            h = g[c];
            e = h.getName();
            a = h.inputValue;
            if (h.getValue()) {
                if (d.hasOwnProperty(e)) {
                    i = d[e];
                    if (!Ext.isArray(i)) {
                        i = d[e] = [i]
                    }
                    i.push(a)
                } else {
                    d[e] = a
                }
            }
        }
        return d
    },
    getSubmitData: function () {
        return null
    },
    getModelData: function () {
        return null
    },
    validate: function () {
        var a = this, d, c, b;
        if (a.disabled) {
            c = true
        } else {
            d = a.getErrors();
            c = Ext.isEmpty(d);
            b = a.wasValid;
            if (c) {
                a.unsetActiveError()
            } else {
                a.setActiveError(d)
            }
        }
        if (c !== b) {
            a.wasValid = c;
            a.fireEvent("validitychange", a, c);
            a.updateLayout()
        }
        return c
    }
}, 0, ["checkboxgroup"], ["component", "box", "container", "fieldcontainer", "checkboxgroup"], {
    component: true,
    box: true,
    container: true,
    fieldcontainer: true,
    checkboxgroup: true
}, ["widget.checkboxgroup"], [["field", Ext.form.field.Field]], [Ext.form, "CheckboxGroup"], function () {
    this.borrow(Ext.form.field.Base, ["markInvalid", "clearInvalid", "setError"])
}));
(Ext.cmd.derive("Ext.form.FieldSet", Ext.container.Container, {
    checkboxUI: "default",
    collapsed: false,
    toggleOnTitleClick: true,
    baseCls: "x-fieldset",
    layout: "anchor",
    descriptionText: "{0} field set",
    expandText: "Expand field set",
    componentLayout: "fieldset",
    ariaRole: "group",
    focusable: false,
    autoEl: "fieldset",
    childEls: ["body"],
    renderTpl: ["{%this.renderLegend(out,values);%}", '<div id="{id}-body" data-ref="body" class="{baseCls}-body {baseCls}-body-{ui} {bodyTargetCls}" ', 'role="presentation"<tpl if="bodyStyle"> style="{bodyStyle}"</tpl>>', "{%this.renderContainer(out,values);%}", "</div>"],
    stateEvents: ["collapse", "expand"],
    maskOnDisable: false,
    beforeDestroy: function () {
        var b = this, a = b.legend;
        if (a) {
            delete a.ownerCt;
            a.destroy();
            b.legend = null
        }
        Ext.container.Container.prototype.beforeDestroy.call(this)
    },
    initComponent: function () {
        var b = this, a = b.baseCls;
        if (b.ariaRole && !b.ariaLabel) {
            b.ariaLabel = Ext.String.formatEncode(b.descriptionText, b.title || "")
        }
        b.ariaRenderAttributes = b.ariaRenderAttributes || {};
        b.ariaRenderAttributes["aria-expanded"] = !b.collapsed;
        b.initFieldAncestor();
        Ext.container.Container.prototype.initComponent.call(this);
        b.layout.managePadding = b.layout.manageOverflow = false;
        if (b.collapsed) {
            b.addCls(a + "-collapsed");
            b.collapse()
        }
        if (b.title || b.checkboxToggle || b.collapsible) {
            b.addTitleClasses();
            b.legend = b.createLegendCt()
        }
        b.initMonitor()
    },
    initRenderData: function () {
        var a = this, b = Ext.container.Container.prototype.initRenderData.call(this);
        b.bodyTargetCls = a.bodyTargetCls;
        a.protoBody.writeTo(b);
        delete a.protoBody;
        return b
    },
    getState: function () {
        var a = Ext.container.Container.prototype.getState.call(this);
        a = this.addPropertyToState(a, "collapsed");
        return a
    },
    afterCollapse: Ext.emptyFn,
    afterExpand: Ext.emptyFn,
    collapsedHorizontal: function () {
        return true
    },
    collapsedVertical: function () {
        return true
    },
    createLegendCt: function () {
        var c = this, a = [], d = {
            baseCls: c.baseCls + "-header",
            layout: "container",
            ui: c.ui,
            id: c.id + "-legend",
            autoEl: "legend",
            ariaRole: null,
            items: a,
            ownerCt: c,
            shrinkWrap: true,
            ownerLayout: c.componentLayout
        }, b;
        if (c.checkboxToggle) {
            a.push(c.createCheckboxCmp())
        } else {
            if (c.collapsible) {
                a.push(c.createToggleCmp())
            }
        }
        a.push(c.createTitleCmp());
        b = new Ext.container.Container(d);
        b.collapseImmune = true;
        b.getInherited().collapseImmune = true;
        return b
    },
    createTitleCmp: function () {
        var b = this, a = {
            html: b.title,
            ui: b.ui,
            cls: b.baseCls + "-header-text",
            id: b.id + "-legendTitle",
            ariaRole: "presentation"
        };
        if (b.collapsible && b.toggleOnTitleClick) {
            a.listeners = {click: {element: "el", scope: b, fn: b.toggle}};
            a.cls += " " + b.baseCls + "-header-text-collapsible"
        }
        b.titleCmp = new Ext.Component(a);
        return b.titleCmp
    },
    createCheckboxCmp: function () {
        var b = this, d = "-checkbox", a = b.baseCls + "-header" + d, c;
        a += " " + a + "-" + b.ui;
        b.checkboxCmp = c = new Ext.form.field.Checkbox({
            hideEmptyLabel: true,
            name: b.checkboxName || b.id + d,
            cls: a,
            id: b.id + "-legendChk",
            ui: b.checkboxUI,
            checked: !b.collapsed,
            msgTarget: "none",
            listeners: {change: b.onCheckChange, scope: b},
            ariaLabel: b.expandText
        });
        return c
    },
    createToggleCmp: function () {
        var a = this, b;
        a.toggleCmp = b = new Ext.panel.Tool({
            cacheHeight: false,
            cls: a.baseCls + "-header-tool-" + a.ui,
            type: "toggle",
            handler: a.toggle,
            id: a.id + "-legendToggle",
            scope: a,
            ariaRole: "checkbox",
            ariaLabel: a.expandText,
            ariaRenderAttributes: {"aria-checked": !a.collapsed}
        });
        return b
    },
    doRenderLegend: function (b, e) {
        var d = e.$comp, c = d.legend, a;
        if (c) {
            c.ownerLayout.configureItem(c);
            a = c.getRenderTree();
            Ext.DomHelper.generateMarkup(a, b)
        }
    },
    getCollapsed: function () {
        return this.collapsed ? "top" : false
    },
    getCollapsedDockedItems: function () {
        var a = this.legend;
        return a ? [a] : []
    },
    setTitle: function (c) {
        var b = this, a = b.legend;
        b.title = c;
        b.ariaLabel = Ext.String.formatEncode(b.descriptionText, c || "");
        if (b.rendered) {
            if (!a) {
                b.legend = a = b.createLegendCt();
                b.addTitleClasses();
                a.ownerLayout.configureItem(a);
                a.render(b.el, 0)
            }
            b.titleCmp.update(c);
            b.ariaEl.dom.setAttribute("aria-label", b.ariaLabel)
        } else {
            if (a) {
                b.titleCmp.update(c)
            } else {
                b.addTitleClasses();
                b.legend = b.createLegendCt()
            }
        }
        return b
    },
    addTitleClasses: function () {
        var b = this, c = b.title, a = b.baseCls;
        if (c) {
            b.addCls(a + "-with-title")
        }
        if (c || b.checkboxToggle || b.collapsible) {
            b.addCls(a + "-with-legend")
        }
    },
    expand: function () {
        return this.setExpanded(true)
    },
    collapse: function () {
        return this.setExpanded(false)
    },
    setExpanded: function (b) {
        var c = this, d = c.checkboxCmp, e = c.toggleCmp, a = b ? "expand" : "collapse";
        if (!c.rendered || c.fireEvent("before" + a, c) !== false) {
            b = !!b;
            if (d) {
                d.setValue(b)
            } else {
                if (e && e.ariaEl.dom) {
                    e.ariaEl.dom.setAttribute("aria-checked", b)
                }
            }
            if (b) {
                c.removeCls(c.baseCls + "-collapsed")
            } else {
                c.addCls(c.baseCls + "-collapsed")
            }
            if (c.ariaEl.dom) {
                c.ariaEl.dom.setAttribute("aria-expanded", !!b)
            }
            c.collapsed = !b;
            if (b) {
                delete c.getInherited().collapsed
            } else {
                c.getInherited().collapsed = true
            }
            if (c.rendered) {
                c.updateLayout({isRoot: false});
                c.fireEvent(a, c)
            }
        }
        return c
    },
    getRefItems: function (a) {
        var c = Ext.container.Container.prototype.getRefItems.apply(this, arguments), b = this.legend;
        if (b) {
            c.unshift(b);
            if (a) {
                c.unshift.apply(c, b.getRefItems(true))
            }
        }
        return c
    },
    toggle: function () {
        this.setExpanded(!!this.collapsed)
    },
    privates: {
        applyTargetCls: function (a) {
            this.bodyTargetCls = a
        }, finishRender: function () {
            var a = this.legend;
            Ext.container.Container.prototype.finishRender.call(this);
            if (a) {
                a.finishRender()
            }
        }, getProtoBody: function () {
            var b = this, a = b.protoBody;
            if (!a) {
                b.protoBody = a = new Ext.util.ProtoElement({styleProp: "bodyStyle", styleIsText: true})
            }
            return a
        }, getDefaultContentTarget: function () {
            return this.body
        }, getTargetEl: function () {
            return this.body || this.frameBody || this.el
        }, initPadding: function (e) {
            var c = this, a = c.getProtoBody(), d = c.padding, b;
            if (d !== undefined) {
                if (Ext.isIE8) {
                    d = c.parseBox(d);
                    b = Ext.Element.parseBox(0);
                    b.top = d.top;
                    d.top = 0;
                    a.setStyle("padding", c.unitizeBox(b))
                }
                e.setStyle("padding", c.unitizeBox(d))
            }
        }, onCheckChange: function (b, a) {
            this.setExpanded(a)
        }, setupRenderTpl: function (a) {
            Ext.container.Container.prototype.setupRenderTpl.apply(this, arguments);
            a.renderLegend = this.doRenderLegend
        }
    }
}, 0, ["fieldset"], ["component", "box", "container", "fieldset"], {
    component: true,
    box: true,
    container: true,
    fieldset: true
}, ["widget.fieldset"], [["fieldAncestor", Ext.form.FieldAncestor]], [Ext.form, "FieldSet"], 0));
(Ext.cmd.derive("Ext.form.Label", Ext.Component, {
    autoEl: "label", maskOnDisable: false, getElConfig: function () {
        var a = this;
        a.html = a.text ? Ext.util.Format.htmlEncode(a.text) : (a.html || "");
        return Ext.apply(Ext.Component.prototype.getElConfig.call(this), {htmlFor: a.forId || ""})
    }, setText: function (c, b) {
        var a = this;
        b = b !== false;
        if (b) {
            a.text = c;
            delete a.html
        } else {
            a.html = c;
            delete a.text
        }
        if (a.rendered) {
            a.el.dom.innerHTML = b !== false ? Ext.util.Format.htmlEncode(c) : c;
            a.updateLayout()
        }
        return a
    }
}, 0, ["label"], ["component", "box", "label"], {
    component: true,
    box: true,
    label: true
}, ["widget.label"], 0, [Ext.form, "Label"], 0));
(Ext.cmd.derive("Ext.form.Panel", Ext.panel.Panel, {
    alternateClassName: ["Ext.FormPanel", "Ext.form.FormPanel"],
    layout: "anchor",
    bodyAriaRole: "form",
    basicFormConfigs: ["api", "baseParams", "errorReader", "jsonSubmit", "method", "paramOrder", "paramsAsHash", "reader", "standardSubmit", "timeout", "trackResetOnLoad", "url", "waitMsgTarget", "waitTitle"],
    initComponent: function () {
        var a = this;
        if (a.frame) {
            a.border = false
        }
        a.initFieldAncestor();
        Ext.panel.Panel.prototype.initComponent.call(this);
        a.relayEvents(a.form, ["beforeaction", "actionfailed", "actioncomplete", "validitychange", "dirtychange"]);
        if (a.pollForChanges) {
            a.startPolling(a.pollInterval || 500)
        }
    },
    initItems: function () {
        Ext.panel.Panel.prototype.initItems.call(this);
        this.initMonitor();
        this.form = this.createForm()
    },
    afterFirstLayout: function () {
        Ext.panel.Panel.prototype.afterFirstLayout.apply(this, arguments);
        this.form.initialize()
    },
    createForm: function () {
        var b = {}, d = this.basicFormConfigs, a = d.length, c = 0, e;
        for (; c < a; ++c) {
            e = d[c];
            b[e] = this[e]
        }
        return new Ext.form.Basic(this, b)
    },
    getForm: function () {
        return this.form
    },
    loadRecord: function (a) {
        return this.getForm().loadRecord(a)
    },
    getRecord: function () {
        return this.getForm().getRecord()
    },
    updateRecord: function (a) {
        return this.getForm().updateRecord(a)
    },
    getValues: function (d, b, c, a) {
        return this.getForm().getValues(d, b, c, a)
    },
    isDirty: function () {
        return this.form.isDirty()
    },
    isValid: function () {
        return this.form.isValid()
    },
    reset: function () {
        this.form.reset()
    },
    hasInvalidField: function () {
        return this.form.hasInvalidField()
    },
    beforeDestroy: function () {
        this.stopPolling();
        this.form.destroy();
        Ext.panel.Panel.prototype.beforeDestroy.call(this)
    },
    load: function (a) {
        this.form.load(a)
    },
    submit: function (a) {
        this.form.submit(a)
    },
    startPolling: function (b) {
        this.stopPolling();
        var a = new Ext.util.TaskRunner(b);
        a.start({interval: 0, run: this.checkChange, scope: this});
        this.pollTask = a
    },
    stopPolling: function () {
        var a = this.pollTask;
        if (a) {
            a.stopAll();
            delete this.pollTask
        }
    },
    checkChange: function () {
        var a = this.form.getFields().items, b, c = a.length;
        for (b = 0; b < c; b++) {
            a[b].checkChange()
        }
    }
}, 0, ["form"], ["component", "box", "container", "panel", "form"], {
    component: true,
    box: true,
    container: true,
    panel: true,
    form: true
}, ["widget.form"], [["fieldAncestor", Ext.form.FieldAncestor]], [Ext.form, "Panel", Ext, "FormPanel", Ext.form, "FormPanel"], 0));
(Ext.cmd.derive("Ext.form.RadioManager", Ext.util.MixedCollection, {
    singleton: true, getByName: function (a, b) {
        return this.filterBy(function (c) {
            return c.name === a && c.getFormId() === b
        })
    }, getWithValue: function (a, b, c) {
        return this.filterBy(function (d) {
            return d.name === a && d.inputValue == b && d.getFormId() === c
        })
    }, getChecked: function (a, b) {
        return this.findBy(function (c) {
            return c.name === a && c.checked && c.getFormId() === b
        })
    }
}, 0, 0, 0, 0, 0, 0, [Ext.form, "RadioManager"], 0));
(Ext.cmd.derive("Ext.form.field.Radio", Ext.form.field.Checkbox, {
    alternateClassName: "Ext.form.Radio",
    isRadio: true,
    inputType: "radio",
    ariaRole: "radio",
    tabIndex: 0,
    formId: null,
    getGroupValue: function () {
        var a = this.getManager().getChecked(this.name, this.getFormId());
        return a ? a.inputValue : null
    },
    onBoxClick: function () {
        var a = this;
        if (!a.disabled && !a.readOnly) {
            this.setValue(true)
        }
    },
    onRemoved: function () {
        Ext.form.field.Checkbox.prototype.onRemoved.apply(this, arguments);
        this.formId = null
    },
    setValue: function (b) {
        var a = this, c;
        if (Ext.isBoolean(b)) {
            Ext.form.field.Checkbox.prototype.setValue.apply(this, arguments)
        } else {
            c = a.getManager().getWithValue(a.name, b, a.getFormId()).getAt(0);
            if (c) {
                c.setValue(true)
            }
        }
        return a
    },
    getSubmitValue: function () {
        return this.checked ? this.inputValue : null
    },
    getModelData: function () {
        var a = Ext.form.field.Checkbox.prototype.getModelData.apply(this, arguments);
        if (a) {
            a[this.getName()] = this.getSubmitValue()
        }
        return a
    },
    onChange: function (c, a) {
        var g = this, e, d, b, h;
        Ext.form.field.Checkbox.prototype.onChange.apply(this, arguments);
        if (c) {
            h = g.getManager().getByName(g.name, g.getFormId()).items;
            d = h.length;
            for (e = 0; e < d; e++) {
                b = h[e];
                if (b !== g) {
                    b.setValue(false)
                }
            }
        }
    },
    getManager: function () {
        return Ext.form.RadioManager
    }
}, 0, ["radiofield", "radio"], ["component", "box", "field", "checkboxfield", "checkbox", "radiofield", "radio"], {
    component: true,
    box: true,
    field: true,
    checkboxfield: true,
    checkbox: true,
    radiofield: true,
    radio: true
}, ["widget.radio", "widget.radiofield"], 0, [Ext.form.field, "Radio", Ext.form, "Radio"], 0));
(Ext.cmd.derive("Ext.form.RadioGroup", Ext.form.CheckboxGroup, {
    allowBlank: true,
    blankText: "You must select one item in this group",
    defaultType: "radiofield",
    groupCls: "x-form-radio-group",
    ariaRole: "radiogroup",
    initRenderData: function () {
        var b = this, c, a;
        c = Ext.form.CheckboxGroup.prototype.initRenderData.call(this);
        a = c.ariaAttributes;
        if (a) {
            a["aria-required"] = !b.allowBlank;
            a["aria-invalid"] = false
        }
        return c
    },
    getBoxes: function (b, a) {
        return (a || this).query("[isRadio]" + (b || ""))
    },
    checkChange: function () {
        var b = this.getValue(), a = Ext.Object.getKeys(b)[0];
        if (Ext.isArray(b[a])) {
            return
        }
        Ext.form.CheckboxGroup.prototype.checkChange.apply(this, arguments)
    },
    setValue: function (d) {
        var j, g, e, h, c, a, b;
        if (Ext.isObject(d)) {
            Ext.suspendLayouts();
            g = this.items.first();
            e = g ? g.getFormId() : null;
            for (b in d) {
                j = d[b];
                h = Ext.form.RadioManager.getWithValue(b, j, e).items;
                a = h.length;
                for (c = 0; c < a; ++c) {
                    h[c].setValue(true)
                }
            }
            Ext.resumeLayouts(true)
        }
        return this
    },
    markInvalid: function (b) {
        var a = this.ariaEl.dom;
        Ext.form.CheckboxGroup.prototype.markInvalid.call(this, b);
        if (a) {
            a.setAttribute("aria-invalid", true)
        }
    },
    clearInvalid: function () {
        var a = this.ariaEl.dom;
        Ext.form.CheckboxGroup.prototype.clearInvalid.call(this);
        if (a) {
            a.setAttribute("aria-invalid", false)
        }
    },
    privates: {
        getFocusables: function () {
            return this.getBoxes()
        }, initDefaultFocusable: function (a) {
            var d = this, c, b;
            c = d.getChecked();
            if (c.length) {
                b = c[0]
            } else {
                b = d.findNextFocusableChild(null, true, null, a)
            }
            if (b) {
                d.activateFocusable(b)
            }
            return b
        }, getFocusableContainerEl: function () {
            return this.containerEl
        }, onFocusableContainerFocusLeave: function () {
            this.clearFocusables();
            this.initDefaultFocusable()
        }, doFocusableChildAdd: function (g) {
            var e = this, b = e.mixins.focusablecontainer, d, c, a;
            d = g.isContainer ? e.getBoxes("", g) : [g];
            for (c = 0, a = d.length; c < a; c++) {
                b.doFocusableChildAdd.call(e, d[c])
            }
        }, doFocusableChildRemove: function (g) {
            var e = this, b = e.mixins.focusablecontainer, d, c, a;
            d = g.isContainer ? e.getBoxes("", g) : [g];
            for (c = 0, a = d.length; c < a; c++) {
                b.doFocusableChildRemove.call(e, d[c])
            }
        }, focusChild: function (c, b, d) {
            var a = this.mixins.focusablecontainer.focusChild.apply(this, arguments);
            if (!d.ctrlKey) {
                a.setValue(true)
            }
        }
    }
}, 0, ["radiogroup"], ["component", "box", "container", "fieldcontainer", "checkboxgroup", "radiogroup"], {
    component: true,
    box: true,
    container: true,
    fieldcontainer: true,
    checkboxgroup: true,
    radiogroup: true
}, ["widget.radiogroup"], [[Ext.util.FocusableContainer.prototype.mixinId || Ext.util.FocusableContainer.$className, Ext.util.FocusableContainer]], [Ext.form, "RadioGroup"], 0));
(Ext.cmd.derive("Ext.form.action.DirectAction", Ext.Mixin, {
    mixinConfig: {id: "directaction"},
    resolveMethod: function (c) {
        var e = this, d = e.form, b = d.api, a;
        a = b[c];
        if (typeof a !== "function") {
            b[c] = a = Ext.direct.Manager.parseMethod(a)
        }
        return a
    }
}, 0, 0, 0, 0, 0, 0, [Ext.form.action, "DirectAction"], 0));
(Ext.cmd.derive("Ext.form.action.DirectLoad", Ext.form.action.Load, {
    alternateClassName: "Ext.form.Action.DirectLoad",
    type: "directload",
    run: function () {
        var e = this, d = e.form, b = e.metadata || d.metadata, g = e.timeout || d.timeout, a, c;
        c = e.resolveMethod("load");
        a = c.directCfg.method.getArgs({
            params: e.getParams(),
            paramOrder: d.paramOrder,
            paramsAsHash: d.paramsAsHash,
            options: g != null ? {timeout: g * 1000} : null,
            metadata: b,
            callback: e.onComplete,
            scope: e
        });
        c.apply(window, a)
    },
    processResponse: function (a) {
        return (this.result = a)
    },
    onComplete: function (a) {
        if (a) {
            this.onSuccess(a)
        } else {
            this.onFailure(null)
        }
    }
}, 0, 0, 0, 0, ["formaction.directload"], [[Ext.form.action.DirectAction.prototype.mixinId || Ext.form.action.DirectAction.$className, Ext.form.action.DirectAction]], [Ext.form.action, "DirectLoad", Ext.form.Action, "DirectLoad"], 0));
(Ext.cmd.derive("Ext.form.action.DirectSubmit", Ext.form.action.Submit, {
    alternateClassName: "Ext.form.Action.DirectSubmit",
    type: "directsubmit",
    doSubmit: function () {
        var e = this, d = e.form, b = e.metadata || d.metadata, g = e.timeout || d.timeout, c, h, a;
        c = e.resolveMethod("submit");
        h = e.buildForm();
        a = c.directCfg.method.getArgs({
            params: h.formEl,
            options: g != null ? {timeout: g * 1000} : null,
            metadata: b,
            callback: e.onComplete,
            scope: e
        });
        c.apply(window, a);
        e.cleanup(h)
    },
    processResponse: function (a) {
        return (this.result = a)
    },
    onComplete: function (a) {
        if (a) {
            this.onSuccess(a)
        } else {
            this.onFailure(null)
        }
    }
}, 0, 0, 0, 0, ["formaction.directsubmit"], [[Ext.form.action.DirectAction.prototype.mixinId || Ext.form.action.DirectAction.$className, Ext.form.action.DirectAction]], [Ext.form.action, "DirectSubmit", Ext.form.Action, "DirectSubmit"], 0));
(Ext.cmd.derive("Ext.form.action.StandardSubmit", Ext.form.action.Submit, {
    doSubmit: function () {
        var a = this.buildForm();
        a.formEl.submit();
        this.cleanup(a)
    }
}, 0, 0, 0, 0, ["formaction.standardsubmit"], 0, [Ext.form.action, "StandardSubmit"], 0));
(Ext.cmd.derive("Ext.form.field.Picker", Ext.form.field.Text, {
    alternateClassName: "Ext.form.Picker",
    config: {triggers: {picker: {handler: "onTriggerClick", scope: "this"}}},
    isPickerField: true,
    matchFieldWidth: true,
    pickerAlign: "tl-bl?",
    openCls: "x-pickerfield-open",
    isExpanded: false,
    editable: true,
    applyTriggers: function (b) {
        var c = this, a = b.picker;
        if (!a.cls) {
            a.cls = c.triggerCls
        }
        return Ext.form.field.Text.prototype.applyTriggers.call(this, b)
    },
    getSubTplData: function (b) {
        var c = this, d, a;
        d = Ext.form.field.Text.prototype.getSubTplData.call(this, b);
        if (c.ariaRole) {
            a = d.inputElAriaAttributes;
            if (a) {
                a["aria-haspopup"] = true;
                a["aria-expanded"] = false
            }
        }
        return d
    },
    initEvents: function () {
        var a = this;
        Ext.form.field.Text.prototype.initEvents.call(this);
        a.keyNav = new Ext.util.KeyNav(a.inputEl, {
            down: a.onDownArrow,
            esc: {handler: a.onEsc, scope: a, defaultEventAction: false},
            scope: a,
            forceKeyDown: true
        });
        if (!a.editable) {
            a.mon(a.inputEl, "click", a.onTriggerClick, a)
        }
        if (Ext.isGecko) {
            a.inputEl.dom.setAttribute("autocomplete", "off")
        }
    },
    onEsc: function (a) {
        if (Ext.isIE) {
            a.preventDefault()
        }
        if (this.isExpanded) {
            this.collapse();
            a.stopEvent()
        }
    },
    onDownArrow: function (b) {
        var a = this;
        if ((b.time - a.lastDownArrow) > 150) {
            delete a.lastDownArrow
        }
        if (!a.isExpanded) {
            b.stopEvent();
            a.onTriggerClick();
            a.lastDownArrow = b.time
        } else {
            if (!b.isStopped && (b.time - a.lastDownArrow) < 150) {
                delete a.lastDownArrow
            }
        }
    },
    expand: function () {
        var d = this, b, a, c, e, g;
        if (d.rendered && !d.isExpanded && !d.destroyed) {
            b = d.bodyEl;
            c = d.getPicker();
            e = Ext.getDoc();
            g = d.collapseIf;
            c.setMaxHeight(c.initialConfig.maxHeight);
            if (d.matchFieldWidth) {
                c.setWidth(d.bodyEl.getWidth())
            }
            c.show();
            d.isExpanded = true;
            d.alignPicker();
            b.addCls(d.openCls);
            if (d.ariaRole) {
                a = d.ariaEl.dom;
                a.setAttribute("aria-owns", c.listEl ? c.listEl.id : c.el.id);
                a.setAttribute("aria-expanded", true)
            }
            d.hideListeners = e.on({
                mousewheel: d.collapseIf,
                touchstart: d.collapseIf,
                scope: d,
                delegated: false,
                destroyable: true
            });
            Ext.on("resize", d.alignPicker, d, {buffer: 1});
            d.fireEvent("expand", d);
            d.onExpand()
        }
    },
    onExpand: Ext.emptyFn,
    alignPicker: function () {
        if (!this.destroyed) {
            var a = this.getPicker();
            if (a.isVisible() && a.isFloating()) {
                this.doAlign()
            }
        }
    },
    doAlign: function () {
        var d = this, c = d.picker, a = "-above", b;
        d.picker.alignTo(d.triggerWrap, d.pickerAlign, d.pickerOffset);
        b = c.el.getY() < d.inputEl.getY();
        d.bodyEl[b ? "addCls" : "removeCls"](d.openCls + a);
        c[b ? "addCls" : "removeCls"](c.baseCls + a)
    },
    collapse: function () {
        var d = this;
        if (d.isExpanded && !d.destroyed && !d.destroying) {
            var c = d.openCls, b = d.picker, a = "-above";
            b.hide();
            d.isExpanded = false;
            d.bodyEl.removeCls([c, c + a]);
            b.el.removeCls(b.baseCls + a);
            if (d.ariaRole) {
                d.ariaEl.dom.setAttribute("aria-expanded", false)
            }
            d.hideListeners.destroy();
            Ext.un("resize", d.alignPicker, d);
            d.fireEvent("collapse", d);
            d.onCollapse()
        }
    },
    onCollapse: Ext.emptyFn,
    collapseIf: function (b) {
        var a = this;
        if (!a.destroyed && !b.within(a.bodyEl, false, true) && !a.owns(b.target) && !Ext.fly(b.target).isFocusable()) {
            a.collapse()
        }
    },
    getPicker: function () {
        var b = this, a = b.picker;
        if (!a) {
            b.creatingPicker = true;
            b.picker = a = b.createPicker();
            a.ownerCmp = b;
            delete b.creatingPicker
        }
        return b.picker
    },
    onFocusLeave: function (b) {
        var a = this;
        a.collapse();
        Ext.form.field.Text.prototype.onFocusLeave.call(this, b)
    },
    getRefItems: function () {
        var a = [];
        if (this.picker) {
            a[0] = this.picker
        }
        return a
    },
    createPicker: Ext.emptyFn,
    onTriggerClick: function (b) {
        var a = this;
        if (!a.readOnly && !a.disabled) {
            if (a.isExpanded) {
                a.collapse()
            } else {
                a.expand()
            }
        }
    },
    beforeDestroy: function () {
        var b = this, a = b.picker;
        Ext.form.field.Text.prototype.beforeDestroy.call(this);
        Ext.un("resize", b.alignPicker, b);
        Ext.destroy(b.keyNav, a);
        if (a) {
            b.picker = a.pickerField = null
        }
    }
}, 0, ["pickerfield"], ["component", "box", "field", "textfield", "pickerfield"], {
    component: true,
    box: true,
    field: true,
    textfield: true,
    pickerfield: true
}, ["widget.pickerfield"], 0, [Ext.form.field, "Picker", Ext.form, "Picker"], 0));
(Ext.cmd.derive("Ext.selection.Model", Ext.mixin.Observable, {
    alternateClassName: "Ext.AbstractSelectionModel",
    factoryConfig: {defaultType: "dataviewmodel"},
    $configPrefixed: false,
    $configStrict: false,
    config: {store: null, selected: {}},
    isSelectionModel: true,
    allowDeselect: undefined,
    toggleOnClick: true,
    selected: null,
    pruneRemoved: true,
    suspendChange: 0,
    ignoreRightMouseSelection: false,
    constructor: function (a) {
        var b = this;
        b.modes = {SINGLE: true, SIMPLE: true, MULTI: true};
        Ext.mixin.Observable.prototype.constructor.call(this, a);
        b.setSelectionMode(b.mode);
        if (b.selectionMode !== "SINGLE") {
            b.allowDeselect = true
        }
    },
    updateStore: function (a, b) {
        this.bindStore(a, !b)
    },
    applySelected: function (a) {
        if (!a.isCollection) {
            a = new Ext.util.Collection(Ext.apply({rootProperty: "data"}, a))
        }
        return a
    },
    onBindStore: function (a, b) {
        var c = this;
        c.mixins.storeholder.onBindStore.call(c, [a, b]);
        if (a && !c.preventRefresh) {
            c.refresh()
        }
    },
    getStoreListeners: function () {
        var a = this;
        return {
            add: a.onStoreAdd,
            clear: a.onStoreClear,
            remove: a.onStoreRemove,
            update: a.onStoreUpdate,
            idchanged: a.onIdChanged,
            load: a.onStoreLoad,
            refresh: a.onStoreRefresh,
            pageadd: a.onPageAdd,
            pageremove: a.onPageRemove
        }
    },
    suspendChanges: function () {
        ++this.suspendChange
    },
    resumeChanges: function () {
        if (this.suspendChange) {
            --this.suspendChange
        }
    },
    selectAll: function (a) {
        var c = this, b = c.store.getRange(), d = c.getSelection().length;
        c.suspendChanges();
        c.doSelect(b, true, a);
        c.resumeChanges();
        if (!a && !c.destroyed) {
            c.maybeFireSelectionChange(c.getSelection().length !== d)
        }
    },
    deselectAll: function (k) {
        var g = this, b = g.getSelection(), h = {}, j = g.store, a = b.length, e, c, d;
        for (e = 0, c = b.length; e < c; e++) {
            d = b[e];
            h[d.id] = j.indexOf(d)
        }
        b = Ext.Array.sort(b, function (m, i) {
            var n = h[m.id], l = h[i.id];
            return n < l ? -1 : 1
        });
        g.suspendChanges();
        g.doDeselect(b, k);
        g.resumeChanges();
        if (!k && !g.destroyed) {
            g.maybeFireSelectionChange(g.getSelection().length !== a)
        }
    },
    getSelectionStart: function () {
        return this.selectionStart
    },
    setSelectionStart: function (a) {
        this.selectionStart = a
    },
    selectWithEvent: function (b, g) {
        var d = this, c = d.isSelected(b), a = g.shiftKey;
        switch (d.selectionMode) {
            case"MULTI":
                d.selectWithEventMulti(b, g, c);
                break;
            case"SIMPLE":
                d.selectWithEventSimple(b, g, c);
                break;
            case"SINGLE":
                d.selectWithEventSingle(b, g, c);
                break
        }
        if (!a) {
            if (d.isSelected(b)) {
                d.selectionStart = b
            } else {
                d.selectionStart = null
            }
        }
    },
    vetoSelection: function (a) {
        if (a.stopSelection) {
            return true
        } else {
            if (a.type !== "keydown" && a.button !== 0) {
                if (this.ignoreRightMouseSelection || this.isSelected(a.record)) {
                    return true
                }
            } else {
                return a.type === "mousedown"
            }
        }
    },
    onNavigate: function (h) {
        if (!h.record || this.vetoSelection(h.keyEvent)) {
            return
        }
        this.onBeforeNavigate(h);
        var j = this, i = h.keyEvent, b = i.ctrlKey || h.ctrlKey, d = h.recordIndex, g = h.record, n = h.previousRecord,
            c = j.isSelected(g),
            l = (j.selectionStart && j.isSelected(h.previousRecord)) ? j.selectionStart : (j.selectionStart = h.previousRecord),
            a = h.previousRecordIndex, m = i.getCharCode(), o = m === i.SPACE,
            k = m === i.UP || m === i.PAGE_UP ? "up" : (m === i.DOWN || m === i.DOWN ? "down" : null);
        switch (j.selectionMode) {
            case"MULTI":
                j.setSelectionStart(h.selectionStart);
                if (m === i.A && b) {
                    j.selected.beginUpdate();
                    j.selectRange(0, j.store.getCount() - 1);
                    j.selected.endUpdate()
                } else {
                    if (o) {
                        if (i.shiftKey) {
                            j.selectRange(l, g, b)
                        } else {
                            if (c) {
                                if (j.allowDeselect) {
                                    j.doDeselect(g)
                                }
                            } else {
                                j.doSelect(g, b)
                            }
                        }
                    } else {
                        if (i.shiftKey && l) {
                            if (k === "up" && a <= d) {
                                j.deselectRange(n, d + 1)
                            } else {
                                if (k === "down" && a >= d) {
                                    j.deselectRange(n, d - 1)
                                } else {
                                    if (l !== g) {
                                        j.selectRange(l, g, b)
                                    }
                                }
                            }
                            j.lastSelected = g
                        } else {
                            if (m) {
                                if (!b) {
                                    j.doSelect(g, false)
                                }
                            } else {
                                j.selectWithEvent(g, i)
                            }
                        }
                    }
                }
                break;
            case"SIMPLE":
                if (m === i.A && b) {
                    j.selected.beginUpdate();
                    j.selectRange(0, j.store.getCount() - 1);
                    j.selected.endUpdate()
                } else {
                    if (c) {
                        j.doDeselect(g)
                    } else {
                        j.doSelect(g, true)
                    }
                }
                break;
            case"SINGLE":
                if (k) {
                    if (!b) {
                        j.doSelect(g, false)
                    }
                } else {
                    if (c) {
                        if (j.allowDeselect) {
                            j.doDeselect(g)
                        }
                    } else {
                        j.doSelect(g)
                    }
                }
        }
        if (!i.shiftKey && !j.destroyed && j.isSelected(g)) {
            j.selectionStart = g;
            j.selectionStartIdx = d
        }
    },
    selectRange: function (m, d, n) {
        var j = this, l = j.store, c = j.selected.items, o, g, h, e, a, k, b;
        if (j.isLocked()) {
            return
        }
        o = j.normalizeRowRange(m, d);
        m = o[0];
        d = o[1];
        e = [];
        for (g = m; g <= d; g++) {
            if (!j.isSelected(l.getAt(g))) {
                e.push(l.getAt(g))
            }
        }
        if (!n) {
            a = [];
            j.suspendChanges();
            for (g = 0, h = c.length; g < h; ++g) {
                b = c[g];
                k = l.indexOf(b);
                if (k < m || k > d) {
                    a.push(b)
                }
            }
            for (g = 0, h = a.length; g < h; ++g) {
                j.doDeselect(a[g])
            }
            j.resumeChanges()
        }
        if (!j.destroyed) {
            if (e.length) {
                j.doMultiSelect(e, true)
            } else {
                if (a) {
                    j.maybeFireSelectionChange(a.length > 0)
                }
            }
        }
    },
    deselectRange: function (e, d) {
        var j = this, c = j.store, a, h, g, b;
        if (j.isLocked()) {
            return
        }
        a = j.normalizeRowRange(e, d);
        e = a[0];
        d = a[1];
        g = [];
        for (h = e; h <= d; h++) {
            b = c.getAt(h);
            if (j.isSelected(b)) {
                g.push(b)
            }
        }
        if (g.length) {
            j.doDeselect(g)
        }
    },
    normalizeRowRange: function (c, b) {
        var a = this.store, d;
        if (!Ext.isNumber(c)) {
            c = a.indexOf(c)
        }
        c = Math.max(0, c);
        if (!Ext.isNumber(b)) {
            b = a.indexOf(b)
        }
        b = Math.min(b, a.getCount() - 1);
        if (c > b) {
            d = b;
            b = c;
            c = d
        }
        return [c, b]
    },
    select: function (b, c, a) {
        if (Ext.isDefined(b) && !(Ext.isArray(b) && !b.length)) {
            this.doSelect(b, c, a)
        }
    },
    deselect: function (b, a) {
        this.doDeselect(b, a)
    },
    doSelect: function (c, e, b) {
        var d = this, a;
        if (d.locked || c == null) {
            return
        }
        if (typeof c === "number") {
            a = d.store.getAt(c);
            if (!a) {
                return
            }
            c = [a]
        }
        if (d.selectionMode === "SINGLE") {
            if (c.isModel) {
                c = [c]
            }
            if (c.length) {
                d.doSingleSelect(c[0], b)
            }
        } else {
            d.doMultiSelect(c, e, b)
        }
    },
    doMultiSelect: function (a, l, k) {
        var h = this, b = h.selected, j = false, m, d, g, e, c;
        if (h.locked) {
            return
        }
        a = !Ext.isArray(a) ? [a] : a;
        g = a.length;
        if (!l && b.getCount() > 0) {
            m = h.deselectDuringSelect(a, k);
            if (h.destroyed) {
                return
            }
            if (m[0]) {
                h.maybeFireSelectionChange(m[1] > 0 && !k);
                return
            } else {
                j = m[1] > 0
            }
        }
        c = function () {
            if (!b.getCount()) {
                h.selectionStart = e
            }
            b.add(e);
            j = true
        };
        for (d = 0; d < g; d++) {
            e = a[d];
            if (h.isSelected(e)) {
                continue
            }
            h.onSelectChange(e, true, k, c);
            if (h.destroyed) {
                return
            }
        }
        h.lastSelected = e;
        h.maybeFireSelectionChange(j && !k)
    },
    deselectDuringSelect: function (d, j) {
        var h = this, a = h.selected.getRange(), g = a.length, c = 0, e = false, k, b;
        h.suspendChanges();
        h.deselectingDuringSelect = true;
        for (b = 0; b < g; ++b) {
            k = a[b];
            if (!Ext.Array.contains(d, k)) {
                if (h.doDeselect(k, j)) {
                    ++c
                } else {
                    e = true
                }
            }
            if (h.destroyed) {
                e = true;
                c = 0;
                break
            }
        }
        h.deselectingDuringSelect = false;
        h.resumeChanges();
        return [e, c]
    },
    doDeselect: function (a, k) {
        var j = this, b = j.selected, d = 0, h, e, l = 0, g = 0, c;
        if (j.locked || !j.store) {
            return false
        }
        if (typeof a === "number") {
            e = j.store.getAt(a);
            if (!e) {
                return false
            }
            a = [e]
        } else {
            if (!Ext.isArray(a)) {
                a = [a]
            }
        }
        c = function () {
            ++g;
            b.remove(e);
            if (e === j.selectionStart) {
                j.selectionStart = null
            }
        };
        h = a.length;
        j.suspendChanges();
        for (; d < h; d++) {
            e = a[d];
            if (j.isSelected(e)) {
                if (j.lastSelected === e) {
                    j.lastSelected = b.last()
                }
                ++l;
                j.onSelectChange(e, false, k, c);
                if (j.destroyed) {
                    return false
                }
            }
        }
        j.resumeChanges();
        j.maybeFireSelectionChange(g > 0 && !k);
        return g === l
    },
    doSingleSelect: function (a, b) {
        var d = this, g = false, c = d.selected, e;
        if (d.locked) {
            return
        }
        if (d.isSelected(a)) {
            return
        }
        e = function () {
            if (c.getCount()) {
                d.suspendChanges();
                var h = d.deselectDuringSelect([a], b);
                if (d.destroyed) {
                    return
                }
                d.resumeChanges();
                if (h[0]) {
                    return false
                }
            }
            d.lastSelected = a;
            if (!c.getCount()) {
                d.selectionStart = a
            }
            c.add(a);
            g = true
        };
        d.onSelectChange(a, true, b, e);
        if (g && !d.destroyed) {
            d.maybeFireSelectionChange(!b)
        }
    },
    maybeFireSelectionChange: function (a) {
        var b = this;
        if (a && !b.suspendChange) {
            b.fireEvent("selectionchange", b, b.getSelection())
        }
    },
    getLastSelected: function () {
        return this.lastSelected
    },
    getSelection: function () {
        return this.selected.getRange()
    },
    getSelectionMode: function () {
        return this.selectionMode
    },
    setSelectionMode: function (a) {
        a = a ? a.toUpperCase() : "SINGLE";
        this.selectionMode = this.modes[a] ? a : "SINGLE"
    },
    isLocked: function () {
        return this.locked
    },
    setLocked: function (a) {
        this.locked = !!a
    },
    isRangeSelected: function (d, c) {
        var g = this, b = g.store, e, a;
        a = g.normalizeRowRange(d, c);
        d = a[0];
        c = a[1];
        for (e = d; e <= c; e++) {
            if (!g.isSelected(b.getAt(e))) {
                return false
            }
        }
        return true
    },
    isSelected: function (a) {
        a = Ext.isNumber(a) ? this.store.getAt(a) : a;
        return this.selected.contains(a)
    },
    hasSelection: function () {
        var a = this.getSelected();
        return !!(a && a.getCount())
    },
    refresh: function () {
        var m = this, p = m.store, h = [], l = [], g = m.getSelection(), j = g.length, c = m.getSelected(), n, k, a, o,
            b, e;
        if (!p || !(c.isCollection || c.isRows) || !c.getCount()) {
            return
        }
        a = p.getData();
        if (a.getSource) {
            k = a.getSource();
            if (k) {
                a = k
            }
        }
        m.refreshing = true;
        c.beginUpdate();
        m.suspendChanges();
        for (e = 0; e < j; e++) {
            o = g[e];
            b = a.get(o.getId());
            if (b) {
                h.push(b)
            } else {
                if (!m.pruneRemoved) {
                    l.push(o)
                }
            }
            if (m.mode === "SINGLE" && l.length) {
                break
            }
        }
        if (c.getCount() !== (h.length + l.length)) {
            n = true
        }
        m.clearSelections();
        if (h.length) {
            m.doSelect(h, false, true)
        }
        if (l.length) {
            c.add(l);
            if (!m.lastSelected) {
                m.lastSelected = l[l.length - 1]
            }
        }
        m.resumeChanges();
        if (n) {
            c.endUpdate()
        } else {
            c.updating--
        }
        m.refreshing = false;
        m.maybeFireSelectionChange(n)
    },
    clearSelections: function () {
        var a = this.getSelected();
        if (a) {
            a.clear()
        }
        this.lastSelected = null
    },
    onStoreAdd: Ext.emptyFn,
    onStoreClear: function () {
        if (!this.store.isLoading() && this.hasSelection()) {
            this.clearSelections();
            this.maybeFireSelectionChange(true)
        }
    },
    onStoreRemove: function (k, b, e, l) {
        var j = this, a = b, d, g, c, h;
        if (j.selectionStart && Ext.Array.contains(b, j.selectionStart)) {
            j.selectionStart = null
        }
        if (l || j.locked || !j.pruneRemoved) {
            return
        }
        h = k.isMoving(null, true);
        if (h) {
            a = null;
            for (d = 0, g = b.length; d < g; ++d) {
                c = b[d];
                if (!h[c.id]) {
                    (a || (a = [])).push(c)
                }
            }
        }
        if (a) {
            j.deselect(a)
        }
    },
    onPageRemove: function (b, a, c) {
        this.onStoreRemove(this.store, c)
    },
    onPageAdd: function (d, c, e) {
        var a = e.length, g, b;
        for (g = 0; g < a; g++) {
            b = e[g];
            if (this.selected.get(b.id)) {
                this.selected.replace(b)
            }
        }
    },
    getCount: function () {
        return this.selected.getCount()
    },
    onUpdate: Ext.emptyFn,
    destroy: function () {
        var a = this;
        a.clearSelections();
        a.bindStore(null);
        a.selected = Ext.destroy(a.selected);
        Ext.mixin.Observable.prototype.destroy.call(this)
    },
    onStoreUpdate: Ext.emptyFn,
    onIdChanged: function (a, d, c, b) {
        this.selected.updateKey(d, c)
    },
    onStoreRefresh: function () {
        this.updateSelectedInstances(this.selected)
    },
    updateSelectedInstances: function (e) {
        var k = this, m = k.getStore(), l = k.lastSelected, a = 0, c = k.pruneRemovedOnRefresh(), j, b, g, n, d, h;
        if (m.isBufferedStore) {
            return
        }
        j = e.getRange();
        b = j.length;
        if (l) {
            k.lastSelected = m.getById(l.id);
            h = k.lastSelected !== l
        }
        k.refreshing = true;
        for (g = 0; g < b; ++g) {
            n = j[g];
            d = m.getById(n.id);
            if (d) {
                if (d !== n) {
                    e.replace(d)
                }
            } else {
                if (c) {
                    e.remove(n);
                    ++a
                }
            }
        }
        k.refreshing = false;
        k.maybeFireSelectionChange(a > 0);
        if (h) {
            k.fireEvent("lastselectedchanged", k, k.getSelection(), k.lastSelected)
        }
    },
    pruneRemovedOnRefresh: function () {
        return this.pruneRemoved
    },
    onStoreLoad: Ext.emptyFn,
    onSelectChange: function (a, d, c, g) {
        var e = this, b = d ? "select" : "deselect";
        if ((c || e.fireEvent("before" + b, e, a)) !== false && g() !== false) {
            if (!c) {
                e.fireEvent(b, e, a)
            }
        }
    },
    onEditorKey: Ext.emptyFn,
    beforeViewRender: function (a) {
        Ext.Array.include(this.views || (this.views = []), a)
    },
    onHeaderClick: Ext.emptyFn,
    resolveListenerScope: function (c) {
        var a = this.view, b;
        if (a) {
            b = a.resolveSatelliteListenerScope(this, c)
        }
        return b || Ext.mixin.Observable.prototype.resolveListenerScope.call(this, c)
    },
    bindComponent: Ext.emptyFn,
    privates: {
        onBeforeNavigate: Ext.privateFn, selectWithEventMulti: function (k, m, d) {
            var n = this, g = m.shiftKey, a = m.ctrlKey, c = g ? (n.getSelectionStart()) : null, h = n.getSelection(),
                l = h.length, b, j, o;
            if (g && c) {
                n.selectRange(c, k, a)
            } else {
                if (a && d) {
                    if (n.allowDeselect) {
                        n.doDeselect(k, false)
                    }
                } else {
                    if (a) {
                        n.doSelect(k, true, false)
                    } else {
                        if (d && !g && !a && l > 1) {
                            if (n.allowDeselect) {
                                b = [];
                                for (j = 0; j < l; ++j) {
                                    o = h[j];
                                    if (o !== k) {
                                        b.push(o)
                                    }
                                }
                                n.doDeselect(b)
                            }
                        } else {
                            if (!d) {
                                n.doSelect(k, false)
                            }
                        }
                    }
                }
            }
        }, selectWithEventSimple: function (a, c, b) {
            if (b) {
                this.doDeselect(a)
            } else {
                this.doSelect(a, true)
            }
        }, selectWithEventSingle: function (b, g, c) {
            var d = this, a = d.allowDeselect;
            if (a && !g.ctrlKey) {
                a = d.toggleOnClick
            }
            if (a && c) {
                d.doDeselect(b)
            } else {
                d.doSelect(b, false)
            }
        }
    }
}, 1, 0, 0, 0, ["selection.abstract"], [[Ext.util.StoreHolder.prototype.mixinId || Ext.util.StoreHolder.$className, Ext.util.StoreHolder], [Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.selection, "Model", Ext, "AbstractSelectionModel"], 0));
(Ext.cmd.derive("Ext.selection.DataViewModel", Ext.selection.Model, {
    deselectOnContainerClick: true, bindComponent: function (a) {
        var c = this, b;
        if (c.view !== a) {
            if (c.view) {
                c.navigationModel = null;
                Ext.destroy(c.viewListeners, c.navigationListeners)
            }
            c.view = a;
            if (a) {
                b = c.getViewListeners();
                b.scope = c;
                b.destroyable = true;
                c.navigationModel = a.getNavigationModel();
                c.viewListeners = a.on(b);
                c.navigationListeners = c.navigationModel.on({navigate: c.onNavigate, scope: c, destroyable: true})
            }
        }
    }, getViewListeners: function () {
        var a = this, b = {};
        b[a.view.triggerCtEvent] = a.onContainerClick;
        return b
    }, onUpdate: function (b) {
        var a = this.view;
        if (a && this.isSelected(b)) {
            a.onItemSelect(b)
        }
    }, onContainerClick: function () {
        if (this.deselectOnContainerClick) {
            this.deselectAll()
        }
    }, onSelectChange: function (b, g, e, i) {
        var h = this, a = h.view, d = g ? "select" : "deselect", c = h.store.indexOf(b);
        if ((e || h.fireEvent("before" + d, h, b, c)) !== false && i() !== false) {
            if (a) {
                if (g) {
                    a.onItemSelect(b)
                } else {
                    a.onItemDeselect(b)
                }
            }
            if (!e) {
                h.fireEvent(d, h, b, c)
            }
        }
    }, destroy: function () {
        this.bindComponent();
        Ext.destroy(this.keyNav);
        Ext.selection.Model.prototype.destroy.call(this)
    }
}, 0, 0, 0, 0, ["selection.dataviewmodel"], 0, [Ext.selection, "DataViewModel"], 0));
(Ext.cmd.derive("Ext.view.NavigationModel", Ext.Base, {
    config: {store: null}, focusCls: "x-view-item-focused", constructor: function () {
        this.mixins.observable.constructor.call(this)
    }, bindComponent: function (a) {
        if (this.view !== a) {
            this.view = a;
            this.bindView(a)
        }
    }, bindView: function (a) {
        var c = this, d = a.dataSource, b;
        c.initKeyNav(a);
        if (!d.isEmptyStore) {
            c.setStore(d)
        }
        b = c.getViewListeners();
        b.destroyable = true;
        c.viewListeners = c.viewListeners || [];
        c.viewListeners.push(a.on(b))
    }, updateStore: function (a) {
        this.mixins.storeholder.bindStore.apply(this, [a])
    }, getStoreListeners: function () {
        var a = this;
        return {remove: {fn: a.onStoreRemove, priority: 1000}, scope: a}
    }, getViewListeners: function () {
        var a = this;
        return {
            containermousedown: a.onContainerMouseDown,
            itemmousedown: a.onItemMouseDown,
            itemclick: a.onItemClick,
            itemcontextmenu: a.onItemMouseDown,
            scope: a
        }
    }, initKeyNav: function (a) {
        var b = this;
        b.keyNav = new Ext.util.KeyNav({
            target: a,
            ignoreInputFields: true,
            eventName: "itemkeydown",
            defaultEventAction: "stopEvent",
            processEvent: b.processViewEvent,
            up: b.onKeyUp,
            down: b.onKeyDown,
            right: b.onKeyRight,
            left: b.onKeyLeft,
            pageDown: b.onKeyPageDown,
            pageUp: b.onKeyPageUp,
            home: b.onKeyHome,
            end: b.onKeyEnd,
            space: b.onKeySpace,
            enter: b.onKeyEnter,
            A: {ctrl: true, handler: b.onSelectAllKeyPress},
            scope: b
        })
    }, processViewEvent: function (b, a, e, c, d) {
        return d
    }, addKeyBindings: function (a) {
        this.keyNav.addBindings(a)
    }, enable: function () {
        this.keyNav.enable();
        this.disabled = false
    }, disable: function () {
        this.keyNav.disable();
        this.disabled = true
    }, onContainerMouseDown: function (a, b) {
        if (this.view.containsFocus) {
            b.preventDefault()
        }
    }, onItemMouseDown: function (b, a, g, d, c) {
        var e = c.parentEvent;
        if (!e || e.type !== "touchstart") {
            this.setPosition(d)
        }
    }, onItemClick: function (c, b, e, d, a) {
        if (this.record === b) {
            this.fireNavigateEvent(a)
        } else {
            this.setPosition(d, a)
        }
    }, beforeViewRefresh: function () {
        this.focusRestorePosition = this.view.dataSource.isBufferedStore ? this.recordIndex : this.record
    }, onViewRefresh: function () {
        if (this.focusRestorePosition != null) {
            this.setPosition(this.focusRestorePosition);
            this.focusRestorePosition = null
        }
    }, onStoreRemove: function (a) {
        var b = this;
        if (b.record && b.view.el.contains(Ext.Element.getActiveElement())) {
            b.view.refreshing = true;
            Ext.on({idle: b.afterStoreRemove, scope: b, single: true, args: [b.record, b.recordIndex, a]})
        }
    }, afterStoreRemove: function (e, d, b) {
        var c = this, a = c.view;
        a.refreshing = false;
        if (!b.getCount()) {
            c.setPosition();
            a.revertFocus()
        }
        if (!a.el.contains(Ext.Element.getActiveElement())) {
            c.setPosition(b.contains(e) ? e : d, null, null, true)
        }
    }, setPosition: function (c, h, k, d) {
        var i = this, j = i.view, e = j.getSelectionModel(), a = j.dataSource, g, b;
        if (c == null || !j.all.getCount()) {
            i.record = i.recordIndex = null
        } else {
            if (typeof c === "number") {
                b = Math.max(Math.min(c, a.getCount() - 1), 0);
                g = a.getAt(c)
            } else {
                if (c.isEntity) {
                    g = a.getById(c.id);
                    b = a.indexOf(g);
                    if (b === -1) {
                        g = a.getAt(0);
                        b = 0
                    }
                } else {
                    if (c.tagName) {
                        g = j.getRecord(c);
                        b = a.indexOf(g)
                    } else {
                        g = b = null
                    }
                }
            }
        }
        if (g === i.record) {
            i.recordIndex = b;
            return i.focusPosition(b)
        }
        if (i.item) {
            i.item.removeCls(i.focusCls)
        }
        i.previousRecordIndex = i.recordIndex;
        i.previousRecord = i.record;
        i.previousItem = i.item;
        i.recordIndex = b;
        i.record = g;
        d = d || i.record === i.lastFocused;
        if (g) {
            i.focusPosition(i.recordIndex)
        } else {
            i.item = null
        }
        if (!k) {
            e.fireEvent("focuschange", e, i.previousRecord, i.record)
        }
        if (!d && h) {
            i.fireNavigateEvent(h)
        }
    }, focusPosition: function (a) {
        var b = this;
        if (a != null && a !== -1) {
            if (a.isEntity) {
                a = b.view.dataSource.indexOf(a)
            }
            b.item = b.view.all.item(a);
            if (b.item) {
                b.lastFocused = b.record;
                b.lastFocusedIndex = b.recordIndex;
                b.focusItem(b.item)
            } else {
                b.record = null
            }
        } else {
            b.item = null
        }
    }, focusItem: function (a) {
        a.addCls(this.focusCls);
        a.focus()
    }, getPosition: function () {
        return this.record ? this.recordIndex : null
    }, getRecordIndex: function () {
        return this.recordIndex
    }, getItem: function () {
        return this.item
    }, getRecord: function () {
        return this.record
    }, getLastFocused: function () {
        if (this.view.dataSource.indexOf(this.lastFocused) === -1) {
            return null
        }
        return this.lastFocused
    }, onKeyUp: function (b) {
        var a = this.recordIndex - 1;
        if (a < 0) {
            a = this.view.all.getCount() - 1
        }
        this.setPosition(a, b)
    }, onKeyDown: function (b) {
        var a = this.recordIndex + 1;
        if (a > this.view.all.getCount() - 1) {
            a = 0
        }
        this.setPosition(a, b)
    }, onKeyRight: function (b) {
        var a = this.recordIndex + 1;
        if (a > this.view.all.getCount() - 1) {
            a = 0
        }
        this.setPosition(a, b)
    }, onKeyLeft: function (b) {
        var a = this.recordIndex - 1;
        if (a < 0) {
            a = this.view.all.getCount() - 1
        }
        this.setPosition(a, b)
    }, onKeyPageDown: Ext.emptyFn, onKeyPageUp: Ext.emptyFn, onKeyHome: function (a) {
        this.setPosition(0, a)
    }, onKeyEnd: function (a) {
        this.setPosition(this.view.all.getCount() - 1, a)
    }, onKeySpace: function (a) {
        this.fireNavigateEvent(a)
    }, onKeyEnter: function (a) {
        a.stopEvent();
        a.view.fireEvent("itemclick", a.view, a.record, a.item, a.recordIndex, a)
    }, onSelectAllKeyPress: function (a) {
        this.fireNavigateEvent(a)
    }, fireNavigateEvent: function (b) {
        var a = this;
        a.fireEvent("navigate", {
            navigationModel: a,
            keyEvent: b,
            previousRecordIndex: a.previousRecordIndex,
            previousRecord: a.previousRecord,
            previousItem: a.previousItem,
            recordIndex: a.recordIndex,
            record: a.record,
            item: a.item
        })
    }, destroy: function () {
        var a = this;
        a.setStore(null);
        Ext.destroy(a.viewListeners, a.keyNav);
        a.keyNav = a.viewListeners = a.dataSource = a.lastFocused = null;
        a.callParent()
    }
}, 1, 0, 0, 0, ["view.navigation.default"], [[Ext.util.Observable.prototype.mixinId || Ext.util.Observable.$className, Ext.util.Observable], [Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable], [Ext.util.StoreHolder.prototype.mixinId || Ext.util.StoreHolder.$className, Ext.util.StoreHolder]], [Ext.view, "NavigationModel"], 0));
(Ext.cmd.derive("Ext.view.AbstractView", Ext.Component, {
    inheritableStatics: {
        getRecord: function (a) {
            return this.getBoundView(a).getRecord(a)
        }, getBoundView: function (a) {
            return Ext.getCmp(a.getAttribute("data-boundView"))
        }
    },
    defaultBindProperty: "store",
    renderBuffer: document.createElement("div"),
    statics: {
        updateDelay: 200, queueRecordChange: function (n, p, h, b, c) {
            var m = this, a = m.changeQueue || (m.changeQueue = {}), j = h.internalId, l, g, k, d, q, o, e;
            l = a[j] || (a[j] = {operation: b, record: h, data: {}, views: []});
            g = l.data;
            Ext.Array.include(l.views, n);
            if (c && (k = c.length)) {
                for (d = 0; d < k; d++) {
                    q = c[d];
                    o = h.data[q];
                    if (g.hasOwnProperty(q)) {
                        if (h.isEqual(g[q], o)) {
                            delete g[q];
                            e = true
                        }
                    } else {
                        g[q] = o
                    }
                }
                if (e && !Ext.Object.getKeys(g).length) {
                    delete a[j]
                }
            } else {
                Ext.apply(g, h.data)
            }
            if (!m.flushQueueTask) {
                m.flushQueueTask = Ext.util.TaskManager.newTask({
                    run: Ext.global.requestAnimationFrame ? Ext.Function.createAnimationFrame(m.onFlushTick, m) : Ext.Function.bind(m.onFlushTick, m),
                    interval: Ext.view.AbstractView.updateDelay,
                    repeat: 1
                })
            }
            m.flushQueueTask.start()
        }, onFlushTick: function () {
            Ext.AnimationQueue.start(this.flushChangeQueue, this)
        }, flushChangeQueue: function () {
            var e = this, g, a, j, d, h, c, b;
            if (Ext.isScrolling) {
                e.flushQueueTask.start();
                return
            }
            j = e.changeQueue;
            this.changeQueue = {};
            for (h in j) {
                d = j[h];
                g = d.views;
                a = g.length;
                for (c = 0; c < a; c++) {
                    b = g[c];
                    if (!b.destroyed) {
                        b.handleUpdate(b.dataSource, d.record, d.operation, Ext.Object.getKeys(d.data))
                    }
                }
            }
            Ext.AnimationQueue.stop(e.flushChangeQueue, e)
        }
    },
    config: {
        selection: null,
        store: "ext-empty-store",
        navigationModel: {type: "default"},
        selectionModel: {type: "dataviewmodel"}
    },
    publishes: ["selection"],
    twoWayBindable: ["selection"],
    throttledUpdate: false,
    deferInitialRefresh: false,
    itemCls: "x-dataview-item",
    loadingText: "Loading...",
    loadMask: true,
    loadingUseMsg: true,
    selectedItemCls: "x-item-selected",
    emptyText: "",
    deferEmptyText: true,
    trackOver: false,
    blockRefresh: false,
    preserveScrollOnRefresh: false,
    preserveScrollOnReload: false,
    ariaRole: "listbox",
    itemAriaRole: "option",
    last: false,
    focusable: true,
    tabIndex: 0,
    triggerEvent: "itemclick",
    triggerCtEvent: "containerclick",
    refreshNeeded: true,
    updateSuspendCounter: 0,
    addCmpEvents: Ext.emptyFn,
    constructor: function (a) {
        if (a && a.selModel) {
            a.selectionModel = a.selModel
        }
        Ext.Component.prototype.constructor.call(this, a)
    },
    initComponent: function () {
        var c = this, a = Ext.isDefined, d = c.itemTpl, b = {};
        if (d) {
            if (Ext.isArray(d)) {
                d = d.join("")
            } else {
                if (Ext.isObject(d)) {
                    b = Ext.apply(b, d.initialConfig);
                    d = d.html
                }
            }
            if (!c.itemSelector) {
                c.itemSelector = "." + c.itemCls
            }
            d = Ext.String.format('<tpl for="."><div class="{0}" role="{2}">{1}</div></tpl>', c.itemCls, d, c.itemAriaRole);
            c.tpl = new Ext.XTemplate(d, b)
        }
        Ext.Component.prototype.initComponent.call(this);
        c.tpl = c.getTpl("tpl");
        if (c.overItemCls) {
            c.trackOver = true
        }
        c.addCmpEvents();
        c.store = Ext.data.StoreManager.lookup(c.store || "ext-empty-store");
        if (!c.dataSource) {
            c.dataSource = c.store
        }
        c.getNavigationModel().bindComponent(this);
        c.bindStore(c.dataSource, true, "dataSource");
        if (!c.all) {
            c.all = new Ext.CompositeElementLite()
        }
        c.scrollState = {top: 0, left: 0};
        c.savedTabIndexAttribute = "data-savedtabindex-" + c.id
    },
    getElConfig: function () {
        var a = this.mixins.renderable.getElConfig.call(this);
        if (this.focusable) {
            a.tabIndex = 0
        }
        return a
    },
    onRender: function () {
        var a = this.loadMask;
        Ext.Component.prototype.onRender.apply(this, arguments);
        if (a) {
            this.createMask(a)
        }
    },
    beforeLayout: function () {
        var a = this;
        Ext.Component.prototype.beforeLayout.apply(this, arguments);
        if (a.refreshNeeded && !a.pendingRefresh) {
            if (a.refreshCounter) {
                a.refresh()
            } else {
                a.doFirstRefresh(a.dataSource)
            }
        }
    },
    onMaskBeforeShow: function () {
        var b = this, a = b.loadingHeight;
        if (a && a > b.getHeight()) {
            b.hasLoadingHeight = true;
            b.oldMinHeight = b.minHeight;
            b.minHeight = a;
            b.updateLayout()
        }
    },
    onMaskHide: function () {
        var a = this;
        if (!a.destroying && a.hasLoadingHeight) {
            a.minHeight = a.oldMinHeight;
            a.updateLayout();
            delete a.hasLoadingHeight
        }
    },
    beforeRender: function () {
        Ext.Component.prototype.beforeRender.apply(this, arguments);
        this.getSelectionModel().beforeViewRender(this)
    },
    afterRender: function () {
        Ext.Component.prototype.afterRender.apply(this, arguments);
        if (this.focusable) {
            this.focusEl = this.el
        }
    },
    getRefItems: function () {
        var b = this.loadMask, a = [];
        if (b && b.isComponent) {
            a.push(b)
        }
        return a
    },
    getSelection: function () {
        return this.getSelectionModel().getSelection()
    },
    updateSelection: function (a) {
        var b = this, c;
        if (!b.ignoreNextSelection) {
            b.ignoreNextSelection = true;
            c = b.getSelectionModel();
            if (a) {
                c.select(a)
            } else {
                c.deselectAll()
            }
            b.ignoreNextSelection = false
        }
    },
    updateBindSelection: function (a, c) {
        var d = this, b = null;
        if (!d.ignoreNextSelection) {
            d.ignoreNextSelection = true;
            if (c.length) {
                b = a.getLastSelected();
                d.hasHadSelection = true
            }
            if (d.hasHadSelection) {
                d.setSelection(b)
            }
            d.ignoreNextSelection = false
        }
    },
    applySelectionModel: function (b, g) {
        var e = this, d = e.grid, h, c, a;
        if (g) {
            g.un({
                scope: e,
                selectionchange: e.updateBindSelection,
                lastselectedchanged: e.updateBindSelection,
                select: e.ariaSelect,
                deselect: e.ariaDeselect
            });
            Ext.destroy(e.selModelRelayer);
            b = Ext.Factory.selection(b)
        } else {
            if (b && b.isSelectionModel) {
                b.locked = e.disableSelection
            } else {
                if (e.simpleSelect) {
                    h = "SIMPLE"
                } else {
                    if (e.multiSelect) {
                        h = "MULTI"
                    } else {
                        h = "SINGLE"
                    }
                }
                if (typeof b === "string") {
                    b = {type: b}
                }
                b = Ext.Factory.selection(Ext.apply({
                    allowDeselect: e.allowDeselect || e.multiSelect,
                    mode: h,
                    locked: e.disableSelection
                }, b))
            }
        }
        if (b.mode !== "SINGLE") {
            a = (d || e).ariaEl.dom;
            if (a) {
                a.setAttribute("aria-multiselectable", true)
            } else {
                if (!d) {
                    c = e.ariaRenderAttributes || (e.ariaRenderAttributes = {});
                    c["aria-multiselectable"] = true
                }
            }
        }
        e.selModelRelayer = e.relayEvents(b, ["selectionchange", "beforeselect", "beforedeselect", "select", "deselect", "focuschange"]);
        b.on({
            scope: e,
            lastselectedchanged: e.updateBindSelection,
            selectionchange: e.updateBindSelection,
            select: e.ariaSelect,
            deselect: e.ariaDeselect
        });
        return b
    },
    updateSelectionModel: function (a) {
        this.selModel = a
    },
    applyNavigationModel: function (a) {
        return Ext.Factory.viewNavigation(a)
    },
    onFocusEnter: function (d) {
        var c = this, b = c.getNavigationModel(), a;
        c.toggleChildrenTabbability(false);
        if (!c.itemFocused && c.all.getCount()) {
            a = b.getLastFocused();
            b.setPosition(a || 0, d.event, null, !a);
            c.itemFocused = b.getPosition() != null
        }
        if (c.itemFocused) {
            this.el.dom.setAttribute("tabIndex", "-1")
        }
        Ext.Component.prototype.onFocusEnter.call(this, d)
    },
    onFocusLeave: function (b) {
        var a = this;
        if (a.itemFocused && !a.refreshing) {
            a.getNavigationModel().setPosition(null, b.event, null, true);
            a.itemFocused = false;
            a.el.dom.setAttribute("tabIndex", 0)
        }
        Ext.Component.prototype.onFocusLeave.call(this, b)
    },
    ariaSelect: function (b, a) {
        var c = this.getNode(a);
        if (c) {
            c.setAttribute("aria-selected", true)
        }
    },
    ariaDeselect: function (b, a) {
        var c = this.getNode(a);
        if (c) {
            c.removeAttribute("aria-selected")
        }
    },
    onRemoved: function (a) {
        Ext.Component.prototype.onRemoved.call(this, a);
        if (!a) {
            this.onFocusLeave({})
        }
    },
    refresh: function () {
        var j = this, i = j.all, l = i.getCount(), h = j.refreshCounter, k, d, c, g = j.getSelectionModel(),
            b = j.getNavigationModel(), e = h && i.getCount() && j.preserveScrollOnRefresh && j.getScrollable(), a;
        if (!j.rendered || j.destroyed || j.preventRefresh) {
            return
        }
        if (!j.hasListeners.beforerefresh || j.fireEvent("beforerefresh", j) !== false) {
            j.refreshing = true;
            b.beforeViewRefresh(j);
            k = j.getTargetEl();
            c = j.getViewRange();
            d = k.dom;
            if (e) {
                a = e.getPosition()
            }
            if (h) {
                j.clearViewEl();
                j.refreshCounter++
            } else {
                j.refreshCounter = 1
            }
            j.tpl.append(k, j.collectData(c, i.startIndex || 0));
            if (c.length < 1) {
                j.addEmptyText();
                i.clear()
            } else {
                j.collectNodes(k.dom);
                j.updateIndexes(0)
            }
            b.onViewRefresh();
            if (j.refreshSelmodelOnRefresh !== false) {
                g.refresh()
            }
            j.refreshNeeded = false;
            j.refreshSize(i.getCount() !== l);
            j.fireEvent("refresh", j, c);
            if (e) {
                e.scrollTo(a)
            }
            if (!j.viewReady) {
                j.viewReady = true;
                j.fireEvent("viewready", j)
            }
            j.refreshing = false;
            j.refreshScroll();
            j.cleanupData()
        }
    },
    addEmptyText: function () {
        var b = this, a = b.getStore();
        if (b.emptyText && !a.isLoading() && (!b.deferEmptyText || b.refreshCounter > 1 || a.isLoaded())) {
            b.emptyEl = Ext.core.DomHelper.insertHtml("beforeEnd", b.getTargetEl().dom, b.emptyText)
        }
    },
    getViewRange: function () {
        return this.dataSource.getRange()
    },
    refreshSize: function (d) {
        var c = this, b = c.getSizeModel(), a = c.getScrollable();
        if (b.height.shrinkWrap || b.width.shrinkWrap || d) {
            c.updateLayout()
        } else {
            if (c.touchScroll && !c.bufferedRenderer) {
                if (a) {
                    a.refresh()
                } else {
                    c.on({boxready: c.refreshScroll, scope: c, single: true})
                }
            }
        }
    },
    onResize: function () {
        var b = this, a = b.getScrollable();
        if (a && !b._hasScrollListener) {
            a.on({
                scroll: b.onViewScroll,
                scrollend: b.onViewScrollEnd,
                scope: b,
                onFrame: !!Ext.global.requestAnimationFrame
            });
            b._hasScrollListener = true
        }
        Ext.Component.prototype.onResize.apply(this, arguments)
    },
    clearViewEl: function () {
        var b = this, c = b.getTargetEl(), a = b.getNodeContainer() === c;
        b.clearEmptyEl();
        b.all.clear(!a);
        if (a) {
            c.dom.innerHTML = ""
        }
    },
    clearEmptyEl: function () {
        var a = this.emptyEl;
        if (a) {
            Ext.removeNode(a)
        }
        this.emptyEl = null
    },
    onViewScroll: function (b, a, c) {
        this.fireEvent("scroll", this, a, c)
    },
    onViewScrollEnd: function (b, a, c) {
        this.fireEvent("scrollend", this, a, c)
    },
    saveScrollState: function () {
        var a = this, b = a.scrollState;
        if (a.rendered) {
            b.left = a.getScrollX();
            b.top = a.getScrollY()
        }
    },
    restoreScrollState: function () {
        var a = this, b = a.scrollState;
        if (a.rendered) {
            a.setScrollX(b.left);
            a.setScrollY(b.top)
        }
    },
    prepareData: function (e, d, c) {
        var b, a, g;
        if (c) {
            b = c.getAssociatedData();
            for (a in b) {
                if (b.hasOwnProperty(a)) {
                    if (!g) {
                        e = Ext.Object.chain(e);
                        g = true
                    }
                    e[a] = b[a]
                }
            }
        }
        return e
    },
    collectData: function (c, g) {
        var e = [], d = 0, a = c.length, b;
        for (; d < a; d++) {
            b = c[d];
            e[d] = this.prepareData(b.data, g + d, b)
        }
        return e
    },
    cleanupData: Ext.emptyFn,
    bufferRender: function (d, e) {
        var h = this, j = h.renderBuffer, b = document.createDocumentFragment(), c, a, g;
        h.tpl.overwrite(j, h.collectData(d, e));
        c = Ext.fly(j).query(h.getItemSelector());
        for (g = 0, a = c.length; g < a; g++) {
            b.appendChild(c[g])
        }
        return {fragment: b, children: c}
    },
    nodeContainerSelector: null,
    getNodeContainer: function () {
        var b = this.getTargetEl(), a = this.nodeContainerSelector;
        return a ? b.down(a, true) : b
    },
    getNodeContainerSelector: function () {
        return this.nodeContainerSelector
    },
    onUpdate: function (d, b, c, h, e) {
        var g = this, a = e && e.filtered;
        if (!a && g.getNode(b)) {
            if (g.throttledUpdate) {
                g.statics().queueRecordChange(g, d, b, c, h)
            } else {
                g.handleUpdate.apply(g, arguments)
            }
        }
    },
    handleUpdate: function (c, a) {
        var g = this, d, e, b = g.getSelectionModel();
        if (g.viewReady) {
            d = g.dataSource.indexOf(a);
            if (d > -1) {
                if (g.getNode(a)) {
                    e = g.bufferRender([a], d).children[0];
                    g.all.replaceElement(d, e, true);
                    g.updateIndexes(d, d);
                    b.onUpdate(a);
                    g.refreshSizePending = true;
                    if (b.isSelected(a)) {
                        g.onItemSelect(a)
                    }
                    if (g.hasListeners.itemupdate) {
                        g.fireEvent("itemupdate", a, d, e)
                    }
                    return e
                }
            }
        }
    },
    onReplace: function (j, l, b, c) {
        var h = this, i = h.all, e = h.getSelectionModel(), m = l, o, n, g, a, k, d;
        if (h.rendered) {
            o = h.bufferRender(c, l, true);
            g = o.fragment;
            a = o.children;
            n = i.item(l);
            if (n) {
                i.item(l).insertSibling(g, "before", true)
            } else {
                h.appendNodes(g)
            }
            i.insert(l, a);
            l += c.length;
            d = l + b.length - 1;
            k = i.removeRange(l, d, true);
            if (h.refreshSelmodelOnRefresh !== false) {
                e.refresh()
            }
            h.updateIndexes(l);
            if (h.hasListeners.itemremove) {
                h.fireEvent("itemremove", b, m, k, h)
            }
            if (h.hasListeners.itemadd) {
                h.fireEvent("itemadd", c, m, a)
            }
            h.refreshSize()
        }
    },
    onAdd: function (d, c, e) {
        var g = this, b, a = g.getSelectionModel();
        if (g.rendered) {
            if (g.all.getCount() === 0) {
                g.refresh();
                b = g.all.slice()
            } else {
                b = g.doAdd(c, e);
                if (g.refreshSelmodelOnRefresh !== false) {
                    a.refresh()
                }
                g.updateIndexes(e);
                g.refreshSizePending = true
            }
            if (g.hasListeners.itemadd) {
                g.fireEvent("itemadd", c, e, b)
            }
        }
    },
    appendNodes: function (a) {
        var b = this.all, c = b.getCount();
        if (this.nodeContainerSelector) {
            this.getNodeContainer().appendChild(a)
        } else {
            b.item(c - 1).insertSibling(a, "after")
        }
    },
    doAdd: function (c, e) {
        var h = this, k = h.bufferRender(c, e, true), g = k.fragment, b = k.children, i = h.all, d = i.getCount(),
            j = i.startIndex || 0, a = i.endIndex || d - 1;
        if (d === 0 || e > a) {
            h.appendNodes(g)
        } else {
            if (e <= j) {
                i.item(j).insertSibling(g, "before", true)
            } else {
                i.item(e).insertSibling(b, "before", true)
            }
        }
        i.insert(e, b);
        return b
    },
    onRemove: function (b, e, j) {
        var k = this, m = k.all, c = k.hasListeners.itemremove, l, g, h, a, d;
        if (m.getCount()) {
            if (k.dataSource.getCount() === 0) {
                if (c) {
                    k.fireEvent("itemremove", e, j, k.getNodes(j, j + e.length - 1))
                }
                k.refresh()
            } else {
                if (c) {
                    a = []
                }
                for (g = e.length - 1; g >= 0; --g) {
                    h = e[g];
                    l = j + g;
                    if (a) {
                        d = m.item(l);
                        a[g] = d ? d.dom : undefined
                    }
                    if (m.item(l)) {
                        k.doRemove(h, l)
                    }
                }
                if (c) {
                    k.fireEvent("itemremove", e, j, a, k)
                }
                k.updateIndexes(j)
            }
            k.refreshSizePending = true
        }
    },
    doRemove: function (a, b) {
        this.all.removeElement(b, true)
    },
    refreshNode: function (a) {
        if (Ext.isNumber(a)) {
            a = this.store.getAt(a)
        }
        this.onUpdate(this.dataSource, a)
    },
    updateIndexes: function (h, g) {
        var b = this.all.elements, e, a = this.getViewRange(), d, c = this.id;
        h = h || 0;
        g = g || ((g === 0) ? 0 : (b.length - 1));
        for (d = h; d <= g; d++) {
            e = b[d];
            e.setAttribute("data-recordIndex", d);
            e.setAttribute("data-recordId", a[d].internalId);
            e.setAttribute("data-boundView", c)
        }
    },
    bindStore: function (b, c, g) {
        var e = this, a = e.getSelectionModel(), d = e.getNavigationModel();
        a.preventRefresh = true;
        a.bindStore(b);
        a.bindComponent(b ? e : null);
        a.preventRefresh = false;
        d.setStore(b);
        e.mixins.storeholder.bindStore.apply(e, arguments);
        if (b && e.componentLayoutCounter && !e.preventRefresh) {
            e.doFirstRefresh(b, !c)
        }
    },
    doFirstRefresh: function (a, c) {
        var b = this;
        if (b.deferInitialRefresh && !c) {
            Ext.defer(b.doFirstRefresh, 1, b, [a, true])
        } else {
            if (a && !a.isLoading()) {
                b.refresh()
            }
        }
    },
    onUnbindStore: function (b, c, a) {
        if (a === "store") {
            this.setMaskBind(null);
            this.getSelectionModel().bindStore(null)
        }
    },
    onBindStore: function (a, b, d, e) {
        var c = this;
        if (c.store.isBufferedStore) {
            c.store.preserveScrollOnReload = c.preserveScrollOnReload
        }
        if (e && e.isBufferedStore) {
            delete e.preserveScrollOnReload
        }
        c.setMaskBind(a);
        if (!b && d === "store") {
            c.preventRefresh = true;
            c.store = a;
            c.bindStore(a, false, "dataSource");
            c.preventRefresh = false
        }
    },
    setMaskBind: function (b) {
        var a = this.loadMask;
        if (this.rendered && a && b && !a.bindStore) {
            a = this.createMask()
        }
        if (a && a.bindStore) {
            a.bindStore(b)
        }
    },
    getStoreListeners: function () {
        var a = this;
        return {
            refresh: a.onDataRefresh,
            replace: a.onReplace,
            add: a.onAdd,
            remove: a.onRemove,
            update: a.onUpdate,
            clear: a.onDataRefresh,
            beginupdate: a.onBeginUpdate,
            endupdate: a.onEndUpdate
        }
    },
    onBeginUpdate: function () {
        ++this.updateSuspendCounter;
        Ext.suspendLayouts()
    },
    onEndUpdate: function () {
        var a = this;
        if (a.updateSuspendCounter) {
            --a.updateSuspendCounter
        }
        Ext.resumeLayouts(true);
        if (a.refreshSizePending) {
            a.refreshSize(true);
            a.refreshSizePending = false
        }
    },
    onDataRefresh: function (a) {
        var c = this, b = c.preserveScrollOnRefresh;
        if (a.loadCount > c.lastRefreshLoadCount) {
            c.preserveScrollOnRefresh = c.preserveScrollOnReLoad
        }
        c.refreshView();
        c.preserveScrollOnRefresh = b;
        c.lastRefreshLoadCount = a.loadCount
    },
    refreshView: function () {
        var b = this, a = b.blockRefresh || !b.rendered || b.up("[collapsed],[isCollapsingOrExpanding],[hidden]");
        if (a) {
            b.refreshNeeded = true
        } else {
            if (b.bufferedRenderer) {
                b.bufferedRenderer.refreshView()
            } else {
                b.refresh()
            }
        }
    },
    findItemByChild: function (a) {
        return Ext.fly(a).findParent(this.getItemSelector(), this.getTargetEl())
    },
    findTargetByEvent: function (a) {
        return a.getTarget(this.getItemSelector(), this.getTargetEl())
    },
    getSelectedNodes: function () {
        var b = [], a = this.getSelectionModel().getSelection(), d = a.length, c = 0;
        for (; c < d; c++) {
            b.push(this.getNode(a[c]))
        }
        return b
    },
    getRecords: function (c) {
        var b = [], d = 0, a = c.length, e = this.dataSource.data;
        for (; d < a; d++) {
            b[b.length] = e.getByKey(c[d].getAttribute("data-recordId"))
        }
        return b
    },
    getRecord: function (a) {
        return this.dataSource.getByInternalId(Ext.getDom(a).getAttribute("data-recordId"))
    },
    isSelected: function (b) {
        var a = this.getRecord(b);
        return this.getSelectionModel().isSelected(a)
    },
    select: function (b, c, a) {
        this.getSelectionModel().select(b, c, a)
    },
    deselect: function (b, a) {
        this.getSelectionModel().deselect(b, a)
    },
    getNode: function (b) {
        var c = this, a;
        if (c.rendered && (b || b === 0)) {
            if (Ext.isString(b)) {
                a = document.getElementById(b)
            } else {
                if (b.isModel) {
                    a = c.getNodeByRecord(b)
                } else {
                    if (Ext.isNumber(b)) {
                        a = c.all.elements[b]
                    } else {
                        if (b.target && b.target.nodeType) {
                            b = b.target
                        }
                        a = Ext.fly(b).findParent(c.itemSelector, c.getTargetEl())
                    }
                }
            }
        }
        return a || null
    },
    getNodeByRecord: function (a) {
        var b = this.store.indexOf(a);
        return this.all.elements[b] || null
    },
    getNodes: function (c, a) {
        var b = this.all;
        if (a !== undefined) {
            a++
        }
        return b.slice(c, a)
    },
    indexOf: function (a) {
        a = this.getNode(a);
        if (!a && a !== 0) {
            return -1
        }
        if (a.getAttribute("data-recordIndex")) {
            return Number(a.getAttribute("data-recordIndex"))
        }
        return this.all.indexOf(a)
    },
    onDestroy: function () {
        var b = this, a = b.updateSuspendCounter;
        b.all.clear();
        b.emptyEl = null;
        Ext.Component.prototype.onDestroy.call(this);
        b.bindStore(null);
        b.store = b.dataSource = b.storeListeners = null;
        if (b.selModelRelayer) {
            b.selModelRelayer.destroy();
            b.selModelRelayer = null
        }
        Ext.destroy(b.navigationModel, b.selectionModel);
        b.navigationModel = b.selectionModel = b.selModel = null;
        b.loadMask = null;
        while (a--) {
            Ext.resumeLayouts(true)
        }
    },
    onItemSelect: function (a) {
        var b = this.getNode(a);
        if (b) {
            Ext.fly(b).addCls(this.selectedItemCls)
        }
    },
    onItemDeselect: function (a) {
        var b = this.getNode(a);
        if (b) {
            Ext.fly(b).removeCls(this.selectedItemCls)
        }
    },
    getItemSelector: function () {
        return this.itemSelector
    },
    addItemCls: function (b, a) {
        var c = this.getNode(b);
        if (c) {
            Ext.fly(c).addCls(a)
        }
    },
    removeItemCls: function (b, a) {
        var c = this.getNode(b);
        if (c) {
            Ext.fly(c).removeCls(a)
        }
    },
    updateStore: function (a) {
        if (!this.isConfiguring) {
            delete this.store;
            this.bindStore(a)
        }
    },
    privates: {
        toggleChildrenTabbability: function (b) {
            var a = this.getTargetEl();
            if (b) {
                a.restoreTabbableState(true)
            } else {
                a.saveTabbableState({skipSelf: true, includeSaved: false})
            }
        }, collectNodes: function (c) {
            var b = this.all, a = {role: this.itemAriaRole};
            b.fill(Ext.fly(c).query(this.getItemSelector()), b.startIndex || 0);
            if (this.focusable) {
                a.tabindex = "-1"
            }
            b.set(a)
        }, createMask: function (b) {
            var d = this, c = d.getStore(), a;
            if (c && !c.isEmptyStore && !c.loadsSynchronously()) {
                a = {target: d, msg: d.loadingText, useMsg: d.loadingUseMsg, store: c};
                if (d.loadingCls) {
                    a.msgCls = d.loadingCls
                }
                if (Ext.isObject(b)) {
                    a = Ext.apply(a, b)
                }
                d.loadMask = new Ext.LoadMask(a);
                d.loadMask.on({scope: d, beforeshow: d.onMaskBeforeShow, hide: d.onMaskHide})
            }
            return d.loadMask
        }, getOverflowEl: function () {
            return Ext.Component.prototype.getTargetEl.call(this)
        }, getTargetEl: function () {
            return this.touchScroll ? this.getScrollerEl() : Ext.Component.prototype.getTargetEl.call(this)
        }
    }
}, 1, 0, ["component", "box"], {
    component: true,
    box: true
}, 0, [[Ext.util.StoreHolder.prototype.mixinId || Ext.util.StoreHolder.$className, Ext.util.StoreHolder]], [Ext.view, "AbstractView"], function () {
    Ext.deprecate("extjs", "4.0", function () {
        Ext.view.AbstractView.override({
            getSelectionCount: function () {
                if (Ext.global.console) {
                    Ext.global.console.warn("DataView: getSelectionCount will be removed, please interact with the Ext.selection.DataViewModel")
                }
                return this.selModel.getSelection().length
            }, getSelectedRecords: function () {
                if (Ext.global.console) {
                    Ext.global.console.warn("DataView: getSelectedRecords will be removed, please interact with the Ext.selection.DataViewModel")
                }
                return this.selModel.getSelection()
            }, select: function (a, b, d) {
                if (Ext.global.console) {
                    Ext.global.console.warn("DataView: select will be removed, please access select through a DataView's SelectionModel, ie: view.getSelectionModel().select()")
                }
                var c = this.getSelectionModel();
                return c.select.apply(c, arguments)
            }, clearSelections: function () {
                if (Ext.global.console) {
                    Ext.global.console.warn("DataView: clearSelections will be removed, please access deselectAll through DataView's SelectionModel, ie: view.getSelectionModel().deselectAll()")
                }
                var a = this.getSelectionModel();
                return a.deselectAll()
            }
        })
    })
}));
(Ext.cmd.derive("Ext.view.View", Ext.view.AbstractView, {
    alternateClassName: "Ext.DataView",
    inputTagRe: /^textarea$|^input$/i,
    keyEventRe: /^key/,
    inheritableStatics: {
        EventMap: {
            longpress: "LongPress",
            mousedown: "MouseDown",
            mouseup: "MouseUp",
            click: "Click",
            dblclick: "DblClick",
            contextmenu: "ContextMenu",
            mouseover: "MouseOver",
            mouseout: "MouseOut",
            mouseenter: "MouseEnter",
            mouseleave: "MouseLeave",
            keydown: "KeyDown",
            keyup: "KeyUp",
            keypress: "KeyPress",
            focus: "Focus"
        }, TouchEventMap: {touchstart: "mousedown", touchend: "mouseup", tap: "click", doubletap: "dblclick"}
    },
    afterRender: function () {
        var a = this;
        Ext.view.AbstractView.prototype.afterRender.call(this);
        a.mon(a.el, {
            scope: a,
            click: a.handleEvent,
            longpress: a.handleEvent,
            mousedown: a.handleEvent,
            mouseup: a.handleEvent,
            dblclick: a.handleEvent,
            contextmenu: a.handleEvent,
            keydown: a.handleEvent,
            keyup: a.handleEvent,
            keypress: a.handleEvent,
            mouseover: a.handleMouseOver,
            mouseout: a.handleMouseOut
        })
    },
    getTargetSelector: function () {
        return this.dataRowSelector || this.itemSelector
    },
    handleMouseOver: function (d) {
        var c = this, a = c.getTargetSelector(), b = d.getTarget(a);
        if (!c.destroyed) {
            if (b) {
                if (c.mouseOverItem !== b && c.el.contains(b)) {
                    c.mouseOverItem = d.item = b;
                    d.newType = "mouseenter";
                    c.handleEvent(d)
                }
            } else {
                c.handleEvent(d)
            }
        }
    },
    handleMouseOut: function (h) {
        var d = this, b = d.getTargetSelector(), c = h.getTarget(b), g = h.getRelatedTarget(b), a;
        if ((c === g) && !(c === null && g === null)) {
            return
        }
        if (!d.destroyed) {
            if (c && (a = d.self.getBoundView(c))) {
                h.item = c;
                h.newType = "mouseleave";
                a.handleEvent(h);
                a.mouseOverItem = null
            } else {
                d.handleEvent(h)
            }
        }
    },
    handleEvent: function (c) {
        var b = this, a = b.keyEventRe.test(c.type);
        c.view = b;
        c.item = c.getTarget(b.itemSelector);
        if (c.item) {
            c.record = b.getRecord(c.item)
        }
        if (b.processUIEvent(c) !== false) {
            b.processSpecialEvent(c)
        }
        if (a && !Ext.fly(c.target).isInputField()) {
            if (c.getKey() === c.SPACE || c.isNavKeyPress(true)) {
                c.preventDefault()
            }
        }
        c.view = null
    },
    processItemEvent: Ext.emptyFn,
    processContainerEvent: Ext.emptyFn,
    processSpecialEvent: Ext.emptyFn,
    processUIEvent: function (g) {
        if (!Ext.getBody().isAncestor(g.target)) {
            return
        }
        var j = this, k = g.item, l = j.self, a = l.EventMap, h = l.TouchEventMap, d, c = g.record, i = g.type, b = i;
        if (g.newType) {
            b = g.newType
        }
        if (k) {
            b = h[b] || b;
            d = g.recordIndex = j.indexInStore ? j.indexInStore(c) : j.indexOf(k);
            if (!c || j.processItemEvent(c, k, d, g) === false) {
                return false
            }
            if ((j["onBeforeItem" + a[b]](c, k, d, g) === false) || (j.fireEvent("beforeitem" + b, j, c, k, d, g) === false) || (j["onItem" + a[b]](c, k, d, g) === false)) {
                return false
            }
            j.fireEvent("item" + b, j, c, k, d, g)
        } else {
            i = h[i] || i;
            if ((j.processContainerEvent(g) === false) || (j["onBeforeContainer" + a[i]](g) === false) || (j.fireEvent("beforecontainer" + i, j, g) === false) || (j["onContainer" + a[i]](g) === false)) {
                return false
            }
            j.fireEvent("container" + i, j, g)
        }
        return true
    },
    onItemMouseEnter: function (a, c, b, d) {
        if (this.trackOver) {
            this.highlightItem(c)
        }
    },
    onItemMouseLeave: function (a, c, b, d) {
        if (this.trackOver) {
            this.clearHighlight()
        }
    },
    onItemMouseDown: Ext.emptyFn,
    onItemLongPress: Ext.emptyFn,
    onItemMouseUp: Ext.emptyFn,
    onItemFocus: Ext.emptyFn,
    onItemClick: Ext.emptyFn,
    onItemDblClick: Ext.emptyFn,
    onItemContextMenu: Ext.emptyFn,
    onItemKeyDown: Ext.emptyFn,
    onItemKeyUp: Ext.emptyFn,
    onItemKeyPress: Ext.emptyFn,
    onBeforeItemLongPress: Ext.emptyFn,
    onBeforeItemMouseDown: Ext.emptyFn,
    onBeforeItemMouseUp: Ext.emptyFn,
    onBeforeItemFocus: Ext.emptyFn,
    onBeforeItemMouseEnter: Ext.emptyFn,
    onBeforeItemMouseLeave: Ext.emptyFn,
    onBeforeItemClick: Ext.emptyFn,
    onBeforeItemDblClick: Ext.emptyFn,
    onBeforeItemContextMenu: Ext.emptyFn,
    onBeforeItemKeyDown: Ext.emptyFn,
    onBeforeItemKeyUp: Ext.emptyFn,
    onBeforeItemKeyPress: Ext.emptyFn,
    onContainerMouseDown: Ext.emptyFn,
    onContainerLongPress: Ext.emptyFn,
    onContainerMouseUp: Ext.emptyFn,
    onContainerMouseOver: Ext.emptyFn,
    onContainerMouseOut: Ext.emptyFn,
    onContainerClick: Ext.emptyFn,
    onContainerDblClick: Ext.emptyFn,
    onContainerContextMenu: Ext.emptyFn,
    onContainerKeyDown: Ext.emptyFn,
    onContainerKeyUp: Ext.emptyFn,
    onContainerKeyPress: Ext.emptyFn,
    onBeforeContainerMouseDown: Ext.emptyFn,
    onBeforeContainerLongPress: Ext.emptyFn,
    onBeforeContainerMouseUp: Ext.emptyFn,
    onBeforeContainerMouseOver: Ext.emptyFn,
    onBeforeContainerMouseOut: Ext.emptyFn,
    onBeforeContainerClick: Ext.emptyFn,
    onBeforeContainerDblClick: Ext.emptyFn,
    onBeforeContainerContextMenu: Ext.emptyFn,
    onBeforeContainerKeyDown: Ext.emptyFn,
    onBeforeContainerKeyUp: Ext.emptyFn,
    onBeforeContainerKeyPress: Ext.emptyFn,
    setHighlightedItem: function (c) {
        var b = this, a = b.highlightedItem, d = b.overItemCls;
        if (a !== c) {
            if (a) {
                Ext.fly(a).removeCls(d);
                if (Ext.isIE8) {
                    b.repaintBorder(a);
                    b.repaintBorder(a.nextSibling)
                }
                if (b.hasListeners.unhighlightitem) {
                    b.fireEvent("unhighlightitem", b, a)
                }
            }
            b.highlightedItem = c;
            if (c) {
                Ext.fly(c).addCls(b.overItemCls);
                if (Ext.isIE8) {
                    b.repaintBorder(c.nextSibling)
                }
                if (b.hasListeners.highlightitem) {
                    b.fireEvent("highlightitem", b, c)
                }
            }
        }
    },
    highlightItem: function (a) {
        this.setHighlightedItem(a)
    },
    clearHighlight: function () {
        this.setHighlightedItem(undefined)
    },
    handleUpdate: function (b, a) {
        var g = this, e, c, d;
        if (g.viewReady) {
            e = g.getNode(a);
            c = Ext.view.AbstractView.prototype.handleUpdate.apply(this, arguments);
            d = g.highlightedItem;
            if (d && d === e) {
                delete g.highlightedItem;
                if (c) {
                    g.highlightItem(c)
                }
            }
        }
    },
    refresh: function () {
        this.clearHighlight();
        Ext.view.AbstractView.prototype.refresh.apply(this, arguments)
    },
    focusNode: function (i) {
        var g = this, e = g.getNode(i), d = g.el, a = 0, b = 0, h = d.getRegion(), c;
        h.bottom = h.top + d.dom.clientHeight;
        h.right = h.left + d.dom.clientWidth;
        if (e) {
            c = Ext.fly(e).getRegion();
            if (c.top < h.top) {
                a = c.top - h.top
            } else {
                if (c.bottom > h.bottom) {
                    a = c.bottom - h.bottom
                }
            }
            if (c.left < h.left) {
                b = c.left - h.left
            } else {
                if (c.right > h.right) {
                    b = c.right - h.right
                }
            }
            if (b || a) {
                g.scrollBy(b, a, false)
            }
            Ext.fly(e).set({tabIndex: -1});
            e.focus()
        }
    },
    bindStore: function (c, d, b) {
        var e = this, g = e[b], a = e.getSelectionModel();
        if (g && g.isFeatureStore && e.rendered) {
            a.bindStore(g.store);
            a.bindComponent(e);
            if (c.isFeatureStore) {
                e.bindStoreListeners(c);
                g.bindStore(g.store)
            } else {
                g.bindStore(c)
            }
        } else {
            Ext.view.AbstractView.prototype.bindStore.call(this, c, d, b)
        }
    },
    privates: {
        repaintBorder: function (b) {
            var a = this.getNode(b);
            if (a) {
                a.className = a.className
            }
        }
    }
}, 0, ["dataview"], ["component", "box", "dataview"], {
    component: true,
    box: true,
    dataview: true
}, ["widget.dataview"], 0, [Ext.view, "View", Ext, "DataView"], 0));
(Ext.cmd.derive("Ext.view.BoundListKeyNav", Ext.view.NavigationModel, {
    navigateOnSpace: true, initKeyNav: function (a) {
        var b = this, c = a.pickerField;
        if (!b.keyNav) {
            Ext.view.NavigationModel.prototype.initKeyNav.call(this, a);
            b.keyNav.map.addBinding({key: Ext.event.Event.ESC, fn: b.onKeyEsc, scope: b})
        }
        if (!c) {
            return
        }
        if (!c.rendered) {
            c.on("render", Ext.Function.bind(b.initKeyNav, b, [a], 0), b, {single: true});
            return
        }
        b.fieldKeyNav = new Ext.util.KeyNav({
            disabled: true,
            target: c.inputEl,
            forceKeyDown: true,
            up: b.onKeyUp,
            down: b.onKeyDown,
            right: b.onKeyRight,
            left: b.onKeyLeft,
            pageDown: b.onKeyPageDown,
            pageUp: b.onKeyPageUp,
            home: b.onKeyHome,
            end: b.onKeyEnd,
            tab: b.onKeyTab,
            space: b.onKeySpace,
            enter: b.onKeyEnter,
            A: {ctrl: true, handler: b.onSelectAllKeyPress},
            priority: 1001,
            scope: b
        })
    }, processViewEvent: function (b, a, e, c, d) {
        if (d.within(b.listWrap)) {
            return d
        }
        if (d.getKey() === d.ESC) {
            if (Ext.fly(d.target).isInputField()) {
                d.target = d.target.parentNode
            }
            return d
        }
    }, enable: function () {
        this.fieldKeyNav.enable();
        Ext.view.NavigationModel.prototype.enable.call(this)
    }, disable: function () {
        this.fieldKeyNav.disable();
        Ext.view.NavigationModel.prototype.disable.call(this)
    }, onItemMouseDown: function (b, a, e, c, d) {
        Ext.view.NavigationModel.prototype.onItemMouseDown.call(this, b, a, e, c, d);
        d.preventDefault()
    }, onKeyUp: function () {
        var e = this, b = e.view, d = b.all, g = b.highlightedItem, c = g ? b.indexOf(g) : -1,
            a = c > 0 ? c - 1 : d.getCount() - 1;
        e.setPosition(a)
    }, onKeyDown: function (i) {
        var g = this, b = g.view, d = b.all, h = b.highlightedItem, c = h ? b.indexOf(h) : -1,
            a = c < d.getCount() - 1 ? c + 1 : 0;
        g.setPosition(a)
    }, onKeyLeft: Ext.returnTrue, onKeyRight: Ext.returnTrue, onKeyTab: function (c) {
        var a = this.view, b = a.pickerField;
        if (a.isVisible()) {
            if (b.selectOnTab) {
                this.selectHighlighted(c)
            }
            if (b.collapse) {
                b.collapse()
            }
        }
        return true
    }, onKeyEnter: function (g) {
        var a = this.view, b = a.getSelectionModel(), d = a.pickerField, c = b.getCount();
        g.stopEvent();
        this.selectHighlighted(g);
        if (!d.multiSelect && c === b.getCount() && d.collapse) {
            d.collapse()
        }
        return false
    }, onKeySpace: function () {
        if (this.navigateOnSpace) {
            Ext.view.NavigationModel.prototype.onKeySpace.apply(this, arguments)
        }
        return true
    }, onKeyEsc: function () {
        if (this.view.pickerField) {
            this.view.pickerField.collapse()
        }
    }, focusItem: function (c) {
        var b = this, a = b.view;
        if (typeof c === "number") {
            c = a.all.item(c)
        }
        if (c) {
            c = c.dom;
            a.highlightItem(c);
            a.getScrollable().scrollIntoView(c, false)
        }
    }, selectHighlighted: function (h) {
        var g = this, b = g.view, a = b.getSelectionModel(), c, d = g.recordIndex;
        if (b.all.getCount()) {
            c = g.getRecord();
            if (c) {
                if (h.getKey() === h.ENTER || !a.isSelected(c)) {
                    a.selectWithEvent(c, h);
                    if (!b.store.data.contains(c)) {
                        g.setPosition(Math.min(d, b.store.getCount() - 1))
                    }
                }
            }
        }
    }, destroy: function () {
        this.fieldKeyNav = Ext.destroy(this.fieldKeyNav);
        Ext.view.NavigationModel.prototype.destroy.call(this)
    }
}, 0, 0, 0, 0, ["view.navigation.boundlist"], 0, [Ext.view, "BoundListKeyNav"], 0));
(Ext.cmd.derive("Ext.layout.component.BoundList", Ext.layout.component.Auto, {
    type: "component", beginLayout: function (d) {
        var c = this, a = c.owner, b = a.pagingToolbar;
        c.scrollPos = a.listWrap.getScroll();
        Ext.layout.component.Auto.prototype.beginLayout.apply(this, arguments);
        if (a.floating) {
            d.savedXY = a.getXY();
            a.setXY([0, -9999])
        }
        if (b) {
            d.toolbarContext = d.context.getCmp(b)
        }
        d.listContext = d.getEl("listWrap")
    }, beginLayoutCycle: function (b) {
        var a = this.owner;
        Ext.layout.component.Auto.prototype.beginLayoutCycle.apply(this, arguments);
        if (b.heightModel.auto) {
            a.el.setHeight("auto");
            a.listWrap.setHeight("auto")
        }
    }, getLayoutItems: function () {
        var a = this.owner.pagingToolbar;
        return a ? [a] : []
    }, isValidParent: function () {
        return true
    }, finishedLayout: function (d) {
        var c = this, e = d.savedXY, a = c.owner, b = a.listWrap, g = c.scrollPos;
        Ext.layout.component.Auto.prototype.finishedLayout.apply(this, arguments);
        if (e) {
            c.owner.setXY(e)
        }
        b.setScrollLeft(g.left);
        b.setScrollTop(g.top)
    }, measureContentWidth: function (a) {
        return this.owner.listWrap.getWidth()
    }, measureContentHeight: function (a) {
        return this.owner.listWrap.getHeight()
    }, publishInnerHeight: function (c, a) {
        var b = c.toolbarContext, d = 0;
        if (b) {
            d = b.getProp("height")
        }
        if (d === undefined) {
            this.done = false
        } else {
            c.listContext.setHeight(a - c.getFrameInfo().height - d)
        }
    }, calculateOwnerHeightFromContentHeight: function (c) {
        var a = Ext.layout.component.Auto.prototype.calculateOwnerHeightFromContentHeight.apply(this, arguments),
            b = c.toolbarContext;
        if (b) {
            a += b.getProp("height")
        }
        return a
    }
}, 0, 0, 0, 0, ["layout.boundlist"], 0, [Ext.layout.component, "BoundList"], 0));
(Ext.cmd.derive("Ext.toolbar.Item", Ext.Component, {
    alternateClassName: "Ext.Toolbar.Item",
    enable: Ext.emptyFn,
    disable: Ext.emptyFn,
    focus: Ext.emptyFn
}, 0, ["tbitem"], ["component", "box", "tbitem"], {
    component: true,
    box: true,
    tbitem: true
}, ["widget.tbitem"], 0, [Ext.toolbar, "Item", Ext.Toolbar, "Item"], 0));
(Ext.cmd.derive("Ext.toolbar.TextItem", Ext.toolbar.Item, {
    alternateClassName: "Ext.Toolbar.TextItem",
    text: "",
    baseCls: "x-toolbar-text",
    ariaRole: null,
    beforeRender: function () {
        var a = this.text;
        Ext.toolbar.Item.prototype.beforeRender.call(this);
        if (a) {
            this.html = a
        }
    },
    setText: function (a) {
        this.update(a)
    }
}, 0, ["tbtext"], ["component", "box", "tbitem", "tbtext"], {
    component: true,
    box: true,
    tbitem: true,
    tbtext: true
}, ["widget.tbtext"], 0, [Ext.toolbar, "TextItem", Ext.Toolbar, "TextItem"], 0));
(Ext.cmd.derive("Ext.form.trigger.Spinner", Ext.form.trigger.Trigger, {
    cls: "x-form-trigger-spinner",
    spinnerCls: "x-form-spinner",
    spinnerUpCls: "x-form-spinner-up",
    spinnerDownCls: "x-form-spinner-down",
    focusCls: "x-form-spinner-focus",
    overCls: "x-form-spinner-over",
    clickCls: "x-form-spinner-click",
    focusFieldOnClick: true,
    vertical: true,
    bodyTpl: '<tpl if="vertical"><div class="{spinnerCls} {spinnerCls}-{ui} {spinnerUpCls} {spinnerUpCls}-{ui} {childElCls} {upDisabledCls}"></div></tpl><div class="{spinnerCls} {spinnerCls}-{ui} {spinnerDownCls} {spinnerDownCls}-{ui} {childElCls} {downDisabledCls}"></div><tpl if="!vertical"><div class="{spinnerCls} {spinnerCls}-{ui} {spinnerUpCls} {spinnerUpCls}-{ui} {childElCls} {upDisabledCls}"></div></tpl>',
    destroy: function () {
        var a = this;
        if (a.spinnerEl) {
            a.spinnerEl.destroy();
            a.spinnerEl = a.upEl = a.downEl = null
        }
        Ext.form.trigger.Trigger.prototype.destroy.call(this)
    },
    getBodyRenderData: function () {
        var a = this;
        return {
            vertical: a.vertical,
            upDisabledCls: a.upEnabled ? "" : (a.spinnerUpCls + "-disabled"),
            downDisabledCls: a.downEnabled ? "" : (a.spinnerDownCls + "-disabled"),
            spinnerCls: a.spinnerCls,
            spinnerUpCls: a.spinnerUpCls,
            spinnerDownCls: a.spinnerDownCls
        }
    },
    getStateEl: function () {
        return this.spinnerEl
    },
    onClick: function () {
        var b = this, a = arguments, d = b.clickRepeater ? a[1] : a[0], c = b.field;
        if (!c.readOnly && !c.disabled) {
            if (b.upEl.contains(d.target)) {
                Ext.callback(b.upHandler, b.scope, [c, b, d], 0, c)
            } else {
                if (b.downEl.contains(d.target)) {
                    Ext.callback(b.downHandler, b.scope, [c, b, d], 0, c)
                }
            }
        }
        c.inputEl.focus()
    },
    onFieldRender: function () {
        var b = this, a = b.vertical, d, c;
        Ext.form.trigger.Trigger.prototype.onFieldRender.call(this);
        d = b.spinnerEl = b.el.select("." + b.spinnerCls, true);
        c = d.elements;
        b.upEl = a ? c[0] : c[1];
        b.downEl = a ? c[1] : c[0]
    },
    setUpEnabled: function (a) {
        this.upEl[a ? "removeCls" : "addCls"](this.spinnerUpCls + "-disabled")
    },
    setDownEnabled: function (a) {
        this.downEl[a ? "removeCls" : "addCls"](this.spinnerDownCls + "-disabled")
    }
}, 0, 0, 0, 0, ["trigger.spinner"], 0, [Ext.form.trigger, "Spinner"], 0));
(Ext.cmd.derive("Ext.form.field.Spinner", Ext.form.field.Text, {
    alternateClassName: "Ext.form.Spinner",
    config: {
        triggers: {
            spinner: {
                type: "spinner",
                upHandler: "onSpinnerUpClick",
                downHandler: "onSpinnerDownClick",
                scope: "this"
            }
        }
    },
    spinUpEnabled: true,
    spinDownEnabled: true,
    keyNavEnabled: true,
    mouseWheelEnabled: true,
    repeatTriggerClick: true,
    onSpinUp: Ext.emptyFn,
    onSpinDown: Ext.emptyFn,
    ariaRole: "spinbutton",
    applyTriggers: function (b) {
        var c = this, a = b.spinner;
        a.upEnabled = c.spinUpEnabled;
        a.downEnabled = c.spinDownEnabled;
        return Ext.form.field.Text.prototype.applyTriggers.call(this, b)
    },
    onRender: function () {
        var b = this, a = b.getTrigger("spinner");
        (arguments.callee.$previous || Ext.form.field.Text.prototype.onRender).call(this);
        if (b.keyNavEnabled) {
            b.spinnerKeyNav = new Ext.util.KeyNav(b.inputEl, {scope: b, up: b.spinUp, down: b.spinDown})
        }
        if (b.mouseWheelEnabled) {
            b.mon(b.bodyEl, "mousewheel", b.onMouseWheel, b)
        }
        b.spinUpEl = a.upEl;
        b.spinDownEl = a.downEl
    },
    onSpinnerUpClick: function () {
        this.spinUp()
    },
    onSpinnerDownClick: function () {
        this.spinDown()
    },
    spinUp: function () {
        var a = this;
        if (a.spinUpEnabled && !a.disabled) {
            a.fireEvent("spin", a, "up");
            a.fireEvent("spinup", a);
            a.onSpinUp()
        }
    },
    spinDown: function () {
        var a = this;
        if (a.spinDownEnabled && !a.disabled) {
            a.fireEvent("spin", a, "down");
            a.fireEvent("spindown", a);
            a.onSpinDown()
        }
    },
    setSpinUpEnabled: function (a) {
        var b = this, c = b.spinUpEnabled;
        b.spinUpEnabled = a;
        if (c !== a && b.rendered) {
            b.getTrigger("spinner").setUpEnabled(a)
        }
    },
    setSpinDownEnabled: function (a) {
        var b = this, c = b.spinDownEnabled;
        b.spinDownEnabled = a;
        if (c !== a && b.rendered) {
            b.getTrigger("spinner").setDownEnabled(a)
        }
    },
    onMouseWheel: function (b) {
        var a = this, c;
        if (a.hasFocus) {
            c = b.getWheelDelta();
            if (c > 0) {
                a.spinUp()
            } else {
                if (c < 0) {
                    a.spinDown()
                }
            }
            b.stopEvent()
        }
    },
    onDestroy: function () {
        Ext.destroyMembers(this, "spinnerKeyNav");
        Ext.form.field.Text.prototype.onDestroy.call(this)
    }
}, 0, ["spinnerfield"], ["component", "box", "field", "textfield", "spinnerfield"], {
    component: true,
    box: true,
    field: true,
    textfield: true,
    spinnerfield: true
}, ["widget.spinnerfield"], 0, [Ext.form.field, "Spinner", Ext.form, "Spinner"], 0));
(Ext.cmd.derive("Ext.form.field.Number", Ext.form.field.Spinner, {
    alternateClassName: ["Ext.form.NumberField", "Ext.form.Number"],
    allowExponential: true,
    allowDecimals: true,
    decimalSeparator: null,
    submitLocaleSeparator: true,
    decimalPrecision: 2,
    minValue: Number.NEGATIVE_INFINITY,
    maxValue: Number.MAX_VALUE,
    step: 1,
    minText: "The minimum value for this field is {0}",
    maxText: "The maximum value for this field is {0}",
    nanText: "{0} is not a valid number",
    negativeText: "The value cannot be negative",
    baseChars: "0123456789",
    autoStripChars: false,
    initComponent: function () {
        var a = this;
        if (a.decimalSeparator === null) {
            a.decimalSeparator = Ext.util.Format.decimalSeparator
        }
        Ext.form.field.Spinner.prototype.initComponent.call(this);
        a.setMinValue(a.minValue);
        a.setMaxValue(a.maxValue)
    },
    getSubTplData: function (c) {
        var e = this, d = e.minValue, a = e.maxValue, h, b, g;
        h = Ext.form.field.Spinner.prototype.getSubTplData.call(this, c);
        b = h.inputElAriaAttributes;
        if (b) {
            if (d > Number.NEGATIVE_INFINITY) {
                b["aria-valuemin"] = d
            }
            if (a < Number.MAX_VALUE) {
                b["aria-valuemax"] = a
            }
            g = e.getValue();
            if (g != null && g >= d && g <= a) {
                b["aria-valuenow"] = g
            }
        }
        return h
    },
    setValue: function (c) {
        var b = this, d, a;
        if (b.hasFocus) {
            d = b.getBind();
            a = d && d.value;
            if (a && a.syncing && c === b.value) {
                return b
            }
        }
        return Ext.form.field.Spinner.prototype.setValue.call(this, c)
    },
    getErrors: function (c) {
        c = arguments.length > 0 ? c : this.processRawValue(this.getRawValue());
        var b = this, e = Ext.form.field.Spinner.prototype.getErrors.call(this, c), d = Ext.String.format, a;
        if (c.length < 1) {
            return e
        }
        c = String(c).replace(b.decimalSeparator, ".");
        if (isNaN(c)) {
            e.push(d(b.nanText, c))
        }
        a = b.parseValue(c);
        if (b.minValue === 0 && a < 0) {
            e.push(this.negativeText)
        } else {
            if (a < b.minValue) {
                e.push(d(b.minText, b.minValue))
            }
        }
        if (a > b.maxValue) {
            e.push(d(b.maxText, b.maxValue))
        }
        return e
    },
    rawToValue: function (b) {
        var a = this.fixPrecision(this.parseValue(b));
        if (a === null) {
            a = b || null
        }
        return a
    },
    valueToRaw: function (c) {
        var b = this, a = b.decimalSeparator;
        c = b.parseValue(c);
        c = b.fixPrecision(c);
        c = Ext.isNumber(c) ? c : parseFloat(String(c).replace(a, "."));
        c = isNaN(c) ? "" : String(c).replace(".", a);
        return c
    },
    getSubmitValue: function () {
        var a = this, b = Ext.form.field.Spinner.prototype.getSubmitValue.call(this);
        if (!a.submitLocaleSeparator) {
            b = b.replace(a.decimalSeparator, ".")
        }
        return b
    },
    onChange: function (b) {
        var a = this.ariaEl.dom;
        this.toggleSpinners();
        Ext.form.field.Spinner.prototype.onChange.apply(this, arguments);
        if (a) {
            if (Ext.isNumber(b) && isFinite(b)) {
                a.setAttribute("aria-valuenow", b)
            } else {
                a.removeAttribute("aria-valuenow")
            }
        }
    },
    toggleSpinners: function () {
        var c = this, d = c.getValue(), b = d === null, a;
        if (c.spinUpEnabled || c.spinUpDisabledByToggle) {
            a = b || d < c.maxValue;
            c.setSpinUpEnabled(a, true)
        }
        if (c.spinDownEnabled || c.spinDownDisabledByToggle) {
            a = b || d > c.minValue;
            c.setSpinDownEnabled(a, true)
        }
    },
    setMinValue: function (d) {
        var b = this, a = b.ariaEl.dom, c, e, a;
        b.minValue = c = Ext.Number.from(d, Number.NEGATIVE_INFINITY);
        b.toggleSpinners();
        if (a) {
            if (c > Number.NEGATIVE_INFINITY) {
                a.setAttribute("aria-valuemin", c)
            } else {
                a.removeAttribute("aria-valuemin")
            }
        }
        if (b.disableKeyFilter !== true) {
            e = b.baseChars + "";
            if (b.allowExponential) {
                e += b.decimalSeparator + "e+-"
            } else {
                if (b.allowDecimals) {
                    e += b.decimalSeparator
                }
                if (b.minValue < 0) {
                    e += "-"
                }
            }
            e = Ext.String.escapeRegex(e);
            b.maskRe = new RegExp("[" + e + "]");
            if (b.autoStripChars) {
                b.stripCharsRe = new RegExp("[^" + e + "]", "gi")
            }
        }
    },
    setMaxValue: function (b) {
        var a = this.ariaEl.dom, c;
        this.maxValue = c = Ext.Number.from(b, Number.MAX_VALUE);
        if (a) {
            if (c < Number.MAX_VALUE) {
                a.setAttribute("aria-valuemax", c)
            } else {
                a.removeAttribute("aria-valuemax")
            }
        }
        this.toggleSpinners()
    },
    parseValue: function (a) {
        a = parseFloat(String(a).replace(this.decimalSeparator, "."));
        return isNaN(a) ? null : a
    },
    fixPrecision: function (d) {
        var c = this, b = isNaN(d), a = c.decimalPrecision;
        if (b || !d) {
            return b ? "" : d
        } else {
            if (!c.allowDecimals || a <= 0) {
                a = 0
            }
        }
        return parseFloat(Ext.Number.toFixed(parseFloat(d), a))
    },
    onBlur: function (c) {
        var b = this, a = b.rawToValue(b.getRawValue());
        if (!Ext.isEmpty(a)) {
            b.setValue(a)
        }
        Ext.form.field.Spinner.prototype.onBlur.call(this, c)
    },
    setSpinUpEnabled: function (b, a) {
        Ext.form.field.Spinner.prototype.setSpinUpEnabled.apply(this, arguments);
        if (!a) {
            delete this.spinUpDisabledByToggle
        } else {
            this.spinUpDisabledByToggle = !b
        }
    },
    onSpinUp: function () {
        var a = this;
        if (!a.readOnly) {
            a.setSpinValue(Ext.Number.constrain(a.getValue() + a.step, a.minValue, a.maxValue))
        }
    },
    setSpinDownEnabled: function (b, a) {
        Ext.form.field.Spinner.prototype.setSpinDownEnabled.apply(this, arguments);
        if (!a) {
            delete this.spinDownDisabledByToggle
        } else {
            this.spinDownDisabledByToggle = !b
        }
    },
    onSpinDown: function () {
        var a = this;
        if (!a.readOnly) {
            a.setSpinValue(Ext.Number.constrain(a.getValue() - a.step, a.minValue, a.maxValue))
        }
    },
    setSpinValue: function (b) {
        var a = this;
        if (a.enforceMaxLength) {
            if (a.fixPrecision(b).toString().length > a.maxLength) {
                return
            }
        }
        a.setValue(b)
    }
}, 0, ["numberfield"], ["component", "box", "field", "textfield", "spinnerfield", "numberfield"], {
    component: true,
    box: true,
    field: true,
    textfield: true,
    spinnerfield: true,
    numberfield: true
}, ["widget.numberfield"], 0, [Ext.form.field, "Number", Ext.form, "NumberField", Ext.form, "Number"], 0));
(Ext.cmd.derive("Ext.toolbar.Paging", Ext.toolbar.Toolbar, {
    alternateClassName: "Ext.PagingToolbar",
    displayInfo: false,
    prependButtons: false,
    displayMsg: "Displaying {0} - {1} of {2}",
    emptyMsg: "No data to display",
    beforePageText: "Page",
    afterPageText: "of {0}",
    firstText: "First Page",
    prevText: "Previous Page",
    nextText: "Next Page",
    lastText: "Last Page",
    refreshText: "Refresh",
    inputItemWidth: 30,
    emptyPageData: {total: 0, currentPage: 0, pageCount: 0, toRecord: 0, fromRecord: 0},
    defaultBindProperty: "store",
    getPagingItems: function () {
        var b = this, a = {scope: b, blur: b.onPagingBlur};
        a[Ext.supports.SpecialKeyDownRepeat ? "keydown" : "keypress"] = b.onPagingKeyDown;
        return [{
            itemId: "first",
            tooltip: b.firstText,
            overflowText: b.firstText,
            iconCls: "x-tbar-page-first",
            disabled: true,
            handler: b.moveFirst,
            scope: b
        }, {
            itemId: "prev",
            tooltip: b.prevText,
            overflowText: b.prevText,
            iconCls: "x-tbar-page-prev",
            disabled: true,
            handler: b.movePrevious,
            scope: b
        }, "-", b.beforePageText, {
            xtype: "numberfield",
            itemId: "inputItem",
            name: "inputItem",
            cls: "x-tbar-page-number",
            allowDecimals: false,
            minValue: 1,
            hideTrigger: true,
            enableKeyEvents: true,
            keyNavEnabled: false,
            selectOnFocus: true,
            submitValue: false,
            isFormField: false,
            width: b.inputItemWidth,
            margin: "-1 2 3 2",
            listeners: a
        }, {
            xtype: "tbtext",
            itemId: "afterTextItem",
            text: Ext.String.format(b.afterPageText, 1)
        }, "-", {
            itemId: "next",
            tooltip: b.nextText,
            overflowText: b.nextText,
            iconCls: "x-tbar-page-next",
            disabled: true,
            handler: b.moveNext,
            scope: b
        }, {
            itemId: "last",
            tooltip: b.lastText,
            overflowText: b.lastText,
            iconCls: "x-tbar-page-last",
            disabled: true,
            handler: b.moveLast,
            scope: b
        }, "-", {
            itemId: "refresh",
            tooltip: b.refreshText,
            overflowText: b.refreshText,
            iconCls: "x-tbar-loading",
            disabled: b.store.isLoading(),
            handler: b.doRefresh,
            scope: b
        }]
    },
    initComponent: function () {
        var b = this, a = b.items || b.buttons || [], c;
        b.bindStore(b.store || "ext-empty-store", true);
        c = b.getPagingItems();
        if (b.prependButtons) {
            b.items = a.concat(c)
        } else {
            b.items = c.concat(a)
        }
        delete b.buttons;
        if (b.displayInfo) {
            b.items.push("->");
            b.items.push({xtype: "tbtext", itemId: "displayItem"})
        }
        Ext.toolbar.Toolbar.prototype.initComponent.call(this)
    },
    beforeRender: function () {
        Ext.toolbar.Toolbar.prototype.beforeRender.apply(this, arguments);
        this.updateBarInfo()
    },
    updateBarInfo: function () {
        var a = this;
        if (!a.store.isLoading()) {
            a.calledInternal = true;
            a.onLoad();
            a.calledInternal = false
        }
    },
    updateInfo: function () {
        var e = this, c = e.child("#displayItem"), a = e.store, b = e.getPageData(), d, g;
        if (c) {
            d = a.getCount();
            if (d === 0) {
                g = e.emptyMsg
            } else {
                g = Ext.String.format(e.displayMsg, b.fromRecord, b.toRecord, b.total)
            }
            c.setText(g)
        }
    },
    onLoad: function () {
        var h = this, d, b, c, a, g, i, e;
        g = h.store.getCount();
        i = g === 0;
        if (!i) {
            d = h.getPageData();
            b = d.currentPage;
            c = d.pageCount;
            if (b > c) {
                if (c > 0) {
                    h.store.loadPage(c)
                } else {
                    h.getInputItem().reset()
                }
                return
            }
            a = Ext.String.format(h.afterPageText, isNaN(c) ? 1 : c)
        } else {
            b = 0;
            c = 0;
            a = Ext.String.format(h.afterPageText, 0)
        }
        Ext.suspendLayouts();
        e = h.child("#afterTextItem");
        if (e) {
            e.setText(a)
        }
        e = h.getInputItem();
        if (e) {
            e.setDisabled(i).setValue(b)
        }
        h.setChildDisabled("#first", b === 1 || i);
        h.setChildDisabled("#prev", b === 1 || i);
        h.setChildDisabled("#next", b === c || i);
        h.setChildDisabled("#last", b === c || i);
        h.setChildDisabled("#refresh", false);
        h.updateInfo();
        Ext.resumeLayouts(true);
        if (!h.calledInternal) {
            h.fireEvent("change", h, d || h.emptyPageData)
        }
    },
    setChildDisabled: function (a, b) {
        var c = this.child(a);
        if (c) {
            c.setDisabled(b)
        }
    },
    getPageData: function () {
        var b = this.store, a = b.getTotalCount();
        return {
            total: a,
            currentPage: b.currentPage,
            pageCount: Math.ceil(a / b.pageSize),
            fromRecord: ((b.currentPage - 1) * b.pageSize) + 1,
            toRecord: Math.min(b.currentPage * b.pageSize, a)
        }
    },
    onLoadError: function () {
        this.setChildDisabled("#refresh", false)
    },
    getInputItem: function () {
        return this.child("#inputItem")
    },
    readPageFromInput: function (b) {
        var c = this.getInputItem(), d = false, a;
        if (c) {
            a = c.getValue();
            d = parseInt(a, 10);
            if (!a || isNaN(d)) {
                c.setValue(b.currentPage);
                return false
            }
        }
        return d
    },
    onPagingBlur: function (c) {
        var b = this.getInputItem(), a;
        if (b) {
            a = this.getPageData().currentPage;
            b.setValue(a)
        }
    },
    onPagingKeyDown: function (b, a) {
        this.processKeyEvent(b, a)
    },
    processKeyEvent: function (i, h) {
        var d = this, c = h.getKey(), b = d.getPageData(), a = h.shiftKey ? 10 : 1, g;
        if (c === h.RETURN) {
            h.stopEvent();
            g = d.readPageFromInput(b);
            if (g !== false) {
                g = Math.min(Math.max(1, g), b.pageCount);
                if (g !== b.currentPage && d.fireEvent("beforechange", d, g) !== false) {
                    d.store.loadPage(g)
                }
            }
        } else {
            if (c === h.HOME || c === h.END) {
                h.stopEvent();
                g = c === h.HOME ? 1 : b.pageCount;
                i.setValue(g)
            } else {
                if (c === h.UP || c === h.PAGE_UP || c === h.DOWN || c === h.PAGE_DOWN) {
                    h.stopEvent();
                    g = d.readPageFromInput(b);
                    if (g) {
                        if (c === h.DOWN || c === h.PAGE_DOWN) {
                            a *= -1
                        }
                        g += a;
                        if (g >= 1 && g <= b.pageCount) {
                            i.setValue(g)
                        }
                    }
                }
            }
        }
    },
    beforeLoad: function () {
        this.setChildDisabled("#refresh", true)
    },
    moveFirst: function () {
        if (this.fireEvent("beforechange", this, 1) !== false) {
            this.store.loadPage(1);
            return true
        }
        return false
    },
    movePrevious: function () {
        var c = this, a = c.store, b = a.currentPage - 1;
        if (b > 0) {
            if (c.fireEvent("beforechange", c, b) !== false) {
                a.previousPage();
                return true
            }
        }
        return false
    },
    moveNext: function () {
        var d = this, a = d.store, c = d.getPageData().pageCount, b = a.currentPage + 1;
        if (b <= c) {
            if (d.fireEvent("beforechange", d, b) !== false) {
                a.nextPage();
                return true
            }
        }
        return false
    },
    moveLast: function () {
        var b = this, a = b.getPageData().pageCount;
        if (b.fireEvent("beforechange", b, a) !== false) {
            b.store.loadPage(a);
            return true
        }
        return false
    },
    doRefresh: function () {
        var b = this, a = b.store, c = a.currentPage;
        if (b.fireEvent("beforechange", b, c) !== false) {
            a.loadPage(c);
            return true
        }
        return false
    },
    getStoreListeners: function () {
        return {beforeload: this.beforeLoad, load: this.onLoad, exception: this.onLoadError}
    },
    onBindStore: function () {
        if (this.rendered) {
            this.updateBarInfo()
        }
    },
    onDestroy: function () {
        this.bindStore(null);
        Ext.toolbar.Toolbar.prototype.onDestroy.call(this)
    }
}, 0, ["pagingtoolbar"], ["component", "box", "container", "toolbar", "pagingtoolbar"], {
    component: true,
    box: true,
    container: true,
    toolbar: true,
    pagingtoolbar: true
}, ["widget.pagingtoolbar"], [[Ext.util.StoreHolder.prototype.mixinId || Ext.util.StoreHolder.$className, Ext.util.StoreHolder]], [Ext.toolbar, "Paging", Ext, "PagingToolbar"], 0));
(Ext.cmd.derive("Ext.view.BoundList", Ext.view.View, {
    alternateClassName: "Ext.BoundList",
    pageSize: 0,
    baseCls: "x-boundlist",
    itemCls: "x-boundlist-item",
    listItemCls: "",
    shadow: false,
    trackOver: true,
    preserveScrollOnRefresh: true,
    enableInitialSelection: false,
    refreshSelmodelOnRefresh: true,
    componentLayout: "boundlist",
    navigationModel: "boundlist",
    scrollable: true,
    ariaEl: "listEl",
    tabIndex: -1,
    childEls: ["listWrap", "listEl"],
    renderTpl: ['<div id="{id}-listWrap" data-ref="listWrap"', ' class="{baseCls}-list-ct ', Ext.dom.Element.unselectableCls, '">', '<ul id="{id}-listEl" data-ref="listEl" class="', "x-", 'list-plain"', '<tpl foreach="ariaAttributes"> {$}="{.}"</tpl>', ">", "</ul>", "</div>", "{%", "var pagingToolbar=values.$comp.pagingToolbar;", "if (pagingToolbar) {", "Ext.DomHelper.generateMarkup(pagingToolbar.getRenderTree(), out);", "}", "%}", {disableFormats: true}],
    focusOnToFront: false,
    initComponent: function () {
        var b = this, a = b.baseCls, c = b.itemCls;
        b.selectedItemCls = a + "-selected";
        if (b.trackOver) {
            b.overItemCls = a + "-item-over"
        }
        b.itemSelector = "." + c;
        b.scrollerSelector = "ul.x-list-plain";
        if (b.floating) {
            b.addCls(a + "-floating")
        }
        if (!b.tpl) {
            b.tpl = new Ext.XTemplate('<tpl for=".">', '<li role="option" unselectable="on" class="' + c + '">' + b.getInnerTpl(b.displayField) + "</li>", "</tpl>")
        } else {
            if (!b.tpl.isTemplate) {
                b.tpl = new Ext.XTemplate(b.tpl)
            }
        }
        if (b.pageSize) {
            b.pagingToolbar = b.createPagingToolbar()
        }
        Ext.view.View.prototype.initComponent.call(this)
    },
    getRefOwner: function () {
        return this.pickerField || Ext.view.View.prototype.getRefOwner.call(this)
    },
    getRefItems: function () {
        var a = Ext.view.View.prototype.getRefItems.call(this), b = this.pagingToolbar;
        if (b) {
            a.push(b)
        }
        return a
    },
    createPagingToolbar: function () {
        return Ext.widget("pagingtoolbar", {
            id: this.id + "-paging-toolbar",
            pageSize: this.pageSize,
            store: this.dataSource,
            border: false,
            ownerCt: this,
            ownerLayout: this.getComponentLayout()
        })
    },
    getNodeContainer: function () {
        return this.listEl
    },
    refresh: function () {
        var b = this, a = b.tpl;
        a.field = b.pickerField;
        a.store = b.store;
        Ext.view.View.prototype.refresh.call(this);
        a.field = a.store = null
    },
    bindStore: function (a, b) {
        var c = this.pagingToolbar;
        Ext.view.View.prototype.bindStore.apply(this, arguments);
        if (c) {
            c.bindStore(a, b)
        }
    },
    getInnerTpl: function (a) {
        return "{" + a + "}"
    },
    onShow: function () {
        Ext.view.View.prototype.onShow.call(this);
        if (Ext.Element.getActiveElement() !== this.pickerField.inputEl.dom) {
            this.focus()
        }
    },
    onHide: function () {
        var a = this.pickerField.inputEl.dom;
        if (Ext.Element.getActiveElement() !== a && (!Ext.EventObject || Ext.EventObject.pointerType !== "touch")) {
            a.focus()
        }
        Ext.view.View.prototype.onHide.apply(this, arguments)
    },
    afterComponentLayout: function (d, a, b, e) {
        var c = this.pickerField;
        Ext.view.View.prototype.afterComponentLayout.apply(this, arguments);
        if (c && c.alignPicker) {
            c.alignPicker()
        }
    },
    onItemClick: function (a) {
        var d = this, e = d.pickerField, b = e.valueField, c = d.getSelectionModel().getSelection();
        if (!e.multiSelect && c.length) {
            c = c[0];
            if (c && e.isEqual(a.get(b), c.get(b)) && e.collapse) {
                e.collapse()
            }
        }
    },
    onContainerClick: function (a) {
        if (this.pagingToolbar && this.pagingToolbar.rendered && a.within(this.pagingToolbar.el)) {
            return false
        }
    },
    onDestroy: function () {
        Ext.view.View.prototype.onDestroy.call(this);
        Ext.destroyMembers(this, "pagingToolbar", "listWrap", "listEl")
    },
    privates: {
        getTargetEl: function () {
            return this.listEl
        }, getOverflowEl: function () {
            return this.listWrap
        }, finishRenderChildren: function () {
            var a = this.pagingToolbar;
            Ext.view.View.prototype.finishRenderChildren.apply(this, arguments);
            if (a) {
                a.finishRender()
            }
        }
    }
}, 0, ["boundlist"], ["component", "box", "dataview", "boundlist"], {
    component: true,
    box: true,
    dataview: true,
    boundlist: true
}, ["widget.boundlist"], [[Ext.mixin.Queryable.prototype.mixinId || Ext.mixin.Queryable.$className, Ext.mixin.Queryable]], [Ext.view, "BoundList", Ext, "BoundList"], 0));
(Ext.cmd.derive("Ext.form.field.ComboBox", Ext.form.field.Picker, {
    alternateClassName: "Ext.form.ComboBox",
    config: {
        filters: null,
        selection: null,
        valueNotFoundText: null,
        displayTpl: false,
        delimiter: ", ",
        displayField: "text"
    },
    publishes: ["selection"],
    twoWayBindable: ["selection"],
    triggerCls: "x-form-arrow-trigger",
    hiddenName: "",
    collapseOnSelect: false,
    hiddenDataCls: "x-hidden-display x-form-data-hidden",
    ariaRole: "combobox",
    childEls: {hiddenDataEl: true},
    filtered: false,
    afterRender: function () {
        var a = this;
        Ext.form.field.Picker.prototype.afterRender.apply(this, arguments);
        a.setHiddenValue(a.value)
    },
    multiSelect: false,
    triggerAction: "all",
    allQuery: "",
    queryParam: "query",
    queryMode: "remote",
    queryCaching: true,
    autoLoadOnValue: false,
    pageSize: 0,
    anyMatch: false,
    caseSensitive: false,
    autoSelect: true,
    typeAhead: false,
    typeAheadDelay: 250,
    selectOnTab: true,
    forceSelection: false,
    growToLongestValue: true,
    clearFilterOnBlur: true,
    defaultListConfig: {loadingHeight: 70, minWidth: 70, maxHeight: 300, shadow: "sides"},
    transformInPlace: true,
    clearValueOnEmpty: true,
    getGrowWidth: function () {
        var d = this, g = d.inputEl.dom.value, e, h, j, c, b, k, a;
        if (d.growToLongestValue) {
            e = d.displayField;
            h = d.store;
            j = h.data.length;
            c = 0;
            for (b = 0; b < j; b++) {
                k = h.getAt(b).data[e];
                a = k.length;
                if (a > c) {
                    c = a;
                    g = k
                }
            }
        }
        return g
    },
    initComponent: function () {
        var e = this, c = Ext.isDefined, b = e.store, d = e.transform, a, g;
        if ("pinList" in e) {
            e.collapseOnSelect = !e.pinList
        }
        if (d) {
            a = Ext.getDom(d);
            if (a) {
                if (!e.store) {
                    b = Ext.Array.map(Ext.Array.from(a.options), function (h) {
                        return [h.value, h.text]
                    })
                }
                if (!e.name) {
                    e.name = a.name
                }
                if (!("value" in e)) {
                    e.value = a.value
                }
            }
        }
        e.bindStore(b || "ext-empty-store", true, true);
        g = e.queryMode === "local";
        if (!c(e.queryDelay)) {
            e.queryDelay = g ? 10 : 500
        }
        if (!c(e.minChars)) {
            e.minChars = g ? 0 : 4
        }
        Ext.form.field.Picker.prototype.initComponent.call(this);
        e.doQueryTask = new Ext.util.DelayedTask(e.doRawQuery, e);
        if (a) {
            if (e.transformInPlace) {
                e.render(a.parentNode, a);
                delete e.renderTo
            }
            Ext.removeNode(a)
        }
    },
    getSubTplData: function (b) {
        var c, a;
        c = Ext.form.field.Picker.prototype.getSubTplData.call(this, b);
        a = c.inputElAriaAttributes;
        if (a) {
            a["aria-autocomplete"] = "list"
        }
        return c
    },
    getSubTplMarkup: function (c) {
        var d = this, a = "", b = Ext.form.field.Picker.prototype.getSubTplMarkup.apply(this, arguments);
        if (d.hiddenName) {
            a = '<div id="' + c.id + '-hiddenDataEl" data-ref="hiddenDataEl" class="' + d.hiddenDataCls + '" role="presentation"></div>'
        }
        return a + b
    },
    applyDisplayTpl: function (b) {
        var a = this;
        if (!b) {
            b = new Ext.XTemplate('<tpl for=".">{[typeof values === "string" ? values : values["' + a.getDisplayField() + '"]]}<tpl if="xindex < xcount">' + a.getDelimiter() + "</tpl></tpl>")
        } else {
            if (!b.isTemplate) {
                b = new Ext.XTemplate(b)
            }
        }
        return b
    },
    applyFilters: function (b, c) {
        var a = this;
        if (b === null || b.isFilterCollection) {
            return b
        }
        if (b) {
            if (!c) {
                c = this.getFilters()
            }
            c.beginUpdate();
            c.splice(0, c.length, b);
            c.each(function (d) {
                d.ownerId = a.id
            });
            c.endUpdate()
        }
        return c
    },
    applyValueNotFoundText: function (a) {
        var b = this, c = b.valueNotFoundRecord || (b.valueNotFoundRecord = new Ext.data.Model());
        c.set(b.displayField, a);
        if (b.valueField && b.displayField !== b.valueField) {
            c.set(b.valueField, a)
        }
        return a
    },
    getFilters: function (b) {
        var a = this.filters;
        if (!a && b !== false) {
            a = new Ext.util.FilterCollection();
            this.setFilters(a)
        }
        return a
    },
    updateFilters: function (a, b) {
        var c = this;
        if (b) {
            b.un("endupdate", "onEndUpdateFilters", c)
        }
        if (a) {
            a.on("endupdate", "onEndUpdateFilters", c)
        }
        c.onEndUpdateFilters(a)
    },
    onEndUpdateFilters: function (e) {
        var d = this, g = d.filtered, c = !!e && (e.length > 0), a, b;
        if (g || c) {
            d.filtered = c;
            a = [];
            b = d.store.getFilters();
            b.each(function (h) {
                if (h.ownerId === d.id && !e.contains(h)) {
                    a.push(h)
                }
            });
            b.splice(0, a, e.items)
        }
    },
    completeEdit: function (c) {
        var b = this, a = b.queryFilter;
        Ext.form.field.Picker.prototype.completeEdit.call(this, c);
        b.doQueryTask.cancel();
        b.assertValue();
        if (a && b.queryMode === "local" && b.clearFilterOnBlur) {
            b.getStore().getFilters().remove(a)
        }
    },
    onFocus: function (b) {
        var a = this;
        Ext.form.field.Picker.prototype.onFocus.call(this, b);
        if (a.triggerAction !== "all" && a.queryFilter && a.queryMode === "local" && a.clearFilterOnBlur) {
            delete a.lastQuery;
            a.doRawQuery()
        }
    },
    assertValue: function () {
        var b = this, c = b.getRawValue(), a = b.getDisplayValue(), d = b.lastSelectedRecords, e;
        if (b.forceSelection) {
            if (b.multiSelect) {
                if (c !== a) {
                    b.setRawValue(a)
                }
            } else {
                e = b.findRecordByDisplay(c);
                if (e) {
                    if (b.getDisplayValue([b.getRecordDisplayData(e)]) !== a) {
                        b.select(e, true)
                    }
                } else {
                    if (d) {
                        b.setValue(d)
                    } else {
                        b.setRawValue("")
                    }
                }
            }
        }
        b.collapse()
    },
    onTypeAhead: function () {
        var e = this, d = e.displayField, b = e.store.findRecord(d, e.getRawValue()), c = e.getPicker(), g, a, h;
        if (b) {
            g = b.get(d);
            a = g.length;
            h = e.getRawValue().length;
            c.highlightItem(c.getNode(b));
            if (h !== 0 && h !== a) {
                e.setRawValue(g);
                e.selectText(h, g.length)
            }
        }
    },
    resetToDefault: Ext.emptyFn,
    beforeReset: function () {
        var a = this.queryFilter;
        Ext.form.field.Picker.prototype.beforeReset.call(this);
        if (a) {
            this.getStore().getFilters().remove(a)
        }
    },
    onUnbindStore: function () {
        var c = this, a = c.picker, b = c.queryFilter;
        if (b && !c.store.destroyed) {
            c.changingFilters = true;
            c.getStore().removeFilter(b, true);
            c.changingFilters = false
        }
        c.pickerSelectionModel.destroy();
        if (a) {
            a.bindStore(null)
        }
    },
    onBindStore: function (a, c) {
        var e = this, b = e.picker, d, g;
        if (a) {
            if (a.autoCreated) {
                e.queryMode = "local";
                e.valueField = e.displayField = "field1";
                if (!a.expanded) {
                    e.displayField = "field2"
                }
                e.setDisplayTpl(null)
            }
            if (!Ext.isDefined(e.valueField)) {
                e.valueField = e.displayField
            }
            d = {byValue: {rootProperty: "data", unique: false}};
            d.byValue.property = e.valueField;
            a.setExtraKeys(d);
            if (e.displayField === e.valueField) {
                a.byText = a.byValue
            } else {
                d.byText = {rootProperty: "data", unique: false};
                d.byText.property = e.displayField;
                a.setExtraKeys(d)
            }
            g = {
                rootProperty: "data",
                extraKeys: {
                    byInternalId: {property: "internalId"},
                    byValue: {property: e.valueField, rootProperty: "data"}
                },
                listeners: {
                    beginupdate: e.onValueCollectionBeginUpdate,
                    endupdate: e.onValueCollectionEndUpdate,
                    scope: e
                }
            };
            e.valueCollection = new Ext.util.Collection(g);
            e.pickerSelectionModel = new Ext.selection.DataViewModel({
                mode: e.multiSelect ? "SIMPLE" : "SINGLE",
                deselectOnContainerClick: false,
                enableInitialSelection: false,
                pruneRemoved: false,
                selected: e.valueCollection,
                store: a,
                listeners: {scope: e, lastselectedchanged: e.updateBindSelection}
            });
            if (!c) {
                e.resetToDefault()
            }
            if (b) {
                b.setSelectionModel(e.pickerSelectionModel);
                if (b.getStore() !== a) {
                    b.bindStore(a)
                }
            }
        }
    },
    bindStore: function (a, e, b) {
        var d = this, c = d.queryFilter;
        d.mixins.storeholder.bindStore.call(d, a, b);
        a = d.getStore();
        if (a && c && !e) {
            a.getFilters().add(c)
        }
        if (!b && a && !a.isEmptyStore) {
            d.setValueOnData()
        }
    },
    getStoreListeners: function (b) {
        if (!b.isEmptyStore) {
            var c = this, a = {
                datachanged: c.onDataChanged,
                load: c.onLoad,
                exception: c.onException,
                update: c.onStoreUpdate,
                remove: c.checkValueOnChange
            };
            if (!b.getRemoteFilter()) {
                a.filterchange = c.checkValueOnChange
            }
            return a
        }
    },
    onDataChanged: function () {
        if (this.grow && this.growToLongestValue) {
            this.autoSize()
        }
    },
    checkValueOnChange: function () {
        var a = this;
        if (!a.destroying && a.getStore().isLoaded()) {
            if (a.multiSelect) {
            } else {
                if (a.forceSelection && !a.changingFilters && !a.findRecordByValue(a.value)) {
                    a.setValue(null)
                }
            }
        }
    },
    onStoreUpdate: function (b, a) {
        this.updateValue()
    },
    onException: function () {
        this.collapse()
    },
    onLoad: function (c, b, e) {
        var d = this, a = !d.valueCollection.byValue.get(d.value);
        if (e && a && !(c.lastOptions && "rawQuery" in c.lastOptions)) {
            d.setValueOnData()
        }
        d.checkValueOnChange()
    },
    setValueOnData: function () {
        var a = this;
        a.setValue(a.value);
        if (a.isExpanded && a.getStore().getCount()) {
            a.doAutoSelect()
        }
    },
    doRawQuery: function () {
        var a = this, b = a.inputEl.dom.value;
        if (a.multiSelect) {
            b = b.split(a.delimiter).pop()
        }
        a.doQuery(b, false, true)
    },
    doQuery: function (e, b, d) {
        var c = this, a = c.beforeQuery({query: e || "", rawQuery: d, forceAll: b, combo: c, cancel: false});
        if (a !== false && !a.cancel) {
            if (c.queryCaching && a.query === c.lastQuery) {
                c.expand()
            } else {
                c.lastQuery = a.query;
                if (c.queryMode === "local") {
                    c.doLocalQuery(a)
                } else {
                    c.doRemoteQuery(a)
                }
            }
        }
        return true
    },
    beforeQuery: function (a) {
        var b = this;
        if (b.fireEvent("beforequery", a) === false) {
            a.cancel = true
        } else {
            if (!a.cancel) {
                if (a.query.length < b.minChars && !a.forceAll) {
                    a.cancel = true
                }
            }
        }
        return a
    },
    doLocalQuery: function (b) {
        var d = this, e = b.query, a = d.getStore(), c = d.queryFilter;
        d.queryFilter = null;
        d.changingFilters = true;
        if (c) {
            a.removeFilter(c, true)
        }
        if (e) {
            c = d.queryFilter = new Ext.util.Filter({
                id: d.id + "-filter",
                anyMatch: d.anyMatch,
                caseSensitive: d.caseSensitive,
                root: "data",
                property: d.displayField,
                value: d.enableRegEx ? new RegExp(e) : e
            });
            a.addFilter(c, true)
        }
        d.changingFilters = false;
        if (d.store.getCount() || d.getPicker().emptyText) {
            d.getPicker().refresh();
            d.expand()
        } else {
            d.collapse()
        }
        d.afterQuery(b)
    },
    doRemoteQuery: function (b) {
        var c = this, a = function () {
            if (!c.destroyed) {
                c.afterQuery(b)
            }
        };
        c.expand();
        if (c.pageSize) {
            c.loadPage(1, {rawQuery: b.rawQuery, callback: a})
        } else {
            c.store.load({params: c.getParams(b.query), rawQuery: b.rawQuery, callback: a})
        }
    },
    afterQuery: function (a) {
        var b = this;
        if (b.store.getCount()) {
            if (b.typeAhead) {
                b.doTypeAhead()
            }
            if (a.rawQuery) {
                if (b.picker && !b.picker.getSelectionModel().hasSelection()) {
                    b.doAutoSelect()
                }
            } else {
                b.doAutoSelect()
            }
        }
        b.checkChange()
    },
    loadPage: function (b, a) {
        this.store.loadPage(b, Ext.apply({params: this.getParams(this.lastQuery)}, a))
    },
    onPageChange: function (b, a) {
        this.loadPage(a);
        return false
    },
    getParams: function (c) {
        var b = {}, a = this.queryParam;
        if (a) {
            b[a] = c
        }
        return b
    },
    doAutoSelect: function () {
        var b = this, a = b.picker;
        if (a && b.autoSelect && b.store.getCount() > 0) {
            a.getNavigationModel().setPosition(b.picker.getSelectionModel().lastSelected || 0)
        }
    },
    doTypeAhead: function () {
        var b = this, a = Ext.event.Event;
        if (!b.typeAheadTask) {
            b.typeAheadTask = new Ext.util.DelayedTask(b.onTypeAhead, b)
        }
        if (b.lastKey !== a.BACKSPACE && b.lastKey !== a.DELETE) {
            b.typeAheadTask.delay(b.typeAheadDelay)
        }
    },
    onTriggerClick: function () {
        var a = this;
        if (!a.readOnly && !a.disabled) {
            if (a.isExpanded) {
                a.collapse()
            } else {
                if (a.triggerAction === "all") {
                    a.doQuery(a.allQuery, true)
                } else {
                    if (a.triggerAction === "last") {
                        a.doQuery(a.lastQuery, true)
                    } else {
                        a.doQuery(a.getRawValue(), false, true)
                    }
                }
            }
        }
    },
    onFieldMutation: function (h) {
        var d = this, b = h.getKey(), c = b === h.BACKSPACE || b === h.DELETE, g = d.inputEl.dom.value, a = g.length;
        if (!d.readOnly && (g !== d.lastMutatedValue || c) && b !== h.TAB) {
            d.lastMutatedValue = g;
            d.lastKey = b;
            if (a && (h.type !== "keyup" || (!h.isSpecialKey() || c))) {
                d.doQueryTask.delay(d.queryDelay)
            } else {
                if (!a && (!b || c)) {
                    if (!d.multiSelect) {
                        d.value = null;
                        d.displayTplData = undefined
                    }
                    if (d.clearValueOnEmpty) {
                        d.valueCollection.removeAll()
                    }
                    d.collapse();
                    if (d.queryFilter) {
                        d.changingFilters = true;
                        d.store.removeFilter(d.queryFilter, true);
                        d.changingFilters = false
                    }
                }
                Ext.form.field.Picker.prototype.onFieldMutation.call(this, h)
            }
        }
    },
    onDestroy: function () {
        var a = this;
        a.doQueryTask.cancel();
        if (a.typeAheadTask) {
            a.typeAheadTask.cancel();
            a.typeAheadTask = null
        }
        a.bindStore(null);
        a.valueCollection = Ext.destroy(a.valueCollection);
        Ext.form.field.Picker.prototype.onDestroy.call(this)
    },
    onAdded: function () {
        var a = this;
        Ext.form.field.Picker.prototype.onAdded.apply(this, arguments);
        if (a.picker) {
            a.picker.ownerCt = a.up("[floating]");
            a.picker.registerWithOwnerCt()
        }
    },
    createPicker: function () {
        var c = this, b, a = Ext.apply({
            xtype: "boundlist",
            id: c.pickerId,
            pickerField: c,
            selectionModel: c.pickerSelectionModel,
            floating: true,
            hidden: true,
            store: c.getPickerStore(),
            displayField: c.displayField,
            preserveScrollOnRefresh: true,
            pageSize: c.pageSize,
            tpl: c.tpl
        }, c.listConfig, c.defaultListConfig);
        b = c.picker = Ext.widget(a);
        if (c.pageSize) {
            b.pagingToolbar.on("beforechange", c.onPageChange, c)
        }
        if (!b.initialConfig.maxHeight) {
            b.on({beforeshow: c.onBeforePickerShow, scope: c})
        }
        b.getSelectionModel().on({
            beforeselect: c.onBeforeSelect,
            beforedeselect: c.onBeforeDeselect,
            focuschange: c.onFocusChange,
            scope: c
        });
        b.getNavigationModel().navigateOnSpace = false;
        return b
    },
    getPickerStore: function () {
        return this.store
    },
    onBeforePickerShow: function (a) {
        var b = this, d = b.getPosition()[1] - Ext.getBody().getScroll().top,
            c = Ext.Element.getViewportHeight() - d - b.getHeight();
        a.maxHeight = Math.max(d, c) - 5
    },
    onBeforeSelect: function (c, a, b) {
        return this.fireEvent("beforeselect", this, a, b)
    },
    onBeforeDeselect: function (c, a, b) {
        return this.fireEvent("beforedeselect", this, a, b)
    },
    onFocusChange: function (c, a, b) {
        var d = this.picker, e;
        if (b) {
            e = Ext.get(d.getNodeByRecord(b));
            if (e) {
                this.ariaEl.dom.setAttribute("aria-activedescendant", e.id)
            }
        }
    },
    getSelection: function () {
        var a = this.getPicker().getSelectionModel(), b = a.getSelection();
        return b.length ? a.getLastSelected() : null
    },
    updateSelection: function (a) {
        var b = this, c;
        if (!b.ignoreNextSelection) {
            b.ignoreNextSelection = true;
            c = b.getPicker().getSelectionModel();
            if (a) {
                c.select(a);
                b.hasHadSelection = true
            } else {
                c.deselectAll()
            }
            b.ignoreNextSelection = false
        }
    },
    updateBindSelection: function (a, c) {
        var d = this, b = null;
        if (!d.ignoreNextSelection) {
            d.ignoreNextSelection = true;
            if (c.length) {
                b = a.getLastSelected();
                d.hasHadSelection = true
            }
            if (d.hasHadSelection) {
                d.setSelection(b)
            }
            d.ignoreNextSelection = false
        }
    },
    onValueCollectionBeginUpdate: Ext.emptyFn,
    onValueCollectionEndUpdate: function () {
        var d = this, c = d.store, e = d.valueCollection.getRange(), b = e[0], a = e.length;
        d.updateBindSelection(d.pickerSelectionModel, e);
        if (d.isSelectionUpdating()) {
            return
        }
        Ext.suspendLayouts();
        d.lastSelection = e;
        if (a) {
            d.lastSelectedRecords = e
        }
        d.updateValue();
        if (a && ((!d.multiSelect && c.contains(b)) || d.collapseOnSelect || !c.getCount())) {
            d.updatingValue = true;
            d.collapse();
            d.updatingValue = false
        }
        Ext.resumeLayouts(true);
        if (a && !d.suspendCheckChange) {
            if (!d.multiSelect) {
                e = b
            }
            d.fireEvent("select", d, e)
        }
    },
    isSelectionUpdating: function () {
        var a = this.pickerSelectionModel;
        return a.deselectingDuringSelect || a.refreshing
    },
    onExpand: function () {
        var a = this.getPicker().getNavigationModel();
        if (a) {
            a.enable()
        }
        this.doAutoSelect()
    },
    onCollapse: function () {
        var a = this.getPicker().getNavigationModel();
        if (a) {
            a.disable()
        }
        if (this.updatingValue) {
            this.doQueryTask.cancel()
        }
    },
    select: function (d, a) {
        var c = this, b = c.picker, e;
        if (d && d.isModel && a === true && b) {
            e = !b.getSelectionModel().isSelected(d)
        }
        if (!e) {
            c.suspendEvent("select")
        }
        c.setValue(d);
        c.resumeEvent("select")
    },
    findRecord: function (d, c) {
        var b = this.store, a = b.findExact(d, c);
        return a !== -1 ? b.getAt(a) : false
    },
    getSelectedRecord: function () {
        return this.findRecordByValue(this.value) || null
    },
    findRecordByValue: function (c) {
        var a = this.store.byValue.get(c), b = false;
        if (a) {
            b = a[0] || a
        }
        return b
    },
    findRecordByDisplay: function (c) {
        var a = this.store.byText.get(c), b = false;
        if (a) {
            b = a[0] || a
        }
        return b
    },
    addValue: function (a) {
        if (a != null) {
            return this.doSetValue(a, true)
        }
    },
    setValue: function (b) {
        var a = this;
        if (b != null) {
            return a.doSetValue(b)
        } else {
            a.suspendEvent("select");
            a.valueCollection.beginUpdate();
            a.pickerSelectionModel.deselectAll();
            a.valueCollection.endUpdate();
            a.lastSelectedRecords = null;
            a.resumeEvent("select")
        }
    },
    setRawValue: function (a) {
        Ext.form.field.Picker.prototype.setRawValue.call(this, a);
        this.lastMutatedValue = a
    },
    doSetValue: function (q, m) {
        var w = this, h = w.getStore(), j = h.getModel(), t = [], g = [], s = w.autoLoadOnValue,
            e = h.getCount() > 0 || h.isLoaded(), a = h.hasPendingLoad(), n = s && !e && !a, l = w.forceSelection,
            p = w.pickerSelectionModel, b = w.displayField === w.valueField, o = h.isEmptyStore, k = w.lastSelection, u,
            v, c, r, d, x;
        if (a || n || !e || o) {
            if (!q.isModel) {
                if (m) {
                    w.value = Ext.Array.from(w.value).concat(q)
                } else {
                    w.value = q
                }
                w.setHiddenValue(w.value);
                w.setRawValue(b ? q : "")
            }
            if (n && !o) {
                h.load()
            }
            if (!q.isModel || o) {
                return w
            }
        }
        q = m ? Ext.Array.from(w.value).concat(q) : Ext.Array.from(q);
        for (u = 0, v = q.length; u < v; u++) {
            c = q[u];
            if (!c || !c.isModel) {
                c = w.findRecordByValue(x = c);
                if (!c) {
                    c = w.valueCollection.find(w.valueField, x)
                }
            }
            if (!c) {
                if (!l) {
                    if (!c && q[u]) {
                        r = {};
                        r[w.displayField] = q[u];
                        if (w.valueField && w.displayField !== w.valueField) {
                            r[w.valueField] = q[u]
                        }
                        c = new j(r)
                    }
                } else {
                    if (w.valueNotFoundRecord) {
                        c = w.valueNotFoundRecord
                    }
                }
            }
            if (c) {
                t.push(c);
                g.push(c.get(w.valueField))
            }
        }
        if (k) {
            v = k.length;
            if (v === t.length) {
                for (u = 0; !d && u < v; u++) {
                    if (Ext.Array.indexOf(w.lastSelection, t[u]) === -1) {
                        d = true
                    }
                }
            } else {
                d = true
            }
        } else {
            d = t.length
        }
        if (d) {
            w.suspendEvent("select");
            w.valueCollection.beginUpdate();
            if (t.length) {
                p.select(t, false)
            } else {
                p.deselectAll()
            }
            w.valueCollection.endUpdate();
            w.resumeEvent("select")
        } else {
            w.updateValue()
        }
        return w
    },
    updateValue: function () {
        var e = this, j = e.valueCollection.getRange(), a = j.length, d = [],
            g = e.displayTplData || (e.displayTplData = []), h = e.inputEl, c, b;
        g.length = 0;
        for (c = 0; c < a; c++) {
            b = j[c];
            g.push(e.getRecordDisplayData(b));
            if (b !== e.valueNotFoundRecord) {
                d.push(b.get(e.valueField))
            }
        }
        e.setHiddenValue(d);
        e.value = e.multiSelect ? d : d[0];
        if (!Ext.isDefined(e.value)) {
            e.value = undefined
        }
        e.displayTplData = g;
        if (h && e.emptyText && !Ext.isEmpty(e.value)) {
            h.removeCls(e.emptyCls)
        }
        e.setRawValue(e.getDisplayValue());
        e.checkChange();
        e.applyEmptyText()
    },
    setHiddenValue: function (j) {
        var e = this, a = e.hiddenName, d, b, k, h, g, c;
        if (!e.hiddenDataEl || !a) {
            return
        }
        j = Ext.Array.from(j);
        b = e.hiddenDataEl.dom;
        k = b.childNodes;
        h = k[0];
        g = j.length;
        c = k.length;
        if (!h && g > 0) {
            e.hiddenDataEl.setHtml(Ext.DomHelper.markup({tag: "input", type: "hidden", name: a}));
            c = 1;
            h = b.firstChild
        }
        while (c > g) {
            b.removeChild(k[0]);
            --c
        }
        while (c < g) {
            b.appendChild(h.cloneNode(true));
            ++c
        }
        for (d = 0; d < g; d++) {
            k[d].value = j[d]
        }
    },
    getDisplayValue: function (a) {
        a = a || this.displayTplData;
        return this.getDisplayTpl().apply(a)
    },
    getRecordDisplayData: function (a) {
        return a.data
    },
    getValue: function () {
        var c = this, a = c.getStore(), b = c.picker, e = c.getRawValue(), d = c.value;
        if (!a.isEmptyStore && c.getDisplayValue() !== e) {
            c.displayTplData = undefined;
            if (b) {
                c.valueCollection.suspendEvents();
                b.getSelectionModel().deselectAll();
                c.valueCollection.resumeEvents();
                c.lastSelection = null
            }
            if (a.isLoaded() && (c.multiSelect || c.forceSelection)) {
                d = c.value = undefined
            } else {
                d = c.value = e
            }
        }
        c.value = d == null ? null : d;
        return c.value
    },
    getSubmitValue: function () {
        var a = this.getValue();
        if (Ext.isEmpty(a)) {
            a = ""
        }
        return a
    },
    isEqual: function (e, d) {
        var b = Ext.Array.from, c, a;
        e = b(e);
        d = b(d);
        a = e.length;
        if (a !== d.length) {
            return false
        }
        for (c = 0; c < a; c++) {
            if (d[c] !== e[c]) {
                return false
            }
        }
        return true
    },
    clearValue: function () {
        this.setValue(null)
    }
}, 0, ["combo", "combobox"], ["component", "box", "field", "textfield", "pickerfield", "combobox", "combo"], {
    component: true,
    box: true,
    field: true,
    textfield: true,
    pickerfield: true,
    combobox: true,
    combo: true
}, ["widget.combo", "widget.combobox"], [[Ext.util.StoreHolder.prototype.mixinId || Ext.util.StoreHolder.$className, Ext.util.StoreHolder]], [Ext.form.field, "ComboBox", Ext.form, "ComboBox"], 0));
(Ext.cmd.derive("Ext.picker.Month", Ext.Component, {
    alternateClassName: "Ext.MonthPicker",
    isMonthPicker: true,
    focusable: true,
    childEls: ["bodyEl", "prevEl", "nextEl", "monthEl", "yearEl"],
    renderTpl: ['<div id="{id}-bodyEl" data-ref="bodyEl" class="{baseCls}-body">', '<div id="{id}-monthEl" data-ref="monthEl" class="{baseCls}-months">', '<tpl for="months">', '<div class="{parent.baseCls}-item {parent.baseCls}-month">', '<a style="{parent.monthStyle}" role="button" hidefocus="on" class="{parent.baseCls}-item-inner">{.}</a>', "</div>", "</tpl>", "</div>", '<div id="{id}-yearEl" data-ref="yearEl" class="{baseCls}-years">', '<div class="{baseCls}-yearnav">', '<div class="{baseCls}-yearnav-button-ct">', '<a id="{id}-prevEl" data-ref="prevEl" class="{baseCls}-yearnav-button {baseCls}-yearnav-prev" hidefocus="on" role="button"></a>', "</div>", '<div class="{baseCls}-yearnav-button-ct">', '<a id="{id}-nextEl" data-ref="nextEl" class="{baseCls}-yearnav-button {baseCls}-yearnav-next" hidefocus="on" role="button"></a>', "</div>", "</div>", '<tpl for="years">', '<div class="{parent.baseCls}-item {parent.baseCls}-year">', '<a hidefocus="on" class="{parent.baseCls}-item-inner" role="button">{.}</a>', "</div>", "</tpl>", "</div>", '<div class="x-clear"></div>', '<tpl if="showButtons">', '<div class="{baseCls}-buttons">{%', "var me=values.$comp, okBtn=me.okBtn, cancelBtn=me.cancelBtn;", "okBtn.ownerLayout = cancelBtn.ownerLayout = me.componentLayout;", "okBtn.ownerCt = cancelBtn.ownerCt = me;", "Ext.DomHelper.generateMarkup(okBtn.getRenderTree(), out);", "Ext.DomHelper.generateMarkup(cancelBtn.getRenderTree(), out);", "%}</div>", "</tpl>", "</div>"],
    okText: "OK",
    cancelText: "Cancel",
    baseCls: "x-monthpicker",
    showButtons: true,
    footerButtonUI: "default",
    measureWidth: 35,
    measureMaxHeight: 20,
    smallCls: "x-monthpicker-small",
    totalYears: 10,
    yearOffset: 5,
    monthOffset: 6,
    initComponent: function () {
        var a = this;
        a.selectedCls = a.baseCls + "-selected";
        if (a.small) {
            a.addCls(a.smallCls)
        }
        a.setValue(a.value);
        a.activeYear = a.getYear(new Date().getFullYear() - 4, -4);
        if (a.showButtons) {
            a.okBtn = new Ext.button.Button({ui: a.footerButtonUI, text: a.okText, handler: a.onOkClick, scope: a});
            a.cancelBtn = new Ext.button.Button({
                ui: a.footerButtonUI,
                text: a.cancelText,
                handler: a.onCancelClick,
                scope: a
            })
        }
        Ext.Component.prototype.initComponent.call(this)
    },
    beforeRender: function () {
        var g = this, c = 0, b = [], a = Ext.Date.getShortMonthName, e = g.monthOffset, h = g.monthMargin, d = "";
        if (g.padding && !g.width) {
            g.cacheWidth()
        }
        Ext.Component.prototype.beforeRender.call(this);
        for (; c < e; ++c) {
            b.push(a(c), a(c + e))
        }
        if (Ext.isDefined(h)) {
            d = "margin: 0 " + h + "px;"
        }
        Ext.apply(g.renderData, {months: b, years: g.getYears(), showButtons: g.showButtons, monthStyle: d})
    },
    cacheWidth: function () {
        var a = this, b = a.parseBox(a.padding), c = Ext.getBody().createChild({
            cls: a.baseCls + " " + a.borderBoxCls,
            style: "position:absolute;top:-1000px;left:-1000px;",
            html: "&nbsp;"
        });
        a.self.prototype.width = c.getWidth() + b.left + b.right;
        c.destroy()
    },
    afterRender: function () {
        var b = this, a = b.bodyEl;
        Ext.Component.prototype.afterRender.call(this);
        b.mon(a, "click", b.onBodyClick, b);
        b.mon(a, "dblclick", b.onBodyClick, b);
        b.years = a.select("." + b.baseCls + "-year a");
        b.months = a.select("." + b.baseCls + "-month a");
        b.backRepeater = new Ext.util.ClickRepeater(b.prevEl, {handler: Ext.Function.bind(b.adjustYear, b, [-b.totalYears])});
        b.prevEl.addClsOnOver(b.baseCls + "-yearnav-prev-over");
        b.nextRepeater = new Ext.util.ClickRepeater(b.nextEl, {handler: Ext.Function.bind(b.adjustYear, b, [b.totalYears])});
        b.nextEl.addClsOnOver(b.baseCls + "-yearnav-next-over");
        b.updateBody();
        if (!Ext.isDefined(b.monthMargin)) {
            Ext.picker.Month.prototype.monthMargin = b.calculateMonthMargin()
        }
    },
    calculateMonthMargin: function () {
        var c = this, a = c.months, d = a.first(), b = d.getMargin("l");
        while (b && c.getLargest() > c.measureMaxHeight) {
            --b;
            a.setStyle("margin", "0 " + b + "px")
        }
        return b
    },
    getLargest: function (a) {
        var b = 0;
        this.months.each(function (d) {
            var c = d.getHeight();
            if (c > b) {
                b = c
            }
        });
        return b
    },
    setValue: function (c) {
        var b = this, d = b.activeYear, a;
        if (!c) {
            b.value = [null, null]
        } else {
            if (Ext.isDate(c)) {
                b.value = [c.getMonth(), c.getFullYear()]
            } else {
                b.value = [c[0], c[1]]
            }
        }
        if (b.rendered) {
            a = b.value[1];
            if (a !== null) {
                if ((a < d || a > d + b.yearOffset)) {
                    b.activeYear = a - b.yearOffset + 1
                }
            }
            b.updateBody()
        }
        return b
    },
    getValue: function () {
        return this.value
    },
    hasSelection: function () {
        var a = this.value;
        return a[0] !== null && a[1] !== null
    },
    getYears: function () {
        var d = this, e = d.yearOffset, g = d.activeYear, a = g + e, c = g, b = [];
        for (; c < a; ++c) {
            b.push(c, c + e)
        }
        return b
    },
    updateBody: function () {
        var i = this, e = i.years, b = i.months, m = i.getYears(), n = i.selectedCls, k = i.getYear(null),
            g = i.value[0], l = i.monthOffset, h, d, j, a, c;
        if (i.rendered) {
            e.removeCls(n);
            b.removeCls(n);
            d = e.elements;
            a = d.length;
            for (j = 0; j < a; j++) {
                c = Ext.fly(d[j]);
                h = m[j];
                c.dom.innerHTML = h;
                if (h === k) {
                    c.addCls(n)
                }
            }
            if (g !== null) {
                if (g < l) {
                    g = g * 2
                } else {
                    g = (g - l) * 2 + 1
                }
                b.item(g).addCls(n)
            }
        }
    },
    getYear: function (a, c) {
        var b = this.value[1];
        c = c || 0;
        return b === null ? a : b + c
    },
    onBodyClick: function (d, b) {
        var c = this, a = d.type === "dblclick";
        if (d.getTarget("." + c.baseCls + "-month")) {
            d.stopEvent();
            c.onMonthClick(b, a)
        } else {
            if (d.getTarget("." + c.baseCls + "-year")) {
                d.stopEvent();
                c.onYearClick(b, a)
            }
        }
    },
    adjustYear: function (a) {
        if (typeof a !== "number") {
            a = this.totalYears
        }
        this.activeYear += a;
        this.updateBody()
    },
    onOkClick: function () {
        this.fireEvent("okclick", this, this.value)
    },
    onCancelClick: function () {
        this.fireEvent("cancelclick", this)
    },
    onMonthClick: function (c, a) {
        var b = this;
        b.value[0] = b.resolveOffset(b.months.indexOf(c), b.monthOffset);
        b.updateBody();
        b.fireEvent("month" + (a ? "dbl" : "") + "click", b, b.value);
        b.fireEvent("select", b, b.value)
    },
    onYearClick: function (c, a) {
        var b = this;
        b.value[1] = b.activeYear + b.resolveOffset(b.years.indexOf(c), b.yearOffset);
        b.updateBody();
        b.fireEvent("year" + (a ? "dbl" : "") + "click", b, b.value);
        b.fireEvent("select", b, b.value)
    },
    resolveOffset: function (a, b) {
        if (a % 2 === 0) {
            return (a / 2)
        } else {
            return b + Math.floor(a / 2)
        }
    },
    beforeDestroy: function () {
        var a = this;
        a.years = a.months = null;
        Ext.destroyMembers(a, "backRepeater", "nextRepeater", "okBtn", "cancelBtn");
        Ext.Component.prototype.beforeDestroy.call(this)
    },
    onDestroy: function () {
        Ext.destroyMembers(this, "okBtn", "cancelBtn");
        Ext.Component.prototype.onDestroy.call(this)
    },
    privates: {
        finishRenderChildren: function () {
            var a = this;
            Ext.Component.prototype.finishRenderChildren.apply(this, arguments);
            if (this.showButtons) {
                a.okBtn.finishRender();
                a.cancelBtn.finishRender()
            }
        }
    }
}, 0, ["monthpicker"], ["component", "box", "monthpicker"], {
    component: true,
    box: true,
    monthpicker: true
}, ["widget.monthpicker"], 0, [Ext.picker, "Month", Ext, "MonthPicker"], 0));
(Ext.cmd.derive("Ext.picker.Date", Ext.Component, {
    alternateClassName: "Ext.DatePicker",
    todayText: "Today",
    ariaTitle: "Date Picker: {0}",
    ariaTitleDateFormat: "F d",
    todayTip: "{0} (Spacebar)",
    minText: "This date is before the minimum date",
    ariaMinText: "This date is before the minimum date",
    maxText: "This date is after the maximum date",
    ariaMaxText: "This date is after the maximum date",
    disabledDaysText: "Disabled",
    ariaDisabledDaysText: "This day of week is disabled",
    disabledDatesText: "Disabled",
    ariaDisabledDatesText: "This date is disabled",
    nextText: "Next Month (Control+Right)",
    prevText: "Previous Month (Control+Left)",
    monthYearText: "Choose a month (Control+Up/Down to move years)",
    monthYearFormat: "F Y",
    startDay: 0,
    showToday: true,
    disableAnim: false,
    baseCls: "x-datepicker",
    longDayFormat: "F d, Y",
    footerButtonUI: "default",
    isDatePicker: true,
    ariaRole: "region",
    focusable: true,
    childEls: ["innerEl", "eventEl", "prevEl", "nextEl", "middleBtnEl", "footerEl"],
    border: true,
    renderTpl: ['<div id="{id}-innerEl" data-ref="innerEl" role="presentation">', '<div class="{baseCls}-header">', '<div id="{id}-prevEl" data-ref="prevEl" class="{baseCls}-prev {baseCls}-arrow" role="presentation" title="{prevText}"></div>', '<div id="{id}-middleBtnEl" data-ref="middleBtnEl" class="{baseCls}-month" role="heading">{%this.renderMonthBtn(values, out)%}</div>', '<div id="{id}-nextEl" data-ref="nextEl" class="{baseCls}-next {baseCls}-arrow" role="presentation" title="{nextText}"></div>', "</div>", '<table role="grid" id="{id}-eventEl" data-ref="eventEl" class="{baseCls}-inner" cellspacing="0" tabindex="0">', "<thead>", '<tr role="row">', '<tpl for="dayNames">', '<th role="columnheader" class="{parent.baseCls}-column-header" aria-label="{.}">', '<div role="presentation" class="{parent.baseCls}-column-header-inner">{.:this.firstInitial}</div>', "</th>", "</tpl>", "</tr>", "</thead>", "<tbody>", '<tr role="row">', '<tpl for="days">', "{#:this.isEndOfWeek}", '<td role="gridcell">', '<div hidefocus="on" class="{parent.baseCls}-date"></div>', "</td>", "</tpl>", "</tr>", "</tbody>", "</table>", '<tpl if="showToday">', '<div id="{id}-footerEl" data-ref="footerEl" role="presentation" class="{baseCls}-footer">{%this.renderTodayBtn(values, out)%}</div>', "</tpl>", '<div id="{id}-todayText" class="x-hidden-clip">{todayText}.</div>', '<div id="{id}-ariaMinText" class="x-hidden-clip">{ariaMinText}.</div>', '<div id="{id}-ariaMaxText" class="x-hidden-clip">{ariaMaxText}.</div>', '<div id="{id}-ariaDisabledDaysText" class="x-hidden-clip">{ariaDisabledDaysText}.</div>', '<div id="{id}-ariaDisabledDatesText" class="x-hidden-clip">{ariaDisabledDatesText}.</div>', "</div>", {
        firstInitial: function (a) {
            return Ext.picker.Date.prototype.getDayInitial(a)
        }, isEndOfWeek: function (b) {
            b--;
            var a = b % 7 === 0 && b !== 0;
            return a ? '</tr><tr role="row">' : ""
        }, renderTodayBtn: function (a, b) {
            Ext.DomHelper.generateMarkup(a.$comp.todayBtn.getRenderTree(), b)
        }, renderMonthBtn: function (a, b) {
            Ext.DomHelper.generateMarkup(a.$comp.monthBtn.getRenderTree(), b)
        }
    }],
    initHour: 12,
    numDays: 42,
    initComponent: function () {
        var b = this, a = Ext.Date.clearTime;
        b.selectedCls = b.baseCls + "-selected";
        b.disabledCellCls = b.baseCls + "-disabled";
        b.prevCls = b.baseCls + "-prevday";
        b.activeCls = b.baseCls + "-active";
        b.cellCls = b.baseCls + "-cell";
        b.nextCls = b.baseCls + "-prevday";
        b.todayCls = b.baseCls + "-today";
        if (!b.format) {
            b.format = Ext.Date.defaultFormat
        }
        if (!b.dayNames) {
            b.dayNames = Ext.Date.dayNames
        }
        b.dayNames = b.dayNames.slice(b.startDay).concat(b.dayNames.slice(0, b.startDay));
        Ext.Component.prototype.initComponent.call(this);
        b.value = b.value ? a(b.value, true) : a(new Date());
        b.initDisabledDays()
    },
    getRefOwner: function () {
        return this.pickerField || Ext.Component.prototype.getRefOwner.call(this)
    },
    getRefItems: function () {
        var a = [], c = this.monthBtn, b = this.todayBtn;
        if (c) {
            a.push(c)
        }
        if (b) {
            a.push(b)
        }
        return a
    },
    beforeRender: function () {
        var c = this, b = Ext.String.htmlEncode, d = new Array(c.numDays), a = Ext.Date.format(new Date(), c.format);
        if (c.padding && !c.width) {
            c.cacheWidth()
        }
        c.monthBtn = new Ext.button.Split({
            ownerCt: c,
            ownerLayout: c.getComponentLayout(),
            text: "",
            tooltip: c.monthYearText,
            tabIndex: -1,
            ariaRole: "presentation",
            listeners: {click: c.doShowMonthPicker, arrowclick: c.doShowMonthPicker, scope: c}
        });
        if (c.showToday) {
            c.todayBtn = new Ext.button.Button({
                ui: c.footerButtonUI,
                ownerCt: c,
                ownerLayout: c.getComponentLayout(),
                text: Ext.String.format(c.todayText, a),
                tooltip: Ext.String.format(c.todayTip, a),
                tooltipType: "title",
                tabIndex: -1,
                ariaRole: "presentation",
                handler: c.selectToday,
                scope: c
            })
        }
        Ext.Component.prototype.beforeRender.call(this);
        Ext.applyIf(c, {renderData: {}});
        Ext.apply(c.renderData, {
            dayNames: c.dayNames,
            showToday: c.showToday,
            prevText: b(c.prevText),
            nextText: b(c.nextText),
            todayText: b(c.todayText),
            ariaMinText: b(c.ariaMinText),
            ariaMaxText: b(c.ariaMaxText),
            ariaDisabledDaysText: b(c.ariaDisabledDaysText),
            ariaDisabledDatesText: b(c.ariaDisabledDatesText),
            days: d
        });
        c.protoEl.unselectable()
    },
    cacheWidth: function () {
        var a = this, b = a.parseBox(a.padding), c = Ext.getBody().createChild({
            cls: a.baseCls + " " + a.borderBoxCls,
            style: "position:absolute;top:-1000px;left:-1000px;"
        });
        a.self.prototype.width = c.getWidth() + b.left + b.right;
        c.destroy()
    },
    onRender: function (b, a) {
        var c = this;
        Ext.Component.prototype.onRender.apply(this, arguments);
        c.cells = c.eventEl.select("tbody td");
        c.textNodes = c.eventEl.query("tbody td div");
        c.eventEl.set({"aria-labelledby": c.monthBtn.id});
        c.mon(c.eventEl, {
            scope: c,
            mousewheel: c.handleMouseWheel,
            click: {fn: c.handleDateClick, delegate: "div." + c.baseCls + "-date"}
        })
    },
    initEvents: function () {
        var c = this, d = c.pickerField, a = Ext.Date, b = a.DAY;
        Ext.Component.prototype.initEvents.call(this);
        if (d) {
            c.el.on("mousedown", c.onMouseDown, c)
        }
        c.prevRepeater = new Ext.util.ClickRepeater(c.prevEl, {
            handler: c.showPrevMonth,
            scope: c,
            preventDefault: true,
            stopDefault: true
        });
        c.nextRepeater = new Ext.util.ClickRepeater(c.nextEl, {
            handler: c.showNextMonth,
            scope: c,
            preventDefault: true,
            stopDefault: true
        });
        c.keyNav = new Ext.util.KeyNav(c.eventEl, Ext.apply({
            scope: c, left: function (g) {
                if (g.ctrlKey) {
                    c.showPrevMonth()
                } else {
                    c.update(a.add(c.activeDate, b, -1))
                }
            }, right: function (g) {
                if (g.ctrlKey) {
                    c.showNextMonth()
                } else {
                    c.update(a.add(c.activeDate, b, 1))
                }
            }, up: function (g) {
                if (g.ctrlKey) {
                    c.showNextYear()
                } else {
                    c.update(a.add(c.activeDate, b, -7))
                }
            }, down: function (g) {
                if (g.ctrlKey) {
                    c.showPrevYear()
                } else {
                    c.update(a.add(c.activeDate, b, 7))
                }
            }, pageUp: function (g) {
                if (g.ctrlKey) {
                    c.showPrevYear()
                } else {
                    c.showPrevMonth()
                }
            }, pageDown: function (g) {
                if (g.ctrlKey) {
                    c.showNextYear()
                } else {
                    c.showNextMonth()
                }
            }, tab: function (g) {
                c.handleTabClick(g);
                return true
            }, enter: function (g) {
                c.handleDateClick(g, c.activeCell.firstChild)
            }, space: function () {
                c.setValue(new Date(c.activeCell.firstChild.dateValue));
                var e = c.startValue, g = c.value, h;
                if (d) {
                    h = d.getValue();
                    if (h && e && h.getTime() === g.getTime()) {
                        d.setValue(e)
                    } else {
                        d.setValue(g)
                    }
                }
            }, home: function (g) {
                c.update(a.getFirstDateOfMonth(c.activeDate))
            }, end: function (g) {
                c.update(a.getLastDateOfMonth(c.activeDate))
            }
        }, c.keyNavConfig));
        if (c.disabled) {
            c.syncDisabled(true)
        }
        c.update(c.value)
    },
    onMouseDown: function (a) {
        a.preventDefault()
    },
    handleTabClick: function (d) {
        var c = this, a = c.getSelectedDate(c.activeDate), b = c.handler;
        if (!c.disabled && a.dateValue && !Ext.fly(a.parentNode).hasCls(c.disabledCellCls)) {
            c.setValue(new Date(a.dateValue));
            c.fireEvent("select", c, c.value);
            if (b) {
                b.call(c.scope || c, c, c.value)
            }
            c.onSelect()
        }
    },
    getSelectedDate: function (a) {
        var d = this, i = a.getTime(), j = d.cells, k = d.selectedCls, g = j.elements, e = g.length, h, b;
        j.removeCls(k);
        for (b = 0; b < e; b++) {
            h = g[b].firstChild;
            if (h.dateValue === i) {
                return h
            }
        }
        return null
    },
    initDisabledDays: function () {
        var h = this, b = h.disabledDates, g = "(?:", a, i, c, e;
        if (!h.disabledDatesRE && b) {
            a = b.length - 1;
            c = b.length;
            for (i = 0; i < c; i++) {
                e = b[i];
                g += Ext.isDate(e) ? "^" + Ext.String.escapeRegex(Ext.Date.dateFormat(e, h.format)) + "$" : e;
                if (i !== a) {
                    g += "|"
                }
            }
            h.disabledDatesRE = new RegExp(g + ")")
        }
    },
    setDisabledDates: function (a) {
        var b = this;
        if (Ext.isArray(a)) {
            b.disabledDates = a;
            b.disabledDatesRE = null
        } else {
            b.disabledDatesRE = a
        }
        b.initDisabledDays();
        b.update(b.value, true);
        return b
    },
    setDisabledDays: function (a) {
        this.disabledDays = a;
        return this.update(this.value, true)
    },
    setMinDate: function (a) {
        this.minDate = a;
        return this.update(this.value, true)
    },
    setMaxDate: function (a) {
        this.maxDate = a;
        return this.update(this.value, true)
    },
    setValue: function (a) {
        this.value = Ext.Date.clearTime(a || new Date(), true);
        return this.update(this.value)
    },
    getValue: function () {
        return this.value
    },
    getDayInitial: function (a) {
        return a.substr(0, 1)
    },
    onEnable: function () {
        var a = this;
        Ext.Component.prototype.onEnable.call(this);
        a.syncDisabled(false);
        a.update(a.activeDate)
    },
    onShow: function () {
        var a = this;
        Ext.Component.prototype.onShow.call(this);
        a.syncDisabled(false);
        if (a.pickerField) {
            a.startValue = a.pickerField.getValue()
        }
    },
    onHide: function () {
        Ext.Component.prototype.onHide.call(this);
        this.syncDisabled(true)
    },
    onDisable: function () {
        Ext.Component.prototype.onDisable.call(this);
        this.syncDisabled(true)
    },
    getActive: function () {
        return this.activeDate || this.value
    },
    runAnimation: function (c) {
        var b = this.monthPicker, a = {
            duration: 200, callback: function () {
                b.setVisible(!c)
            }
        };
        if (c) {
            b.el.slideOut("t", a)
        } else {
            b.el.slideIn("t", a)
        }
    },
    hideMonthPicker: function (a) {
        var c = this, b = c.monthPicker;
        if (b && b.isVisible()) {
            if (c.shouldAnimate(a)) {
                c.runAnimation(true)
            } else {
                b.hide()
            }
        }
        return c
    },
    doShowMonthPicker: function () {
        this.showMonthPicker()
    },
    doHideMonthPicker: function () {
        this.hideMonthPicker()
    },
    showMonthPicker: function (a) {
        var d = this, c = d.el, b;
        if (d.rendered && !d.disabled) {
            b = d.createMonthPicker();
            if (!b.isVisible()) {
                b.setValue(d.getActive());
                b.setSize(c.getSize());
                b.floatParent = null;
                b.setPosition(-c.getBorderWidth("l"), -c.getBorderWidth("t"));
                if (d.shouldAnimate(a)) {
                    d.runAnimation(false)
                } else {
                    b.show()
                }
            }
        }
        return d
    },
    shouldAnimate: function (a) {
        return Ext.isDefined(a) ? a : !this.disableAnim
    },
    createMonthPicker: function () {
        var b = this, a = b.monthPicker;
        if (!a) {
            b.monthPicker = a = new Ext.picker.Month({
                renderTo: b.el,
                ownerCmp: b,
                floating: true,
                padding: b.padding,
                shadow: false,
                small: b.showToday === false,
                footerButtonUI: b.footerButtonUI,
                listeners: {
                    scope: b,
                    cancelclick: b.onCancelClick,
                    okclick: b.onOkClick,
                    yeardblclick: b.onOkClick,
                    monthdblclick: b.onOkClick
                }
            });
            if (!b.disableAnim) {
                a.el.setStyle("display", "none")
            }
            a.hide();
            b.on("beforehide", b.doHideMonthPicker, b)
        }
        return a
    },
    onOkClick: function (b, e) {
        var d = this, g = e[0], c = e[1], a = new Date(c, g, d.getActive().getDate());
        if (a.getMonth() !== g) {
            a = Ext.Date.getLastDateOfMonth(new Date(c, g, 1))
        }
        d.setValue(a);
        d.hideMonthPicker()
    },
    onCancelClick: function () {
        this.selectedUpdate(this.activeDate);
        this.hideMonthPicker()
    },
    showPrevMonth: function (a) {
        return this.setValue(Ext.Date.add(this.activeDate, Ext.Date.MONTH, -1))
    },
    showNextMonth: function (a) {
        return this.setValue(Ext.Date.add(this.activeDate, Ext.Date.MONTH, 1))
    },
    showPrevYear: function () {
        return this.setValue(Ext.Date.add(this.activeDate, Ext.Date.YEAR, -1))
    },
    showNextYear: function () {
        return this.setValue(Ext.Date.add(this.activeDate, Ext.Date.YEAR, 1))
    },
    handleMouseWheel: function (a) {
        a.stopEvent();
        if (!this.disabled) {
            var b = a.getWheelDelta();
            if (b > 0) {
                this.showPrevMonth()
            } else {
                if (b < 0) {
                    this.showNextMonth()
                }
            }
        }
    },
    handleDateClick: function (d, a) {
        var c = this, b = c.handler;
        d.stopEvent();
        if (!c.disabled && a.dateValue && !Ext.fly(a.parentNode).hasCls(c.disabledCellCls)) {
            c.setValue(new Date(a.dateValue));
            c.fireEvent("select", c, c.value);
            if (b) {
                b.call(c.scope || c, c, c.value)
            }
            c.onSelect()
        }
    },
    onSelect: function () {
        if (this.hideOnSelect) {
            this.hide()
        }
    },
    selectToday: function () {
        var c = this, a = c.todayBtn, b = c.handler;
        if (a && !a.disabled) {
            c.setValue(Ext.Date.clearTime(new Date()));
            c.fireEvent("select", c, c.value);
            if (b) {
                b.call(c.scope || c, c, c.value)
            }
            c.onSelect()
        }
        return c
    },
    selectedUpdate: function (e) {
        var h = this, g = e.getTime(), d = h.cells, b = h.selectedCls, j, i = d.getCount(), a;
        h.eventEl.dom.setAttribute("aria-busy", "true");
        a = h.activeCell;
        if (a) {
            Ext.fly(a).removeCls(b);
            a.setAttribute("aria-selected", false)
        }
        for (j = 0; j < i; j++) {
            a = d.item(j);
            if (h.textNodes[j].dateValue === g) {
                h.activeCell = a.dom;
                h.eventEl.dom.setAttribute("aria-activedescendant", a.dom.id);
                a.dom.setAttribute("aria-selected", true);
                a.addCls(b);
                h.fireEvent("highlightitem", h, a);
                break
            }
        }
        h.eventEl.dom.removeAttribute("aria-busy")
    },
    fullUpdate: function (z) {
        var D = this, d = D.cells.elements, c = D.textNodes, F = D.disabledCellCls, m = Ext.Date, v = 0, C = 0,
            k = +m.clearTime(z, true), y = +m.clearTime(new Date()),
            t = D.minDate ? m.clearTime(D.minDate, true) : Number.NEGATIVE_INFINITY,
            u = D.maxDate ? m.clearTime(D.maxDate, true) : Number.POSITIVE_INFINITY, B = D.disabledDatesRE,
            s = D.disabledDatesText, G = D.disabledDays ? D.disabledDays.join("") : false, A = D.disabledDaysText,
            w = D.format, j = m.getDaysInMonth(z), p = m.getFirstDateOfMonth(z), e = p.getDay() - D.startDay,
            x = m.add(z, m.MONTH, -1), o = D.ariaTitleDateFormat, h, q, a, E, l, n, b, g, r;
        if (e < 0) {
            e += 7
        }
        j += e;
        h = m.getDaysInMonth(x) - e;
        q = new Date(x.getFullYear(), x.getMonth(), h, D.initHour);
        if (D.showToday) {
            E = m.clearTime(new Date());
            a = (E < t || E > u || (B && w && B.test(m.dateFormat(E, w))) || (G && G.indexOf(E.getDay()) !== -1));
            if (!D.disabled) {
                D.todayBtn.setDisabled(a)
            }
        }
        l = function (I, H) {
            var i = d[I], J = [];
            if (!i.hasAttribute("id")) {
                i.setAttribute("id", D.id + "-cell-" + I)
            }
            r = +m.clearTime(q, true);
            i.firstChild.dateValue = r;
            i.setAttribute("aria-label", m.format(q, o));
            i.removeAttribute("aria-describedby");
            i.removeAttribute("data-qtip");
            if (r === y) {
                H += " " + D.todayCls;
                J.push(D.id + "-todayText")
            }
            if (r === k) {
                D.activeCell = i;
                D.eventEl.dom.setAttribute("aria-activedescendant", i.id);
                i.setAttribute("aria-selected", true);
                H += " " + D.selectedCls;
                D.fireEvent("highlightitem", D, i)
            } else {
                i.setAttribute("aria-selected", false)
            }
            if (r < t) {
                H += " " + F;
                J.push(D.id + "-ariaMinText");
                i.setAttribute("data-qtip", D.minText)
            } else {
                if (r > u) {
                    H += " " + F;
                    J.push(D.id + "-ariaMaxText");
                    i.setAttribute("data-qtip", D.maxText)
                } else {
                    if (G && G.indexOf(q.getDay()) !== -1) {
                        i.setAttribute("data-qtip", A);
                        J.push(D.id + "-ariaDisabledDaysText");
                        H += " " + F
                    } else {
                        if (B && w) {
                            g = m.dateFormat(q, w);
                            if (B.test(g)) {
                                i.setAttribute("data-qtip", s.replace("%0", g));
                                J.push(D.id + "-ariaDisabledDatesText");
                                H += " " + F
                            }
                        }
                    }
                }
            }
            if (J.length) {
                i.setAttribute("aria-describedby", J.join(" "))
            }
            i.className = H + " " + D.cellCls
        };
        D.eventEl.dom.setAttribute("aria-busy", "true");
        for (; v < D.numDays; ++v) {
            if (v < e) {
                n = (++h);
                b = D.prevCls
            } else {
                if (v >= j) {
                    n = (++C);
                    b = D.nextCls
                } else {
                    n = v - e + 1;
                    b = D.activeCls
                }
            }
            c[v].innerHTML = n;
            q.setDate(q.getDate() + 1);
            l(v, b)
        }
        D.eventEl.dom.removeAttribute("aria-busy");
        D.monthBtn.setText(Ext.Date.format(z, D.monthYearFormat))
    },
    update: function (a, d) {
        var b = this, c = b.activeDate;
        if (b.rendered) {
            b.activeDate = a;
            if (!d && c && b.el && c.getMonth() === a.getMonth() && c.getFullYear() === a.getFullYear()) {
                b.selectedUpdate(a, c)
            } else {
                b.fullUpdate(a, c)
            }
        }
        return b
    },
    beforeDestroy: function () {
        var a = this;
        if (a.rendered) {
            Ext.destroy(a.keyNav, a.monthPicker, a.monthBtn, a.nextRepeater, a.prevRepeater, a.todayBtn, a.todayElSpan);
            delete a.textNodes;
            delete a.cells.elements
        }
        Ext.Component.prototype.beforeDestroy.call(this)
    },
    privates: {
        finishRenderChildren: function () {
            var a = this;
            Ext.Component.prototype.finishRenderChildren.call(this);
            a.monthBtn.finishRender();
            if (a.showToday) {
                a.todayBtn.finishRender()
            }
        }, getFocusEl: function () {
            return this.eventEl
        }, syncDisabled: function (b) {
            var c = this, a = c.keyNav;
            if (a) {
                a.setDisabled(b);
                c.prevRepeater.setDisabled(b);
                c.nextRepeater.setDisabled(b);
                if (c.todayBtn) {
                    c.todayBtn.setDisabled(b)
                }
            }
        }
    }
}, 0, ["datepicker"], ["component", "box", "datepicker"], {
    component: true,
    box: true,
    datepicker: true
}, ["widget.datepicker"], 0, [Ext.picker, "Date", Ext, "DatePicker"], 0));
(Ext.cmd.derive("Ext.form.field.Date", Ext.form.field.Picker, {
    alternateClassName: ["Ext.form.DateField", "Ext.form.Date"],
    format: "m/d/Y",
    ariaFormat: "M j Y",
    altFormats: "m/d/Y|n/j/Y|n/j/y|m/j/y|n/d/y|m/j/Y|n/d/Y|m-d-y|m-d-Y|m/d|m-d|md|mdy|mdY|d|Y-m-d|n-j|n/j",
    disabledDaysText: "Disabled",
    ariaDisabledDaysText: "This day of week is disabled",
    disabledDatesText: "Disabled",
    ariaDisabledDatesText: "This date cannot be selected",
    minText: "The date in this field must be equal to or after {0}",
    ariaMinText: "The date must be equal to or after {0}",
    maxText: "The date in this field must be equal to or before {0}",
    ariaMaxText: "The date must be equal to or before {0}",
    invalidText: "{0} is not a valid date - it must be in the format {1}",
    formatText: "Expected date format: {0}",
    triggerCls: "x-form-date-trigger",
    showToday: true,
    useStrict: undefined,
    initTime: "12",
    initTimeFormat: "H",
    matchFieldWidth: false,
    startDay: 0,
    valuePublishEvent: ["select", "blur"],
    ariaRole: "combobox",
    initComponent: function () {
        var d = this, b = Ext.isString, c, a;
        c = d.minValue;
        a = d.maxValue;
        if (b(c)) {
            d.minValue = d.parseDate(c)
        }
        if (b(a)) {
            d.maxValue = d.parseDate(a)
        }
        d.disabledDatesRE = null;
        d.initDisabledDays();
        Ext.form.field.Picker.prototype.initComponent.call(this)
    },
    initValue: function () {
        var a = this, b = a.value;
        if (Ext.isString(b)) {
            a.value = a.rawToValue(b)
        }
        Ext.form.field.Picker.prototype.initValue.call(this)
    },
    initDisabledDays: function () {
        if (this.disabledDates) {
            var b = this.disabledDates, a = b.length - 1, g = "(?:", h, e = b.length, c;
            for (h = 0; h < e; h++) {
                c = b[h];
                g += Ext.isDate(c) ? "^" + Ext.String.escapeRegex(c.dateFormat(this.format)) + "$" : c;
                if (h !== a) {
                    g += "|"
                }
            }
            this.disabledDatesRE = new RegExp(g + ")")
        }
    },
    setDisabledDates: function (c) {
        var b = this, a = b.picker;
        b.disabledDates = c;
        b.initDisabledDays();
        if (a) {
            a.setDisabledDates(b.disabledDatesRE)
        }
    },
    setDisabledDays: function (b) {
        var a = this.picker;
        this.disabledDays = b;
        if (a) {
            a.setDisabledDays(b)
        }
    },
    setMinValue: function (d) {
        var b = this, a = b.picker, c = (Ext.isString(d) ? b.parseDate(d) : d);
        b.minValue = c;
        if (a) {
            a.minText = Ext.String.format(b.minText, b.formatDate(b.minValue));
            a.setMinDate(c)
        }
    },
    setMaxValue: function (c) {
        var b = this, a = b.picker, d = (Ext.isString(c) ? b.parseDate(c) : c);
        b.maxValue = d;
        if (a) {
            a.maxText = Ext.String.format(b.maxText, b.formatDate(b.maxValue));
            a.setMaxDate(d)
        }
    },
    getErrors: function (q) {
        q = arguments.length > 0 ? q : this.formatDate(this.processRawValue(this.getRawValue()));
        var j = this, p = Ext.String.format, k = Ext.Date.clearTime,
            o = Ext.form.field.Picker.prototype.getErrors.call(this, q), n = j.disabledDays, d = j.disabledDatesRE,
            m = j.minValue, h = j.maxValue, g = n ? n.length : 0, e = 0, a, b, l, c;
        if (q === null || q.length < 1) {
            return o
        }
        a = q;
        q = j.parseDate(q);
        if (!q) {
            o.push(p(j.invalidText, a, Ext.Date.unescapeFormat(j.format)));
            return o
        }
        c = q.getTime();
        if (m && c < k(m).getTime()) {
            o.push(p(j.minText, j.formatDate(m)))
        }
        if (h && c > k(h).getTime()) {
            o.push(p(j.maxText, j.formatDate(h)))
        }
        if (n) {
            l = q.getDay();
            for (; e < g; e++) {
                if (l === n[e]) {
                    o.push(j.disabledDaysText);
                    break
                }
            }
        }
        b = j.formatDate(q);
        if (d && d.test(b)) {
            o.push(p(j.disabledDatesText, b))
        }
        return o
    },
    rawToValue: function (a) {
        return this.parseDate(a) || a || null
    },
    valueToRaw: function (a) {
        return this.formatDate(this.parseDate(a))
    },
    safeParse: function (g, h) {
        var e = this, c = Ext.Date, a = null, b = e.useStrict, d;
        if (c.formatContainsHourInfo(h)) {
            a = c.parse(g, h, b)
        } else {
            d = c.parse(g + " " + e.initTime, h + " " + e.initTimeFormat, b);
            if (d) {
                a = c.clearTime(d)
            }
        }
        return a
    },
    getSubmitValue: function () {
        var b = this.submitFormat || this.format, a = this.getValue();
        return a ? Ext.Date.format(a, b) : ""
    },
    parseDate: function (e) {
        if (!e || Ext.isDate(e)) {
            return e
        }
        var d = this, h = d.safeParse(e, d.format), b = d.altFormats, g = d.altFormatsArray, c = 0, a;
        if (!h && b) {
            g = g || b.split("|");
            a = g.length;
            for (; c < a && !h; ++c) {
                h = d.safeParse(e, g[c])
            }
        }
        return h
    },
    formatDate: function (a, b) {
        return Ext.isDate(a) ? Ext.Date.dateFormat(a, b || this.format) : a
    },
    createPicker: function () {
        var a = this, b = Ext.String.format;
        return new Ext.picker.Date({
            pickerField: a,
            floating: true,
            preventRefocus: true,
            hidden: true,
            minDate: a.minValue,
            maxDate: a.maxValue,
            disabledDatesRE: a.disabledDatesRE,
            disabledDatesText: a.disabledDatesText,
            ariaDisabledDatesText: a.ariaDisabledDatesText,
            disabledDays: a.disabledDays,
            disabledDaysText: a.disabledDaysText,
            ariaDisabledDaysText: a.ariaDisabledDaysText,
            format: a.format,
            showToday: a.showToday,
            startDay: a.startDay,
            minText: b(a.minText, a.formatDate(a.minValue)),
            ariaMinText: b(a.ariaMinText, a.formatDate(a.minValue, a.ariaFormat)),
            maxText: b(a.maxText, a.formatDate(a.maxValue)),
            ariaMaxText: b(a.ariaMaxText, a.formatDate(a.maxValue, a.ariaFormat)),
            listeners: {scope: a, select: a.onSelect},
            keyNavConfig: {
                esc: function () {
                    a.inputEl.focus();
                    a.collapse()
                }
            }
        })
    },
    onSelect: function (a, c) {
        var b = this;
        b.setValue(c);
        b.fireEvent("select", b, c);
        b.inputEl.focus();
        b.collapse()
    },
    onExpand: function () {
        var a = this.getValue();
        this.picker.setValue(Ext.isDate(a) ? a : new Date())
    },
    onBlur: function (c) {
        var b = this, a = b.rawToValue(b.getRawValue());
        if (Ext.isDate(a)) {
            b.setValue(a)
        }
        Ext.form.field.Picker.prototype.onBlur.call(this, c)
    }
}, 0, ["datefield"], ["component", "box", "field", "textfield", "pickerfield", "datefield"], {
    component: true,
    box: true,
    field: true,
    textfield: true,
    pickerfield: true,
    datefield: true
}, ["widget.datefield"], 0, [Ext.form.field, "Date", Ext.form, "DateField", Ext.form, "Date"], 0));
(Ext.cmd.derive("Ext.form.field.Display", Ext.form.field.Base, {
    alternateClassName: ["Ext.form.DisplayField", "Ext.form.Display"],
    fieldSubTpl: ['<div id="{id}" data-ref="inputEl" tabindex="-1" role="textbox" aria-readonly="true"', ' aria-labelledby="{cmpId}-labelEl" {inputAttrTpl}', '<tpl if="fieldStyle"> style="{fieldStyle}"</tpl>', ' class="{fieldCls} {fieldCls}-{ui}">{value}</div>', {
        compiled: true,
        disableFormats: true
    }],
    ariaRole: undefined,
    focusable: false,
    readOnly: true,
    fieldCls: "x-form-display-field",
    fieldBodyCls: "x-form-display-field-body",
    htmlEncode: false,
    noWrap: false,
    validateOnChange: false,
    initEvents: Ext.emptyFn,
    submitValue: false,
    getValue: function () {
        return this.value
    },
    valueToRaw: function (a) {
        if (a || a === 0 || a === false) {
            return a
        } else {
            return ""
        }
    },
    isDirty: function () {
        return false
    },
    isValid: Ext.returnTrue,
    validate: Ext.returnTrue,
    getRawValue: function () {
        return this.rawValue
    },
    setRawValue: function (b) {
        var a = this;
        b = Ext.valueFrom(b, "");
        a.rawValue = b;
        if (a.rendered) {
            a.inputEl.dom.innerHTML = a.getDisplayValue();
            a.updateLayout()
        }
        return b
    },
    getDisplayValue: function () {
        var a = this, b = this.getRawValue(), c;
        if (a.renderer) {
            c = a.renderer.call(a.scope || a, b, a)
        } else {
            c = a.htmlEncode ? Ext.util.Format.htmlEncode(b) : b
        }
        return c
    },
    getSubTplData: function (b) {
        var a = Ext.form.field.Base.prototype.getSubTplData.apply(this, arguments);
        a.value = this.getDisplayValue();
        return a
    }
}, 0, ["displayfield"], ["component", "box", "field", "displayfield"], {
    component: true,
    box: true,
    field: true,
    displayfield: true
}, ["widget.displayfield"], 0, [Ext.form.field, "Display", Ext.form, "DisplayField", Ext.form, "Display"], 0));
(Ext.cmd.derive("Ext.form.field.FileButton", Ext.button.Button, {
    childEls: ["fileInputEl"],
    inputCls: "x-form-file-input",
    cls: "x-form-file-btn",
    preventDefault: false,
    tabIndex: undefined,
    autoEl: {tag: "div", unselectable: "on"},
    afterTpl: ['<input id="{id}-fileInputEl" data-ref="fileInputEl" class="{childElCls} {inputCls}" ', 'type="file" size="1" name="{inputName}" role="{role}" ', '<tpl if="tabIndex != null">tabindex="{tabIndex}"</tpl>', ">"],
    keyHandlers: null,
    ariaEl: "fileInputEl",
    getAfterMarkup: function (a) {
        return this.getTpl("afterTpl").apply(a)
    },
    getTemplateArgs: function () {
        var a = Ext.button.Button.prototype.getTemplateArgs.call(this);
        a.inputCls = this.inputCls;
        a.inputName = this.inputName;
        a.tabIndex = this.ownerCt.tabIndex;
        return a
    },
    afterRender: function () {
        var a = this;
        Ext.button.Button.prototype.afterRender.apply(this, arguments);
        a.fileInputEl.on({scope: a, change: a.fireChange, focus: a.onFileFocus, blur: a.onFileBlur})
    },
    fireChange: function (a) {
        this.fireEvent("change", this, a, this.fileInputEl.dom.value)
    },
    createFileInput: function (b) {
        var c = this, a = c.fileInputEl = c.el.createChild({
            name: c.inputName,
            id: !b ? c.id + "-fileInputEl" : undefined,
            cls: c.inputCls,
            tag: "input",
            type: "file",
            size: 1,
            role: "button"
        });
        a.dom.setAttribute(Ext.Component.componentIdAttribute, c.id);
        a.on({scope: c, change: c.fireChange, focus: c.onFileFocus, blur: c.onFileBlur})
    },
    onFileFocus: function (b) {
        var a = this.ownerCt;
        if (!this.hasFocus) {
            this.onFocus(b)
        }
        if (a && !a.hasFocus) {
            a.onFocus(b)
        }
    },
    onFileBlur: function (b) {
        var a = this.ownerCt;
        if (this.hasFocus) {
            this.onBlur(b)
        }
        if (a && a.hasFocus) {
            a.onBlur(b)
        }
    },
    reset: function (a) {
        var b = this;
        if (a) {
            b.fileInputEl.destroy()
        }
        b.createFileInput(!a)
    },
    restoreInput: function (a) {
        var b = this;
        b.fileInputEl.destroy();
        a = Ext.get(a);
        b.el.appendChild(a);
        b.fileInputEl = a
    },
    onDisable: function () {
        Ext.button.Button.prototype.onDisable.call(this);
        this.fileInputEl.dom.disabled = true
    },
    onEnable: function () {
        Ext.button.Button.prototype.onEnable.call(this);
        this.fileInputEl.dom.disabled = false
    },
    privates: {
        getFocusEl: function () {
            return this.fileInputEl
        }, getFocusClsEl: function () {
            return this.el
        }
    }
}, 0, ["filebutton"], ["component", "box", "button", "filebutton"], {
    component: true,
    box: true,
    button: true,
    filebutton: true
}, ["widget.filebutton"], 0, [Ext.form.field, "FileButton"], 0));
(Ext.cmd.derive("Ext.form.trigger.Component", Ext.form.trigger.Trigger, {
    cls: "x-form-trigger-cmp",
    onFieldRender: function () {
        var b = this, a = b.component;
        Ext.form.trigger.Trigger.prototype.onFieldRender.call(this);
        if (!a.isComponent && !a.isWidget) {
            a = Ext.widget(a)
        }
        b.component = a;
        a.render(b.el)
    },
    destroy: function () {
        var a = this.component;
        if (a.isComponent || a.isWidget) {
            a.destroy()
        }
        this.component = null;
        Ext.form.trigger.Trigger.prototype.destroy.call(this)
    }
}, 0, 0, 0, 0, ["trigger.component"], 0, [Ext.form.trigger, "Component"], 0));
(Ext.cmd.derive("Ext.form.field.File", Ext.form.field.Text, {
    alternateClassName: ["Ext.form.FileUploadField", "Ext.ux.form.FileUploadField", "Ext.form.File"],
    needArrowKeys: false,
    triggers: {filebutton: {type: "component", hideOnReadOnly: false, preventMouseDown: false}},
    buttonText: "Browse...",
    buttonOnly: false,
    buttonMargin: 3,
    clearOnSubmit: true,
    extraFieldBodyCls: "x-form-file-wrap",
    inputCls: "x-form-text-file",
    readOnly: true,
    editable: false,
    submitValue: false,
    triggerNoEditCls: "",
    childEls: ["browseButtonWrap"],
    applyTriggers: function (a) {
        var b = this, c = (a || {}).filebutton;
        if (c) {
            c.component = Ext.apply({
                xtype: "filebutton",
                ownerCt: b,
                id: b.id + "-button",
                ui: b.ui,
                disabled: b.disabled,
                text: b.buttonText,
                style: b.buttonOnly ? "" : b.getButtonMarginProp() + b.buttonMargin + "px",
                inputName: b.getName(),
                listeners: {scope: b, change: b.onFileChange}
            }, b.buttonConfig);
            return Ext.form.field.Text.prototype.applyTriggers.call(this, a)
        }
    },
    getSubTplData: function (a) {
        var b = Ext.form.field.Text.prototype.getSubTplData.call(this, a);
        b.tabIdx = -1;
        return b
    },
    onRender: function () {
        var d = this, e, c, a, b;
        (arguments.callee.$previous || Ext.form.field.Text.prototype.onRender).apply(this, arguments);
        e = d.inputEl;
        e.dom.name = "";
        e.on("focus", d.focus, d);
        b = d.getTrigger("filebutton");
        c = d.button = b.component;
        d.fileInputEl = c.fileInputEl;
        a = c.el;
        if (d.buttonOnly) {
            d.inputWrap.setDisplayed(false);
            d.shrinkWrap = 3
        }
        b.el.setWidth(a.getWidth() + a.getMargin("lr"));
        if (Ext.isIE) {
            d.button.getEl().repaint()
        }
    },
    getTriggerMarkup: function () {
        return '<td id="' + this.id + '-browseButtonWrap" data-ref="browseButtonWrap" role="presentation"></td>'
    },
    onFileChange: function (a, c, b) {
        this.duringFileSelect = true;
        Ext.form.field.File.superclass.setValue.call(this, b);
        delete this.duringFileSelect
    },
    didValueChange: function () {
        return !!this.duringFileSelect
    },
    setValue: Ext.emptyFn,
    reset: function () {
        var b = this, a = b.clearOnSubmit;
        if (b.rendered) {
            b.button.reset(a);
            b.fileInputEl = b.button.fileInputEl;
            if (a) {
                b.inputEl.dom.value = "";
                Ext.form.field.File.superclass.setValue.call(this, null)
            }
        }
        Ext.form.field.Text.prototype.reset.call(this)
    },
    onShow: function () {
        Ext.form.field.Text.prototype.onShow.call(this);
        this.button.updateLayout()
    },
    onDisable: function () {
        Ext.form.field.Text.prototype.onDisable.call(this);
        this.button.disable()
    },
    onEnable: function () {
        Ext.form.field.Text.prototype.onEnable.call(this);
        this.button.enable()
    },
    isFileUpload: Ext.returnTrue,
    extractFileInput: function () {
        var b = this, a;
        if (b.rendered) {
            a = b.button.fileInputEl.dom;
            b.reset()
        } else {
            a = document.createElement("input");
            a.type = "file";
            a.className = "x-hidden-display";
            a.name = b.getName()
        }
        return a
    },
    restoreInput: function (b) {
        if (this.rendered) {
            var a = this.button;
            a.restoreInput(b);
            this.fileInputEl = a.fileInputEl
        }
    },
    onDestroy: function () {
        this.fileInputEl = this.button = null;
        Ext.form.field.Text.prototype.onDestroy.call(this)
    },
    getButtonMarginProp: function () {
        return "margin-left:"
    },
    privates: {
        getFocusEl: function () {
            return this.button
        }, getFocusClsEl: Ext.privateFn
    }
}, 0, ["fileuploadfield", "filefield"], ["component", "box", "field", "textfield", "filefield", "fileuploadfield"], {
    component: true,
    box: true,
    field: true,
    textfield: true,
    filefield: true,
    fileuploadfield: true
}, ["widget.filefield", "widget.fileuploadfield"], 0, [Ext.form.field, "File", Ext.form, "FileUploadField", Ext.ux.form, "FileUploadField", Ext.form, "File"], 0));
(Ext.cmd.derive("Ext.form.field.Hidden", Ext.form.field.Base, {
    alternateClassName: "Ext.form.Hidden",
    focusable: false,
    inputType: "hidden",
    isTextInput: false,
    hideLabel: true,
    hidden: true,
    ariaRole: "presentation",
    initComponent: function () {
        this.formItemCls += "-hidden";
        Ext.form.field.Base.prototype.initComponent.call(this)
    },
    isEqual: function (b, a) {
        return this.isEqualAsString(b, a)
    },
    initEvents: Ext.emptyFn,
    setSize: Ext.emptyFn,
    setWidth: Ext.emptyFn,
    setHeight: Ext.emptyFn,
    setPosition: Ext.emptyFn,
    setPagePosition: Ext.emptyFn,
    markInvalid: Ext.emptyFn,
    clearInvalid: Ext.emptyFn
}, 0, ["hiddenfield", "hidden"], ["component", "box", "field", "hiddenfield", "hidden"], {
    component: true,
    box: true,
    field: true,
    hiddenfield: true,
    hidden: true
}, ["widget.hidden", "widget.hiddenfield"], 0, [Ext.form.field, "Hidden", Ext.form, "Hidden"], 0));
(Ext.cmd.derive("Ext.tip.Tip", Ext.panel.Panel, {
    alternateClassName: "Ext.Tip",
    minWidth: 40,
    maxWidth: 500,
    shadow: "sides",
    defaultAlign: "tl-bl?",
    constrainPosition: true,
    autoRender: true,
    hidden: true,
    baseCls: "x-tip",
    focusOnToFront: false,
    maskOnDisable: false,
    closeAction: "hide",
    alwaysFramed: true,
    frameHeader: false,
    initComponent: function () {
        var a = this;
        a.floating = Ext.apply({}, {shadow: a.shadow, constrain: a.constrainPosition}, a.self.prototype.floating);
        Ext.panel.Panel.prototype.initComponent.apply(this, arguments);
        a.constrain = a.constrain || a.constrainPosition
    },
    showAt: function (b) {
        var a = this;
        Ext.panel.Panel.prototype.showAt.apply(this, arguments);
        if (a.isVisible()) {
            a.setPagePosition(b[0], b[1]);
            if (a.constrainPosition || a.constrain) {
                a.doConstrain()
            }
            a.toFront(true)
        }
    },
    privates: {
        initDraggable: function () {
            var a = this;
            a.draggable = {el: a.getDragEl(), delegate: a.header.el, constrain: a, constrainTo: a.el.dom.parentNode};
            Ext.Component.prototype.initDraggable.call(a)
        }
    },
    ghost: undefined,
    unghost: undefined
}, 0, ["tip"], ["component", "box", "container", "panel", "tip"], {
    component: true,
    box: true,
    container: true,
    panel: true,
    tip: true
}, ["widget.tip"], 0, [Ext.tip, "Tip", Ext, "Tip"], 0));
(Ext.cmd.derive("Ext.tip.ToolTip", Ext.tip.Tip, {
    alternateClassName: "Ext.ToolTip",
    autoHide: true,
    showDelay: 500,
    hideDelay: 200,
    dismissDelay: 5000,
    trackMouse: false,
    anchorToTarget: true,
    anchorOffset: 0,
    targetCounter: 0,
    quickShowInterval: 250,
    hideAction: "hide",
    fadeOutDuration: 1000,
    ariaRole: "tooltip",
    initComponent: function () {
        var a = this;
        Ext.tip.Tip.prototype.initComponent.apply(this, arguments);
        a.lastActive = new Date();
        a.setTarget(a.target);
        a.origAnchor = a.anchor
    },
    onRender: function (b, a) {
        var c = this;
        Ext.tip.Tip.prototype.onRender.apply(this, arguments);
        c.anchorCls = "x-tip-anchor-" + c.getAnchorPosition();
        c.anchorEl = c.el.createChild({role: "presentation", cls: "x-tip-anchor " + c.anchorCls})
    },
    setTarget: function (d) {
        var b = this, a = Ext.get(d), c;
        if (b.target) {
            c = Ext.get(b.target);
            if (Ext.supports.Touch) {
                b.mun(c, "tap", b.onTargetOver, b)
            } else {
                b.mun(c, {mouseover: b.onTargetOver, mouseout: b.onTargetOut, mousemove: b.onMouseMove, scope: b})
            }
        }
        b.target = a;
        if (a) {
            if (Ext.supports.Touch) {
                b.mon(a, {tap: b.onTargetOver, scope: b})
            } else {
                b.mon(a, {mouseover: b.onTargetOver, mouseout: b.onTargetOut, mousemove: b.onMouseMove, scope: b})
            }
        }
        if (b.anchor) {
            b.anchorTarget = b.target
        }
    },
    onMouseMove: function (d) {
        var b = this, a, c;
        if (!b.target || b.target.contains(d.target)) {
            a = b.delegate ? d.getTarget(b.delegate) : (b.triggerElement = true);
            if (a) {
                b.targetXY = d.getXY();
                if (a === b.triggerElement) {
                    if (!b.hidden && b.trackMouse) {
                        c = b.getTargetXY();
                        if (b.constrainPosition) {
                            c = b.el.adjustForConstraints(c, b.el.parent())
                        }
                        b.setPagePosition(c)
                    }
                } else {
                    b.hide();
                    b.lastActive = new Date(0);
                    b.onTargetOver(d)
                }
            } else {
                if ((!b.closable && b.isVisible()) && b.autoHide !== false) {
                    b.delayHide()
                }
            }
        }
    },
    getTargetXY: function () {
        var j = this, d, c, n, a, i, l, e, m, k, b, h, g;
        if (j.delegate) {
            j.anchorTarget = j.triggerElement
        }
        if (j.anchor) {
            j.targetCounter++;
            c = j.getOffsets();
            n = (j.anchorToTarget && !j.trackMouse) ? j.getAlignToXY(j.anchorTarget, j.getAnchorAlign()) : j.targetXY;
            a = Ext.Element.getViewportWidth() - 5;
            i = Ext.Element.getViewportHeight() - 5;
            l = document.documentElement;
            e = document.body;
            m = (l.scrollLeft || e.scrollLeft || 0) + 5;
            k = (l.scrollTop || e.scrollTop || 0) + 5;
            b = [n[0] + c[0], n[1] + c[1]];
            h = j.getSize();
            g = j.constrainPosition;
            j.anchorEl.removeCls(j.anchorCls);
            if (j.targetCounter < 2 && g) {
                if (b[0] < m) {
                    if (j.anchorToTarget) {
                        j.defaultAlign = "l-r";
                        if (j.mouseOffset) {
                            j.mouseOffset[0] *= -1
                        }
                    }
                    j.anchor = "left";
                    return j.getTargetXY()
                }
                if (b[0] + h.width > a) {
                    if (j.anchorToTarget) {
                        j.defaultAlign = "r-l";
                        if (j.mouseOffset) {
                            j.mouseOffset[0] *= -1
                        }
                    }
                    j.anchor = "right";
                    return j.getTargetXY()
                }
                if (b[1] < k) {
                    if (j.anchorToTarget) {
                        j.defaultAlign = "t-b";
                        if (j.mouseOffset) {
                            j.mouseOffset[1] *= -1
                        }
                    }
                    j.anchor = "top";
                    return j.getTargetXY()
                }
                if (b[1] + h.height > i) {
                    if (j.anchorToTarget) {
                        j.defaultAlign = "b-t";
                        if (j.mouseOffset) {
                            j.mouseOffset[1] *= -1
                        }
                    }
                    j.anchor = "bottom";
                    return j.getTargetXY()
                }
            }
            j.anchorCls = "x-tip-anchor-" + j.getAnchorPosition();
            j.anchorEl.addCls(j.anchorCls);
            j.targetCounter = 0;
            return b
        } else {
            d = j.getMouseOffset();
            return (j.targetXY) ? [j.targetXY[0] + d[0], j.targetXY[1] + d[1]] : d
        }
    },
    calculateConstrainedPosition: function (b) {
        var c = this, e, a, d;
        if (!b && c.isContainedFloater()) {
            e = c.isVisible();
            if (!e) {
                c.el.show()
            }
            a = c.getTargetXY();
            if (!e) {
                c.el.hide()
            }
            d = c.floatParent.getTargetEl().getViewRegion();
            a[0] -= d.left;
            a[1] -= d.top
        } else {
            a = c.callOverridden(arguments)
        }
        return a
    },
    getMouseOffset: function () {
        var a = this, b = a.anchor ? [0, 0] : [15, 18];
        if (a.mouseOffset) {
            b[0] += a.mouseOffset[0];
            b[1] += a.mouseOffset[1]
        }
        return b
    },
    fadeOut: function () {
        var a = this;
        a.el.fadeOut({
            duration: a.fadeOutDuration, callback: function () {
                a.hide();
                a.el.setOpacity("")
            }
        })
    },
    getAnchorPosition: function () {
        var b = this, a;
        if (b.anchor) {
            b.tipAnchor = b.anchor.charAt(0)
        } else {
            a = b.defaultAlign.match(/^([a-z]+)-([a-z]+)(\\?)?$/);
            b.tipAnchor = a[1].charAt(0)
        }
        switch (b.tipAnchor) {
            case"t":
                return "top";
            case"b":
                return "bottom";
            case"r":
                return "right"
        }
        return "left"
    },
    getAnchorAlign: function () {
        switch (this.anchor) {
            case"top":
                return "tl-bl";
            case"left":
                return "tl-tr";
            case"right":
                return "tr-tl";
            default:
                return "bl-tl"
        }
    },
    getOffsets: function () {
        var c = this, d, b, a = c.getAnchorPosition().charAt(0);
        if (c.anchorToTarget && !c.trackMouse) {
            switch (a) {
                case"t":
                    b = [0, 9];
                    break;
                case"b":
                    b = [0, -13];
                    break;
                case"r":
                    b = [-13, 0];
                    break;
                default:
                    b = [9, 0];
                    break
            }
        } else {
            switch (a) {
                case"t":
                    b = [-15 - c.anchorOffset, 30];
                    break;
                case"b":
                    b = [-19 - c.anchorOffset, -13 - c.el.dom.offsetHeight];
                    break;
                case"r":
                    b = [-15 - c.el.dom.offsetWidth, -13 - c.anchorOffset];
                    break;
                default:
                    b = [25, -13 - c.anchorOffset];
                    break
            }
        }
        d = c.getMouseOffset();
        b[0] += d[0];
        b[1] += d[1];
        return b
    },
    onTargetOver: function (d) {
        var c = this, b = c.delegate, a;
        if (c.disabled || d.within(c.target.dom, true)) {
            return
        }
        a = b ? d.getTarget(b) : true;
        if (a) {
            c.triggerElement = a;
            c.triggerEvent = d;
            c.clearTimer("hide");
            c.targetXY = d.getXY();
            c.delayShow()
        }
    },
    delayShow: function (c) {
        var a = this, b = a.el && (c === false || !a.trackMouse) && a.getTargetXY();
        if (a.hidden && !a.showTimer) {
            if (Ext.Date.getElapsed(a.lastActive) < a.quickShowInterval) {
                a.show()
            } else {
                a.showTimer = Ext.defer(a.showFromDelay, a.showDelay, a, [b])
            }
        } else {
            if (!a.hidden && a.autoHide !== false) {
                a.show(b)
            }
        }
    },
    showFromDelay: function (b) {
        var a = this;
        if (a.disabled) {
            return
        }
        a.fromDelayShow = true;
        a.show(b);
        delete a.fromDelayShow
    },
    onShowVeto: function () {
        Ext.tip.Tip.prototype.onShowVeto.call(this);
        delete this.triggerElement;
        this.clearTimer("show")
    },
    onTargetOut: function (d) {
        var b = this, a = b.triggerElement, c = a === true ? b.target : a;
        if (b.disabled || !a || d.within(c, true)) {
            return
        }
        if (b.showTimer) {
            b.clearTimer("show");
            b.triggerElement = null
        }
        if (b.autoHide !== false) {
            b.delayHide()
        }
    },
    delayHide: function () {
        var a = this;
        if (!a.hidden && !a.hideTimer) {
            a.hideTimer = Ext.defer(a[a.hideAction], a.hideDelay, a)
        }
    },
    hide: function () {
        var a = this;
        a.clearTimer("dismiss");
        a.lastActive = new Date();
        if (a.anchorEl) {
            a.anchorEl.hide()
        }
        Ext.tip.Tip.prototype.hide.apply(this, arguments);
        delete a.triggerElement
    },
    show: function (b) {
        var a = this;
        Ext.tip.Tip.prototype.show.call(this);
        if (this.hidden === false) {
            if (a.anchor) {
                a.anchor = a.origAnchor
            }
            if (!a.calledFromShowAt) {
                a.showAt(b || a.getTargetXY())
            }
        }
    },
    showAt: function (b) {
        var a = this;
        a.lastActive = new Date();
        a.clearTimers();
        a.calledFromShowAt = true;
        if (!a.isVisible()) {
            Ext.tip.Tip.prototype.showAt.apply(this, arguments)
        }
        if (a.isVisible()) {
            a.setPagePosition(b[0], b[1]);
            if (a.constrainPosition || a.constrain) {
                a.doConstrain()
            }
            a.toFront(true);
            a.el.syncUnderlays();
            if (a.dismissDelay && a.autoHide !== false) {
                a.dismissTimer = Ext.defer(a.hide, a.dismissDelay, a)
            }
        }
        delete a.calledFromShowAt
    },
    syncAnchor: function () {
        var c = this, a, b, d;
        switch (c.tipAnchor.charAt(0)) {
            case"t":
                a = "b";
                b = "tl";
                d = [20 + c.anchorOffset, 1];
                break;
            case"r":
                a = "l";
                b = "tr";
                d = [-1, 12 + c.anchorOffset];
                break;
            case"b":
                a = "t";
                b = "bl";
                d = [20 + c.anchorOffset, -1];
                break;
            default:
                a = "r";
                b = "tl";
                d = [1, 12 + c.anchorOffset];
                break
        }
        c.anchorEl.alignTo(c.el, a + "-" + b, d);
        c.anchorEl.setStyle("z-index", parseInt(c.el.getZIndex(), 10) || 0 + 1).setVisibilityMode(Ext.Element.DISPLAY)
    },
    afterSetPosition: function (a, c) {
        var b = this;
        Ext.tip.Tip.prototype.afterSetPosition.apply(this, arguments);
        if (b.anchor) {
            b.syncAnchor();
            if (!b.anchorEl.isVisible()) {
                b.anchorEl.show()
            }
        } else {
            b.anchorEl.hide()
        }
    },
    _timerNames: {},
    clearTimer: function (a) {
        var b = this, d = b._timerNames, c = d[a] || (d[a] = a + "Timer"), e = b[c];
        if (e) {
            clearTimeout(e);
            b[c] = null
        }
    },
    clearTimers: function () {
        var a = this;
        a.clearTimer("show");
        a.clearTimer("dismiss");
        a.clearTimer("hide")
    },
    onShow: function () {
        var a = this;
        Ext.tip.Tip.prototype.onShow.call(this);
        a.mon(Ext.getDoc(), "mousedown", a.onDocMouseDown, a)
    },
    onHide: function () {
        var a = this;
        Ext.tip.Tip.prototype.onHide.call(this);
        a.mun(Ext.getDoc(), "mousedown", a.onDocMouseDown, a)
    },
    onDocMouseDown: function (b) {
        var a = this;
        if (!a.closable && !b.within(a.el.dom)) {
            a.disable();
            Ext.defer(a.doEnable, 100, a)
        }
    },
    doEnable: function () {
        if (!this.destroyed) {
            this.enable()
        }
    },
    onDisable: function () {
        Ext.tip.Tip.prototype.onDisable.call(this);
        this.clearTimers();
        this.hide()
    },
    beforeDestroy: function () {
        var a = this;
        a.clearTimers();
        Ext.destroy(a.anchorEl);
        delete a.anchorEl;
        delete a.target;
        delete a.anchorTarget;
        delete a.triggerElement;
        Ext.tip.Tip.prototype.beforeDestroy.call(this)
    },
    onDestroy: function () {
        Ext.getDoc().un("mousedown", this.onDocMouseDown, this);
        Ext.tip.Tip.prototype.onDestroy.call(this)
    }
}, 0, ["tooltip"], ["component", "box", "container", "panel", "tip", "tooltip"], {
    component: true,
    box: true,
    container: true,
    panel: true,
    tip: true,
    tooltip: true
}, ["widget.tooltip"], 0, [Ext.tip, "ToolTip", Ext, "ToolTip"], 0));
(Ext.cmd.derive("Ext.tip.QuickTip", Ext.tip.ToolTip, {
    alternateClassName: "Ext.QuickTip",
    interceptTitles: false,
    title: "&#160;",
    tagConfig: {
        namespace: "data-",
        attribute: "qtip",
        width: "qwidth",
        target: "target",
        title: "qtitle",
        hide: "hide",
        cls: "qclass",
        align: "qalign",
        anchor: "anchor",
        showDelay: "qshowDelay",
        hideAction: "hideAction",
        anchorTarget: "anchorTarget"
    },
    isQuickTip: true,
    shrinkWrapDock: true,
    initComponent: function () {
        var a = this;
        a.target = a.target || Ext.getDoc();
        a.targets = a.targets || {};
        Ext.tip.ToolTip.prototype.initComponent.call(this)
    },
    setTagConfig: function (a) {
        this.tagConfig = Ext.apply({}, a);
        delete this.tagConfig.attr
    },
    text: null,
    register: function (c) {
        var h = Ext.isArray(c) ? c : arguments, d = 0, a = h.length, g, b, e;
        for (; d < a; d++) {
            c = h[d];
            g = c.target;
            if (g) {
                if (Ext.isArray(g)) {
                    for (b = 0, e = g.length; b < e; b++) {
                        this.targets[Ext.id(g[b])] = c
                    }
                } else {
                    this.targets[Ext.id(g)] = c
                }
            }
        }
    },
    unregister: function (a) {
        delete this.targets[Ext.id(a)]
    },
    cancelShow: function (a) {
        var b = this, c = b.activeTarget;
        a = Ext.get(a).dom;
        if (b.isVisible()) {
            if (c && c.el === a) {
                b.hide()
            }
        } else {
            if (c && c.el === a) {
                b.clearTimer("show")
            }
        }
    },
    getTipCfg: function (e, d) {
        var c = e.title, b = this.tagConfig, a = b.attr || (b.attr = b.namespace + b.attribute), g;
        if (this.interceptTitles && c && Ext.isString(c)) {
            e.setAttribute(a, c);
            e.removeAttribute("title");
            return {text: c}
        } else {
            e = Ext.fly(e).findParent(function (h) {
                return (g = h.getAttribute(a))
            });
            if (e) {
                return {target: e, text: g}
            }
        }
    },
    onTargetOver: function (a) {
        this.doTargetOver(a.getTarget(this.delegate), null, a)
    },
    doTargetOver: function (j, q, b) {
        var k = this, a, e, g, c, i, l, d, n, h, p, m, o;
        if (k.disabled) {
            return
        }
        if (typeof j === "string") {
            j = Ext.getDom(j)
        }
        k.targetXY = q || (b ? b.getXY() : Ext.fly(j).getXY());
        if (!j || j.nodeType !== 1 || j === document.documentElement || j === document.body) {
            return
        }
        if (k.activeTarget && ((j === k.activeTarget.el) || Ext.fly(k.activeTarget.el).contains(j))) {
            if (k.targetTextEmpty()) {
                k.onShowVeto();
                delete k.activeTarget
            } else {
                k.clearTimer("hide");
                k.show()
            }
            return
        }
        if (j) {
            h = k.targets;
            for (o in h) {
                if (h.hasOwnProperty(o)) {
                    m = h[o];
                    p = Ext.fly(m.target);
                    if (p && (p.dom === j || p.contains(j))) {
                        c = p.dom;
                        break
                    }
                }
            }
            if (c) {
                k.activeTarget = k.targets[c.id];
                k.activeTarget.el = j;
                k.anchor = k.activeTarget.anchor;
                if (k.anchor) {
                    k.anchorTarget = j
                }
                a = parseInt(k.activeTarget.showDelay, 10);
                if (a) {
                    g = k.showDelay;
                    k.showDelay = a
                }
                k.delayShow();
                if (a) {
                    k.showDelay = g
                }
                if (!(e = k.activeTarget.hideAction)) {
                    delete k.hideAction
                } else {
                    k.hideAction = e
                }
                return
            }
        }
        c = Ext.fly(j, "_quicktip-target");
        i = k.tagConfig;
        l = i.namespace;
        d = k.getTipCfg(j, b);
        if (d) {
            if (d.target) {
                j = d.target;
                c = Ext.fly(j, "_quicktip-target")
            }
            n = c.getAttribute(l + i.hide);
            k.activeTarget = {
                el: j,
                text: d.text,
                width: +c.getAttribute(l + i.width) || null,
                autoHide: n !== "user" && n !== "false",
                title: c.getAttribute(l + i.title),
                cls: c.getAttribute(l + i.cls),
                align: c.getAttribute(l + i.align),
                showDelay: parseInt(c.getAttribute(l + i.showDelay) || 0, 10),
                hideAction: c.getAttribute(l + i.hideAction),
                anchorTarget: c.getAttribute(l + i.anchorTarget)
            };
            if (!k.initialConfig.hasOwnProperty("anchor")) {
                k.anchor = c.getAttribute(l + i.anchor)
            }
            if (k.anchor && !k.initialConfig.hasOwnProperty("anchorTarget")) {
                k.anchorTarget = k.activeTarget.anchorTarget || j
            }
            a = parseInt(k.activeTarget.showDelay, 10);
            if (a) {
                g = k.showDelay;
                k.showDelay = a
            }
            k.delayShow();
            if (a) {
                k.showDelay = g
            }
        }
    },
    onTargetOut: function (g) {
        var c = this, d = c.activeTarget, a, b;
        if (d && g.within(c.activeTarget.el) && !c.getTipCfg(g.getTarget(), g)) {
            return
        }
        c.clearTimer("show");
        delete c.activeTarget;
        if (c.autoHide !== false) {
            a = d && parseInt(d.hideDelay, 10);
            if (a) {
                b = c.hideDelay;
                c.hideDelay = a
            }
            c.delayHide();
            if (a) {
                c.hideDelay = b
            }
        }
    },
    targetTextEmpty: function () {
        var c = this, d = c.activeTarget, a = c.tagConfig, b, e;
        if (d) {
            b = d.el;
            if (b) {
                e = b.getAttribute(a.namespace + a.attribute);
                if (!e && !c.targets[Ext.id(d.target)]) {
                    return true
                }
            }
        }
        return false
    },
    show: function () {
        var b = this, a = b.fromDelayShow;
        if (a && b.targetTextEmpty()) {
            b.onShowVeto();
            delete b.activeTarget;
            return
        }
        Ext.tip.ToolTip.prototype.show.apply(this, arguments)
    },
    showAt: function (e) {
        var c = this, d = c.activeTarget, g = c.header, b, a;
        if (d) {
            if (!c.rendered) {
                c.render(Ext.getBody());
                c.activeTarget = d
            }
            c.suspendLayouts();
            if (d.title) {
                c.setTitle(d.title);
                g.show()
            } else {
                if (g) {
                    g.hide()
                }
            }
            c.update(d.text);
            c.autoHide = d.autoHide;
            b = d.dismissDelay;
            c.dismissDelay = Ext.isNumber(b) ? b : c.dismissDelay;
            if (d.mouseOffset) {
                e[0] += d.mouseOffset[0];
                e[1] += d.mouseOffset[1]
            }
            a = c.lastCls;
            if (a) {
                c.removeCls(a);
                delete c.lastCls
            }
            a = d.cls;
            if (a) {
                c.addCls(a);
                c.lastCls = a
            }
            c.setWidth(d.width);
            if (c.anchor) {
                c.constrainPosition = false
            } else {
                if (d.align) {
                    e = c.getAlignToXY(d.el, d.align);
                    c.constrainPosition = false
                } else {
                    c.constrainPosition = true
                }
            }
            c.resumeLayouts(true)
        }
        Ext.tip.ToolTip.prototype.showAt.call(this, e)
    },
    showByTarget: function (g) {
        var c = this, e, b, d, a, h;
        e = c.targets[g.id];
        if (e) {
            c.activeTarget = e;
            c.activeTarget.el = Ext.get(g).dom;
            c.anchor = c.activeTarget.anchor;
            b = g.getSize();
            d = g.getXY();
            c.showAt([d[0], d[1] + b.height])
        }
    },
    hide: function () {
        delete this.activeTarget;
        Ext.tip.ToolTip.prototype.hide.call(this)
    }
}, 0, ["quicktip"], ["component", "box", "container", "panel", "tip", "tooltip", "quicktip"], {
    component: true,
    box: true,
    container: true,
    panel: true,
    tip: true,
    tooltip: true,
    quicktip: true
}, ["widget.quicktip"], 0, [Ext.tip, "QuickTip", Ext, "QuickTip"], 0));
(Ext.cmd.derive("Ext.tip.QuickTipManager", Ext.Base, {
    singleton: true, alternateClassName: "Ext.QuickTips", disabled: false, init: function (e, b) {
        var d = this;
        if (!d.tip) {
            if (!Ext.isReady) {
                Ext.onInternalReady(function () {
                    Ext.tip.QuickTipManager.init(e, b)
                });
                return false
            }
            var a = Ext.apply({disabled: d.disabled, id: "ext-quicktips-tip"}, b), c = a.className, g = a.xtype;
            if (c) {
                delete a.className
            } else {
                if (g) {
                    c = "widget." + g;
                    delete a.xtype
                }
            }
            if (e !== false) {
                a.renderTo = document.body
            }
            d.tip = Ext.create(c || "Ext.tip.QuickTip", a);
            Ext.quickTipsActive = true
        }
    }, destroy: function () {
        Ext.destroy(this.tip);
        this.tip = undefined
    }, ddDisable: function () {
        var a = this, b = a.tip;
        if (b && !a.disabled) {
            b.disable()
        }
    }, ddEnable: function () {
        var a = this, b = a.tip;
        if (b && !a.disabled) {
            b.enable()
        }
    }, enable: function () {
        var a = this, b = a.tip;
        if (b) {
            b.enable()
        }
        a.disabled = false
    }, disable: function () {
        var a = this, b = a.tip;
        if (b) {
            b.disable()
        }
        a.disabled = true
    }, isEnabled: function () {
        var a = this.tip;
        return a !== undefined && !a.disabled
    }, getQuickTip: function () {
        return this.tip
    }, register: function () {
        var a = this.tip;
        a.register.apply(a, arguments)
    }, unregister: function () {
        var a = this.tip;
        a.unregister.apply(a, arguments)
    }, tips: function () {
        var a = this.tip;
        a.register.apply(a, arguments)
    }
}, 0, 0, 0, 0, 0, 0, [Ext.tip, "QuickTipManager", Ext, "QuickTips"], 0));
(Ext.cmd.derive("Ext.picker.Color", Ext.Component, {
    alternateClassName: "Ext.ColorPalette",
    focusable: true,
    componentCls: "x-color-picker",
    selectedCls: "x-color-picker-selected",
    itemCls: "x-color-picker-item",
    value: null,
    clickEvent: "click",
    allowReselect: false,
    colors: ["000000", "993300", "333300", "003300", "003366", "000080", "333399", "333333", "800000", "FF6600", "808000", "008000", "008080", "0000FF", "666699", "808080", "FF0000", "FF9900", "99CC00", "339966", "33CCCC", "3366FF", "800080", "969696", "FF00FF", "FFCC00", "FFFF00", "00FF00", "00FFFF", "00CCFF", "993366", "C0C0C0", "FF99CC", "FFCC99", "FFFF99", "CCFFCC", "CCFFFF", "99CCFF", "CC99FF", "FFFFFF"],
    colorRe: /(?:^|\\s)color-(.{6})(?:\\s|$)/,
    renderTpl: ['<tpl for="colors">', '<a href="#" role="button" class="color-{.} {parent.itemCls}" hidefocus="on">', '<span class="{parent.itemCls}-inner" style="background:#{.}">&#160;</span>', "</a>", "</tpl>"],
    initComponent: function () {
        var a = this;
        Ext.Component.prototype.initComponent.apply(this, arguments);
        if (a.handler) {
            a.on("select", a.handler, a.scope, true)
        }
    },
    initRenderData: function () {
        var a = this;
        return Ext.apply(Ext.Component.prototype.initRenderData.call(this), {itemCls: a.itemCls, colors: a.colors})
    },
    onRender: function () {
        var b = this, a = b.clickEvent;
        Ext.Component.prototype.onRender.apply(this, arguments);
        b.mon(b.el, a, b.handleClick, b, {delegate: "a"});
        if (a !== "click") {
            b.mon(b.el, "click", Ext.emptyFn, b, {delegate: "a", stopEvent: true})
        }
    },
    afterRender: function () {
        var a = this, b;
        Ext.Component.prototype.afterRender.apply(this, arguments);
        if (a.value) {
            b = a.value;
            a.value = null;
            a.select(b, true)
        }
    },
    handleClick: function (c) {
        var b = this, a;
        c.stopEvent();
        if (!b.disabled) {
            a = c.currentTarget.className.match(b.colorRe)[1];
            b.select(a.toUpperCase())
        }
    },
    select: function (b, a) {
        var e = this, h = e.selectedCls, g = e.value, c, d;
        b = b.replace("#", "");
        if (!e.rendered) {
            e.value = b;
            return
        }
        if (b !== g || e.allowReselect) {
            c = e.el;
            if (e.value) {
                d = c.down("a.color-" + g, true);
                Ext.fly(d).removeCls(h)
            }
            d = c.down("a.color-" + b, true);
            Ext.fly(d).addCls(h);
            e.value = b;
            if (a !== true) {
                e.fireEvent("select", e, b)
            }
        }
    },
    clear: function () {
        var b = this, c = b.value, a;
        if (c && b.rendered) {
            a = b.el.down("a.color-" + c, true);
            Ext.fly(a).removeCls(b.selectedCls)
        }
        b.value = null
    },
    getValue: function () {
        return this.value || null
    }
}, 0, ["colorpicker"], ["component", "box", "colorpicker"], {
    component: true,
    box: true,
    colorpicker: true
}, ["widget.colorpicker"], 0, [Ext.picker, "Color", Ext, "ColorPalette"], 0));
(Ext.cmd.derive("Ext.layout.component.field.HtmlEditor", Ext.layout.component.field.FieldContainer, {
    type: "htmleditor", naturalHeight: 150, naturalWidth: 300, beginLayout: function (b) {
        var a = this.owner, c;
        if (Ext.isGecko) {
            c = a.textareaEl.dom;
            this.lastValue = c.value;
            c.value = ""
        }
        Ext.layout.component.field.FieldContainer.prototype.beginLayout.apply(this, arguments);
        b.toolbarContext = b.context.getCmp(a.toolbar);
        b.inputCmpContext = b.context.getCmp(a.inputCmp);
        b.bodyCellContext = b.getEl("bodyEl");
        b.textAreaContext = b.getEl("textareaEl");
        b.iframeContext = b.getEl("iframeEl")
    }, beginLayoutCycle: function (i) {
        var h = this, d = i.widthModel, c = i.heightModel, b = h.owner, g = b.iframeEl, e = b.textareaEl,
            a = (c.natural || c.shrinkWrap) ? h.naturalHeight : "";
        Ext.layout.component.field.FieldContainer.prototype.beginLayoutCycle.apply(this, arguments);
        if (d.shrinkWrap) {
            g.setStyle("width", "");
            e.setStyle("width", "")
        } else {
            if (d.natural) {
                i.bodyCellContext.setWidth(h.naturalWidth)
            }
        }
        g.setStyle("height", a);
        e.setStyle("height", a)
    }, finishedLayout: function () {
        var a = this.owner;
        Ext.layout.component.field.FieldContainer.prototype.finishedLayout.apply(this, arguments);
        if (Ext.isGecko) {
            a.textareaEl.dom.value = this.lastValue
        }
    }
}, 0, 0, 0, 0, ["layout.htmleditor"], 0, [Ext.layout.component.field, "HtmlEditor"], 0));
(Ext.cmd.derive("Ext.toolbar.Separator", Ext.toolbar.Item, {
    alternateClassName: "Ext.Toolbar.Separator",
    baseCls: "x-toolbar-separator",
    ariaRole: "separator"
}, 0, ["tbseparator"], ["component", "box", "tbitem", "tbseparator"], {
    component: true,
    box: true,
    tbitem: true,
    tbseparator: true
}, ["widget.tbseparator"], 0, [Ext.toolbar, "Separator", Ext.Toolbar, "Separator"], 0));
(Ext.cmd.derive("Ext.layout.container.boxOverflow.Menu", Ext.layout.container.boxOverflow.None, {
    alternateClassName: "Ext.layout.boxOverflow.Menu",
    noItemsMenuText: '<div class="x-toolbar-no-items" role="menuitem">(None)</div>',
    menuCls: "x-box-menu",
    constructor: function (a) {
        var b = this;
        Ext.layout.container.boxOverflow.None.prototype.constructor.call(this, a);
        b.menuItems = []
    },
    beginLayout: function (a) {
        Ext.layout.container.boxOverflow.None.prototype.beginLayout.call(this, a);
        this.clearOverflow(a)
    },
    beginLayoutCycle: function (b, a) {
        Ext.layout.container.boxOverflow.None.prototype.beginLayoutCycle.call(this, b, a);
        if (!a) {
            this.clearOverflow(b);
            this.layout.cacheChildItems(b)
        }
    },
    onRemove: function (a) {
        Ext.Array.remove(this.menuItems, a)
    },
    clearItem: function (a) {
        var b = a.menu;
        if (a.isButton && b) {
            a.setMenu(b, false)
        }
    },
    getSuffixConfig: function () {
        var d = this, c = d.layout, a = c.owner, b = a.id;
        d.menu = new Ext.menu.Menu({listeners: {scope: d, beforeshow: d.beforeMenuShow}});
        d.menuTrigger = new Ext.button.Button({
            id: b + "-menu-trigger",
            cls: d.menuCls + "-after x-toolbar-item",
            plain: a.usePlainButtons,
            ownerCt: a,
            ownerLayout: c,
            iconCls: "x-" + d.getOwnerType(a) + "-more-icon",
            ui: a.defaultButtonUI || "default",
            menu: d.menu,
            showEmptyMenu: true,
            getSplitCls: function () {
                return ""
            }
        });
        return d.menuTrigger.getRenderTree()
    },
    getOverflowCls: function (a) {
        return this.menuCls + "-body-" + a
    },
    handleOverflow: function (c) {
        var b = this, a = b.layout;
        b.showTrigger(c);
        if (a.direction !== "vertical") {
            b.menuTrigger.setLocalY((c.state.boxPlan.maxSize - b.menuTrigger[a.names.getHeight]()) / 2)
        }
        return {reservedSpace: b.triggerTotalWidth}
    },
    captureChildElements: function () {
        var a = this, c = a.menuTrigger, b = a.layout.names;
        if (c.rendering) {
            c.finishRender();
            a.triggerTotalWidth = c[b.getWidth]() + c.el.getMargin(b.parallelMargins)
        }
    },
    clearOverflow: function (h) {
        var g = this, b = g.menuItems, e = b.length, a = g.layout.owner, j = a._asLayoutRoot, d, c;
        a.suspendLayouts();
        g.captureChildElements();
        g.hideTrigger();
        a.resumeLayouts();
        for (c = 0; c < e; c++) {
            d = b[c];
            d.suspendLayouts();
            d.show();
            g.clearItem(d);
            d.resumeLayouts(j)
        }
        b.length = 0
    },
    showTrigger: function (d) {
        var p = this, l = p.layout, b = l.owner, o = l.names, s = o.x, g = o.width, q = d.state.boxPlan,
            c = q.targetSize[g], j = d.childItems, h = p.menuTrigger, a = p.menuItems, r, k, e, n, m;
        h.suspendLayouts();
        h.show();
        h.resumeLayouts(p._asLayoutRoot);
        c -= p.triggerTotalWidth;
        b.suspendLayouts();
        for (e = 0, m = a.length; e < m; ++e) {
            p.clearItem(a[e])
        }
        a.length = 0;
        for (e = 0, m = j.length; e < m; e++) {
            r = j[e];
            n = r.props;
            if (n[s] + n[g] > c) {
                k = r.target;
                p.menuItems.push(k);
                k.hide()
            }
        }
        b.resumeLayouts()
    },
    hideTrigger: function () {
        var a = this.menuTrigger;
        if (a) {
            a.hide()
        }
    },
    beforeMenuShow: function (j) {
        var h = this, b = h.menuItems, d = 0, a = b.length, g, e, c = function (k, i) {
            return k.isXType("buttongroup") && !(i instanceof Ext.toolbar.Separator)
        };
        j.suspendLayouts();
        j.removeAll(false);
        for (; d < a; d++) {
            g = b[d];
            if (!d && (g instanceof Ext.toolbar.Separator)) {
                continue
            }
            if (e && (c(g, e) || c(e, g))) {
                j.add("-")
            }
            h.addComponentToMenu(j, g);
            e = g
        }
        if (j.items.length < 1) {
            j.add(h.noItemsMenuText)
        }
        j.resumeLayouts()
    },
    createMenuConfig: function (c, a) {
        var b = Ext.apply({}, c.initialConfig), d = c.toggleGroup;
        Ext.copyTo(b, c, ["iconCls", "icon", "itemId", "disabled", "handler", "scope", "menu", "tabIndex"]);
        Ext.applyIf(b, {text: c.overflowText || c.text, hideOnClick: a, destroyMenu: false, listeners: null});
        b.masterComponent = c;
        if (c.isFormField) {
            b.value = c.getValue();
            b.listeners = {
                change: function (h, g, e) {
                    h.masterComponent.setValue(g)
                }
            };
            c.on("change", function (h, g, e) {
                h.overflowClone.setValue(g)
            })
        } else {
            if (d || c.enableToggle) {
                Ext.apply(b, {
                    hideOnClick: false, group: d, checked: c.pressed, handler: function (g, h) {
                        g.masterComponent.onClick(h)
                    }
                })
            }
        }
        if (c.isButton && !c.changeListenersAdded) {
            c.on({
                textchange: this.onButtonAttrChange,
                iconchange: this.onButtonAttrChange,
                toggle: this.onButtonToggle
            });
            c.changeListenersAdded = true
        }
        delete b.margin;
        delete b.ownerCt;
        delete b.xtype;
        delete b.id;
        delete b.itemId;
        return b
    },
    onButtonAttrChange: function (a) {
        var b = a.overflowClone;
        b.suspendLayouts();
        b.setText(a.text);
        b.setIcon(a.icon);
        b.setIconCls(a.iconCls);
        b.resumeLayouts(true)
    },
    onButtonToggle: function (a, b) {
        if (a.overflowClone.checked !== b) {
            a.overflowClone.setChecked(b)
        }
    },
    addComponentToMenu: function (g, c) {
        var e = this, d, b, a;
        if (c instanceof Ext.toolbar.Fill) {
            return
        } else {
            if (c instanceof Ext.toolbar.Separator) {
                g.add("-")
            } else {
                if (c.overflowClone) {
                    g.add(c.overflowClone)
                } else {
                    if (c.isComponent) {
                        if (c.isXType("splitbutton")) {
                            c.overflowClone = g.add(e.createMenuConfig(c, true))
                        } else {
                            if (c.isXType("button")) {
                                c.overflowClone = g.add(e.createMenuConfig(c, !c.menu))
                            } else {
                                if (c.isXType("buttongroup")) {
                                    b = c.items.items;
                                    a = b.length;
                                    for (d = 0; d < a; d++) {
                                        e.addComponentToMenu(g, b[d])
                                    }
                                } else {
                                    c.overflowClone = g.add(Ext.create(Ext.getClassName(c), e.createMenuConfig(c)))
                                }
                            }
                        }
                    }
                }
            }
        }
    },
    destroy: function () {
        var b = this, a = b.menuTrigger;
        if (a && !b.layout.owner.items.contains(a)) {
            delete a.ownerCt
        }
        b.menu = b.menuTrigger = Ext.destroy(b.menu, a);
        b.callParent()
    }
}, 1, 0, 0, 0, ["box.overflow.Menu", "box.overflow.menu"], 0, [Ext.layout.container.boxOverflow, "Menu", Ext.layout.boxOverflow, "Menu"], 0));
(Ext.cmd.derive("Ext.form.field.HtmlEditor", Ext.form.FieldContainer, {
    alternateClassName: "Ext.form.HtmlEditor",
    focusable: true,
    componentLayout: "htmleditor",
    textareaCls: "x-htmleditor-textarea",
    componentTpl: ["{beforeTextAreaTpl}", '<textarea id="{id}-textareaEl" data-ref="textareaEl" name="{name}" tabindex="-1" {inputAttrTpl}', ' class="{textareaCls}" autocomplete="off">', "{[Ext.util.Format.htmlEncode(values.value)]}", "</textarea>", "{afterTextAreaTpl}", "{beforeIFrameTpl}", '<iframe id="{id}-iframeEl" data-ref="iframeEl" name="{iframeName}" frameBorder="0" {iframeAttrTpl}', ' src="{iframeSrc}" class="{iframeCls}"></iframe>', "{afterIFrameTpl}", {disableFormats: true}],
    stretchInputElFixed: true,
    subTplInsertions: ["beforeTextAreaTpl", "afterTextAreaTpl", "beforeIFrameTpl", "afterIFrameTpl", "iframeAttrTpl", "inputAttrTpl"],
    enableFormat: true,
    enableFontSize: true,
    enableColors: true,
    enableAlignments: true,
    enableLists: true,
    enableSourceEdit: true,
    enableLinks: true,
    enableFont: true,
    createLinkText: "Please enter the URL for the link:",
    defaultLinkValue: "http://",
    fontFamilies: ["Arial", "Courier New", "Tahoma", "Times New Roman", "Verdana"],
    defaultValue: Ext.isOpera ? "&#160;" : "&#8203;",
    extraFieldBodyCls: "x-html-editor-wrap",
    defaultButtonUI: "default-toolbar",
    initialized: false,
    activated: false,
    sourceEditMode: false,
    iframePad: 3,
    hideMode: "offsets",
    maskOnDisable: true,
    containerElCls: "x-html-editor-container",
    reStripQuotes: /^['"]*|['"]*$/g,
    textAlignRE: /text-align:(.*?);/i,
    safariNonsenseRE: /\\sclass="(?:Apple-style-span|Apple-tab-span|khtml-block-placeholder)"/gi,
    nonDigitsRE: /\\D/g,
    initComponent: function () {
        var a = this;
        a.items = [a.createToolbar(), a.createInputCmp()];
        a.layout = {type: "vbox", align: "stretch"};
        if (a.value == null) {
            a.value = ""
        }
        Ext.form.FieldContainer.prototype.initComponent.apply(this, arguments);
        a.initField()
    },
    createInputCmp: function () {
        this.inputCmp = Ext.widget(this.getInputCmpCfg());
        return this.inputCmp
    },
    getInputCmpCfg: function () {
        var a = this, c = a.id + "-inputCmp", b = {
            id: c,
            name: a.name,
            textareaCls: a.textareaCls + " x-hidden",
            value: a.value,
            iframeName: Ext.id(),
            iframeSrc: Ext.SSL_SECURE_URL,
            iframeCls: "x-htmleditor-iframe"
        };
        a.getInsertionRenderData(b, a.subTplInsertions);
        return {
            flex: 1,
            xtype: "component",
            tpl: a.getTpl("componentTpl"),
            childEls: ["iframeEl", "textareaEl"],
            id: c,
            cls: "x-html-editor-input",
            data: b
        }
    },
    createToolbar: function () {
        this.toolbar = Ext.widget(this.getToolbarCfg());
        return this.toolbar
    },
    getToolbarCfg: function () {
        var h = this, b = [], e, a = Ext.quickTipsActive && Ext.tip.QuickTipManager.isEnabled(), d = "x-", j, g;

        function c(l, i, k) {
            return {
                itemId: l,
                cls: d + "btn-icon",
                iconCls: d + "edit-" + l,
                enableToggle: i !== false,
                scope: h,
                handler: k || h.relayBtnCmd,
                clickEvent: "mousedown",
                tooltip: a ? h.buttonTips[l] || g : g,
                overflowText: h.buttonTips[l].title || g,
                tabIndex: -1
            }
        }

        if (h.enableFont && !Ext.isSafari2) {
            j = Ext.widget("component", {
                itemId: "fontSelect",
                renderTpl: ['<select id="{id}-selectEl" data-ref="selectEl" class="' + d + 'font-select">', "</select>"],
                childEls: ["selectEl"],
                afterRender: function () {
                    h.fontSelect = this.selectEl;
                    Ext.Component.prototype.afterRender.apply(this, arguments)
                },
                onDisable: function () {
                    var i = this.selectEl;
                    if (i) {
                        i.dom.disabled = true
                    }
                    Ext.Component.prototype.onDisable.apply(this, arguments)
                },
                onEnable: function () {
                    var i = this.selectEl;
                    if (i) {
                        i.dom.disabled = false
                    }
                    Ext.Component.prototype.onEnable.apply(this, arguments)
                },
                listeners: {
                    change: function () {
                        h.win.focus();
                        h.relayCmd("fontName", h.fontSelect.dom.value);
                        h.deferFocus()
                    }, element: "selectEl"
                }
            });
            b.push(j, "-")
        }
        if (h.enableFormat) {
            b.push(c("bold"), c("italic"), c("underline"))
        }
        if (h.enableFontSize) {
            b.push("-", c("increasefontsize", false, h.adjustFont), c("decreasefontsize", false, h.adjustFont))
        }
        if (h.enableColors) {
            b.push("-", {
                itemId: "forecolor",
                cls: d + "btn-icon",
                iconCls: d + "edit-forecolor",
                overflowText: h.buttonTips.forecolor.title,
                tooltip: a ? h.buttonTips.forecolor || g : g,
                tabIndex: -1,
                menu: Ext.widget("menu", {
                    plain: true,
                    items: [{
                        xtype: "colorpicker",
                        allowReselect: true,
                        focus: Ext.emptyFn,
                        value: "000000",
                        plain: true,
                        clickEvent: "mousedown",
                        handler: function (k, i) {
                            h.relayCmd("forecolor", Ext.isWebKit || Ext.isIE ? "#" + i : i);
                            this.up("menu").hide()
                        }
                    }]
                })
            }, {
                itemId: "backcolor",
                cls: d + "btn-icon",
                iconCls: d + "edit-backcolor",
                overflowText: h.buttonTips.backcolor.title,
                tooltip: a ? h.buttonTips.backcolor || g : g,
                tabIndex: -1,
                menu: Ext.widget("menu", {
                    plain: true,
                    items: [{
                        xtype: "colorpicker",
                        focus: Ext.emptyFn,
                        value: "FFFFFF",
                        plain: true,
                        allowReselect: true,
                        clickEvent: "mousedown",
                        handler: function (k, i) {
                            if (Ext.isGecko) {
                                h.execCmd("useCSS", false);
                                h.execCmd("hilitecolor", "#" + i);
                                h.execCmd("useCSS", true);
                                h.deferFocus()
                            } else {
                                h.relayCmd(Ext.isOpera ? "hilitecolor" : "backcolor", Ext.isWebKit || Ext.isIE || Ext.isOpera ? "#" + i : i)
                            }
                            this.up("menu").hide()
                        }
                    }]
                })
            })
        }
        if (h.enableAlignments) {
            b.push("-", c("justifyleft"), c("justifycenter"), c("justifyright"))
        }
        if (!Ext.isSafari2) {
            if (h.enableLinks) {
                b.push("-", c("createlink", false, h.createLink))
            }
            if (h.enableLists) {
                b.push("-", c("insertorderedlist"), c("insertunorderedlist"))
            }
            if (h.enableSourceEdit) {
                b.push("-", c("sourceedit", true, function () {
                    h.toggleSourceEdit(!h.sourceEditMode)
                }))
            }
        }
        for (e = 0; e < b.length; e++) {
            if (b[e].itemId !== "sourceedit") {
                b[e].disabled = true
            }
        }
        return {
            xtype: "toolbar",
            defaultButtonUI: h.defaultButtonUI,
            cls: "x-html-editor-tb",
            enableOverflow: true,
            items: b,
            listeners: {
                click: function (i) {
                    i.preventDefault()
                }, element: "el"
            }
        }
    },
    getMaskTarget: function () {
        return Ext.isGecko ? this.inputCmp.el : this.bodyEl
    },
    setReadOnly: function (e) {
        var d = this, c = d.textareaEl, b = d.iframeEl, a;
        d.readOnly = e;
        if (c) {
            c.dom.readOnly = e
        }
        if (d.initialized) {
            a = d.getEditorBody();
            if (Ext.isIE) {
                b.setDisplayed(false);
                a.contentEditable = !e;
                b.setDisplayed(true)
            } else {
                d.setDesignMode(!e)
            }
            if (a) {
                a.style.cursor = e ? "default" : "text"
            }
            d.disableItems(e)
        }
    },
    getDocMarkup: function () {
        var b = this, a = b.iframeEl.getHeight() - b.iframePad * 2;
        return Ext.String.format('<!DOCTYPE html><html><head><style type="text/css">' + (Ext.isOpera ? "p{margin:0;}" : "") + "body{border:0;margin:0;padding:{0}px;direction:" + (b.rtl ? "rtl;" : "ltr;") + (Ext.isIE8 ? Ext.emptyString : "min-") + "height:{1}px;box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;cursor:text;background-color:white;" + (Ext.isIE ? "" : "font-size:12px;font-family:{2}") + "}</style></head><body></body></html>", b.iframePad, a, b.defaultFont)
    },
    getEditorBody: function () {
        var a = this.getDoc();
        return a.body || a.documentElement
    },
    getDoc: function () {
        return this.iframeEl.dom.contentDocument || this.getWin().document
    },
    getWin: function () {
        return this.iframeEl.dom.contentWindow || window.frames[this.iframeEl.dom.name]
    },
    initDefaultFont: function () {
        var h = this, a = 0, j, b, k, e, d, g, c;
        if (!h.defaultFont) {
            b = h.textareaEl.getStyle("font-family");
            b = Ext.String.capitalize(b.split(",")[0]);
            j = Ext.Array.clone(h.fontFamilies);
            Ext.Array.include(j, b);
            j.sort();
            h.defaultFont = b;
            k = h.down("#fontSelect").selectEl.dom;
            for (d = 0, g = j.length; d < g; ++d) {
                b = j[d];
                c = b.toLowerCase();
                e = new Option(b, c);
                if (b === h.defaultFont) {
                    a = d
                }
                e.style.fontFamily = c;
                if (Ext.isIE) {
                    k.add(e)
                } else {
                    k.options.add(e)
                }
            }
            k.options[a].selected = true
        }
    },
    isEqual: function (b, a) {
        return this.isEqualAsString(b, a)
    },
    afterRender: function () {
        var b = this, a = b.inputCmp;
        Ext.form.FieldContainer.prototype.afterRender.apply(this, arguments);
        b.iframeEl = a.iframeEl;
        b.textareaEl = a.textareaEl;
        b.inputEl = b.iframeEl;
        if (b.enableFont) {
            b.initDefaultFont()
        }
        b.monitorTask = Ext.TaskManager.start({run: b.checkDesignMode, scope: b, interval: 100})
    },
    initFrameDoc: function () {
        var b = this, c, a;
        Ext.TaskManager.stop(b.monitorTask);
        c = b.getDoc();
        b.win = b.getWin();
        c.open();
        c.write(b.getDocMarkup());
        c.close();
        a = {
            run: function () {
                var d = b.getDoc();
                if (d.body || d.readyState === "complete") {
                    Ext.TaskManager.stop(a);
                    b.setDesignMode(true);
                    Ext.defer(b.initEditor, 10, b)
                }
            }, interval: 10, duration: 10000, scope: b
        };
        Ext.TaskManager.start(a)
    },
    checkDesignMode: function () {
        var a = this, b = a.getDoc();
        if (b && (!b.editorInitialized || a.getDesignMode() !== "on")) {
            a.initFrameDoc()
        }
    },
    setDesignMode: function (c) {
        var a = this, b = a.getDoc();
        if (b) {
            if (a.readOnly) {
                c = false
            }
            b.designMode = (/on|true/i).test(String(c).toLowerCase()) ? "on" : "off"
        }
    },
    getDesignMode: function () {
        var a = this.getDoc();
        return !a ? "" : String(a.designMode).toLowerCase()
    },
    disableItems: function (d) {
        var b = this.getToolbar().items.items, c, a = b.length, e;
        for (c = 0; c < a; c++) {
            e = b[c];
            if (e.getItemId() !== "sourceedit") {
                e.setDisabled(d)
            }
        }
    },
    toggleSourceEdit: function (b) {
        var g = this, d = g.iframeEl, a = g.textareaEl, e = "x-hidden", c = g.getToolbar().getComponent("sourceedit");
        if (!Ext.isBoolean(b)) {
            b = !g.sourceEditMode
        }
        g.sourceEditMode = b;
        if (c.pressed !== b) {
            c.toggle(b)
        }
        if (b) {
            g.disableItems(true);
            g.syncValue();
            d.addCls(e);
            a.removeCls(e);
            a.dom.removeAttribute("tabIndex");
            a.focus();
            g.inputEl = a
        } else {
            if (g.initialized) {
                g.disableItems(g.readOnly)
            }
            g.pushValue();
            d.removeCls(e);
            a.addCls(e);
            a.dom.setAttribute("tabIndex", -1);
            g.deferFocus();
            g.inputEl = d
        }
        g.fireEvent("editmodechange", g, b);
        g.updateLayout()
    },
    createLink: function () {
        var a = prompt(this.createLinkText, this.defaultLinkValue);
        if (a && a !== "http://") {
            this.relayCmd("createlink", a)
        }
    },
    clearInvalid: Ext.emptyFn,
    setValue: function (c) {
        var b = this, a = b.textareaEl;
        if (c === null || c === undefined) {
            c = ""
        }
        if (b.value !== c) {
            if (a) {
                a.dom.value = c
            }
            b.pushValue();
            if (!b.rendered && b.inputCmp) {
                b.inputCmp.data.value = c
            }
            b.mixins.field.setValue.call(b, c)
        }
        return b
    },
    cleanHtml: function (a) {
        a = String(a);
        if (Ext.isWebKit) {
            a = a.replace(this.safariNonsenseRE, "")
        }
        if (a.charCodeAt(0) === parseInt(this.defaultValue.replace(this.nonDigitsRE, ""), 10)) {
            a = a.substring(1)
        }
        return a
    },
    syncValue: function () {
        var g = this, b, h, d, a, c, e;
        if (g.initialized) {
            b = g.getEditorBody();
            d = b.innerHTML;
            e = g.textareaEl.dom;
            if (Ext.isWebKit) {
                a = b.getAttribute("style");
                c = a.match(g.textAlignRE);
                if (c && c[1]) {
                    d = '<div style="' + c[0] + '">' + d + "</div>"
                }
            }
            d = g.cleanHtml(d);
            if (g.fireEvent("beforesync", g, d) !== false) {
                if (Ext.isGecko && e.value === "" && d === "<br>") {
                    d = ""
                }
                if (e.value !== d) {
                    e.value = d;
                    h = true
                }
                g.fireEvent("sync", g, d);
                if (h) {
                    g.checkChange()
                }
            }
        }
    },
    getValue: function () {
        var a = this, b;
        if (!a.sourceEditMode) {
            a.syncValue()
        }
        b = a.rendered ? a.textareaEl.dom.value : a.value;
        a.value = b;
        return b
    },
    pushValue: function () {
        var b = this, a;
        if (b.initialized) {
            a = b.textareaEl.dom.value || "";
            if (!b.activated && a.length < 1) {
                a = b.defaultValue
            }
            if (b.fireEvent("beforepush", b, a) !== false) {
                b.getEditorBody().innerHTML = a;
                if (Ext.isGecko) {
                    b.setDesignMode(false);
                    b.setDesignMode(true)
                }
                b.fireEvent("push", b, a)
            }
        }
    },
    focus: function (d, b) {
        var c = this, e, a;
        if (b) {
            if (!c.focusTask) {
                c.focusTask = new Ext.util.DelayedTask(c.focus)
            }
            c.focusTask.delay(Ext.isNumber(b) ? b : 10, null, c, [d, false])
        } else {
            if (d) {
                if (c.textareaEl && c.textareaEl.dom) {
                    e = c.textareaEl.dom.value
                }
                if (e && e.length) {
                    c.execCmd("selectall", true)
                }
            }
            a = c.getFocusEl();
            if (a && a.focus) {
                a.focus()
            }
        }
        return c
    },
    initEditor: function () {
        var d = this, c, a, h, i, b;
        if (d.destroying || d.destroyed) {
            return
        }
        c = d.getEditorBody();
        if (!c) {
            setTimeout(function () {
                d.initEditor()
            }, 10);
            return
        }
        a = d.textareaEl.getStyle(["font-size", "font-family", "background-image", "background-repeat", "background-color", "color"]);
        a["background-attachment"] = "fixed";
        c.bgProperties = "fixed";
        Ext.DomHelper.applyStyles(c, a);
        h = d.getDoc();
        i = Ext.get(h);
        if (i) {
            try {
                i.clearListeners()
            } catch (g) {
            }
            b = d.onEditorEvent.bind(d);
            i.on({mousedown: b, dblclick: b, click: b, keyup: b, delegated: false, buffer: 100});
            b = d.onRelayedEvent;
            i.on({mousedown: b, mousemove: b, mouseup: b, click: b, dblclick: b, delegated: false, scope: d});
            if (Ext.isGecko) {
                i.on("keypress", d.applyCommand, d)
            }
            if (d.fixKeys) {
                i.on("keydown", d.fixKeys, d, {delegated: false})
            }
            if (d.fixKeysAfter) {
                i.on("keyup", d.fixKeysAfter, d, {delegated: false})
            }
            if (Ext.isIE9) {
                Ext.get(h.documentElement).on("focus", d.focus, d)
            }
            if (Ext.isIE8) {
                i.on("focusout", function () {
                    d.savedSelection = h.selection.type !== "None" ? h.selection.createRange() : null
                }, d);
                i.on("focusin", function () {
                    if (d.savedSelection) {
                        d.savedSelection.select()
                    }
                }, d)
            }
            Ext.getWin().on("beforeunload", d.beforeDestroy, d);
            h.editorInitialized = true;
            d.initialized = true;
            d.pushValue();
            d.setReadOnly(d.readOnly);
            d.fireEvent("initialize", d)
        }
    },
    beforeDestroy: function () {
        var a = this, d = a.monitorTask, c, g;
        if (d) {
            Ext.TaskManager.stop(d)
        }
        if (a.rendered) {
            Ext.getWin().un(a.beforeDestroy, a);
            c = a.getDoc();
            if (c) {
                Ext.get(c).destroy();
                if (c.hasOwnProperty) {
                    for (g in c) {
                        try {
                            if (c.hasOwnProperty(g)) {
                                delete c[g]
                            }
                        } catch (b) {
                        }
                    }
                }
            }
            delete a.iframeEl;
            delete a.textareaEl;
            delete a.toolbar;
            delete a.inputCmp
        }
        Ext.form.FieldContainer.prototype.beforeDestroy.call(this)
    },
    onRelayedEvent: function (c) {
        var b = this.iframeEl, d = Ext.fly(b).getTrueXY(), e = c.getXY(), a = c.getXY();
        c.xy = [d[0] + a[0], d[1] + a[1]];
        c.injectEvent(b);
        c.xy = e
    },
    onFirstFocus: function () {
        var c = this, b, a;
        c.activated = true;
        c.disableItems(c.readOnly);
        if (Ext.isGecko) {
            c.win.focus();
            b = c.win.getSelection();
            if (b.focusNode && !c.getValue().length) {
                a = b.getRangeAt(0);
                a.selectNodeContents(c.getEditorBody());
                a.collapse(true);
                c.deferFocus()
            }
            try {
                c.execCmd("useCSS", true);
                c.execCmd("styleWithCSS", false)
            } catch (d) {
            }
        }
        c.fireEvent("activate", c)
    },
    adjustFont: function (d) {
        var e = d.getItemId() === "increasefontsize" ? 1 : -1, c = this.getDoc().queryCommandValue("FontSize") || "2",
            a = Ext.isString(c) && c.indexOf("px") !== -1, b;
        c = parseInt(c, 10);
        if (a) {
            if (c <= 10) {
                c = 1 + e
            } else {
                if (c <= 13) {
                    c = 2 + e
                } else {
                    if (c <= 16) {
                        c = 3 + e
                    } else {
                        if (c <= 18) {
                            c = 4 + e
                        } else {
                            if (c <= 24) {
                                c = 5 + e
                            } else {
                                c = 6 + e
                            }
                        }
                    }
                }
            }
            c = Ext.Number.constrain(c, 1, 6)
        } else {
            b = Ext.isSafari;
            if (b) {
                e *= 2
            }
            c = Math.max(1, c + e) + (b ? "px" : 0)
        }
        this.relayCmd("FontSize", c)
    },
    onEditorEvent: function () {
        this.updateToolbar()
    },
    updateToolbar: function () {
        var j = this, e, c, d, k, b, g, a, h;
        if (j.readOnly) {
            return
        }
        if (!j.activated) {
            j.onFirstFocus();
            return
        }
        d = j.getToolbar().items.map;
        k = j.getDoc();
        if (j.enableFont && !Ext.isSafari2) {
            g = k.queryCommandValue("fontName");
            b = (g ? g.split(",")[0].replace(j.reStripQuotes, "") : j.defaultFont).toLowerCase();
            a = j.fontSelect.dom;
            if (b !== a.value || b !== g) {
                a.value = b
            }
        }

        function m() {
            var i;
            for (e = 0, c = arguments.length, b; e < c; e++) {
                b = arguments[e];
                try {
                    i = k.queryCommandState(b)
                } catch (l) {
                    i = false
                }
                d[b].toggle(i)
            }
        }

        if (j.enableFormat) {
            m("bold", "italic", "underline")
        }
        if (j.enableAlignments) {
            m("justifyleft", "justifycenter", "justifyright")
        }
        if (!Ext.isSafari2 && j.enableLists) {
            m("insertorderedlist", "insertunorderedlist")
        }
        h = j.toolbar.query("menu");
        for (e = 0; e < h.length; e++) {
            h[e].hide()
        }
        j.syncValue()
    },
    relayBtnCmd: function (a) {
        this.relayCmd(a.getItemId())
    },
    relayCmd: function (b, a) {
        Ext.defer(function () {
            var c = this;
            if (!this.destroyed) {
                c.win.focus();
                c.execCmd(b, a);
                c.updateToolbar()
            }
        }, 10, this)
    },
    execCmd: function (c, b) {
        var a = this, d = a.getDoc();
        d.execCommand(c, false, (b === undefined ? null : b));
        a.syncValue()
    },
    applyCommand: function (d) {
        if (d.ctrlKey) {
            var a = this, g = d.getCharCode(), b;
            if (g > 0) {
                g = String.fromCharCode(g);
                switch (g) {
                    case"b":
                        b = "bold";
                        break;
                    case"i":
                        b = "italic";
                        break;
                    case"u":
                        b = "underline";
                        break
                }
                if (b) {
                    a.win.focus();
                    a.execCmd(b);
                    a.deferFocus();
                    d.preventDefault()
                }
            }
        }
    },
    insertAtCursor: function (k) {
        var i = this, h = i.getWin(), j = i.getDoc(), c, g, d, l, e, b, a;
        if (i.activated) {
            h.focus();
            if (h.getSelection) {
                c = h.getSelection();
                if (c.getRangeAt && c.rangeCount) {
                    g = c.getRangeAt(0);
                    g.deleteContents();
                    d = j.createElement("div");
                    d.innerHTML = k;
                    l = j.createDocumentFragment();
                    while ((e = d.firstChild)) {
                        b = l.appendChild(e)
                    }
                    a = l.firstChild;
                    g.insertNode(l);
                    if (b) {
                        g = g.cloneRange();
                        g.setStartAfter(b);
                        g.collapse(true);
                        c.removeAllRanges();
                        c.addRange(g)
                    }
                }
            } else {
                if (j.selection && c.type !== "Control") {
                    c = j.selection;
                    g = c.createRange();
                    g.collapse(true);
                    c.createRange().pasteHTML(k)
                }
            }
            i.deferFocus()
        }
    },
    fixKeys: (function () {
        var a;
        if (Ext.isIE) {
            return function (i) {
                var d = this, c = i.getKey(), h = d.getDoc(), j = d.readOnly, b, g;
                if (c === i.TAB) {
                    i.stopEvent();
                    if (!j) {
                        b = h.selection.createRange();
                        if (b) {
                            if (b.collapse) {
                                b.collapse(true);
                                b.pasteHTML("&#160;&#160;&#160;&#160;")
                            }
                            d.deferFocus()
                        }
                    }
                } else {
                    if (c === i.ENTER) {
                        if (!j) {
                            if (Ext.isIE10m) {
                                b = h.selection.createRange();
                                if (b) {
                                    g = b.parentElement();
                                    if (!g || g.tagName.toLowerCase() !== "li") {
                                        i.stopEvent();
                                        b.pasteHTML("<br />");
                                        b.collapse(false);
                                        b.select()
                                    }
                                }
                            } else {
                                b = h.getSelection().getRangeAt(0);
                                if (b && b.commonAncestorContainer.parentNode.tagName.toLowerCase() !== "li") {
                                    i.stopEvent();
                                    a = h.createElement("div");
                                    b.insertNode(a)
                                }
                            }
                        }
                    }
                }
            }
        }
        if (Ext.isOpera) {
            return function (d) {
                var c = this, b = d.getKey(), g = c.readOnly;
                if (b === d.TAB) {
                    d.stopEvent();
                    if (!g) {
                        c.win.focus();
                        c.execCmd("InsertHTML", "&#160;&#160;&#160;&#160;");
                        c.deferFocus()
                    }
                }
            }
        }
        return null
    }()),
    fixKeysAfter: (function () {
        if (Ext.isIE) {
            return function (d) {
                var b = this, a = d.getKey(), c = b.getDoc(), h = b.readOnly, g;
                if (!h && (a === d.BACKSPACE || a === d.DELETE)) {
                    g = c.body.innerHTML;
                    if (g === "<p>&nbsp;</p>" || g === "<P>&nbsp;</P>") {
                        c.body.innerHTML = ""
                    }
                }
            }
        }
        return null
    }()),
    getToolbar: function () {
        return this.toolbar
    },
    buttonTips: {
        bold: {title: "Bold (Ctrl+B)", text: "Make the selected text bold.", cls: "x-html-editor-tip"},
        italic: {title: "Italic (Ctrl+I)", text: "Make the selected text italic.", cls: "x-html-editor-tip"},
        underline: {title: "Underline (Ctrl+U)", text: "Underline the selected text.", cls: "x-html-editor-tip"},
        increasefontsize: {title: "Grow Text", text: "Increase the font size.", cls: "x-html-editor-tip"},
        decreasefontsize: {title: "Shrink Text", text: "Decrease the font size.", cls: "x-html-editor-tip"},
        backcolor: {
            title: "Text Highlight Color",
            text: "Change the background color of the selected text.",
            cls: "x-html-editor-tip"
        },
        forecolor: {title: "Font Color", text: "Change the color of the selected text.", cls: "x-html-editor-tip"},
        justifyleft: {title: "Align Text Left", text: "Align text to the left.", cls: "x-html-editor-tip"},
        justifycenter: {title: "Center Text", text: "Center text in the editor.", cls: "x-html-editor-tip"},
        justifyright: {title: "Align Text Right", text: "Align text to the right.", cls: "x-html-editor-tip"},
        insertunorderedlist: {title: "Bullet List", text: "Start a bulleted list.", cls: "x-html-editor-tip"},
        insertorderedlist: {title: "Numbered List", text: "Start a numbered list.", cls: "x-html-editor-tip"},
        createlink: {title: "Hyperlink", text: "Make the selected text a hyperlink.", cls: "x-html-editor-tip"},
        sourceedit: {title: "Source Edit", text: "Switch to source editing mode.", cls: "x-html-editor-tip"}
    },
    privates: {
        deferFocus: function () {
            this.focus(false, true)
        }, getFocusEl: function () {
            return this.sourceEditMode ? this.textareaEl : this.iframeEl
        }
    }
}, 0, ["htmleditor"], ["component", "box", "container", "fieldcontainer", "htmleditor"], {
    component: true,
    box: true,
    container: true,
    fieldcontainer: true,
    htmleditor: true
}, ["widget.htmleditor"], [["field", Ext.form.field.Field]], [Ext.form.field, "HtmlEditor", Ext.form, "HtmlEditor"], 0));
(Ext.cmd.derive("Ext.form.field.Tag", Ext.form.field.ComboBox, {
    noWrap: false,
    multiSelect: true,
    delimiter: ",",
    tipTpl: undefined,
    forceSelection: true,
    createNewOnEnter: false,
    createNewOnBlur: false,
    encodeSubmitValue: false,
    triggerOnClick: true,
    stacked: false,
    filterPickList: false,
    grow: true,
    growMin: false,
    growMax: false,
    selectOnFocus: true,
    fieldSubTpl: ['<div id="{cmpId}-listWrapper" data-ref="listWrapper" class="x-tagfield {fieldCls} {typeCls} {typeCls}-{ui}" style="{wrapperStyle}">', '<ul id="{cmpId}-itemList" data-ref="itemList" class="x-tagfield-list{itemListCls}">', '<li id="{cmpId}-inputElCt" data-ref="inputElCt" class="x-tagfield-input">', '<div id="{cmpId}-emptyEl" data-ref="emptyEl" class="{emptyCls}">{emptyText}</div>', '<input id="{cmpId}-inputEl" data-ref="inputEl" type="{type}" ', '<tpl if="name">name="{name}" </tpl>', '<tpl if="value"> value="{[Ext.util.Format.htmlEncode(values.value)]}"</tpl>', '<tpl if="size">size="{size}" </tpl>', '<tpl if="tabIdx != null">tabindex="{tabIdx}" </tpl>', '<tpl if="disabled"> disabled="disabled"</tpl>', 'class="x-tagfield-input-field {inputElCls}" autocomplete="off">', "</li>", "</ul>", "</div>", {disableFormats: true}],
    extraFieldBodyCls: "x-tagfield-body",
    childEls: ["listWrapper", "itemList", "inputEl", "inputElCt", "emptyEl"],
    emptyInputCls: "x-tagfield-emptyinput",
    clearValueOnEmpty: false,
    tagItemCls: "x-tagfield-item",
    tagItemTextCls: "x-tagfield-item-text",
    tagItemCloseCls: "x-tagfield-item-close",
    tagItemSelector: ".x-tagfield-item",
    tagItemCloseSelector: ".x-tagfield-item-close",
    tagSelectedCls: "x-tagfield-item-selected",
    initComponent: function () {
        var c = this, b = c.typeAhead, a = c.delimiter;
        if (c.createNewOnEnter || c.createNewOnBlur) {
            c.forceSelection = false
        }
        c.typeAhead = false;
        if (c.value == null) {
            c.value = []
        }
        c.selectionModel = new Ext.selection.Model({
            mode: "MULTI", onSelectChange: function (d, g, e, h) {
                h()
            }, listeners: {scope: c, selectionchange: c.onSelectionChange, focuschange: c.onFocusChange}
        });
        Ext.form.field.ComboBox.prototype.initComponent.call(this);
        c.typeAhead = b;
        if (a && c.multiSelect) {
            c.delimiterRegexp = new RegExp(Ext.String.escapeRegex(a))
        }
    },
    initEvents: function () {
        var a = this, b = a.inputEl;
        Ext.form.field.ComboBox.prototype.initEvents.apply(this, arguments);
        if (!a.enableKeyEvents) {
            b.on("keydown", a.onKeyDown, a);
            b.on("keyup", a.onKeyUp, a)
        }
        a.listWrapper.on({scope: a, click: a.onItemListClick, mousedown: a.onItemMouseDown})
    },
    isValid: function () {
        var b = this, a = b.disabled, c = b.forceValidation || !a;
        return c ? b.validateValue(b.getValue()) : a
    },
    onBindStore: function (a) {
        var b = this;
        Ext.form.field.ComboBox.prototype.onBindStore.call(this, a);
        if (a) {
            b.valueStore = new Ext.data.Store({model: a.getModel(), useModelWarning: false});
            b.selectionModel.bindStore(b.valueStore);
            if (b.filterPickList) {
                b.listFilter = new Ext.util.Filter({scope: b, filterFn: b.filterPicked});
                b.changingFilters = true;
                a.filter(b.listFilter);
                b.changingFilters = false
            }
        }
    },
    filterPicked: function (a) {
        return !this.valueCollection.contains(a)
    },
    onUnbindStore: function (a) {
        var c = this, d = c.valueStore, b = c.picker;
        if (b) {
            b.bindStore(null)
        }
        if (d) {
            d.destroy();
            c.valueStore = null
        }
        if (c.filterPickList && !a.destroyed) {
            c.changingFilters = true;
            a.removeFilter(c.listFilter);
            c.changingFilters = false
        }
        Ext.form.field.ComboBox.prototype.onUnbindStore.apply(this, arguments)
    },
    onValueCollectionEndUpdate: function () {
        var a = this, c = a.valueCollection.items, b = a.valueStore;
        if (a.isSelectionUpdating()) {
            return
        }
        if (a.filterPickList) {
            a.changingFilters = true;
            a.store.filter(a.listFilter);
            a.changingFilters = false
        }
        Ext.form.field.ComboBox.prototype.onValueCollectionEndUpdate.call(this);
        Ext.suspendLayouts();
        if (b) {
            b.suspendEvents();
            b.loadRecords(c);
            b.resumeEvents()
        }
        Ext.resumeLayouts(true);
        a.alignPicker()
    },
    checkValueOnDataChange: Ext.emptyFn,
    onSelectionChange: function (a, b) {
        this.applyMultiselectItemMarkup();
        this.fireEvent("valueselectionchange", this, b)
    },
    onFocusChange: function (a, c, b) {
        this.fireEvent("valuefocuschange", this, c, b)
    },
    onDestroy: function () {
        this.selectionModel = Ext.destroy(this.selectionModel);
        Ext.form.field.ComboBox.prototype.onDestroy.apply(this, arguments)
    },
    getSubTplData: function (c) {
        var i = this, h = Ext.form.field.ComboBox.prototype.getSubTplData.apply(this, arguments), d = i.emptyText,
            e = i.emptyInputCls, g = d && h.value.length < 1, j = i.growMin, a = i.growMax, b = "";
        h.value = "";
        h.emptyText = g ? d : "";
        h.emptyCls = g ? i.emptyCls : e;
        h.inputElCls = g ? e : "";
        h.itemListCls = "";
        if (i.grow) {
            if (Ext.isNumber(j) && j > 0) {
                b += "min-height:" + j + "px;"
            }
            if (Ext.isNumber(a) && a > 0) {
                b += "max-height:" + a + "px;"
            }
        }
        h.wrapperStyle = b;
        if (i.stacked === true) {
            h.itemListCls += " x-tagfield-stacked"
        }
        if (!i.multiSelect) {
            h.itemListCls += " x-tagfield-singleselect"
        }
        return h
    },
    afterRender: function () {
        var b = this, c = b.inputEl, a = b.emptyText;
        if (a) {
            if (Ext.supports.Placeholder && c) {
                c.dom.removeAttribute("placeholder")
            } else {
                b.applyEmptyText()
            }
        }
        b.applyMultiselectItemMarkup();
        Ext.form.field.ComboBox.prototype.afterRender.apply(this, arguments)
    },
    findRecord: function (c, b) {
        var a = this.getStore().queryRecords(c, b);
        return a.length ? a[0] : false
    },
    getCursorPosition: function () {
        var a;
        if (document.selection) {
            a = document.selection.createRange();
            a.collapse(true);
            a.moveStart("character", -this.inputEl.dom.value.length);
            a = a.text.length
        } else {
            a = this.inputEl.dom.selectionStart
        }
        return a
    },
    hasSelectedText: function () {
        var c = this.inputEl.dom, b, a;
        if (document.selection) {
            b = document.selection;
            a = b.createRange();
            return (a.parentElement() === c)
        } else {
            return c.selectionStart !== c.selectionEnd
        }
    },
    onKeyDown: function (g) {
        var h = this, k = g.getKey(), j = h.inputEl, c = j.dom.value, a = h.valueCollection, d = h.selectionModel,
            b = false, i;
        if (h.readOnly || h.disabled || !h.editable) {
            return
        }
        if (a.getCount() > 0 && (c === "" || (h.getCursorPosition() === 0 && !h.hasSelectedText()))) {
            i = (d.getCount() > 0) ? a.indexOf(d.getLastSelected()) : -1;
            if (k === g.BACKSPACE || k === g.DELETE) {
                if (i > -1) {
                    if (d.getCount() > 1) {
                        i = -1
                    }
                    a.remove(d.getSelection())
                } else {
                    a.remove(a.last())
                }
                d.clearSelections();
                if (i > 0) {
                    d.select(i - 1)
                } else {
                    if (a.getCount()) {
                        d.select(a.last())
                    }
                }
                b = true
            } else {
                if (k === g.RIGHT || k === g.LEFT) {
                    if (i === -1 && k === g.LEFT) {
                        d.select(a.last());
                        b = true
                    } else {
                        if (i > -1) {
                            if (k === g.RIGHT) {
                                if (i < (a.getCount() - 1)) {
                                    d.select(i + 1, g.shiftKey);
                                    b = true
                                } else {
                                    if (!g.shiftKey) {
                                        d.deselectAll();
                                        b = true
                                    }
                                }
                            } else {
                                if (k === g.LEFT && (i > 0)) {
                                    d.select(i - 1, g.shiftKey);
                                    b = true
                                }
                            }
                        }
                    }
                } else {
                    if (k === g.A && g.ctrlKey) {
                        d.selectAll();
                        b = g.A
                    }
                }
            }
        }
        if (b) {
            h.preventKeyUpEvent = b;
            g.stopEvent();
            return
        }
        if (h.isExpanded && k === g.ENTER && h.picker.highlightedItem) {
            h.preventKeyUpEvent = true
        }
        if (h.enableKeyEvents) {
            Ext.form.field.ComboBox.prototype.onKeyDown.apply(this, arguments)
        }
        if (!g.isSpecialKey() && !g.hasModifier()) {
            d.deselectAll()
        }
    },
    onKeyUp: function (h, b) {
        var c = this, g = c.inputEl, d = g.dom.value, a = c.preventKeyUpEvent;
        if (c.preventKeyUpEvent) {
            h.stopEvent();
            if (a === true || h.getKey() === a) {
                delete c.preventKeyUpEvent
            }
            return
        }
        if (c.multiSelect && c.delimiterRegexp && c.delimiterRegexp.test(d) || (c.createNewOnEnter && h.getKey() === h.ENTER)) {
            d = Ext.Array.clean(d.split(c.delimiterRegexp));
            g.dom.value = "";
            c.setValue(c.valueStore.getRange().concat(d));
            g.focus()
        }
        Ext.form.field.ComboBox.prototype.onKeyUp.call(this, h, b)
    },
    onTypeAhead: function () {
        var g = this, e = g.displayField, d = g.inputEl.dom, c = g.getPicker(), b = g.getStore().findRecord(e, d.value),
            h, a, i;
        if (b) {
            h = b.get(e);
            a = h.length;
            i = d.value.length;
            c.highlightItem(c.getNode(b));
            if (i !== 0 && i !== a) {
                d.value = h;
                g.selectText(i, h.length)
            }
        }
    },
    onItemListClick: function (d) {
        var c = this, a = c.selectionModel, b = d.getTarget(c.tagItemSelector),
            g = b ? d.getTarget(c.tagItemCloseSelector) : false;
        if (c.readOnly || c.disabled) {
            return
        }
        d.stopPropagation();
        if (b) {
            if (g) {
                c.removeByListItemNode(b);
                if (c.valueStore.getCount() > 0) {
                    c.fireEvent("select", c, c.valueStore.getRange())
                }
            } else {
                c.toggleSelectionByListItemNode(b, d.shiftKey)
            }
            if (!Ext.supports.TouchEvents) {
                c.inputEl.focus()
            }
        } else {
            if (a.getCount() > 0) {
                a.deselectAll()
            }
            c.inputEl.focus();
            if (c.triggerOnClick) {
                c.onTriggerClick()
            }
        }
    },
    onItemMouseDown: function (a) {
        a.preventDefault()
    },
    getMultiSelectItemMarkup: function () {
        var b = this, a = (b._getChildElCls && b._getChildElCls()) || "";
        if (!b.multiSelectItemTpl) {
            if (!b.labelTpl) {
                b.labelTpl = "{" + b.displayField + "}"
            }
            b.labelTpl = b.getTpl("labelTpl");
            if (b.tipTpl) {
                b.tipTpl = b.getTpl("tipTpl")
            }
            b.multiSelectItemTpl = new Ext.XTemplate(['<tpl for=".">', '<li data-selectionIndex="{[xindex - 1]}" data-recordId="{internalId}" class="' + b.tagItemCls + a, '<tpl if="this.isSelected(values)">', " " + b.tagSelectedCls, "</tpl>", "{%", "values = values.data;", "%}", b.tipTpl ? '" data-qtip="{[this.getTip(values)]}">' : '">', '<div class="' + b.tagItemTextCls + '">{[this.getItemLabel(values)]}</div>', '<div class="' + b.tagItemCloseCls + a + '"></div>', "</li>", "</tpl>", {
                isSelected: function (c) {
                    return b.selectionModel.isSelected(c)
                }, getItemLabel: function (c) {
                    return Ext.String.htmlEncode(b.labelTpl.apply(c))
                }, getTip: function (c) {
                    return Ext.String.htmlEncode(b.tipTpl.apply(c))
                }, strict: true
            }])
        }
        if (!b.multiSelectItemTpl.isTemplate) {
            b.multiSelectItemTpl = this.getTpl("multiSelectItemTpl")
        }
        return b.multiSelectItemTpl.apply(b.valueCollection.getRange())
    },
    applyMultiselectItemMarkup: function () {
        var b = this, a = b.itemList;
        if (a) {
            a.select(".x-tagfield-item").destroy();
            b.inputElCt.insertHtml("beforeBegin", b.getMultiSelectItemMarkup());
            b.autoSize()
        }
    },
    getRecordByListItemNode: function (a) {
        return this.valueCollection.items[Number(a.getAttribute("data-selectionIndex"))]
    },
    toggleSelectionByListItemNode: function (b, d) {
        var c = this, e = c.getRecordByListItemNode(b), a = c.selectionModel;
        if (e) {
            if (a.isSelected(e)) {
                a.deselect(e)
            } else {
                a.select(e, d)
            }
        }
    },
    removeByListItemNode: function (a) {
        var b = this, c = b.getRecordByListItemNode(a);
        if (c) {
            b.pickerSelectionModel.deselect(c)
        }
    },
    getDisplayValue: function () {
        return this.getRawValue()
    },
    getRawValue: function () {
        var e = this, c = e.getValueRecords(), b = [], d, a;
        for (d = 0, a = c.length; d < a; d++) {
            b.push(c[d].data[e.displayField])
        }
        return b.join(",")
    },
    setRawValue: function (a) {
        return
    },
    removeValue: function (h) {
        var g = this, b = g.valueCollection, a, c, e, d = [];
        if (h) {
            h = Ext.Array.from(h);
            for (c = 0, a = h.length; c < a; ++c) {
                e = h[c];
                if (!e.isModel) {
                    e = b.byValue.get(e)
                }
                if (e) {
                    d.push(e)
                }
            }
            g.valueCollection.beginUpdate();
            g.pickerSelectionModel.deselect(d);
            g.valueCollection.endUpdate()
        }
    },
    setValue: function (j, m, n) {
        var h = this, p = h.valueStore, o = h.valueField, g = [], k = h.store, d, e, c, a, l, b;
        if (Ext.isEmpty(j)) {
            j = null
        }
        if (Ext.isString(j) && h.multiSelect) {
            j = j.split(h.delimiter)
        }
        j = Ext.Array.from(j, true);
        for (c = 0, e = j.length; c < e; c++) {
            d = j[c];
            if (!d || !d.isModel) {
                a = p.findExact(o, d);
                if (a > -1) {
                    j[c] = p.getAt(a)
                } else {
                    a = h.findRecord(o, d);
                    if (!a) {
                        if (h.forceSelection) {
                            g.push(d)
                        } else {
                            a = {};
                            a[h.valueField] = d;
                            a[h.displayField] = d;
                            l = h.valueStore.getModel();
                            a = new l(a)
                        }
                    }
                    if (a) {
                        j[c] = a
                    }
                }
            }
        }
        if (!k.isEmptyStore && n !== true && g.length > 0 && h.queryMode === "remote") {
            b = {};
            b[h.valueParam || h.valueField] = g.join(h.delimiter);
            k.load({
                params: b, callback: function () {
                    if (h.itemList) {
                        h.itemList.unmask()
                    }
                    h.setValue(j, m, true);
                    h.autoSize();
                    h.lastQuery = false
                }
            });
            return false
        }
        if (!h.multiSelect && j.length > 0) {
            for (c = j.length - 1; c >= 0; c--) {
                if (j[c].isModel) {
                    j = j[c];
                    break
                }
            }
            if (Ext.isArray(j)) {
                j = j[j.length - 1]
            }
        }
        return Ext.form.field.ComboBox.prototype.setValue.call(this, j, m)
    },
    updateValue: function () {
        var d = this, c = d.valueCollection.getRange(), a = c.length, b;
        for (b = 0; b < a; b++) {
            c[b] = c[b].get(d.valueField)
        }
        d.setHiddenValue(c);
        d.value = d.multiSelect ? c : c[0];
        if (!Ext.isDefined(d.value)) {
            d.value = undefined
        }
        d.applyMultiselectItemMarkup();
        d.checkChange();
        d.applyEmptyText()
    },
    getValueRecords: function () {
        return this.valueCollection.getRange()
    },
    getSubmitData: function () {
        var a = this, b = Ext.form.field.ComboBox.prototype.getSubmitData.apply(this, arguments);
        if (a.multiSelect && a.encodeSubmitValue && b && b[a.name]) {
            b[a.name] = Ext.encode(b[a.name])
        }
        return b
    },
    assertValue: function () {
        var a = this, c = a.inputEl.dom.value, d = !Ext.isEmpty(c) ? a.findRecordByDisplay(c) : false, b = false;
        if (!d && !a.forceSelection && a.createNewOnBlur && !Ext.isEmpty(c)) {
            b = c
        } else {
            if (d) {
                b = d
            }
        }
        if (b) {
            a.addValue(b)
        }
        a.inputEl.dom.value = "";
        a.collapse()
    },
    isEqual: function (j, h) {
        var b = Ext.Array.from, c = this.valueField, d, a, g, e;
        j = b(j);
        h = b(h);
        a = j.length;
        if (a !== h.length) {
            return false
        }
        for (d = 0; d < a; d++) {
            g = j[d].isModel ? j[d].get(c) : j[d];
            e = h[d].isModel ? h[d].get(c) : h[d];
            if (g !== e) {
                return false
            }
        }
        return true
    },
    applyEmptyText: function () {
        var g = this, b = g.emptyText, d = g.emptyEl, h = g.inputEl, a = g.listWrapper, e = g.emptyCls,
            c = g.emptyInputCls, i;
        if (g.rendered && b) {
            i = Ext.isEmpty(g.value) && !g.hasFocus;
            if (i) {
                h.dom.value = "";
                d.setHtml(b);
                d.addCls(e);
                d.removeCls(c);
                a.addCls(e);
                h.addCls(c)
            } else {
                d.addCls(c);
                d.removeCls(e);
                a.removeCls(e);
                h.removeCls(c)
            }
            g.autoSize()
        }
    },
    preFocus: function () {
        var a = this, b = a.inputEl, c = b.dom.value === "";
        a.emptyEl.addCls(a.emptyInputCls);
        a.emptyEl.removeCls(a.emptyCls);
        a.listWrapper.removeCls(a.emptyCls);
        a.inputEl.removeCls(a.emptyInputCls);
        if (a.selectOnFocus || c) {
            b.dom.select()
        }
    },
    onFocus: function () {
        var c = this, b = c.focusCls, a = c.itemList;
        if (b && a) {
            a.addCls(b)
        }
        Ext.form.field.ComboBox.prototype.onFocus.apply(this, arguments)
    },
    onBlur: function () {
        var c = this, b = c.focusCls, a = c.itemList;
        if (b && a) {
            a.removeCls(b)
        }
        Ext.form.field.ComboBox.prototype.onBlur.apply(this, arguments)
    },
    renderActiveError: function () {
        var d = this, c = d.invalidCls, b = d.itemList, a = d.hasActiveError();
        if (c && b) {
            b[a ? "addCls" : "removeCls"](d.invalidCls + "-field")
        }
        Ext.form.field.ComboBox.prototype.renderActiveError.apply(this, arguments)
    },
    autoSize: function () {
        var a = this;
        if (a.grow && a.rendered) {
            a.autoSizing = true;
            a.updateLayout()
        }
        return a
    },
    afterComponentLayout: function () {
        var b = this, a;
        if (b.autoSizing) {
            a = b.getHeight();
            if (a !== b.lastInputHeight) {
                if (b.isExpanded) {
                    b.alignPicker()
                }
                b.fireEvent("autosize", b, a);
                b.lastInputHeight = a;
                b.autoSizing = false
            }
        }
    }
}, 0, ["tagfield"], ["component", "box", "field", "textfield", "pickerfield", "combobox", "combo", "tagfield"], {
    component: true,
    box: true,
    field: true,
    textfield: true,
    pickerfield: true,
    combobox: true,
    combo: true,
    tagfield: true
}, ["widget.tagfield"], 0, [Ext.form.field, "Tag"], 0));
(Ext.cmd.derive("Ext.picker.Time", Ext.view.BoundList, {
    config: {store: true},
    statics: {
        createStore: function (h, c) {
            var b = Ext.Date, d = b.clearTime, g = this.prototype.initDate, i = [], e = d(new Date(g[0], g[1], g[2])),
                a = b.add(d(new Date(g[0], g[1], g[2])), "mi", (24 * 60) - 1);
            while (e <= a) {
                i.push({disp: b.dateFormat(e, h), date: e});
                e = b.add(e, "mi", c)
            }
            return new Ext.data.Store({model: Ext.picker.Time.prototype.modelType, data: i})
        }
    },
    increment: 15,
    format: "g:i A",
    displayField: "disp",
    initDate: [2008, 0, 1],
    componentCls: "x-timepicker",
    loadMask: false,
    initComponent: function () {
        var c = this, a = Ext.Date, b = a.clearTime, d = c.initDate;
        c.absMin = b(new Date(d[0], d[1], d[2]));
        c.absMax = a.add(b(new Date(d[0], d[1], d[2])), "mi", (24 * 60) - 1);
        c.updateList();
        Ext.view.BoundList.prototype.initComponent.call(this)
    },
    applyStore: function (a, b) {
        if (a === true) {
            a = Ext.picker.Time.createStore(this.format, this.increment)
        }
        return a
    },
    setMinValue: function (a) {
        this.minValue = a;
        this.updateList()
    },
    setMaxValue: function (a) {
        this.maxValue = a;
        this.updateList()
    },
    normalizeDate: function (a) {
        var b = this.initDate;
        a.setFullYear(b[0], b[1], b[2]);
        return a
    },
    updateList: function () {
        var e = this, b = e.normalizeDate(e.minValue || e.absMin), a = e.normalizeDate(e.maxValue || e.absMax),
            d = e.getStore().getFilters(), c = e.rangeFilter;
        d.beginUpdate();
        if (c) {
            d.remove(c)
        }
        c = e.rangeFilter = new Ext.util.Filter({
            filterFn: function (g) {
                var h = g.get("date");
                return h >= b && h <= a
            }
        });
        d.add(c);
        d.endUpdate()
    }
}, 0, ["timepicker"], ["component", "box", "dataview", "boundlist", "timepicker"], {
    component: true,
    box: true,
    dataview: true,
    boundlist: true,
    timepicker: true
}, ["widget.timepicker"], 0, [Ext.picker, "Time"], function () {
    this.prototype.modelType = Ext.define(null, {extend: "Ext.data.Model", fields: ["disp", "date"]})
}));
(Ext.cmd.derive("Ext.form.field.Time", Ext.form.field.ComboBox, {
    alternateClassName: ["Ext.form.TimeField", "Ext.form.Time"],
    triggerCls: "x-form-time-trigger",
    minText: "The time in this field must be equal to or after {0}",
    maxText: "The time in this field must be equal to or before {0}",
    invalidText: "{0} is not a valid time",
    format: "g:i A",
    altFormats: "g:ia|g:iA|g:i a|g:i A|h:i|g:i|H:i|ga|ha|gA|h a|g a|g A|gi|hi|gia|hia|g|H|gi a|hi a|giA|hiA|gi A|hi A",
    formatText: "Expected time format: HH:MM space am/pm",
    increment: 15,
    pickerMaxHeight: 300,
    selectOnTab: true,
    snapToIncrement: false,
    valuePublishEvent: ["select", "blur"],
    initDate: "1/1/2008",
    initDateParts: [2008, 0, 1],
    initDateFormat: "j/n/Y",
    queryMode: "local",
    displayField: "disp",
    valueField: "date",
    initComponent: function () {
        var c = this, b = c.minValue, a = c.maxValue;
        if (b) {
            c.setMinValue(b)
        }
        if (a) {
            c.setMaxValue(a)
        }
        c.displayTpl = new Ext.XTemplate('<tpl for=".">{[typeof values === "string" ? values : this.formatDate(values["' + c.displayField + '"])]}<tpl if="xindex < xcount">' + c.delimiter + "</tpl></tpl>", {formatDate: c.formatDate.bind(c)});
        c.store = Ext.picker.Time.createStore(c.format, c.increment);
        Ext.form.field.ComboBox.prototype.initComponent.call(this);
        c.getPicker()
    },
    isEqual: function (g, e) {
        var b = Ext.Array.from, d = Ext.Date.isEqual, c, a;
        g = b(g);
        e = b(e);
        a = g.length;
        if (a !== e.length) {
            return false
        }
        for (c = 0; c < a; c++) {
            if (!d(e[c], g[c])) {
                return false
            }
        }
        return true
    },
    setMinValue: function (c) {
        var b = this, a = b.picker;
        b.setLimit(c, true);
        if (a) {
            a.setMinValue(b.minValue)
        }
    },
    setMaxValue: function (c) {
        var b = this, a = b.picker;
        b.setLimit(c, false);
        if (a) {
            a.setMaxValue(b.maxValue)
        }
    },
    setLimit: function (b, g) {
        var a = this, e, c;
        if (Ext.isString(b)) {
            e = a.parseDate(b)
        } else {
            if (Ext.isDate(b)) {
                e = b
            }
        }
        if (e) {
            c = a.getInitDate();
            c.setHours(e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds())
        } else {
            c = null
        }
        a[g ? "minValue" : "maxValue"] = c
    },
    getInitDate: function (a, b, d) {
        var c = this.initDateParts;
        return new Date(c[0], c[1], c[2], a || 0, b || 0, d || 0, 0)
    },
    valueToRaw: function (a) {
        return this.formatDate(this.parseDate(a))
    },
    getErrors: function (l) {
        l = arguments.length > 0 ? l : this.getRawValue();
        var g = this, k = Ext.String.format, j = Ext.form.field.ComboBox.prototype.getErrors.call(this, l),
            h = g.minValue, e = g.maxValue, c = g.displayTplData, m = g.getRawValue(), b, d, a, n;
        if (c && c.length > 0) {
            for (b = 0, d = c.length; b < d; b++) {
                n = c[b];
                n = n.date || n.disp;
                a = g.parseDate(n);
                if (!a) {
                    j.push(k(g.invalidText, n, Ext.Date.unescapeFormat(g.format)));
                    continue
                }
                if (h && a < h) {
                    j.push(k(g.minText, g.formatDate(h)))
                }
                if (e && a > e) {
                    j.push(k(g.maxText, g.formatDate(e)))
                }
            }
        } else {
            if (m.length && !g.parseDate(m)) {
                j.push(k(g.invalidText, m, Ext.Date.unescapeFormat(g.format)))
            }
        }
        return j
    },
    formatDate: function (b) {
        var d = [], c, a;
        b = Ext.Array.from(b);
        for (c = 0, a = b.length; c < a; c++) {
            d.push(Ext.form.field.Date.prototype.formatDate.call(this, b[c]))
        }
        return d.join(this.delimiter)
    },
    parseDate: function (e) {
        var d = this, h = e, b = d.altFormats, g = d.altFormatsArray, c = 0, a;
        if (e && !Ext.isDate(e)) {
            h = d.safeParse(e, d.format);
            if (!h && b) {
                g = g || b.split("|");
                a = g.length;
                for (; c < a && !h; ++c) {
                    h = d.safeParse(e, g[c])
                }
            }
        }
        if (h && d.snapToIncrement) {
            h = new Date(Ext.Number.snap(h.getTime(), d.increment * 60 * 1000))
        }
        return h
    },
    safeParse: function (e, g) {
        var d = this, b = Ext.Date, c, a = null;
        if (b.formatContainsDateInfo(g)) {
            a = b.parse(e, g)
        } else {
            c = b.parse(d.initDate + " " + e, d.initDateFormat + " " + g);
            if (c) {
                a = c
            }
        }
        return a
    },
    getSubmitValue: function () {
        var a = this, c = a.submitFormat || a.format, b = a.getValue();
        return b ? Ext.Date.format(b, c) : null
    },
    createPicker: function () {
        var a = this;
        a.listConfig = Ext.apply({
            xtype: "timepicker",
            pickerField: a,
            cls: undefined,
            minValue: a.minValue,
            maxValue: a.maxValue,
            increment: a.increment,
            format: a.format,
            maxHeight: a.pickerMaxHeight
        }, a.listConfig);
        return Ext.form.field.ComboBox.prototype.createPicker.call(this)
    },
    completeEdit: function () {
        var a = this, b = a.getValue();
        Ext.form.field.ComboBox.prototype.completeEdit.apply(this, arguments);
        if (a.validateValue(b)) {
            a.setValue(b)
        }
    },
    findRecordByValue: function (a) {
        if (typeof a === "string") {
            a = this.parseDate(a)
        }
        return Ext.form.field.ComboBox.prototype.findRecordByValue.call(this, a)
    },
    rawToValue: function (g) {
        var e = this, c, b, d, a;
        if (e.multiSelect) {
            b = [];
            c = Ext.Array.from(g);
            for (d = 0, a = c.length; d < a; d++) {
                b.push(e.parseDate(c[d]))
            }
            return b
        }
        return e.parseDate(g)
    },
    setValue: function (a) {
        var b = this;
        if (b.creatingPicker) {
            return
        }
        b.getPicker();
        if (Ext.isDate(a)) {
            a = b.getInitDate(a.getHours(), a.getMinutes(), a.getSeconds())
        }
        return Ext.form.field.ComboBox.prototype.setValue.call(this, a)
    },
    getValue: function () {
        return this.rawToValue(Ext.form.field.ComboBox.prototype.getValue.apply(this, arguments))
    }
}, 0, ["timefield"], ["component", "box", "field", "textfield", "pickerfield", "combobox", "combo", "timefield"], {
    component: true,
    box: true,
    field: true,
    textfield: true,
    pickerfield: true,
    combobox: true,
    combo: true,
    timefield: true
}, ["widget.timefield"], 0, [Ext.form.field, "Time", Ext.form, "TimeField", Ext.form, "Time"], 0));
(Ext.cmd.derive("Ext.form.field.Trigger", Ext.form.field.Text, {
    alternateClassName: ["Ext.form.TriggerField", "Ext.form.TwinTriggerField", "Ext.form.Trigger"],
    triggerCls: "x-form-arrow-trigger",
    inheritableStatics: {
        warnDeprecated: function () {
        }
    },
    onClassExtended: function () {
        this.warnDeprecated()
    },
    constructor: function (a) {
        this.self.warnDeprecated();
        Ext.form.field.Text.prototype.constructor.call(this, a)
    }
}, 1, ["triggerfield", "trigger"], ["component", "box", "field", "textfield", "triggerfield", "trigger"], {
    component: true,
    box: true,
    field: true,
    textfield: true,
    triggerfield: true,
    trigger: true
}, ["widget.trigger", "widget.triggerfield"], 0, [Ext.form.field, "Trigger", Ext.form, "TriggerField", Ext.form, "TwinTriggerField", Ext.form, "Trigger"], 0));
(Ext.cmd.derive("Ext.grid.CellContext", Ext.Base, {
    isCellContext: true, constructor: function (a) {
        this.view = a
    }, setPosition: function (c, a) {
        var b = this;
        if (arguments.length === 1) {
            if (c.length) {
                a = c[0];
                c = c[1]
            } else {
                if (c.isCellContext) {
                    return b.setAll(c.view, c.rowIdx, c.colIdx, c.record, c.columnHeader)
                } else {
                    if (c.view) {
                        b.view = c.view
                    }
                    a = c.column;
                    c = c.row
                }
            }
        }
        b.setRow(c);
        b.setColumn(a);
        return b
    }, setAll: function (b, c, d, a, g) {
        var e = this;
        e.view = b;
        e.rowIdx = c;
        e.colIdx = d;
        e.record = a;
        e.column = g;
        return e
    }, setRow: function (c) {
        var a = this, b = a.view.dataSource;
        if (c !== undefined) {
            if (typeof c === "number") {
                a.rowIdx = Math.max(Math.min(c, b.getCount() - 1), 0);
                a.record = b.getAt(c)
            } else {
                if (c.isModel) {
                    a.record = c;
                    a.rowIdx = b.indexOf(c)
                } else {
                    if (c.tagName || c.isElement) {
                        a.record = a.view.getRecord(c);
                        a.rowIdx = b.indexOf(a.record)
                    }
                }
            }
        }
        return a
    }, setColumn: function (a) {
        var c = this, b = c.view.getVisibleColumnManager();
        if (a !== undefined) {
            if (typeof a === "number") {
                c.colIdx = a;
                c.column = b.getHeaderAtIndex(a)
            } else {
                if (a.isHeader) {
                    c.column = a;
                    c.colIdx = b.indexOf(a)
                }
            }
        }
        return c
    }, getCell: function (a) {
        return this.view.getCellByPosition(this, a)
    }, getRow: function (b) {
        var a = this.view.getRow(this.record);
        return b ? a : Ext.get(a)
    }, getNode: function (b) {
        var a = this.view.getNode(this.record);
        return b ? a : Ext.get(a)
    }, isEqual: function (a) {
        return (a && a.isCellContext && a.record === this.record && a.column === this.column)
    }, clone: function () {
        var b = this, a = new b.self(b.view);
        a.rowIdx = b.rowIdx;
        a.colIdx = b.colIdx;
        a.record = b.record;
        a.column = b.column;
        return a
    }, privates: {
        isFirstColumn: function () {
            var a = this.getCell(true);
            if (a) {
                return !a.previousSibling
            }
        }, isLastColumn: function () {
            var a = this.getCell(true);
            if (a) {
                return !a.nextSibling
            }
        }, getLastColumnIndex: function () {
            var a = this.getRow(true);
            if (a) {
                return a.lastChild.cellIndex
            }
            return -1
        }, navigate: function (c) {
            var b = this, a = b.view.getVisibleColumnManager().getColumns();
            switch (c) {
                case -1:
                    do {
                        if (!b.colIdx) {
                            b.colIdx = a.length - 1
                        } else {
                            b.colIdx--
                        }
                        b.setColumn(b.colIdx)
                    } while (!b.getCell(true));
                    break;
                case 1:
                    do {
                        if (b.colIdx >= a.length) {
                            b.colIdx = 0
                        } else {
                            b.colIdx++
                        }
                        b.setColumn(b.colIdx)
                    } while (!b.getCell(true));
                    break
            }
        }
    }, statics: {
        compare: function (b, a) {
            return b.rowIdx - a.rowIdx || b.colIdx - a.colIdx
        }
    }
}, 1, 0, 0, 0, 0, 0, [Ext.grid, "CellContext"], 0));
(Ext.cmd.derive("Ext.grid.CellEditor", Ext.Editor, {
    isCellEditor: true,
    alignment: "l-l?",
    hideEl: false,
    cls: "x-small-editor x-grid-editor x-grid-cell-editor",
    treeNodeSelector: ".x-tree-node-text",
    shim: false,
    shadow: false,
    setGrid: function (b) {
        var d = this, c = d.grid, a;
        if (b !== c) {
            a = {
                beforerefresh: d.beforeViewRefresh,
                refresh: d.onViewRefresh,
                beforeitemupdate: d.beforeItemUpdate,
                itemupdate: d.onItemUpdate,
                scope: d
            };
            if (c) {
                c.getView().un(a)
            }
            d.grid = b;
            b.getView().on(a)
        }
    },
    beforeViewRefresh: function (a) {
        var b = this, c = b.el && b.el.dom;
        if (c) {
            b.wasAllowBlur = b.allowBlur;
            if (b.editing && !(b.field.column && b.field.column.sorting)) {
                b.grid.view.cellFocused = false;
                b.allowBlur = false
            }
            if (c.parentNode) {
                a.refreshing = true;
                c.parentNode.removeChild(c)
            }
        }
    },
    onViewRefresh: function (b) {
        var d = this, g = d.el && d.el.dom, e, a, c = d.context;
        if (g) {
            d.allowBlur = d.wasAllowBlur;
            e = d.field.column && d.field.column.sorting;
            a = b.getCellByPosition(c, true);
            if (!a) {
                d.completeEdit();
                Ext.getDetachedBody().dom.appendChild(g);
                return
            }
            c.node = b.getNode(c.record);
            c.row = b.getRow(c.record);
            c.rowIdx = b.indexOf(c.row);
            a.insertBefore(g, a.firstChild);
            d.boundEl = d.container = Ext.get(a);
            d.realign(true);
            if (d.editing && !e) {
                d.field.focus()
            }
            if (d.editing && e) {
                d.completeEdit()
            }
        }
    },
    beforeItemUpdate: function (c, d, e, b) {
        var j = this, h = j.context, a = b.length, g;
        if (c === h.record) {
            for (g = 0; g < a; g++) {
                if (b[g] === h.column) {
                    j.needsFixOnItemUpdate = true;
                    j.beforeViewRefresh(j.editingPlugin.view);
                    return
                }
            }
        }
    },
    onItemUpdate: function (b, c, d) {
        var a = this.editingPlugin.view;
        if (this.needsFixOnItemUpdate) {
            this.needsFixOnItemUpdate = a.refreshing = false;
            this.onViewRefresh(a)
        }
    },
    startEdit: function (b, c, a) {
        this.context = this.editingPlugin.context;
        Ext.Editor.prototype.startEdit.call(this, b, c, a)
    },
    onShow: function () {
        var a = this, b = a.boundEl.down(a.context.view.innerSelector);
        if (b) {
            if (a.isForTree) {
                b = b.child(a.treeNodeSelector)
            }
            b.hide()
        }
        Ext.Editor.prototype.onShow.apply(this, arguments)
    },
    onFocusEnter: function () {
        Ext.Editor.prototype.onFocusEnter.apply(this, arguments);
        this.focusEnterEvent = null
    },
    onEditComplete: function (a) {
        if (a) {
            this.restoreCell()
        }
        Ext.Editor.prototype.onEditComplete.apply(this, arguments)
    },
    onHide: function () {
        this.restoreCell();
        Ext.Editor.prototype.onHide.apply(this, arguments)
    },
    onSpecialKey: function (h, g) {
        var e = this, c = g.getKey(), b = e.completeOnEnter && c === g.ENTER, d = e.cancelOnEsc && c === g.ESC,
            a = e.editingPlugin.view;
        if (b || d) {
            g.stopEvent();
            if (b) {
                e.completeEdit(true)
            } else {
                if (d) {
                    e.cancelEdit(true)
                }
            }
            a.getNavigationModel().setPosition(e.context, null, g);
            a.ownerGrid.setActionableMode(false)
        }
    },
    getRefOwner: function () {
        return this.column && this.column.getView()
    },
    restoreCell: function () {
        var a = this, b = a.boundEl.down(a.context.view.innerSelector);
        if (b) {
            if (a.isForTree) {
                b = b.child(a.treeNodeSelector)
            }
            b.show()
        }
    },
    afterRender: function () {
        var a = this, b = a.field;
        Ext.Editor.prototype.afterRender.apply(this, arguments);
        if (b.isCheckbox) {
            b.mon(b.inputEl, {mousedown: a.onCheckBoxMouseDown, click: a.onCheckBoxClick, scope: a})
        }
    },
    onCheckBoxMouseDown: function () {
        this.completeEdit = Ext.emptyFn
    },
    onCheckBoxClick: function () {
        delete this.completeEdit;
        this.field.focus(false, 10)
    },
    realign: function (d) {
        var j = this, g = j.boundEl, h = g.down(j.context.view.innerSelector), l = h.dom.firstChild, b = g.getWidth(),
            c = Ext.Array.clone(j.offsets), a = j.grid, i, k = "",
            e = !l || (l.nodeType === 3 && !(Ext.String.trim(k = l.data).length));
        if (j.isForTree) {
            i = j.getTreeNodeOffset(h);
            b -= Math.abs(i);
            c[0] += i
        }
        if (a.columnLines) {
            b -= g.getBorderWidth("rl")
        }
        if (d === true) {
            j.field.setWidth(b)
        }
        if (e) {
            h.dom.innerHTML = "X"
        }
        j.alignTo(h, j.alignment, c);
        if (e) {
            h.dom.firstChild.data = k
        }
    },
    getTreeNodeOffset: function (a) {
        return a.child(this.treeNodeSelector).getOffsetsTo(a)[0]
    }
}, 0, 0, ["component", "box", "container", "editor"], {
    component: true,
    box: true,
    container: true,
    editor: true
}, 0, 0, [Ext.grid, "CellEditor"], 0));
(Ext.cmd.derive("Ext.grid.ColumnComponentLayout", Ext.layout.component.Auto, {
    type: "columncomponent",
    setWidthInDom: true,
    _paddingReset: {paddingTop: "", paddingBottom: ""},
    columnAutoCls: "x-column-header-text-container-auto",
    beginLayout: function (a) {
        Ext.layout.component.Auto.prototype.beginLayout.apply(this, arguments);
        a.titleContext = a.getEl("titleEl")
    },
    beginLayoutCycle: function (c) {
        var b = this, a = b.owner, d = c.widthModel.shrinkWrap;
        Ext.layout.component.Auto.prototype.beginLayoutCycle.apply(this, arguments);
        if (d) {
            a.el.setWidth("")
        }
        a.textContainerEl[d ? "addCls" : "removeCls"](b.columnAutoCls);
        a.titleEl.setStyle(b._paddingReset)
    },
    publishInnerHeight: function (d, c) {
        var b = this, a = b.owner, e;
        if (a.getRootHeaderCt().hiddenHeaders) {
            d.setProp("innerHeight", 0);
            return
        }
        if (!d.hasRawContent) {
            if (a.headerWrap && !d.hasDomProp("width")) {
                b.done = false;
                return
            }
            e = c - d.getBorderInfo().height;
            d.setProp("innerHeight", e - a.titleEl.getHeight(), false)
        }
    },
    measureContentHeight: function (a) {
        return a.el.dom.offsetHeight
    },
    publishInnerWidth: function (a, b) {
        if (!a.hasRawContent) {
            a.setProp("innerWidth", b - a.getBorderInfo().width, false)
        }
    },
    calculateOwnerHeightFromContentHeight: function (d, c) {
        var b = Ext.layout.component.Auto.prototype.calculateOwnerHeightFromContentHeight.apply(this, arguments),
            a = this.owner;
        if (!d.hasRawContent) {
            if (!a.headerWrap || d.hasDomProp("width")) {
                return c + a.titleEl.getHeight() + d.getBorderInfo().height
            }
            return null
        }
        return b
    },
    calculateOwnerWidthFromContentWidth: function (g, b) {
        var a = this.owner, e = g.getPaddingInfo().width, d = this.getTriggerOffset(a, g), c;
        if (a.isGroupHeader) {
            c = b
        } else {
            c = Math.max(b, a.textEl.getWidth() + g.titleContext.getPaddingInfo().width)
        }
        return c + e + d
    },
    getTriggerOffset: function (a, c) {
        var b = 0;
        if (c.widthModel.shrinkWrap && !a.menuDisabled) {
            if (a.query(">:not([hidden])").length === 0) {
                b = a.getTriggerElWidth()
            }
        }
        return b
    }
}, 0, 0, 0, 0, ["layout.columncomponent"], 0, [Ext.grid, "ColumnComponentLayout"], 0));
(Ext.cmd.derive("Ext.layout.container.Fit", Ext.layout.container.Container, {
    alternateClassName: "Ext.layout.FitLayout",
    itemCls: "x-fit-item",
    type: "fit",
    manageMargins: true,
    sizePolicies: {
        0: {readsWidth: 1, readsHeight: 1, setsWidth: 0, setsHeight: 0},
        1: {readsWidth: 0, readsHeight: 1, setsWidth: 1, setsHeight: 0},
        2: {readsWidth: 1, readsHeight: 0, setsWidth: 0, setsHeight: 1},
        3: {readsWidth: 0, readsHeight: 0, setsWidth: 1, setsHeight: 1}
    },
    getItemSizePolicy: function (b, c) {
        var a = c || this.owner.getSizeModel(), d = (a.width.shrinkWrap ? 0 : 1) | (a.height.shrinkWrap ? 0 : 2);
        return this.sizePolicies[d]
    },
    beginLayoutCycle: function (k, g) {
        var t = this, u = t.lastHeightModel && t.lastHeightModel.calculated,
            h = t.lastWidthModel && t.lastWidthModel.calculated, o = h || u, l = 0, m = 0, s, b, p, r, e, a, j, n, q, d;
        Ext.layout.container.Container.prototype.beginLayoutCycle.apply(this, arguments);
        if (o && k.targetContext.el.dom.tagName.toUpperCase() !== "TD") {
            o = h = u = false
        }
        b = k.childItems;
        e = b.length;
        for (p = 0; p < e; ++p) {
            r = b[p];
            if (g) {
                s = r.target;
                j = s.minHeight;
                n = s.minWidth;
                if (n || j) {
                    a = r.marginInfo || r.getMarginInfo();
                    j += a.height;
                    n += a.height;
                    if (l < j) {
                        l = j
                    }
                    if (m < n) {
                        m = n
                    }
                }
            }
            if (o) {
                q = r.el.dom.style;
                if (u) {
                    q.height = ""
                }
                if (h) {
                    q.width = ""
                }
            }
        }
        if (g) {
            k.maxChildMinHeight = l;
            k.maxChildMinWidth = m
        }
        s = k.target;
        k.overflowX = (!k.widthModel.shrinkWrap && k.maxChildMinWidth && s.scrollFlags.x) || d;
        k.overflowY = (!k.heightModel.shrinkWrap && k.maxChildMinHeight && s.scrollFlags.y) || d
    },
    calculate: function (g) {
        var o = this, l = g.childItems, d = l.length, c = o.getContainerSize(g),
            e = {length: d, ownerContext: g, targetSize: c}, r = g.widthModel.shrinkWrap, m = g.heightModel.shrinkWrap,
            k = g.overflowX, h = g.overflowY, n, b, p, j, a, q;
        g.state.info = e;
        if (k || h) {
            n = o.getScrollbarsNeeded(k && c.width, h && c.height, g.maxChildMinWidth, g.maxChildMinHeight);
            if (n) {
                b = Ext.getScrollbarSize();
                if (n & 1) {
                    c.height -= b.height
                }
                if (n & 2) {
                    c.width -= b.width
                }
            }
        }
        if (d > 0) {
            for (j = 0; j < d; ++j) {
                e.index = j;
                o.fitItem(l[j], e)
            }
        } else {
            e.contentWidth = e.contentHeight = 0
        }
        if (m || r) {
            p = g.targetContext.getPaddingInfo();
            if (r) {
                if (h && !c.gotHeight) {
                    o.done = false
                } else {
                    a = e.contentWidth + p.width;
                    if (n & 2) {
                        a += b.width
                    }
                    if (!g.setContentWidth(a)) {
                        o.done = false
                    }
                }
            }
            if (m) {
                if (k && !c.gotWidth) {
                    o.done = false
                } else {
                    q = e.contentHeight + p.height;
                    if (n & 1) {
                        q += b.height
                    }
                    if (!g.setContentHeight(q)) {
                        o.done = false
                    }
                }
            }
        }
    },
    fitItem: function (b, c) {
        var a = this;
        if (b.invalid) {
            a.done = false;
            return
        }
        c.margins = b.getMarginInfo();
        c.needed = c.got = 0;
        a.fitItemWidth(b, c);
        a.fitItemHeight(b, c);
        if (c.got !== c.needed) {
            a.done = false
        }
    },
    fitItemWidth: function (c, d) {
        var a, b;
        if (d.ownerContext.widthModel.shrinkWrap) {
            b = c.getProp("width") + d.margins.width;
            a = d.contentWidth;
            if (a === undefined) {
                d.contentWidth = b
            } else {
                d.contentWidth = Math.max(a, b)
            }
        } else {
            if (c.widthModel.calculated) {
                ++d.needed;
                if (d.targetSize.gotWidth) {
                    ++d.got;
                    this.setItemWidth(c, d)
                } else {
                    return
                }
            }
        }
        this.positionItemX(c, d)
    },
    fitItemHeight: function (c, d) {
        var b, a;
        if (d.ownerContext.heightModel.shrinkWrap) {
            a = c.getProp("height") + d.margins.height;
            b = d.contentHeight;
            if (b === undefined) {
                d.contentHeight = a
            } else {
                d.contentHeight = Math.max(b, a)
            }
        } else {
            if (c.heightModel.calculated) {
                ++d.needed;
                if (d.targetSize.gotHeight) {
                    ++d.got;
                    this.setItemHeight(c, d)
                } else {
                    return
                }
            }
        }
        this.positionItemY(c, d)
    },
    positionItemX: function (a, c) {
        var b = c.margins;
        if (c.index || b.left) {
            a.setProp("x", b.left)
        }
        if (b.width) {
            a.setProp("margin-right", b.width)
        }
    },
    positionItemY: function (a, c) {
        var b = c.margins;
        if (c.index || b.top) {
            a.setProp("y", b.top)
        }
        if (b.height) {
            a.setProp("margin-bottom", b.height)
        }
    },
    setItemHeight: function (a, b) {
        a.setHeight(b.targetSize.height - b.margins.height)
    },
    setItemWidth: function (a, b) {
        a.setWidth(b.targetSize.width - b.margins.width)
    }
}, 0, 0, 0, 0, ["layout.fit"], 0, [Ext.layout.container, "Fit", Ext.layout, "FitLayout"], 0));
(Ext.cmd.derive("Ext.panel.Table", Ext.panel.Panel, {
    extraBaseCls: "x-grid",
    extraBodyCls: "x-grid-body",
    actionableModeCls: "x-grid-actionable",
    noHeaderBordersCls: "x-no-header-borders",
    defaultBindProperty: "store",
    layout: "fit",
    ariaRole: "grid",
    config: {selection: null, headerBorders: true},
    publishes: ["selection"],
    twoWayBindable: ["selection"],
    autoLoad: false,
    variableRowHeight: false,
    numFromEdge: 2,
    trailingBufferZone: 10,
    leadingBufferZone: 20,
    hasView: false,
    viewType: null,
    deferRowRender: false,
    sortableColumns: true,
    multiColumnSort: false,
    enableLocking: false,
    scrollerOwner: true,
    enableColumnMove: true,
    sealedColumns: false,
    enableColumnResize: true,
    rowLines: true,
    bufferedRenderer: true,
    ownerGrid: null,
    colLinesCls: "x-grid-with-col-lines",
    rowLinesCls: "x-grid-with-row-lines",
    noRowLinesCls: "x-grid-no-row-lines",
    hiddenHeaderCtCls: "x-grid-header-ct-hidden",
    hiddenHeaderCls: "x-grid-header-hidden",
    resizeMarkerCls: "x-grid-resize-marker",
    emptyCls: "x-grid-empty",
    focusable: true,
    constructor: function (c) {
        var d = this, a = c && c.ownerGrid, b;
        d.ownerGrid = a || d;
        d.actionables = a ? a.actionables : [];
        Ext.panel.Panel.prototype.constructor.call(this, c);
        b = d.store;
        b.trackStateChanges = true;
        if (d.autoLoad) {
            b.unblockLoad();
            if (!b.isEmptyStore) {
                b.load()
            }
        }
    },
    registerActionable: function (a) {
        Ext.Array.include(this.actionables, a)
    },
    initComponent: function () {
        var h = this, e = h.columns || h.colModel || [], k, j, d, g, l, c, b, a;
        k = h.store = Ext.data.StoreManager.lookup(h.store || "ext-empty-store");
        h.enableLocking = h.enableLocking || h.hasLockedColumns(e);
        if (h.autoLoad) {
            h.store.blockLoad()
        }
        if (h.plugins) {
            h.plugins = h.constructPlugins()
        }
        if (h.columnLines) {
            h.addBodyCls(h.colLinesCls)
        }
        h.addBodyCls(h.rowLines ? h.rowLinesCls : h.noRowLinesCls);
        h.addBodyCls(h.extraBodyCls);
        if (h.enableLocking) {
            h.self.mixin("lockable", Ext.grid.locking.Lockable);
            h.injectLockable();
            a = h.headerCt
        } else {
            if (e.isRootHeader) {
                if (h.hideHeaders) {
                    e.setHeight(0);
                    e.hiddenHeaders = true
                }
                h.headerCt = a = e;
                a.grid = h;
                a.forceFit = !!h.forceFit;
                a.$initParent = h;
                h.columnManager = e.columnManager;
                h.visibleColumnManager = e.visibleColumnManager
            } else {
                if (Ext.isArray(e)) {
                    e = {items: e}
                }
                Ext.apply(e, {
                    grid: h,
                    $initParent: h,
                    forceFit: h.forceFit,
                    sortable: h.sortableColumns,
                    enableColumnMove: h.enableColumnMove,
                    enableColumnResize: h.enableColumnResize,
                    columnLines: h.columnLines,
                    sealed: h.sealedColumns
                });
                if (h.hideHeaders) {
                    e.height = 0;
                    e.hiddenHeaders = true
                }
                if (Ext.isDefined(h.enableColumnHide)) {
                    e.enableColumnHide = h.enableColumnHide
                }
                h.headerCt = a = new Ext.grid.header.Container(e)
            }
            a.setScrollable({x: false, y: false})
        }
        h.columns = c = a.getGridColumns();
        h.scrollTask = new Ext.util.DelayedTask(h.syncHorizontalScroll, h);
        h.cls = (h.cls || "") + (" " + h.extraBaseCls);
        delete h.autoScroll;
        l = h.plugins && Ext.Array.findBy(h.plugins, function (i) {
            return i.isBufferedRenderer
        });
        if (l) {
            h.bufferedRenderer = l
        }
        if (!h.hasView) {
            if (k.isBufferedStore && !k.getRemoteSort()) {
                for (d = 0, g = c.length; d < g; d++) {
                    c[d].sortable = false
                }
            }
            if (h.hideHeaders) {
                h.headerCt.addCls(h.hiddenHeaderCtCls);
                h.addCls(h.hiddenHeaderCls)
            }
            h.relayHeaderCtEvents(a);
            h.features = h.features || [];
            if (!Ext.isArray(h.features)) {
                h.features = [h.features]
            }
            h.dockedItems = [].concat(h.dockedItems || []);
            h.dockedItems.unshift(a);
            h.viewConfig = h.viewConfig || {};
            j = h.getView();
            h.items = [j];
            h.hasView = true;
            if (!h.hideHeaders) {
                b = j.getScrollable();
                if (b) {
                    a.getScrollable().addPartner(b, "x")
                }
            }
            h.bindStore(k, true);
            h.mon(j, {viewready: h.onViewReady, refresh: h.onRestoreHorzScroll, scope: h})
        }
        h.selModel = h.view.getSelectionModel();
        if (h.selModel.isRowModel) {
            h.selModel.on({
                scope: h,
                lastselectedchanged: h.updateBindSelection,
                selectionchange: h.updateBindSelection
            })
        }
        h.relayEvents(h.view, ["beforeitemmousedown", "beforeitemmouseup", "beforeitemmouseenter", "beforeitemmouseleave", "beforeitemclick", "beforeitemdblclick", "beforeitemcontextmenu", "itemmousedown", "itemmouseup", "itemmouseenter", "itemmouseleave", "itemclick", "itemdblclick", "itemcontextmenu", "beforecellclick", "cellclick", "beforecelldblclick", "celldblclick", "beforecellcontextmenu", "cellcontextmenu", "beforecellmousedown", "cellmousedown", "beforecellmouseup", "cellmouseup", "beforecellkeydown", "cellkeydown", "rowclick", "rowdblclick", "rowcontextmenu", "rowmousedown", "rowmouseup", "rowkeydown", "beforeitemkeydown", "itemkeydown", "beforeitemkeyup", "itemkeyup", "beforeitemkeypress", "itemkeypress", "beforecontainermousedown", "beforecontainermouseup", "beforecontainermouseover", "beforecontainermouseout", "beforecontainerclick", "beforecontainerdblclick", "beforecontainercontextmenu", "beforecontainerkeydown", "beforecontainerkeyup", "beforecontainerkeypress", "containermouseup", "containermousedown", "containermouseover", "containermouseout", "containerclick", "containerdblclick", "containercontextmenu", "containerkeydown", "containerkeyup", "containerkeypress", "selectionchange", "beforeselect", "select", "beforedeselect", "deselect"]);
        Ext.panel.Panel.prototype.initComponent.call(this);
        if (h.enableLocking) {
            h.afterInjectLockable()
        } else {
            delete a.$initParent
        }
        h.addStateEvents(["columnresize", "columnmove", "columnhide", "columnshow", "sortchange", "filterchange", "groupchange"])
    },
    beforeRender: function () {
        var b = this, c = b.bufferedRenderer, a;
        if (b.lockable) {
            b.getProtoBody().addCls(b.lockingBodyCls)
        } else {
            if (c && b.getSizeModel().height.auto) {
                b.bufferedRenderer = c = false
            }
            if (c && !c.isBufferedRenderer) {
                c = {xclass: "Ext.grid.plugin.BufferedRenderer"};
                Ext.copyTo(c, b, "variableRowHeight,numFromEdge,trailingBufferZone,leadingBufferZone,scrollToLoadBuffer");
                b.bufferedRenderer = b.addPlugin(c)
            }
            a = b.ariaRenderAttributes || (b.ariaRenderAttributes = {});
            a["aria-readonly"] = !b.isEditable;
            a["aria-multiselectable"] = b.selModel.selectionMode !== "SINGLE"
        }
        Ext.panel.Panel.prototype.beforeRender.apply(this, arguments)
    },
    onRender: function () {
        var b = this, a, c;
        if (b.isLocked && b.getSizeModel().width.shrinkWrap) {
            b.shrinkWrapColumns = true;
            c = b.headerCt.getTableWidth();
            a = b.gridPanelBorderWidth || (b.gridPanelBorderWidth = b.el.getBorderWidth("lr"));
            b.width = c + a
        }
        Ext.panel.Panel.prototype.onRender.call(this)
    },
    getHeaderContainer: function () {
        return this.getView().getHeaderCt()
    },
    getColumns: function () {
        return this.getColumnManager().getColumns()
    },
    getVisibleColumns: function () {
        return this.getVisibleColumnManager().getColumns()
    },
    focus: function () {
        this.getView().focus()
    },
    disableColumnHeaders: function () {
        this.headerCt.disable()
    },
    enableColumnHeaders: function () {
        this.headerCt.enable()
    },
    hasLockedColumns: function (c) {
        var b, a, d;
        if (c.isRootHeader) {
            c = c.items.items
        } else {
            if (Ext.isObject(c)) {
                c = c.items
            }
        }
        for (b = 0, a = c.length; b < a; b++) {
            d = c[b];
            if (!d.processed && d.locked) {
                return true
            }
        }
    },
    relayHeaderCtEvents: function (a) {
        this.relayEvents(a, ["columnresize", "columnmove", "columnhide", "columnshow", "columnschanged", "sortchange", "headerclick", "headercontextmenu", "headertriggerclick"])
    },
    getState: function () {
        var b = this, c = Ext.panel.Panel.prototype.getState.call(this), a = b.store.getState();
        c = b.addPropertyToState(c, "columns", b.headerCt.getColumnsState());
        if (a) {
            c.storeState = a
        }
        return c
    },
    applyState: function (e) {
        var d = this, g = e.sort, a = e.storeState, b = d.store, c = e.columns;
        delete e.columns;
        Ext.panel.Panel.prototype.applyState.apply(this, arguments);
        if (c) {
            d.headerCt.applyColumnsState(c)
        }
        if (g) {
            if (b.getRemoteSort()) {
                b.sort({property: g.property, direction: g.direction, root: g.root}, null, false)
            } else {
                b.sort(g.property, g.direction)
            }
        } else {
            if (a) {
                b.applyState(a)
            }
        }
    },
    getStore: function () {
        return this.store
    },
    getView: function () {
        var c = this, a, d, b;
        if (!c.view) {
            b = c.viewConfig;
            a = b.scroll || c.scroll;
            d = c.scrollable;
            if (d == null && b.scrollable == null && a !== null) {
                if (a === true || a === "both") {
                    d = true
                } else {
                    if (a === false || a === "none") {
                        d = false
                    } else {
                        if (a === "vertical") {
                            d = {x: false, y: true}
                        } else {
                            if (a === "horizontal") {
                                d = {x: true, y: false}
                            }
                        }
                    }
                }
            }
            b = Ext.apply({
                grid: c,
                ownerGrid: c.ownerGrid,
                deferInitialRefresh: c.deferRowRender,
                variableRowHeight: c.variableRowHeight,
                preserveScrollOnRefresh: true,
                trackOver: c.trackMouseOver !== false,
                throttledUpdate: c.throttledUpdate === true,
                xtype: c.viewType,
                store: c.store,
                headerCt: c.headerCt,
                columnLines: c.columnLines,
                rowLines: c.rowLines,
                navigationModel: "grid",
                features: c.features,
                panel: c,
                emptyText: c.emptyText || ""
            }, c.viewConfig);
            if (d != null) {
                b.scrollable = d;
                c.scrollable = null
            }
            Ext.create(b);
            if (c.view.emptyText) {
                c.view.emptyText = '<div class="' + c.emptyCls + '">' + c.view.emptyText + "</div>"
            }
            c.view.getComponentLayout().headerCt = c.headerCt;
            c.mon(c.view, {uievent: c.processEvent, scope: c});
            c.headerCt.view = c.view;
            if (c.hasListeners.viewcreated) {
                c.fireEvent("viewcreated", c, c.view)
            }
        }
        return c.view
    },
    getColumnManager: function () {
        return this.columnManager
    },
    getVisibleColumnManager: function () {
        return this.visibleColumnManager
    },
    getTopLevelColumnManager: function () {
        return this.ownerGrid.getColumnManager()
    },
    getTopLevelVisibleColumnManager: function () {
        return this.ownerGrid.getVisibleColumnManager()
    },
    setAutoScroll: Ext.emptyFn,
    applyScrollable: function (a) {
        if (this.view) {
            this.view.setScrollable(a)
        }
        return a
    },
    getScrollable: function () {
        return null
    },
    processEvent: function (g, i, j, a, h, d, c, k) {
        var b = d.position.column;
        if (b) {
            return b.processEvent.apply(b, arguments)
        }
    },
    ensureVisible: function (a, b) {
        this.doEnsureVisible(a, b)
    },
    scrollByDeltaY: function (b, a) {
        this.getView().scrollBy(0, b, a)
    },
    scrollByDeltaX: function (b, a) {
        this.getView().scrollBy(b, 0, a)
    },
    afterCollapse: function () {
        this.saveScrollPos();
        Ext.panel.Panel.prototype.afterCollapse.apply(this, arguments)
    },
    afterExpand: function () {
        Ext.panel.Panel.prototype.afterExpand.apply(this, arguments);
        this.restoreScrollPos()
    },
    saveScrollPos: Ext.emptyFn,
    restoreScrollPos: Ext.emptyFn,
    onHeaderResize: function () {
        var a = this.view.getScrollable(), b;
        if (a && a.isTouchScroller) {
            b = a.getSize();
            if (b) {
                a.setSize({x: this.headerCt.getTableWidth(), y: b.y})
            }
        }
    },
    onHeaderMove: function (e, g, a, b, d) {
        var c = this;
        if (c.optimizedColumnMove === false) {
            c.view.refreshView()
        } else {
            c.view.moveColumn(b, d, a)
        }
        c.delayScroll()
    },
    onHeaderHide: function (b, c) {
        var a = this.view;
        if (!b.childHideCount && a.refreshCounter) {
            a.refreshView()
        }
    },
    onHeaderShow: function (b, c) {
        var a = this.view;
        if (a.refreshCounter) {
            a.refreshView()
        }
    },
    onHeadersChanged: function (b, c) {
        var a = this;
        if (a.rendered && !a.reconfiguring) {
            a.view.refreshView();
            a.delayScroll()
        }
    },
    delayScroll: function () {
        var a = this.view;
        if (a) {
            this.scrollTask.delay(10, null, null, [a])
        }
    },
    onViewReady: function () {
        this.fireEvent("viewready", this)
    },
    onRestoreHorzScroll: function () {
        var b = this, a = b.scrollXPos;
        if (a) {
            b.syncHorizontalScroll(b, true)
        }
    },
    getScrollerOwner: function () {
        var a = this;
        if (!this.scrollerOwner) {
            a = this.up("[scrollerOwner]")
        }
        return a
    },
    getLhsMarker: function () {
        var a = this;
        return a.lhsMarker || (a.lhsMarker = Ext.DomHelper.append(a.el, {
            role: "presentation",
            cls: a.resizeMarkerCls
        }, true))
    },
    getRhsMarker: function () {
        var a = this;
        return a.rhsMarker || (a.rhsMarker = Ext.DomHelper.append(a.el, {
            role: "presentation",
            cls: a.resizeMarkerCls
        }, true))
    },
    getSelection: function () {
        return this.getSelectionModel().getSelection()
    },
    updateSelection: function (a) {
        var b = this, c;
        if (!b.ignoreNextSelection) {
            b.ignoreNextSelection = true;
            c = b.getSelectionModel();
            if (a) {
                c.select(a)
            } else {
                c.deselectAll()
            }
            b.ignoreNextSelection = false
        }
    },
    updateBindSelection: function (a, c) {
        var d = this, b = null;
        if (!d.ignoreNextSelection) {
            d.ignoreNextSelection = true;
            if (c.length) {
                b = a.getLastSelected();
                d.hasHadSelection = true
            }
            if (d.hasHadSelection) {
                d.setSelection(b)
            }
            d.ignoreNextSelection = false
        }
    },
    updateHeaderBorders: function (a) {
        this[a ? "removeCls" : "addCls"](this.noHeaderBordersCls)
    },
    getNavigationModel: function () {
        return this.getView().getNavigationModel()
    },
    getSelectionModel: function () {
        return this.getView().getSelectionModel()
    },
    getScrollTarget: function () {
        var a = this.getScrollerOwner().query("tableview");
        return a[a.length - 1]
    },
    syncHorizontalScroll: function (e, c) {
        var d = this, a = d.view.getScrollX(), b;
        c = c === true;
        if (d.rendered && (c || a !== d.scrollXPos)) {
            if (c) {
                b = d.getScrollTarget();
                b.setScrollX(a)
            }
            d.headerCt.setScrollX(a);
            d.scrollXPos = a
        }
    },
    onStoreLoad: Ext.emptyFn,
    getEditorParent: function () {
        return this.body
    },
    bindStore: function (b, c) {
        var d = this, a = d.getView();
        if (b) {
            d.store = b;
            if (a.store !== b) {
                a.bindStore(b, false)
            }
            d.mon(b, {load: d.onStoreLoad, scope: d});
            d.storeRelayers = d.relayEvents(b, ["filterchange", "groupchange"])
        } else {
            d.unbindStore()
        }
    },
    unbindStore: function () {
        var c = this, b = c.store, a;
        if (b) {
            c.store = null;
            c.mun(b, {load: c.onStoreLoad, scope: c});
            Ext.destroy(c.storeRelayers);
            a = c.view;
            if (a.store) {
                a.bindStore(null)
            }
        }
    },
    setColumns: function (a) {
        if (a.length || this.getColumnManager().getColumns().length) {
            this.reconfigure(undefined, a)
        }
    },
    setStore: function (a) {
        this.reconfigure(a);
        if (this.autoLoad && !(a.loading || a.isLoaded())) {
            a.load()
        }
    },
    reconfigure: function (k, c) {
        var h = this, a = h.store, b = h.headerCt, j = h.lockable, e = b ? b.items.getRange() : h.columns,
            i = h.getView(), d, g;
        if (arguments.length === 1 && Ext.isArray(k)) {
            c = k;
            k = null
        }
        if (c) {
            c = Ext.Array.slice(c)
        }
        h.reconfiguring = true;
        if (k) {
            k = Ext.StoreManager.lookup(k)
        }
        h.fireEvent("beforereconfigure", h, k, c, a, e);
        Ext.suspendLayouts();
        if (j) {
            h.reconfigureLockable(k, c)
        } else {
            d = i.blockRefresh;
            i.blockRefresh = true;
            if (k && k !== a) {
                h.unbindStore();
                h.bindStore(k)
            }
            if (c) {
                delete h.scrollXPos;
                b.removeAll();
                b.add(c)
            }
            i.blockRefresh = d;
            g = i.refreshCounter
        }
        Ext.resumeLayouts(true);
        if (j) {
            h.afterReconfigureLockable()
        } else {
            if (i.refreshCounter === g) {
                i.refreshView()
            }
        }
        h.fireEvent("reconfigure", h, k, c, a, e);
        delete h.reconfiguring
    },
    beforeDestroy: function () {
        var b = this, a = b.scrollTask;
        if (a) {
            a.cancel();
            b.scrollTask = null
        }
        Ext.destroy(b.focusEnterLeaveListeners);
        Ext.panel.Panel.prototype.beforeDestroy.call(this)
    },
    onDestroy: function () {
        var a = this;
        if (a.lockable) {
            a.destroyLockable()
        }
        a.unbindStore();
        Ext.panel.Panel.prototype.onDestroy.call(this);
        a.columns = a.storeRelayers = a.columnManager = a.visibleColumnManager = null
    },
    destroy: function () {
        var a = this;
        Ext.panel.Panel.prototype.destroy.call(this);
        if (a.destroyed) {
            a.view = a.selModel = a.headerCt = null
        }
    },
    privates: {
        initFocusableElement: function () {
        }, doEnsureVisible: function (d, m) {
            if (this.lockable) {
                return this.ensureLockedVisible(d, m)
            }
            if (typeof d !== "number" && !d.isEntity) {
                d = this.store.getById(d)
            }
            var e = this, h = e.getView(), c = h.getNode(d), j, k, a, b, i, l, g;
            if (m) {
                j = m.callback;
                k = m.scope;
                a = m.animate;
                b = m.highlight;
                i = m.select;
                l = m.focus
            }
            if (e.deferredEnsureVisible) {
                e.deferredEnsureVisible.destroy()
            }
            if (!h.viewReady) {
                e.deferredEnsureVisible = h.on({
                    boxready: e.doEnsureVisible,
                    args: Ext.Array.slice(arguments),
                    scope: e,
                    single: true,
                    destroyable: true
                });
                return
            }
            if (c) {
                g = h.getScrollable();
                if (g) {
                    g.scrollIntoView(c, null, a, b)
                }
                if (!d.isEntity) {
                    d = h.getRecord(c)
                }
                if (i) {
                    h.getSelectionModel().select(d)
                }
                if (l) {
                    h.getNavigationModel().setPosition(d, 0)
                }
                Ext.callback(j, k || e, [true, d, c])
            } else {
                if (h.bufferedRenderer) {
                    h.bufferedRenderer.scrollTo(d, {
                        animate: a,
                        highlight: b,
                        select: i,
                        focus: l,
                        callback: function (p, n, o) {
                            Ext.callback(j, k || e, [true, n, o])
                        }
                    })
                } else {
                    Ext.callback(j, k || e, [false, null])
                }
            }
        }, getFocusEl: function () {
            return this.getView().getFocusEl()
        }, setActionableMode: function (b, a) {
            var c = this.ownerGrid;
            if (!c.destroying && c.view.setActionableMode(b, a) !== false) {
                c.fireEvent("actionablemodechange", b);
                c[b ? "addCls" : "removeCls"](c.actionableModeCls);
                return true
            }
        }
    }
}, 1, ["tablepanel"], ["component", "box", "container", "panel", "tablepanel"], {
    component: true,
    box: true,
    container: true,
    panel: true,
    tablepanel: true
}, ["widget.tablepanel"], 0, [Ext.panel, "Table"], 0));
(Ext.cmd.derive("Ext.grid.ColumnLayout", Ext.layout.container.HBox, {
    type: "gridcolumn",
    firstHeaderCls: "x-column-header-first",
    lastHeaderCls: "x-column-header-last",
    initLayout: function () {
        Ext.layout.container.HBox.prototype.initLayout.call(this);
        if (this.scrollbarWidth === undefined) {
            this.self.prototype.scrollbarWidth = Ext.getScrollbarSize().width
        }
    },
    beginLayout: function (c) {
        var j = this, a = j.owner, k = a.grid ? a.grid.getView() : null, d = j.firstHeaderCls, m = j.lastHeaderCls,
            b = [d, m], h = j.getVisibleItems(), g = h.length, e, l;
        if (k && k.scrollFlags.x) {
            j.viewScrollX = k.getScrollX();
            a.suspendEvent("scroll");
            k.suspendEvent("scroll")
        }
        Ext.layout.container.HBox.prototype.beginLayout.call(this, c);
        for (e = 0; e < g; e++) {
            l = h[e];
            if (g === 1) {
                l.addCls(b)
            } else {
                if (e === 0) {
                    l.addCls(d);
                    l.removeCls(m)
                } else {
                    if (e === g - 1) {
                        l.removeCls(d);
                        l.addCls(m)
                    } else {
                        l.removeCls(b)
                    }
                }
            }
        }
        j.scrollbarWidth = 0;
        if (a.isRootHeader) {
            j.determineScrollbarWidth(c)
        }
        if (!j.scrollbarWidth) {
            c.manageScrollbar = false
        }
    },
    moveItemBefore: function (b, c) {
        var a = b.ownerCt;
        if (b !== c && a) {
            a.remove(b, false)
        }
        return Ext.layout.container.HBox.prototype.moveItemBefore.call(this, b, c)
    },
    determineScrollbarWidth: function (h) {
        var g = this, a = g.owner, e = a.grid, c = a.reserveScrollbar === false, b = e.reserveScrollbar && !c,
            d = !b && !c && e.view.scrollFlags.y;
        h.manageScrollbar = d;
        if (!e.ownerGrid.collapsed && (b || d)) {
            delete g.scrollbarWidth
        }
    },
    calculate: function (d) {
        var p = this, a = p.owner.grid, l = d.viewContext, b = d.state, c = d.context, k, q, m, h, o, n, g, j, e;
        Ext.layout.container.HBox.prototype.calculate.call(this, d);
        if (a && b.parallelDone) {
            k = l.lockingPartnerContext;
            q = a.ownerGrid;
            if (q.forceFit && !b.reflexed) {
                if (p.convertWidthsToFlexes(d)) {
                    p.cacheFlexes(d);
                    p.done = false;
                    d.invalidate({state: {reflexed: true, scrollbarAdjustment: p.getScrollbarAdjustment(d)}});
                    return
                }
            }
            if ((m = b.columnsChanged) === undefined) {
                h = d.target.getVisibleGridColumns();
                m = false;
                for (n = 0, o = h.length; n < o; n++) {
                    g = c.getCmp(h[n]);
                    if (!g.lastBox || g.props.width !== g.lastBox.width) {
                        (m || (m = []))[n] = g
                    }
                }
                b.columnsChanged = m;
                d.setProp("columnsChanged", m)
            }
            if (d.manageScrollbar) {
                j = p.getScrollbarAdjustment(d);
                if (j) {
                    e = l.getProp("viewOverflowY");
                    if (e === undefined) {
                        p.done = false;
                        return
                    }
                    if (!e) {
                        if (k) {
                            k.invalidate();
                            k.headerContext.invalidate()
                        }
                        l.invalidate();
                        d.invalidate({state: {scrollbarAdjustment: 0}})
                    }
                }
            }
        }
    },
    finishedLayout: function (d) {
        var c = this, a = c.owner, b = a.grid ? a.grid.getView() : null, e = c.viewScrollX;
        Ext.layout.container.HBox.prototype.finishedLayout.call(this, d);
        if (b && b.scrollFlags.x) {
            if (e !== undefined && a.tooNarrow && a.componentLayoutCounter) {
                a.setScrollX(e)
            }
            b.resumeEvent("scroll");
            a.resumeEvent("scroll")
        }
        if (a.ariaRole === "rowgroup") {
            c.innerCt.dom.setAttribute("role", "row")
        }
    },
    convertWidthsToFlexes: function (a) {
        var g = this, d = 0, h = g.sizeModels.calculated, c, e, b, k, j;
        c = a.childItems;
        e = c.length;
        for (b = 0; b < e; b++) {
            k = c[b];
            j = k.target;
            d += k.props.width;
            if (!(j.fixed || j.resizable === false)) {
                j.flex = a.childItems[b].flex = k.props.width;
                j.width = null;
                k.widthModel = h
            }
        }
        return d !== a.props.width
    },
    getScrollbarAdjustment: function (d) {
        var b = this, c = d.state, a = b.owner.grid, e = c.scrollbarAdjustment;
        if (e === undefined) {
            e = 0;
            if (a.reserveScrollbar || (d.manageScrollbar && !a.ownerGrid.layout.ownerContext.heightModel.shrinkWrap)) {
                e = b.scrollbarWidth
            }
            c.scrollbarAdjustment = e
        }
        return e
    },
    getContainerSize: function (b) {
        var e = this, g, i, h, c, d, a, j, k;
        if (e.owner.isRootHeader) {
            k = Ext.layout.container.HBox.prototype.getContainerSize.call(this, b);
            if (k.gotWidth) {
                k.width -= e.getScrollbarAdjustment(b)
            }
        } else {
            h = b.paddingContext.getPaddingInfo();
            g = i = 0;
            if (!b.widthModel.shrinkWrap) {
                ++i;
                a = b.getProp("innerWidth");
                c = (typeof a === "number");
                if (c) {
                    ++g;
                    a -= h.width;
                    if (a < 0) {
                        a = 0
                    }
                }
            }
            if (!b.heightModel.shrinkWrap) {
                ++i;
                j = b.getProp("innerHeight");
                d = (typeof j === "number");
                if (d) {
                    ++g;
                    j -= h.height;
                    if (j < 0) {
                        j = 0
                    }
                }
            }
            return {width: a, height: j, needed: i, got: g, gotAll: g === i, gotWidth: c, gotHeight: d}
        }
        return k
    },
    publishInnerCtSize: function (e) {
        var d = this, a = d.owner, b = e.peek("contentWidth"), c = 0;
        if (b != null && a.isRootHeader) {
            c = -e.state.scrollbarAdjustment
        }
        return Ext.layout.container.HBox.prototype.publishInnerCtSize.call(this, e, c)
    }
}, 0, 0, 0, 0, ["layout.gridcolumn"], 0, [Ext.grid, "ColumnLayout"], 0));
(Ext.cmd.derive("Ext.grid.ColumnManager", Ext.Base, {
    alternateClassName: ["Ext.grid.ColumnModel"], columns: null, constructor: function (b, c, a) {
        this.headerCt = c;
        if (a) {
            this.secondHeaderCt = a
        }
        this.visibleOnly = !!b
    }, getColumns: function () {
        if (!this.columns) {
            this.cacheColumns()
        }
        return this.columns
    }, hasVariableRowHeight: function () {
        var d = this, c = d.getColumns(), a = c.length, b;
        if (d.variableRowHeight == null) {
            d.variableRowHeight = false;
            for (b = 0; !d.variableRowHeight && b < a; b++) {
                d.variableRowHeight = !!c[b].variableRowHeight
            }
        }
        return d.variableRowHeight
    }, getHeaderIndex: function (a) {
        if (a.isGroupHeader) {
            a = this.getHeaderColumns(a)[0]
        }
        return Ext.Array.indexOf(this.getColumns(), a)
    }, getHeaderAtIndex: function (b) {
        var c = this.getColumns(), a = c[b];
        return a || null
    }, getPreviousSibling: function (c) {
        var b = this.getHeaderIndex(c), a = null;
        if (b > 0) {
            a = this.getColumns()[b - 1]
        }
        return a
    }, getNextSibling: function (c) {
        var b = this.getHeaderIndex(c), a;
        if (b !== -1) {
            a = this.getColumns()[b + 1]
        }
        return a || null
    }, getFirst: function () {
        var a = this.getColumns();
        return a.length > 0 ? a[0] : null
    }, getLast: function () {
        var b = this.getColumns(), a = b.length;
        return a > 0 ? b[a - 1] : null
    }, getHeaderByDataIndex: function (d) {
        var c = this.getColumns(), a = c.length, b, e;
        for (b = 0; b < a; ++b) {
            e = c[b];
            if (e.dataIndex === d) {
                return e
            }
        }
        return null
    }, getHeaderById: function (e) {
        var c = this.getColumns(), a = c.length, b, d;
        for (b = 0; b < a; ++b) {
            d = c[b];
            if (d.getItemId() === e) {
                return d
            }
        }
        return null
    }, getVisibleHeaderClosestToIndex: function (b) {
        var a = this.getHeaderAtIndex(b);
        if (a && a.hidden) {
            a = a.next(":not([hidden])") || a.prev(":not([hidden])")
        }
        return a
    }, cacheColumns: function () {
        var b = this.getHeaderColumns(this.headerCt), a = this.secondHeaderCt;
        if (a) {
            b = b.concat(this.getHeaderColumns(a))
        }
        this.columns = b
    }, getHeaderColumns: function (b) {
        var a = this.visibleOnly ? b.getVisibleGridColumns() : b.getGridColumns();
        return Ext.Array.clone(a)
    }, invalidate: function () {
        var a = this.rootColumns;
        this.columns = this.variableRowHeight = null;
        if (a) {
            a.invalidate()
        }
    }, destroy: function () {
        this.columns = this.rootColumns = null;
        this.callParent()
    }
}, 1, 0, 0, 0, 0, 0, [Ext.grid, "ColumnManager", Ext.grid, "ColumnModel"], function () {
    this.createAlias("indexOf", "getHeaderIndex")
}));
(Ext.cmd.derive("Ext.grid.NavigationModel", Ext.view.NavigationModel, {
    focusCls: "x-grid-item-focused", getViewListeners: function () {
        var a = this;
        return {
            focusmove: {element: "el", fn: a.onFocusMove},
            containermousedown: a.onContainerMouseDown,
            cellmousedown: a.onCellMouseDown,
            cellclick: a.onCellClick,
            itemmousedown: a.onItemMouseDown,
            itemclick: a.onItemClick,
            itemcontextmenu: a.onItemClick,
            scope: a
        }
    }, initKeyNav: function (a) {
        var b = this;
        if (!b.keyNav) {
            b.keyNav = [];
            b.position = new Ext.grid.CellContext(a)
        }
        b.keyNav.push(new Ext.util.KeyNav({
            target: a,
            ignoreInputFields: true,
            eventName: "itemkeydown",
            defaultEventAction: "stopEvent",
            processEvent: b.processViewEvent,
            up: b.onKeyUp,
            down: b.onKeyDown,
            right: b.onKeyRight,
            left: b.onKeyLeft,
            pageDown: b.onKeyPageDown,
            pageUp: b.onKeyPageUp,
            home: b.onKeyHome,
            end: b.onKeyEnd,
            space: b.onKeySpace,
            enter: b.onKeyEnter,
            esc: b.onKeyEsc,
            113: b.onKeyF2,
            tab: b.onKeyTab,
            A: {ctrl: true, handler: b.onSelectAllKeyPress},
            scope: b
        }))
    }, addKeyBindings: function (c) {
        var a = this.keyNav.length, b;
        for (b = 0; b < a; b++) {
            this.keyNav[b].addBindings(c)
        }
    }, enable: function () {
        var a = this.keyNav.length, b;
        for (b = 0; b < a; b++) {
            this.keyNav[b].enable()
        }
        this.disabled = false
    }, disable: function () {
        var a = this.keyNav.length, b;
        for (b = 0; b < a; b++) {
            this.keyNav[b].disable()
        }
        this.disabled = true
    }, processViewEvent: function (b, a, g, c, e) {
        var d = e.getKey();
        if (b.actionableMode) {
            this.map.ignoreInputFields = false;
            if (d === e.TAB || d === e.ESC || d === e.F2) {
                return e
            }
        } else {
            this.map.ignoreInputFields = true;
            return d === e.TAB ? null : e
        }
    }, onCellMouseDown: function (g, i, e, d, k, c, b) {
        var h = b.parentEvent, a = Ext.Component.fromElement(b.target, i), j;
        if (g.actionableMode && (b.getTarget(null, null, true).isTabbable() || ((j = Ext.ComponentManager.getActiveComponent()) && j.owns(b)))) {
            return
        }
        if ((!h || h.type !== "touchstart")) {
            this.setPosition(b.position, null, b)
        }
        if (a && a.isFocusable && a.isFocusable()) {
            g.setActionableMode(true, b.position);
            a.focus()
        }
    }, onCellClick: function (g, h, e, c, k, b, i) {
        var d = this, a = Ext.Component.fromElement(i.target, h), j = a && a.isFocusable && a.isFocusable();
        if (g.actionableMode) {
            d.fireEvent("navigate", {
                view: g,
                navigationModel: d,
                keyEvent: i,
                previousPosition: d.previousPosition,
                previousRecordIndex: d.previousRecordIndex,
                previousRecord: d.previousRecord,
                previousItem: d.previousItem,
                previousCell: d.previousCell,
                previousColumnIndex: d.previousColumnIndex,
                previousColumn: d.previousColumn,
                position: i.position,
                recordIndex: i.position.rowIdx,
                record: i.position.record,
                item: i.item,
                cell: i.position.cellElement,
                columnIndex: i.position.colIdx,
                column: i.position.column
            })
        } else {
            if (this.position.isEqual(i.position) || j) {
                this.fireNavigateEvent(i)
            } else {
                this.setPosition(i.position, null, i)
            }
        }
    }, onFocusMove: function (h) {
        var a = h.target, c = Ext.Component.fromElement(h.delegatedTarget, null, "tableview"), a = h.target, b, g, d;
        if (c && Ext.fly(a).is(c.cellSelector)) {
            if (c.actionableModeTabbing) {
                return
            }
            c.ownerGrid.setActionableMode(false);
            b = c.getRecord(a);
            g = c.getHeaderByCell(a);
            if (b && g) {
                d = new Ext.grid.CellContext(c).setPosition(b, g);
                if (!d.isEqual(this.position)) {
                    this.setPosition(d)
                }
            }
        }
    }, onItemMouseDown: function (b, a, h, d, c) {
        var g = this, e = c.parentEvent;
        if (!c.position.cellElement && (!e || e.type !== "touchstart")) {
            g.getClosestCell(c);
            g.setPosition(c.position, null, c)
        }
    }, onItemClick: function (c, b, e, d, a) {
        if (!a.position.cellElement) {
            this.getClosestCell(a);
            this.fireNavigateEvent(a)
        }
    }, getClosestCell: function (a) {
        var h = a.position, c = h.cellElement, l, e, j, g, d, k;
        if (!c) {
            l = a.getX();
            e = h.view.getVisibleColumnManager().getColumns();
            j = e.length;
            for (g = 0; g < j; g++) {
                d = e[g];
                k = e[g].getBox();
                if (l >= k.left && l < k.right) {
                    h.setColumn(e[g]);
                    h.rowElement = h.getRow(true);
                    h.cellElement = h.getCell(true);
                    return
                }
            }
        }
    }, beforeViewRefresh: function (b) {
        var a = this.getPosition();
        if (a && a.view === b) {
            this.focusRestorePosition = a.clone()
        } else {
            this.focusRestorePosition = null
        }
    }, onStoreRemove: function (a) {
        var b = this, c = b.view.ownerGrid.actionableMode, d = c ? b.actionPosition : b.getPosition();
        if (d && d.view.el.contains(Ext.Element.getActiveElement())) {
            d.view.refreshing = true;
            Ext.on({idle: b.afterStoreRemove, scope: b, single: true, args: [c, d.clone(), a]})
        }
    }, afterStoreRemove: function (e, g, b) {
        var d = this, a = g.view, c = a.ownerGrid;
        a.refreshing = false;
        if (!b.getCount()) {
            if (e) {
                c.setActionableMode(false)
            } else {
                d.setPosition(null, null, null, null, true)
            }
            g.column.focus();
            return
        }
        if (!g.view.el.contains(Ext.Element.getActiveElement())) {
            g = new Ext.grid.CellContext(a).setPosition(b.contains(g.record) ? g.record : Math.min(g.rowIdx, a.dataSource.getCount() - 1), g.colIdx);
            if (e) {
                c.setActionableMode(false);
                if (!c.setActionableMode(true, g)) {
                    d.setPosition(g, null, null, null, true)
                }
            } else {
                d.setPosition(g, null, null, null, true)
            }
        }
    }, deferSetPosition: function (c, b, d, g, a, h) {
        var e = this.view.getFocusTask();
        e.delay(c, this.setPosition, this, [b, d, g, a, h]);
        return e
    }, setPosition: function (g, m, n, r, i) {
        var o = this, q, k, j, a, c, b, d, l, h, p = g == null && m == null,
            e = o.record == null && o.recordIndex == null && o.item == null;
        if (g && g.isCellContext) {
            q = g.view
        } else {
            if (n && n.view) {
                q = n.view
            } else {
                if (o.lastFocused) {
                    q = o.lastFocused.view
                } else {
                    q = o.view
                }
            }
        }
        q.getFocusTask().cancel();
        if (q.destroyed || !q.refreshCounter || !q.ownerCt || p && e || !q.all.getCount()) {
            return
        }
        j = q.getSelectionModel();
        a = q.dataSource;
        c = q.getVisibleColumnManager();
        if (g && g.isCellContext) {
            l = g.record;
            b = g.rowIdx;
            d = g.colIdx;
            h = g.column;
            if (a.indexOf(l) === -1) {
                k = q.getScrollable();
                o.recordIndex = -1;
                if (k.getPosition().y >= k.getMaxPosition().y - q.all.last(true).offsetHeight) {
                    g.rowIdx--
                }
                b = Math.min(g.rowIdx, a.getCount() - 1);
                d = Math.min(d, c.getColumns().length);
                l = a.getAt(b);
                h = c.getColumns()[d]
            }
        } else {
            if (p) {
                l = b = null
            } else {
                if (m == null) {
                    m = o.lastFocused ? o.lastFocused.column : 0
                }
                if (typeof g === "number") {
                    b = Math.max(Math.min(g, a.getCount() - 1), 0);
                    l = a.getAt(g)
                } else {
                    if (g.isEntity) {
                        l = g;
                        b = a.indexOf(l)
                    } else {
                        if (g.tagName) {
                            l = q.getRecord(g);
                            b = a.indexOf(l);
                            if (b === -1) {
                                l = null
                            }
                        } else {
                            if (e) {
                                return
                            }
                            p = true;
                            l = b = null
                        }
                    }
                }
            }
            if (l) {
                if (b === -1) {
                    o.recordIndex = -1;
                    l = a.getAt(0);
                    b = 0;
                    m = null
                }
                if (m == null) {
                    if (!(h = o.column)) {
                        d = 0;
                        h = c.getColumns()[0]
                    }
                } else {
                    if (typeof m === "number") {
                        h = c.getColumns()[m];
                        d = m
                    } else {
                        h = m;
                        d = c.indexOf(m)
                    }
                }
            } else {
                p = true;
                h = d = null
            }
        }
        if (b === o.recordIndex && d === o.columnIndex && q === o.position.view) {
            return o.focusPosition(o.position)
        }
        if (o.cell) {
            o.cell.removeCls(o.focusCls)
        }
        o.previousRecordIndex = o.recordIndex;
        o.previousRecord = o.record;
        o.previousItem = o.item;
        o.previousCell = o.cell;
        o.previousColumn = o.column;
        o.previousColumnIndex = o.columnIndex;
        o.previousPosition = o.position.clone();
        o.selectionStart = j.selectionStart;
        o.position.setAll(q, o.recordIndex = b, o.columnIndex = d, o.record = l, o.column = h);
        if (p) {
            o.item = o.cell = null
        } else {
            o.focusPosition(o.position, i)
        }
        if (!r) {
            j.fireEvent("focuschange", j, o.previousRecord, o.record);
            q.fireEvent("rowfocus", o.record, o.item, o.recordIndex);
            q.fireEvent("cellfocus", o.record, o.cell, o.position)
        }
        if (n && !i && o.cell !== o.previousCell) {
            o.fireNavigateEvent(n)
        }
    }, focusPosition: function (a) {
        var c = this, b, d;
        c.item = c.cell = null;
        if (a && a.record && a.column) {
            b = a.view;
            if (a.rowElement) {
                d = c.item = a.rowElement
            } else {
                d = b.getRowByRecord(a.record)
            }
            if (d) {
                c.cell = a.cellElement || Ext.fly(d).down(a.column.getCellSelector(), true);
                if (c.cell) {
                    c.cell = new Ext.dom.Fly(c.cell);
                    b.lastFocused = c.lastFocused = c.position.clone();
                    c.focusItem(c.cell);
                    b.focusEl = c.cell
                } else {
                    c.position.setAll();
                    c.record = c.column = c.recordIndex = c.columnIndex = null
                }
            } else {
                d = b.dataSource.indexOf(a.record);
                c.position.setAll();
                c.record = c.column = c.recordIndex = c.columnIndex = null;
                if (d !== -1 && b.bufferedRenderer) {
                    c.lastKeyEvent = null;
                    b.bufferedRenderer.scrollTo(d, false, c.afterBufferedScrollTo, c)
                }
            }
        }
    }, focusItem: function (a) {
        a.addCls(this.focusCls);
        a.focus()
    }, getCell: function () {
        return this.cell
    }, getPosition: function () {
        var d = this, a = d.position, c, b, e;
        if (a.record && a.column) {
            b = a.view;
            e = b.dataSource;
            c = e.indexOf(a.record);
            if (c === -1) {
                c = a.rowIdx;
                if (!(a.record = e.getAt(c))) {
                    c = -1
                }
            }
            if (c === -1 || b.getVisibleColumnManager().indexOf(a.column) === -1) {
                a.setAll();
                d.record = d.column = d.recordIndex = d.columnIndex = null
            } else {
                return a
            }
        }
        return null
    }, getLastFocused: function () {
        var c = this, a, b = c.lastFocused;
        if (b && b.record && b.column) {
            a = b.view;
            if (a.dataSource.indexOf(b.record) !== -1 && a.getVisibleColumnManager().indexOf(b.column) !== -1) {
                return b
            }
        }
    }, onKeyTab: function (e) {
        var b = !e.shiftKey, c = e.position.clone(), g = c.view, l = e.position.cellElement,
            h = Ext.fly(l).findTabbableElements(), j, k = g.ownerGrid.actionables, d = k.length, a;
        e.preventDefault();
        j = h[Ext.Array.indexOf(h, e.target) + (b ? 1 : -1)];
        while (!j && (l = l[b ? "nextSibling" : "previousSibling"])) {
            c.setColumn(g.getHeaderByCell(l));
            for (a = 0; a < d; a++) {
                k[a].activateCell(c)
            }
            if ((h = Ext.fly(l).findTabbableElements()).length) {
                j = h[b ? 0 : h.length - 1]
            }
        }
        if (j) {
            this.actionPosition = c.view.actionPosition = c;
            j.focus();
            return
        }
        if (Ext.isIE) {
            g.el.focus()
        }
        g.onRowExit(e.item, e.item[b ? "nextSibling" : "previousSibling"], b)
    }, onKeyUp: function (b) {
        var a = b.view.walkRecs(b.record, -1), c = this.getPosition();
        if (a) {
            c.setRow(a);
            if (!c.getCell(true)) {
                c.navigate(-1)
            }
            this.setPosition(c, null, b)
        }
    }, onKeyDown: function (b) {
        var a = b.record.isExpandingOrCollapsing ? null : b.view.walkRecs(b.record, 1), c = this.getPosition();
        if (a) {
            c.setRow(a);
            if (!c.getCell(true)) {
                c.navigate(-1)
            }
            this.setPosition(c, null, b)
        }
    }, onKeyRight: function (b) {
        var a = this.move("right", b);
        if (a) {
            this.setPosition(a, null, b)
        }
    }, onKeyLeft: function (b) {
        var a = this.move("left", b);
        if (a) {
            this.setPosition(a, null, b)
        }
    }, onKeyEnter: function (b) {
        var a = ["cellclick", b.view, b.position.cellElement, b.position.colIdx, b.record, b.position.rowElement, b.recordIndex, b],
            c = b.position.getCell();
        if (c) {
            if (!c.query('[tabIndex="-1"]').length) {
                b.stopEvent();
                b.view.fireEvent.apply(b.view, a);
                a[0] = "celldblclick";
                b.view.fireEvent.apply(b.view, a)
            }
            if (!this.view.actionableMode) {
                this.view.ownerGrid.setActionableMode(true, this.getPosition())
            }
        }
    }, onKeyF2: function (b) {
        var a = this.view.ownerGrid, c = a.actionableMode;
        a.setActionableMode(!c, c ? null : this.getPosition())
    }, onKeyEsc: function (a) {
        this.view.ownerGrid.setActionableMode(false)
    }, move: function (b, d) {
        var c = this, a = c.getPosition();
        if (a && a.record) {
            return a.view.walkCells(a, b, d.shiftKey && (b === "right" || b === "left") ? c.vetoRowChange : null, c)
        }
    }, vetoRowChange: function (a) {
        return this.getPosition().record === a.record
    }, onKeyPageDown: function (e) {
        var d = this, a = e.view, g = d.getRowsVisible(), c, b;
        if (g) {
            if (a.bufferedRenderer) {
                c = Math.min(e.recordIndex + g, a.dataSource.getCount() - 1);
                d.lastKeyEvent = e;
                a.bufferedRenderer.scrollTo(c, false, d.afterBufferedScrollTo, d)
            } else {
                b = a.walkRecs(e.record, g);
                d.setPosition(b, null, e)
            }
        }
    }, onKeyPageUp: function (e) {
        var d = this, a = e.view, g = d.getRowsVisible(), c, b;
        if (g) {
            if (a.bufferedRenderer) {
                c = Math.max(e.recordIndex - g, 0);
                d.lastKeyEvent = e;
                a.bufferedRenderer.scrollTo(c, false, d.afterBufferedScrollTo, d)
            } else {
                b = a.walkRecs(e.record, -g);
                d.setPosition(b, null, e)
            }
        }
    }, onKeyHome: function (c) {
        var b = this, a = c.view;
        if (c.altKey) {
            if (a.bufferedRenderer) {
                b.lastKeyEvent = c;
                a.bufferedRenderer.scrollTo(0, false, b.afterBufferedScrollTo, b)
            } else {
                b.setPosition(a.walkRecs(c.record, -a.dataSource.indexOf(c.record)), null, c)
            }
        } else {
            b.setPosition(c.record, 0, c)
        }
    }, afterBufferedScrollTo: function (b, a) {
        this.setPosition(a, null, this.lastKeyEvent, null, !this.lastKeyEvent)
    }, onKeyEnd: function (c) {
        var b = this, a = c.view;
        if (c.altKey) {
            if (a.bufferedRenderer) {
                b.lastKeyEvent = c;
                a.bufferedRenderer.scrollTo(a.store.getCount() - 1, false, b.afterBufferedScrollTo, b)
            } else {
                b.setPosition(a.walkRecs(c.record, a.dataSource.getCount() - 1 - a.dataSource.indexOf(c.record)), null, c)
            }
        } else {
            b.setPosition(c.record, c.view.getVisibleColumnManager().getColumns().length - 1, c)
        }
    }, getRowsVisible: function () {
        var e = false, a = this.view, d = a.all.first(), b, c;
        if (d) {
            b = d.getHeight();
            c = a.el.getHeight();
            e = Math.floor(c / b)
        }
        return e
    }, fireNavigateEvent: function (b) {
        var a = this;
        a.fireEvent("navigate", {
            view: a.position.view,
            navigationModel: a,
            keyEvent: b || new Ext.event.Event({}),
            previousPosition: a.previousPosition,
            previousRecordIndex: a.previousRecordIndex,
            previousRecord: a.previousRecord,
            previousItem: a.previousItem,
            previousCell: a.previousCell,
            previousColumnIndex: a.previousColumnIndex,
            previousColumn: a.previousColumn,
            position: a.position,
            recordIndex: a.recordIndex,
            record: a.record,
            selectionStart: a.selectionStart,
            item: a.item,
            cell: a.cell,
            columnIndex: a.columnIndex,
            column: a.column
        })
    }
}, 0, 0, 0, 0, ["view.navigation.grid"], 0, [Ext.grid, "NavigationModel"], 0));
(Ext.cmd.derive("Ext.view.TableLayout", Ext.layout.component.Auto, {
    type: "tableview", beginLayout: function (d) {
        var c = this, b = c.owner.lockingPartner, a = d.context;
        if (!c.columnFlusherId) {
            c.columnFlusherId = c.id + "-columns";
            c.rowHeightFlusherId = c.id + "-rows"
        }
        Ext.layout.component.Auto.prototype.beginLayout.call(this, d);
        if (b && b.grid.isVisible()) {
            if (!d.lockingPartnerContext) {
                (d.lockingPartnerContext = a.getCmp(b)).lockingPartnerContext = d
            }
            d.rowHeightSynchronizer = c.owner.syncRowHeightBegin()
        }
        (d.headerContext = a.getCmp(c.headerCt)).viewContext = d
    }, beginLayoutCycle: function (b, a) {
        Ext.layout.component.Auto.prototype.beginLayoutCycle.call(this, b, a);
        if (b.syncRowHeights) {
            b.target.syncRowHeightClear(b.rowHeightSynchronizer);
            b.syncRowHeights = false
        }
    }, calculate: function (e) {
        var n = this, b = e.context, h = e.lockingPartnerContext, d = e.headerContext, k = e.ownerCtContext,
            c = n.owner, j = d.getProp("columnsChanged"), a = e.state, o, g, q, p, l = c.body.dom, r, m, i;
        if (!c.all.getCount() && (!l || !c.body.child("table"))) {
            e.setProp("viewOverflowY", false);
            Ext.layout.component.Auto.prototype.calculate.call(this, e);
            return
        }
        if (j === undefined) {
            n.done = false;
            return
        }
        if (j) {
            if (!(o = a.columnFlusher)) {
                b.queueFlush(a.columnFlusher = o = {
                    ownerContext: e,
                    columnsChanged: j,
                    layout: n,
                    id: n.columnFlusherId,
                    flush: n.flushColumnWidths
                })
            }
            if (!o.flushed) {
                n.done = false;
                return
            }
        }
        if (h) {
            if (!(p = a.rowHeightFlusher)) {
                if (!(q = a.rowHeights)) {
                    a.rowHeights = q = e.rowHeightSynchronizer;
                    n.owner.syncRowHeightMeasure(q);
                    e.setProp("rowHeights", q)
                }
                if (!(g = h.getProp("rowHeights"))) {
                    n.done = false;
                    return
                }
                b.queueFlush(a.rowHeightFlusher = p = {
                    ownerContext: e,
                    synchronizer: q,
                    otherSynchronizer: g,
                    layout: n,
                    id: n.rowHeightFlusherId,
                    flush: n.flushRowHeights
                })
            }
            if (!p.flushed) {
                n.done = false;
                return
            }
        }
        Ext.layout.component.Auto.prototype.calculate.call(this, e);
        if (!e.heightModel.shrinkWrap) {
            i = false;
            if (!k.heightModel.shrinkWrap) {
                m = k.target.layout.getContainerSize(k);
                if (!m.gotHeight) {
                    n.done = false;
                    return
                }
                r = l.offsetHeight;
                i = r > m.height
            }
            e.setProp("viewOverflowY", i)
        }
    }, measureContentHeight: function (d) {
        var a = this.owner, c = a.body.dom, b = a.emptyEl, e = 0;
        if (b) {
            e += b.offsetHeight
        }
        if (c) {
            e += c.offsetHeight
        }
        if (d.headerContext.state.boxPlan.tooNarrow) {
            e += Ext.getScrollbarSize().height
        }
        return e
    }, flushColumnWidths: function () {
        var l = this, k = l.layout, b = l.ownerContext, d = l.columnsChanged, a = b.target, j = d.length, c, g, e, h;
        if (b.state.columnFlusher !== l) {
            return
        }
        for (g = 0; g < j; g++) {
            if (!(c = d[g])) {
                continue
            }
            e = c.props.width;
            a.body.select(a.getColumnSizerSelector(c.target)).setWidth(e);
            h = c.lastBox;
            if (h) {
                h.width = e
            }
        }
        l.flushed = true;
        if (!k.pending) {
            b.context.queueLayout(k)
        }
    }, flushRowHeights: function () {
        var a = this, b = a.layout, c = a.ownerContext;
        if (c.state.rowHeightFlusher !== a) {
            return
        }
        c.target.syncRowHeightFinish(a.synchronizer, a.otherSynchronizer);
        a.flushed = true;
        c.syncRowHeights = true;
        if (!b.pending) {
            c.context.queueLayout(b)
        }
    }, finishedLayout: function (a) {
        var b = Ext.fly(this.owner.getNodeContainer());
        Ext.layout.component.Auto.prototype.finishedLayout.call(this, a);
        if (b) {
            b.setWidth(a.headerContext.props.contentWidth)
        }
    }
}, 0, 0, 0, 0, ["layout.tableview"], 0, [Ext.view, "TableLayout"], 0));
(Ext.cmd.derive("Ext.grid.locking.RowSynchronizer", Ext.Base, {
    constructor: function (a, b) {
        var c = this, d;
        c.view = a;
        c.rowEl = b;
        c.els = {};
        c.add("data", a.rowSelector);
        for (d = a.rowTpl; d; d = d.nextTpl) {
            if (d.beginRowSync) {
                d.beginRowSync(c)
            }
        }
    }, add: function (b, a) {
        var c = Ext.fly(this.rowEl).down(a, true);
        if (c) {
            this.els[b] = {el: c}
        }
    }, finish: function (g) {
        var h = this, c = h.els, j = g.els, e, i = 0, b = 0, k, a, d;
        for (a in c) {
            e = j[a];
            d = e ? e.height : 0;
            k = d - c[a].height;
            if (k > 0) {
                i += k;
                Ext.fly(c[a].el).setHeight(d)
            } else {
                b -= k
            }
        }
        d = g.rowHeight + b;
        if (h.rowHeight + i < d) {
            Ext.fly(h.rowEl).setHeight(d)
        }
    }, measure: function () {
        var c = this, b = c.els, a;
        c.rowHeight = c.rowEl.offsetHeight;
        for (a in b) {
            b[a].height = b[a].el.offsetHeight
        }
    }, reset: function () {
        var b = this.els, a;
        this.rowEl.style.height = "";
        for (a in b) {
            b[a].el.style.height = ""
        }
    }
}, 1, 0, 0, 0, 0, 0, [Ext.grid.locking, "RowSynchronizer"], 0));
(Ext.cmd.derive("Ext.view.NodeCache", Ext.Base, {
    statics: {range: document.createRange && document.createRange()}, constructor: function (a) {
        this.view = a;
        this.clear();
        this.el = new Ext.dom.Fly()
    }, destroy: function () {
        var a = this;
        if (!a.destroyed) {
            a.el.destroy();
            a.el = a.view = null;
            a.destroyed = true
        }
        a.callParent()
    }, clear: function (e) {
        var c = this, d = c.elements, a = c.statics().range, b;
        if (c.count && e) {
            if (a) {
                a.setStartBefore(d[c.startIndex]);
                a.setEndAfter(d[c.endIndex]);
                a.deleteContents()
            } else {
                for (b in d) {
                    Ext.removeNode(d[b])
                }
            }
        }
        c.elements = {};
        c.count = c.startIndex = 0;
        c.endIndex = -1
    }, fill: function (b, h, g) {
        g = g || 0;
        var d = this, e = d.elements = {}, c, a = b.length - g;
        if (!h) {
            h = 0
        }
        for (c = 0; c < a; c++) {
            e[h + c] = b[c + g]
        }
        d.startIndex = h;
        d.endIndex = h + a - 1;
        d.count = a;
        return this
    }, insert: function (g, b) {
        var d = this, e = d.elements, c, a = b.length;
        if (d.count) {
            if (g < d.count) {
                for (c = d.endIndex + a; c >= g + a; c--) {
                    e[c] = e[c - a];
                    e[c].setAttribute("data-recordIndex", c)
                }
            }
            d.endIndex = d.endIndex + a
        } else {
            d.startIndex = g;
            d.endIndex = g + a - 1
        }
        for (c = 0; c < a; c++, g++) {
            e[g] = b[c];
            e[g].setAttribute("data-recordIndex", g)
        }
        d.count += a
    }, invoke: function (d, a) {
        var e = this, c, b;
        d = Ext.dom.Element.prototype[d];
        for (b = e.startIndex; b <= e.endIndex; b++) {
            c = e.item(b);
            if (c) {
                d.apply(c, a)
            }
        }
        return e
    }, item: function (c, b) {
        var d = this.elements[c], a = null;
        if (d) {
            a = b ? this.elements[c] : this.el.attach(this.elements[c])
        }
        return a
    }, first: function (a) {
        return this.item(this.startIndex, a)
    }, last: function (a) {
        return this.item(this.endIndex, a)
    }, moveBlock: function (a) {
        var g = this, h = g.elements, e, b, d, c;
        if (!a) {
            return
        }
        if (a < 0) {
            c = g.startIndex - 1;
            b = g.endIndex;
            d = 1
        } else {
            c = g.endIndex + 1;
            b = g.startIndex;
            d = -1
        }
        g.startIndex += a;
        g.endIndex += a;
        do {
            c += d;
            e = h[c + a] = h[c];
            e.setAttribute("data-recordIndex", c + a);
            if (c < g.startIndex || c > g.endIndex) {
                delete h[c]
            }
        } while (c !== b);
        delete h[c]
    }, getCount: function () {
        return this.count
    }, slice: function (e, b) {
        var d = this.elements, a = [], c;
        if (!b) {
            b = this.endIndex
        } else {
            b = Math.min(this.endIndex, b - 1)
        }
        for (c = e || this.startIndex; c <= b; c++) {
            a.push(d[c])
        }
        return a
    }, replaceElement: function (d, c, a) {
        var e = this.elements, b = (typeof d === "number") ? d : this.indexOf(d);
        if (b > -1) {
            c = Ext.getDom(c);
            if (a) {
                d = e[b];
                d.parentNode.insertBefore(c, d);
                Ext.removeNode(d);
                c.setAttribute("data-recordIndex", b)
            }
            this.elements[b] = c
        }
        return this
    }, indexOf: function (b) {
        var c = this.elements, a;
        b = Ext.getDom(b);
        for (a = this.startIndex; a <= this.endIndex; a++) {
            if (c[a] === b) {
                return a
            }
        }
        return -1
    }, removeRange: function (c, g, d) {
        var k = this, a = k.elements, j = [], e, h, b, l;
        if (g == null) {
            g = k.endIndex + 1
        } else {
            g = Math.min(k.endIndex + 1, g + 1)
        }
        if (c == null) {
            c = k.startIndex
        }
        b = g - c;
        for (h = c, l = g; h <= k.endIndex; h++, l++) {
            e = a[h];
            if (h < g) {
                j.push(e);
                if (d) {
                    Ext.removeNode(e)
                }
            }
            if (l <= k.endIndex) {
                e = a[h] = a[l];
                e.setAttribute("data-recordIndex", h)
            } else {
                delete a[h]
            }
        }
        k.count -= b;
        k.endIndex -= b;
        return j
    }, removeElement: function (l, c) {
        var h = this, k, j, a = h.elements, d, e, b = 0, g, i;
        if (Ext.isArray(l)) {
            k = l;
            l = [];
            e = k.length;
            for (b = 0; b < e; b++) {
                j = k[b];
                if (typeof j !== "number") {
                    j = h.indexOf(j)
                }
                if (j >= h.startIndex && j <= h.endIndex) {
                    l[l.length] = j
                }
            }
            Ext.Array.sort(l);
            e = l.length
        } else {
            if (l < h.startIndex || l > h.endIndex) {
                return
            }
            e = 1;
            l = [l]
        }
        for (g = i = l[0], b = 0; g <= h.endIndex; g++, i++) {
            if (b < e && g === l[b]) {
                i++;
                b++;
                if (c) {
                    Ext.removeNode(a[g])
                }
            }
            if (i <= h.endIndex && i >= h.startIndex) {
                d = a[g] = a[i];
                d.setAttribute("data-recordIndex", g)
            } else {
                delete a[g]
            }
        }
        h.endIndex -= e;
        h.count -= e
    }, scroll: function (s, t, j) {
        var u = this, l = u.view, g = l.store, m = u.elements, a = s.length, p = l.getNodeContainer(),
            h = l.hasListeners.itemremove, r = l.hasListeners.itemadd, n = u.statics().range, q, b, c, d, k, e, o, v;
        if (!s.length) {
            return
        }
        if (t === -1) {
            if (j) {
                if (h) {
                    o = [];
                    v = []
                }
                e = (u.endIndex - j) + 1;
                if (n) {
                    n.setStartBefore(m[e]);
                    n.setEndAfter(m[u.endIndex]);
                    n.deleteContents();
                    for (q = e; q <= u.endIndex; q++) {
                        b = m[q];
                        delete m[q];
                        if (h) {
                            o.push(g.getByInternalId(b.getAttribute("data-recordId")));
                            v.push(b)
                        }
                    }
                } else {
                    for (q = e; q <= u.endIndex; q++) {
                        b = m[q];
                        delete m[q];
                        Ext.removeNode(b);
                        if (h) {
                            o.push(g.getByInternalId(b.getAttribute("data-recordId")));
                            v.push(b)
                        }
                    }
                }
                l.fireEvent("itemremove", o, e, v, l);
                u.endIndex -= j
            }
            if (s.length) {
                k = l.bufferRender(s, u.startIndex -= a);
                d = k.children;
                for (q = 0; q < a; q++) {
                    m[u.startIndex + q] = d[q]
                }
                p.insertBefore(k.fragment, p.firstChild);
                if (r) {
                    l.fireEvent("itemadd", s, u.startIndex, d)
                }
            }
        } else {
            if (j) {
                if (h) {
                    o = [];
                    v = []
                }
                c = u.startIndex + j;
                if (n) {
                    n.setStartBefore(m[u.startIndex]);
                    n.setEndAfter(m[c - 1]);
                    n.deleteContents();
                    for (q = u.startIndex; q < c; q++) {
                        b = m[q];
                        delete m[q];
                        if (h) {
                            o.push(g.getByInternalId(b.getAttribute("data-recordId")));
                            v.push(b)
                        }
                    }
                } else {
                    for (q = u.startIndex; q < c; q++) {
                        b = m[q];
                        delete m[q];
                        Ext.removeNode(b);
                        if (h) {
                            o.push(g.getByInternalId(b.getAttribute("data-recordId")));
                            v.push(b)
                        }
                    }
                }
                l.fireEvent("itemremove", o, u.startIndex, v, l);
                u.startIndex = c
            }
            k = l.bufferRender(s, u.endIndex + 1);
            d = k.children;
            for (q = 0; q < a; q++) {
                m[u.endIndex += 1] = d[q]
            }
            p.appendChild(k.fragment);
            if (r) {
                l.fireEvent("itemadd", s, u.endIndex + 1, d)
            }
        }
        u.count = u.endIndex - u.startIndex + 1;
        return d
    }, sumHeights: function () {
        var a = 0, c = this.elements, b;
        for (b = this.startIndex; b <= this.endIndex; b++) {
            a += c[b].offsetHeight
        }
        return a
    }
}, 1, 0, 0, 0, 0, 0, [Ext.view, "NodeCache"], function () {
    Ext.dom.CompositeElementLite.importElementMethods.call(this)
}));
(Ext.cmd.derive("Ext.view.Table", Ext.view.View, {
    alternateClassName: "Ext.grid.View",
    isTableView: true,
    config: {selectionModel: {type: "rowmodel"}},
    inheritableStatics: {
        normalSideEvents: ["deselect", "select", "beforedeselect", "beforeselect", "selectionchange"],
        events: ["blur", "focus", "move", "resize", "destroy", "beforedestroy", "boxready", "afterrender", "render", "beforerender", "removed", "hide", "beforehide", "show", "beforeshow", "enable", "disable", "added", "deactivate", "beforedeactivate", "activate", "beforeactivate", "cellkeydown", "beforecellkeydown", "cellmouseup", "beforecellmouseup", "cellmousedown", "beforecellmousedown", "cellcontextmenu", "beforecellcontextmenu", "celldblclick", "beforecelldblclick", "cellclick", "beforecellclick", "refresh", "itemremove", "itemadd", "itemupdate", "viewready", "beforerefresh", "unhighlightitem", "highlightitem", "focuschange", "containerkeydown", "containercontextmenu", "containerdblclick", "containerclick", "containermouseout", "containermouseover", "containermouseup", "containermousedown", "beforecontainerkeydown", "beforecontainercontextmenu", "beforecontainerdblclick", "beforecontainerclick", "beforecontainermouseout", "beforecontainermouseover", "beforecontainermouseup", "beforecontainermousedown", "itemkeydown", "itemcontextmenu", "itemdblclick", "itemclick", "itemmouseleave", "itemmouseenter", "itemmouseup", "itemmousedown", "rowclick", "rowcontextmenu", "rowdblclick", "rowkeydown", "rowmouseup", "rowmousedown", "rowkeydown", "beforeitemkeydown", "beforeitemcontextmenu", "beforeitemdblclick", "beforeitemclick", "beforeitemmouseleave", "beforeitemmouseenter", "beforeitemmouseup", "beforeitemmousedown", "statesave", "beforestatesave", "staterestore", "beforestaterestore", "uievent", "groupcollapse", "groupexpand", "scroll"]
    },
    scrollable: true,
    componentLayout: "tableview",
    baseCls: "x-grid-view",
    unselectableCls: "x-unselectable",
    firstCls: "x-grid-cell-first",
    lastCls: "x-grid-cell-last",
    itemCls: "x-grid-item",
    selectedItemCls: "x-grid-item-selected",
    selectedCellCls: "x-grid-cell-selected",
    focusedItemCls: "x-grid-item-focused",
    overItemCls: "x-grid-item-over",
    altRowCls: "x-grid-item-alt",
    dirtyCls: "x-grid-dirty-cell",
    rowClsRe: new RegExp("(?:^|\\\\s*)x-grid-item-alt(?:\\\\s+|$)", "g"),
    cellRe: new RegExp("x-grid-cell-([^\\\\s]+)(?:\\\\s|$)", ""),
    positionBody: true,
    positionCells: false,
    stripeOnUpdate: null,
    actionableMode: false,
    trackOver: true,
    getRowClass: null,
    stripeRows: true,
    markDirty: true,
    ariaRole: "rowgroup",
    rowAriaRole: "row",
    cellAriaRole: "gridcell",
    tpl: ["{%", "view = values.view;", "if (!(columns = values.columns)) {", "columns = values.columns = view.ownerCt.getVisibleColumnManager().getColumns();", "}", "values.fullWidth = 0;", "for (i = 0, len = columns.length; i < len; i++) {", "column = columns[i];", "values.fullWidth += (column.cellWidth = column.lastBox ? column.lastBox.width : column.width || column.minWidth);", "}", "tableCls=values.tableCls=[];", "%}", '<div class="x-grid-item-container" role="presentation" style="width:{fullWidth}px">', "{[view.renderTHead(values, out, parent)]}", "{%", "view.renderRows(values.rows, values.columns, values.viewStartIndex, out);", "%}", "{[view.renderTFoot(values, out, parent)]}", "</div>", "{% ", "view = columns = column = null;", "%}", {
        definitions: "var view, tableCls, columns, i, len, column;",
        priority: 0
    }],
    outerRowTpl: ['<table id="{rowId}" role="presentation" ', 'data-boundView="{view.id}" ', 'data-recordId="{record.internalId}" ', 'data-recordIndex="{recordIndex}" ', 'class="{[values.itemClasses.join(" ")]}" cellpadding="0" cellspacing="0" style="{itemStyle};width:0">', "{%", "this.nextTpl.applyOut(values, out, parent)", "%}", "</table>", {priority: 9999}],
    rowTpl: ["{%", 'var dataRowCls = values.recordIndex === -1 ? "" : " x-grid-row";', "%}", '<tr class="{[values.rowClasses.join(" ")]} {[dataRowCls]}"', ' role="{rowRole}" {rowAttr:attributes}>', '<tpl for="columns">{%', "parent.view.renderCell(values, parent.record, parent.recordIndex, parent.rowIndex, xindex - 1, out, parent)", "%}", "</tpl>", "</tr>", {priority: 0}],
    cellTpl: ['<td class="{tdCls}" role="{cellRole}" {tdAttr} {cellAttr:attributes}', ' style="width:{column.cellWidth}px;<tpl if="tdStyle">{tdStyle}</tpl>"', ' tabindex="-1" data-columnid="{[values.column.getItemId()]}">', '<div {unselectableAttr} class="x-grid-cell-inner {innerCls}" ', 'style="text-align:{align};<tpl if="style">{style}</tpl>" ', "{cellInnerAttr:attributes}>{value}</div>", "</td>", {priority: 0}],
    refreshSelmodelOnRefresh: false,
    tableValues: {},
    rowValues: {itemClasses: [], rowClasses: []},
    cellValues: {classes: ["x-grid-cell x-grid-td"]},
    constructor: function (a) {
        if (a.grid.isTree) {
            a.baseCls = "x-tree-view"
        }
        Ext.view.View.prototype.constructor.call(this, a)
    },
    hasVariableRowHeight: function (a) {
        var b = this;
        return b.variableRowHeight || b.store.isGrouped() || b.getVisibleColumnManager().hasVariableRowHeight() || (!a && b.lockingPartner && b.lockingPartner.hasVariableRowHeight(true))
    },
    initComponent: function () {
        var a = this;
        if (a.columnLines) {
            a.addCls(a.grid.colLinesCls)
        }
        if (a.rowLines) {
            a.addCls(a.grid.rowLinesCls)
        }
        a.body = new Ext.dom.Fly();
        a.body.id = a.id + "gridBody";
        if (!a.trackOver) {
            a.overItemCls = null
        }
        a.headerCt.view = a;
        a.grid.view = a;
        a.initFeatures(a.grid);
        a.itemSelector = a.getItemSelector();
        a.all = new Ext.view.NodeCache(a);
        Ext.view.View.prototype.initComponent.call(this)
    },
    applySelectionModel: function (b, e) {
        var d = this, c = d.ownerGrid, g = b.type, a = d.disableSelection || c.disableSelection;
        if (!e) {
            if (!(b && b.isSelectionModel)) {
                b = c.selModel || b
            }
        }
        if (b) {
            if (b.isSelectionModel) {
                b.allowDeselect = c.allowDeselect || b.selectionMode !== "SINGLE";
                b.locked = a
            } else {
                if (typeof b === "string") {
                    b = {type: b}
                } else {
                    b.type = c.selType || b.selType || b.type || g
                }
                if (!b.mode) {
                    if (c.simpleSelect) {
                        b.mode = "SIMPLE"
                    } else {
                        if (c.multiSelect) {
                            b.mode = "MULTI"
                        }
                    }
                }
                b = Ext.Factory.selection(Ext.apply({allowDeselect: c.allowDeselect, locked: a}, b))
            }
        }
        return b
    },
    updateSelectionModel: function (a, c) {
        var b = this;
        if (c) {
            c.un({scope: b, lastselectedchanged: b.updateBindSelection, selectionchange: b.updateBindSelection});
            Ext.destroy(b.selModelRelayer)
        }
        b.selModelRelayer = b.relayEvents(a, ["selectionchange", "beforeselect", "beforedeselect", "select", "deselect", "focuschange"]);
        a.on({scope: b, lastselectedchanged: b.updateBindSelection, selectionchange: b.updateBindSelection});
        b.selModel = a
    },
    getVisibleColumnManager: function () {
        return this.ownerCt.getVisibleColumnManager()
    },
    getColumnManager: function () {
        return this.ownerCt.getColumnManager()
    },
    getTopLevelVisibleColumnManager: function () {
        return this.ownerGrid.getVisibleColumnManager()
    },
    moveColumn: function (a, u, k) {
        var t = this, r = k > 1, m = r && document.createRange ? document.createRange() : null,
            b = r && !m ? document.createDocumentFragment() : null, l = u, n = t.getGridColumns().length, s = n - 1,
            e = (t.firstCls || t.lastCls) && (u === 0 || u === n || a === 0 || a === s), p, o, h, q, c, d, g;
        if (t.rendered && u !== a) {
            h = t.el.query(t.rowSelector);
            if (u > a && b) {
                l -= 1
            }
            for (p = 0, q = h.length; p < q; p++) {
                c = h[p];
                d = c.childNodes;
                if (e) {
                    if (d.length === 1) {
                        Ext.fly(d[0]).addCls(t.firstCls);
                        Ext.fly(d[0]).addCls(t.lastCls);
                        continue
                    }
                    if (a === 0) {
                        Ext.fly(d[0]).removeCls(t.firstCls);
                        Ext.fly(d[1]).addCls(t.firstCls)
                    } else {
                        if (a === s) {
                            Ext.fly(d[s]).removeCls(t.lastCls);
                            Ext.fly(d[s - 1]).addCls(t.lastCls)
                        }
                    }
                    if (u === 0) {
                        Ext.fly(d[0]).removeCls(t.firstCls);
                        Ext.fly(d[a]).addCls(t.firstCls)
                    } else {
                        if (u === n) {
                            Ext.fly(d[s]).removeCls(t.lastCls);
                            Ext.fly(d[a]).addCls(t.lastCls)
                        }
                    }
                }
                if (r) {
                    if (m) {
                        m.setStartBefore(d[a]);
                        m.setEndAfter(d[a + k - 1]);
                        b = m.extractContents()
                    } else {
                        for (o = 0; o < k; o++) {
                            b.appendChild(d[a])
                        }
                    }
                    c.insertBefore(b, d[l] || null)
                } else {
                    c.insertBefore(d[a], d[l] || null)
                }
            }
            g = t.el.query("colgroup");
            for (p = 0, q = g.length; p < q; p++) {
                c = g[p];
                if (r) {
                    if (m) {
                        m.setStartBefore(c.childNodes[a]);
                        m.setEndAfter(c.childNodes[a + k - 1]);
                        b = m.extractContents()
                    } else {
                        for (o = 0; o < k; o++) {
                            b.appendChild(c.childNodes[a])
                        }
                    }
                    c.insertBefore(b, c.childNodes[l] || null)
                } else {
                    c.insertBefore(c.childNodes[a], c.childNodes[l] || null)
                }
            }
        }
    },
    scrollToTop: Ext.emptyFn,
    addElListener: function (a, c, b) {
        this.mon(this, a, c, b, {element: "el"})
    },
    getGridColumns: function () {
        return this.ownerCt.getVisibleColumnManager().getColumns()
    },
    getHeaderAtIndex: function (a) {
        return this.ownerCt.getVisibleColumnManager().getHeaderAtIndex(a)
    },
    getCell: function (a, b) {
        var c = this.getRow(a);
        return Ext.fly(c).down(b.getCellSelector())
    },
    getFeature: function (b) {
        var a = this.featuresMC;
        if (a) {
            return a.get(b)
        }
    },
    findFeature: function (a) {
        if (this.features) {
            return Ext.Array.findBy(this.features, function (b) {
                if (b.ftype === a) {
                    return true
                }
            })
        }
    },
    initFeatures: function (d) {
        var g = this, c, e, b, a;
        g.tpl = Ext.XTemplate.getTpl(this, "tpl");
        g.rowTpl = Ext.XTemplate.getTpl(this, "rowTpl");
        g.addRowTpl(Ext.XTemplate.getTpl(this, "outerRowTpl"));
        g.cellTpl = Ext.XTemplate.getTpl(this, "cellTpl");
        g.featuresMC = new Ext.util.MixedCollection();
        e = g.features = g.constructFeatures();
        a = e ? e.length : 0;
        for (c = 0; c < a; c++) {
            b = e[c];
            b.view = g;
            b.grid = d;
            g.featuresMC.add(b);
            b.init(d)
        }
    },
    renderTHead: function (b, c, e) {
        var g = b.view.headerFns, a, d;
        if (g) {
            for (d = 0, a = g.length; d < a; ++d) {
                g[d].call(this, b, c, e)
            }
        }
    },
    addHeaderFn: function (a) {
        var b = this.headerFns;
        if (!b) {
            b = this.headerFns = []
        }
        b.push(a)
    },
    renderTFoot: function (b, c, e) {
        var g = b.view.footerFns, a, d;
        if (g) {
            for (d = 0, a = g.length; d < a; ++d) {
                g[d].call(this, b, c, e)
            }
        }
    },
    addFooterFn: function (a) {
        var b = this.footerFns;
        if (!b) {
            b = this.footerFns = []
        }
        b.push(a)
    },
    addTpl: function (a) {
        return this.insertTpl("tpl", a)
    },
    addRowTpl: function (a) {
        return this.insertTpl("rowTpl", a)
    },
    addCellTpl: function (a) {
        return this.insertTpl("cellTpl", a)
    },
    insertTpl: function (e, d) {
        var c = this, a, b;
        if (d.isTemplate) {
            d = Ext.Object.chain(d)
        } else {
            d = new Ext.XTemplate("{%this.nextTpl.applyOut(values, out, parent);%}", d)
        }
        for (a = c[e]; d.priority < a.priority; a = a.nextTpl) {
            b = a
        }
        if (b) {
            b.nextTpl = d
        } else {
            c[e] = d
        }
        d.nextTpl = a;
        return d
    },
    tplApplyOut: function (a, b, c) {
        if (this.before) {
            if (this.before(a, b, c) === false) {
                return
            }
        }
        this.nextTpl.applyOut(a, b, c);
        if (this.after) {
            this.after(a, b, c)
        }
    },
    constructFeatures: function () {
        var g = this, e = g.features, d, b, c = 0, a;
        if (e) {
            b = [];
            a = e.length;
            for (; c < a; c++) {
                d = e[c];
                if (!d.isFeature) {
                    d = Ext.create("feature." + d.ftype, d)
                }
                b[c] = d
            }
        }
        return b
    },
    beforeRender: function () {
        Ext.view.View.prototype.beforeRender.call(this);
        if (!this.enableTextSelection) {
            this.protoEl.unselectable()
        }
    },
    getElConfig: function () {
        var a = Ext.view.View.prototype.getElConfig.call(this);
        delete a["aria-hidden"];
        delete a["aria-disabled"];
        return a
    },
    onBindStore: function (a) {
        var b = this, c = b.bufferedRenderer;
        if (c && c.store !== a) {
            c.bindStore(a)
        }
        if (b.all && b.all.getCount()) {
            if (c) {
                c.setBodyTop(0)
            }
            b.clearViewEl()
        }
        Ext.view.View.prototype.onBindStore.apply(this, arguments)
    },
    getStoreListeners: function () {
        var a = Ext.view.View.prototype.getStoreListeners.call(this);
        if (this.bufferedRenderer) {
            delete a.clear
        }
        a.beforepageremove = this.beforePageRemove;
        return a
    },
    beforePageRemove: function (c, b) {
        var d = this.all, a = c.getPageSize();
        if (d.startIndex >= (b - 1) * a && d.endIndex <= (b * a - 1)) {
            c.get(b);
            return false
        }
    },
    onViewScroll: function (b, a, c) {
        if (!this.ignoreScroll) {
            Ext.view.View.prototype.onViewScroll.call(this, b, a, c)
        }
    },
    createRowElement: function (b, c, d) {
        var e = this, g = e.renderBuffer, a = e.collectData([b], c);
        a.columns = d;
        e.tpl.overwrite(g, a);
        e.cleanupData();
        return Ext.fly(g).down(e.getNodeContainerSelector(), true).firstChild
    },
    bufferRender: function (c, d) {
        var e = this, g = e.renderBuffer, a, b = document.createRange ? document.createRange() : null;
        e.tpl.overwrite(g, e.collectData(c, d));
        e.cleanupData();
        Ext.fly(g).saveTabbableState({skipSelf: true, includeHidden: true});
        g = Ext.fly(g).down(e.getNodeContainerSelector(), true);
        if (b) {
            b.selectNodeContents(g);
            a = b.extractContents()
        } else {
            a = document.createDocumentFragment();
            while (g.firstChild) {
                a.appendChild(g.firstChild)
            }
        }
        return {fragment: a, children: Ext.Array.toArray(a.childNodes)}
    },
    collectData: function (a, c) {
        var b = this;
        b.rowValues.view = b;
        b.tableValues.view = b;
        b.tableValues.rows = a;
        b.tableValues.columns = null;
        b.tableValues.viewStartIndex = c;
        b.tableValues.touchScroll = b.touchScroll;
        b.tableValues.tableStyle = "width:" + b.headerCt.getTableWidth() + "px";
        return b.tableValues
    },
    cleanupData: function () {
        var a = this.tableValues;
        a.view = a.columns = a.rows = this.rowValues.view = null
    },
    refreshSize: function (c) {
        var b = this, a = b.getBodySelector();
        if (a) {
            b.body.attach(b.el.down(a, true))
        }
        if (!b.hasLoadingHeight) {
            Ext.suspendLayouts();
            Ext.view.View.prototype.refreshSize.apply(this, arguments);
            if (c || (b.hasVariableRowHeight() && b.dataSource.getCount())) {
                b.grid.updateLayout()
            }
            Ext.resumeLayouts(true)
        }
    },
    clearViewEl: function (j) {
        var e = this, c = e.all, a = e.getStore(), b, d, g, h;
        if (e.hasListeners.itemremove) {
            for (b = c.startIndex; b <= c.endIndex; b++) {
                d = c.item(b, true);
                e.fireEvent("itemremove", a.getByInternalId(d.getAttribute("data-recordId")), b, d, e)
            }
        }
        Ext.view.View.prototype.clearViewEl.call(this);
        g = Ext.fly(e.getNodeContainer());
        if (g && !j) {
            h = e.getTargetEl();
            if (h.dom !== g.dom) {
                g.destroy()
            }
        }
    },
    getMaskTarget: function () {
        return this.ownerCt.body
    },
    statics: {
        getBoundView: function (a) {
            return Ext.getCmp(a.getAttribute("data-boundView"))
        }
    },
    getRecord: function (c) {
        var b = this, a;
        if (b.store.destroyed) {
            return
        }
        if (c.isModel) {
            return c
        }
        c = b.getNode(c);
        if (c) {
            if (!b.hasActiveFeature()) {
                a = c.getAttribute("data-recordIndex");
                if (a) {
                    a = parseInt(a, 10);
                    if (a > -1) {
                        return b.store.data.getAt(a)
                    }
                }
            }
            return b.dataSource.getByInternalId(c.getAttribute("data-recordId"))
        }
    },
    indexOf: function (a) {
        a = this.getNode(a);
        if (!a && a !== 0) {
            return -1
        }
        return this.all.indexOf(a)
    },
    indexInStore: function (a) {
        return a ? this.dataSource.indexOf(this.getRecord(a)) : -1
    },
    indexOfRow: function (b) {
        var c = this.dataSource, a;
        if (b.isCollapsedPlaceholder) {
            a = c.indexOfPlaceholder(b)
        } else {
            a = c.indexOf(b)
        }
        return a
    },
    renderRows: function (h, e, d, b) {
        var g = this, j = g.rowValues, a = h.length, c;
        j.view = g;
        j.columns = e;
        j.rowRole = g.rowAriaRole;
        g.cellValues.cellRole = g.cellAriaRole;
        for (c = 0; c < a; c++, d++) {
            j.itemClasses.length = j.rowClasses.length = 0;
            g.renderRow(h[c], d, b)
        }
        j.view = j.columns = j.record = null
    },
    renderColumnSizer: function (b, c) {
        var e = b.columns || this.getGridColumns(), a = e.length, d, h, g;
        c.push('<colgroup role="presentation">');
        for (d = 0; d < a; d++) {
            h = e[d];
            g = h.cellWidth ? h.cellWidth : Ext.grid.header.Container.prototype.defaultWidth;
            c.push('<col role="presentation" class="', "x-", "grid-cell-", e[d].getItemId(), '" style="width:' + g + 'px">')
        }
        c.push("</colgroup>")
    },
    renderRow: function (h, a, g) {
        var j = this, e = a === -1, i = j.selectionModel, m = j.rowValues, d = m.itemClasses, c = m.rowClasses,
            b = j.itemCls, l, k = j.rowTpl;
        m.rowAttr = {};
        m.record = h;
        m.recordId = h.internalId;
        m.recordIndex = j.store.indexOf(h);
        m.rowIndex = a;
        m.rowId = j.getRowId(h);
        m.itemCls = m.rowCls = "";
        if (!m.columns) {
            m.columns = j.ownerCt.getVisibleColumnManager().getColumns()
        }
        d.length = c.length = 0;
        if (!e) {
            d[0] = b;
            if (!j.ownerCt.disableSelection && i.isRowSelected) {
                if (i.isRowSelected(h)) {
                    d.push(j.selectedItemCls)
                }
            }
            if (j.stripeRows && a % 2 !== 0) {
                d.push(j.altRowCls)
            }
            if (j.getRowClass) {
                l = j.getRowClass(h, a, null, j.dataSource);
                if (l) {
                    c.push(l)
                }
            }
        }
        if (g) {
            k.applyOut(m, g, j.tableValues)
        } else {
            return k.apply(m, j.tableValues)
        }
    },
    renderCell: function (d, h, g, n, j, e) {
        var l = this, b, i = l.selectionModel, k = l.cellValues, c = k.classes, a = h.data[d.dataIndex], o = l.cellTpl,
            p, m, q = l.navigationModel.getPosition();
        k.record = h;
        k.column = d;
        k.recordIndex = g;
        k.rowIndex = n;
        k.columnIndex = k.cellIndex = j;
        k.align = d.align;
        k.innerCls = d.innerCls;
        k.tdCls = k.tdStyle = k.tdAttr = k.style = "";
        k.unselectableAttr = l.enableTextSelection ? "" : 'unselectable="on"';
        c[1] = d.getCellId();
        m = 2;
        if (d.renderer && d.renderer.call) {
            b = l.ownerCt.columnManager.getHeaderIndex(d);
            p = d.renderer.call(d.usingDefaultRenderer ? d : d.scope || l.ownerCt, a, k, h, g, b, l.dataSource, l);
            if (k.css) {
                h.cssWarning = true;
                k.tdCls += " " + k.css;
                k.css = null
            }
            if (k.tdCls) {
                c[m++] = k.tdCls
            }
        } else {
            p = a
        }
        k.value = (p == null || p === "") ? d.emptyCellText : p;
        if (d.tdCls) {
            c[m++] = d.tdCls
        }
        if (l.markDirty && h.dirty && h.isModified(d.dataIndex)) {
            c[m++] = l.dirtyCls
        }
        if (d.isFirstVisible) {
            c[m++] = l.firstCls
        }
        if (d.isLastVisible) {
            c[m++] = l.lastCls
        }
        if (!l.enableTextSelection) {
            c[m++] = l.unselectableCls
        }
        if (i && (i.isCellModel || i.isSpreadsheetModel) && i.isCellSelected(l, g, d)) {
            c[m++] = l.selectedCellCls
        }
        if (q && q.record.id === h.id && q.column === d) {
            c[m++] = l.focusedItemCls
        }
        c.length = m;
        k.tdCls = c.join(" ");
        o.applyOut(k, e);
        k.column = k.record = null
    },
    getRow: function (a) {
        var b;
        if ((!a && a !== 0) || !this.rendered) {
            return null
        }
        if (a.target) {
            a = a.target
        }
        if (Ext.isString(a)) {
            return Ext.fly(a).down(this.rowSelector, true)
        }
        if (Ext.isNumber(a)) {
            b = this.all.item(a);
            return b && b.down(this.rowSelector, true)
        }
        if (a.isModel) {
            return this.getRowByRecord(a)
        }
        b = Ext.fly(a);
        if (b.is(this.itemSelector)) {
            return this.getRowFromItem(b)
        }
        return b.findParent(this.rowSelector, this.getTargetEl())
    },
    getRowId: function (a) {
        return this.id + "-record-" + a.internalId
    },
    constructRowId: function (a) {
        return this.id + "-record-" + a
    },
    getNodeById: function (a) {
        a = this.constructRowId(a);
        return this.retrieveNode(a, false)
    },
    getRowById: function (a) {
        a = this.constructRowId(a);
        return this.retrieveNode(a, true)
    },
    getNodeByRecord: function (a) {
        return this.retrieveNode(this.getRowId(a), false)
    },
    getRowByRecord: function (a) {
        return this.retrieveNode(this.getRowId(a), true)
    },
    getRowFromItem: function (c) {
        var d = Ext.getDom(c).tBodies[0].childNodes, a = d.length, b;
        for (b = 0; b < a; b++) {
            if (Ext.fly(d[b]).is(this.rowSelector)) {
                return d[b]
            }
        }
    },
    retrieveNode: function (c, b) {
        var a = this.el.getById(c, true);
        if (b && a) {
            return Ext.fly(a).down(this.rowSelector, true)
        }
        return a
    },
    updateIndexes: Ext.emptyFn,
    bodySelector: "div.x-grid-item-container",
    nodeContainerSelector: "div.x-grid-item-container",
    itemSelector: "table.x-grid-item",
    rowSelector: "tr.x-grid-row",
    cellSelector: "td.x-grid-cell",
    sizerSelector: ".x-grid-cell",
    innerSelector: "div.x-grid-cell-inner",
    getBodySelector: function () {
        return this.bodySelector
    },
    getColumnSizerSelector: function (b) {
        var a = this.sizerSelector + "-" + b.getItemId();
        return "td" + a + ",col" + a
    },
    getItemSelector: function () {
        return this.itemSelector
    },
    getCellSelector: function (a) {
        return a ? a.getCellSelector() : this.cellSelector
    },
    getCellInnerSelector: function (a) {
        return this.getCellSelector(a) + " " + this.innerSelector
    },
    addRowCls: function (b, a) {
        var c = this.getRow(b);
        if (c) {
            Ext.fly(c).addCls(a)
        }
    },
    removeRowCls: function (b, a) {
        var c = this.getRow(b);
        if (c) {
            Ext.fly(c).removeCls(a)
        }
    },
    onRowSelect: function (c) {
        var b = this, a;
        b.addItemCls(c, b.selectedItemCls);
        a = b.getRow(c);
        if (a) {
            a.setAttribute("aria-selected", true)
        }
        if (Ext.isIE8) {
            b.repaintBorder(c + 1)
        }
    },
    onRowDeselect: function (c) {
        var b = this, a;
        b.removeItemCls(c, b.selectedItemCls);
        a = b.getRow(c);
        if (a) {
            a.removeAttribute("aria-selected")
        }
        if (Ext.isIE8) {
            b.repaintBorder(c + 1)
        }
    },
    onCellSelect: function (b) {
        var a = this.getCellByPosition(b);
        if (a) {
            a.addCls(this.selectedCellCls);
            a.dom.setAttribute("aria-selected", true)
        }
    },
    onCellDeselect: function (b) {
        var a = this.getCellByPosition(b, true);
        if (a) {
            Ext.fly(a).removeCls(this.selectedCellCls);
            a.removeAttribute("aria-selected")
        }
    },
    getCellInclusive: function (a, b) {
        if (a) {
            var c = this.getRow(a.row), d = this.ownerCt.getColumnManager().getHeaderAtIndex(a.column);
            if (d && c) {
                return Ext.fly(c).down(this.getCellSelector(d), b)
            }
        }
        return false
    },
    getCellByPosition: function (a, c) {
        if (a) {
            var b = a.view || this, d = b.getRow(a.record || a.row),
                e = a.column.isColumn ? a.column : b.getVisibleColumnManager().getHeaderAtIndex(a.column);
            if (e && d) {
                return Ext.fly(d).down(b.getCellSelector(e), c)
            }
        }
        return false
    },
    onFocusEnter: function (d) {
        var g = this, i = d.fromComponent, k = g.getNavigationModel(), b, l = g.bufferedRenderer, h, a, j, c;
        if (g.actionableMode) {
            return
        }
        d = d.event;
        if (!g.cellFocused && g.all.getCount() && g.dataSource.getCount()) {
            j = d.getTarget();
            if (Ext.fly(j).is(g.getCellSelector())) {
                b = new Ext.grid.CellContext(g).setPosition(g.getRecord(j), g.getHeaderByCell(j))
            } else {
                if (j && g.el.contains(j) && j !== g.el.dom) {
                    g.ownerGrid.setActionableMode(true, new Ext.grid.CellContext(g).setPosition(g.getRecord(j), g.getHeaderByCell(Ext.fly(j).up(g.getCellSelector()))));
                    j.focus()
                } else {
                    b = g.lastFocused;
                    if (b) {
                        c = g.getScrollable();
                        if (!c || c.isInView(b.getRow()).y) {
                            h = b.record
                        }
                    } else {
                        b = new Ext.grid.CellContext((g.isNormalView && g.lockingPartner.grid.isVisible()) ? g.lockingPartner : g).setColumn(0)
                    }
                    if (i && i.isColumn && i.getView() === g) {
                        b.view = g;
                        b.setColumn(i)
                    }
                    if (!h) {
                        a = l ? l.getFirstVisibleRowIndex() : 0;
                        h = g.dataSource.getAt(a);
                        while (h && h.isNonData) {
                            a++;
                            h = g.dataSource.getAt(a)
                        }
                        if (h) {
                            b.setRow(h)
                        } else {
                            b = null
                        }
                    }
                    if (!b) {
                        d.stopEvent();
                        g.el.dom.focus();
                        return
                    }
                }
            }
        }
        if (b) {
            k.setPosition(b, null, d, null, true);
            g.cellFocused = !!k.getPosition();
            if (g.cellFocused) {
                g.el.dom.setAttribute("tabIndex", "-1");
                g.toggleChildrenTabbability(false)
            }
        }
        Ext.Component.prototype.onFocusEnter.call(g, d)
    },
    onFocusLeave: function (c) {
        var b = this,
            a = !b.lockingPartner || !c.toComponent || (c.toComponent !== b.lockingPartner && !b.lockingPartner.isAncestor(c.toComponent));
        if (!b.refreshing) {
            if (b.cellFocused) {
                if (a) {
                    b.getNavigationModel().setPosition(null, null, c.event, null, true)
                }
                b.cellFocused = false;
                b.focusEl = b.el;
                b.focusEl.dom.setAttribute("tabIndex", 0)
            }
            if (a) {
                if (b.ownerGrid.actionableMode) {
                    b.ownerGrid.setActionableMode(false)
                }
            }
            Ext.Component.prototype.onFocusLeave.call(b, c)
        }
    },
    onRowFocus: function (d, b, a) {
        var c = this;
        if (b) {
            c.addItemCls(d, c.focusedItemCls);
            if (!a) {
                c.focusRow(d)
            }
        } else {
            c.removeItemCls(d, c.focusedItemCls)
        }
        if (Ext.isIE8) {
            c.repaintBorder(d + 1)
        }
    },
    focusRow: function (d, a) {
        var c = this, b = c.getFocusTask();
        if (a) {
            b.delay(Ext.isNumber(a) ? a : 10, c.focusRow, c, [d, false]);
            return
        }
        b.cancel();
        if (c.isVisible(true)) {
            c.getNavigationModel().setPosition(c.getRecord(d))
        }
    },
    focusNode: function (b, a) {
        this.focusRow(b, a)
    },
    scrollRowIntoView: function (b, a) {
        b = this.getRow(b);
        if (b) {
            this.scrollElIntoView(b, false, a)
        }
    },
    focusCell: function (b, c) {
        var e = this, a, d = e.getFocusTask();
        if (c) {
            d.delay(Ext.isNumber(c) ? c : 10, e.focusCell, e, [b, false]);
            return
        }
        d.cancel();
        if (e.isVisible(true) && (a = e.getCellByPosition(b))) {
            e.getNavigationModel().setPosition(b)
        }
    },
    getLastFocused: function () {
        var b = this, a = b.lastFocused;
        if (a && a.record && a.column) {
            if (b.dataSource.indexOf(a.record) !== -1 && b.getVisibleColumnManager().indexOf(a.column) !== -1 && b.getNode(a.record)) {
                return a
            }
        }
    },
    scrollCellIntoView: function (a, b) {
        if (a.isCellContext) {
            a = this.getCellByPosition(a)
        }
        if (a) {
            this.scrollElIntoView(a, null, b)
        }
    },
    scrollElIntoView: function (c, d, b) {
        var a = this.getScrollable();
        if (a) {
            a.scrollIntoView(c, d, b)
        }
    },
    syncRowHeightBegin: function () {
        var g = this, k = g.all, e = k.count, c = [], h = Ext.grid.locking.RowSynchronizer, b, a, d;
        for (b = 0, a = k.startIndex; b < e; b++, a++) {
            c[b] = d = new h(g, k.elements[a]);
            d.reset()
        }
        return c
    },
    syncRowHeightClear: function (b) {
        var d = this, e = d.all, c = e.count, a;
        for (a = 0; a < c; a++) {
            b[a].reset()
        }
    },
    syncRowHeightMeasure: function (b) {
        var c = b.length, a;
        for (a = 0; a < c; a++) {
            b[a].measure()
        }
    },
    syncRowHeightFinish: function (b, d) {
        var c = b.length, e = this.bufferedRenderer, a;
        for (a = 0; a < c; a++) {
            b[a].finish(d[a])
        }
        if (e) {
            e.syncRowHeightsFinish()
        }
    },
    handleUpdate: function (p, h, s, C) {
        s = s || Ext.data.Model.EDIT;
        var K = this, j = K.store.indexOf(h), v = K.rowTpl, n = K.markDirty, z = K.dirtyCls,
            D = s !== Ext.data.Model.EDIT, y = [], A = K.variableRowHeight, w = 0, H = K.ownerCt,
            d = K.cellFly || (K.self.prototype.cellFly = new Ext.dom.Fly()), t, q, k, r, F, I, m, x, c, g, G, E, o, b,
            e, B, J, a, l, u;
        if (K.viewReady) {
            t = K.getNodeByRecord(h);
            if (t) {
                x = K.overItemCls;
                c = K.ownerCt.getVisibleColumnManager().getColumns();
                for (E = 0, G = c.length; E < G; E++) {
                    g = c[E];
                    if (g.preventUpdate) {
                        b = Ext.fly(t).down(g.getCellSelector(), true);
                        if (!D && n) {
                            d.attach(b);
                            if (h.isModified(g.dataIndex)) {
                                d.addCls(z)
                            } else {
                                d.removeCls(z)
                            }
                        }
                    } else {
                        o = K.shouldUpdateCell(h, g, C);
                        if (o) {
                            w = w | o;
                            y[y.length] = g;
                            A = A || g.variableRowHeight
                        }
                    }
                }
                K.fireEvent("beforeitemupdate", h, j, t, y);
                if (K.getRowClass || !K.getRowFromItem(t) || (w & 1) || (t.tBodies[0].childNodes.length > 1)) {
                    l = t._extData;
                    k = K.createRowElement(h, K.indexOfRow(h), y);
                    if (Ext.fly(t, "_internal").hasCls(x)) {
                        Ext.fly(k).addCls(x)
                    }
                    if (Ext.isIE9m && t.mergeAttributes) {
                        t.mergeAttributes(k, true)
                    } else {
                        r = k.attributes;
                        F = r.length;
                        for (m = 0; m < F; m++) {
                            I = r[m].name;
                            if (I !== "id") {
                                t.setAttribute(I, r[m].value)
                            }
                        }
                    }
                    if (l) {
                        l.isSynchronized = false
                    }
                    if (c.length && (q = K.getRow(t))) {
                        K.updateColumns(q, Ext.fly(k).down(K.rowSelector, true), y)
                    }
                    while (v) {
                        if (v.syncContent) {
                            if (v.syncContent(t, k, C ? y : null) === false) {
                                break
                            }
                        }
                        v = v.nextTpl
                    }
                } else {
                    for (E = 0, G = y.length; E < G; E++) {
                        g = y[E];
                        e = g.dataIndex;
                        B = h.get(e);
                        b = Ext.fly(t).down(g.getCellSelector(), true);
                        d.attach(b);
                        if (!D && n) {
                            if (h.isModified(g.dataIndex)) {
                                d.addCls(z)
                            } else {
                                d.removeCls(z)
                            }
                        }
                        J = g.usingDefaultRenderer;
                        a = J ? g : g.scope;
                        if (g.updater) {
                            Ext.callback(g.updater, a, [b, B, h, K, K.dataSource], 0, g, H)
                        } else {
                            if (g.renderer) {
                                B = Ext.callback(g.renderer, a, [B, null, h, 0, 0, K.dataSource, K], 0, g, H)
                            }
                            u = B == null || B === "";
                            B = u ? g.emptyCellText : B;
                            if (g.producesHTML || u) {
                                d.down(K.innerSelector, true).innerHTML = B
                            } else {
                                d.down(K.innerSelector, true).childNodes[0].data = B
                            }
                        }
                        if (K.highlightClass) {
                            Ext.fly(b).addCls(K.highlightClass);
                            if (!K.changedCells) {
                                K.self.prototype.changedCells = [];
                                K.prototype.clearChangedTask = new Ext.util.DelayedTask(K.clearChangedCells, K.prototype);
                                K.clearChangedTask.delay(K.unhighlightDelay)
                            }
                            K.changedCells.push({cell: b, cls: K.highlightClass, expires: Ext.Date.now() + 1000})
                        }
                    }
                }
                if (D && n && !h.dirty) {
                    Ext.fly(t, "_internal").select("." + z).removeCls(z)
                }
                if (A) {
                    Ext.suspendLayouts()
                }
                K.fireEvent("itemupdate", h, j, t);
                if (A) {
                    if (K.bufferedRenderer) {
                        K.bufferedRenderer.refreshSize();
                        K.ownerGrid.updateLayout()
                    } else {
                        K.refreshSize()
                    }
                    Ext.resumeLayouts(true)
                }
            }
        }
    },
    clearChangedCells: function () {
        var d = this, b = Ext.Date.now(), e;
        for (var c = 0, a = d.changedCells.length; c < a;) {
            e = d.changedCells[c];
            if (e.expires <= b) {
                Ext.fly(e.cell).removeCls(e.highlightClass);
                Ext.Array.erase(d.changedCells, c, 1);
                a--
            } else {
                break
            }
        }
        if (a) {
            d.clearChangedTask.delay(d.unhighlightDelay)
        }
    },
    updateColumns: function (j, k, l) {
        var i = this, b, a, h, c, n = l.length, m, d, o, g, e = i.getCellSelector();
        if (j.mergeAttributes) {
            j.mergeAttributes(k, true)
        } else {
            b = k.attributes;
            a = b.length;
            for (c = 0; c < a; c++) {
                h = b[c].name;
                if (h !== "id") {
                    j.setAttribute(h, b[c].value)
                }
            }
        }
        for (m = 0; m < n; m++) {
            d = l[m];
            e = i.getCellSelector(d);
            o = Ext.fly(j).selectNode(e);
            g = Ext.fly(k).selectNode(e);
            Ext.fly(o).syncContent(g)
        }
    },
    shouldUpdateCell: function (b, e, d) {
        if (!e.preventUpdate) {
            if (e.hasCustomRenderer) {
                return 1
            }
            if (d) {
                var a = d.length, c, g;
                for (c = 0; c < a; ++c) {
                    g = d[c];
                    if (g === e.dataIndex || g === b.idProperty) {
                        return 2
                    }
                }
            } else {
                return 2
            }
        }
        return 0
    },
    refresh: function () {
        var b = this, a;
        if (b.destroying) {
            return
        }
        Ext.view.View.prototype.refresh.apply(this, arguments);
        b.headerCt.setSortState();
        if (b.touchScroll && b.el && !b.all.getCount() && b.headerCt && b.headerCt.tooNarrow) {
            a = b.getScrollable();
            if (a && a.isTouchScroller) {
                a.setSize({x: b.headerCt.getTableWidth(), y: a.getSize().y})
            }
        }
    },
    processContainerEvent: function (b) {
        var a = Ext.Component.fromElement(b.target.parentNode);
        if (a && a.up(this.ownerCt)) {
            return false
        }
    },
    processItemEvent: function (b, r, l, q) {
        var u = this, n = u.self, t = n.EventMap, d = q.type, h = u.features, p = h.length, o, k, m, g, c,
            s = q.position = u.eventPosition || (u.eventPosition = new Ext.grid.CellContext()), j, a;
        if (Ext.isIE && d === "mouseup" && !q.within(u.el)) {
            return false
        }
        if (u.indexInStore(r) !== -1) {
            j = s.rowElement = Ext.fly(r).down(u.rowSelector, true);
            a = q.getTarget(u.getCellSelector(), j);
            d = n.TouchEventMap[d] || d;
            if (a) {
                if (!a.parentNode) {
                    return false
                }
                c = u.getHeaderByCell(a);
                k = u.ownerCt.getColumnManager().getHeaderIndex(c)
            } else {
                k = -1
            }
            s.setAll(u, l, c ? u.getVisibleColumnManager().getHeaderIndex(c) : -1, b, c);
            s.cellElement = a;
            m = u.fireEvent("uievent", d, u, a, l, k, q, b, j);
            if ((m === false || Ext.view.View.prototype.processItemEvent.apply(this, arguments) === false)) {
                return false
            }
            for (o = 0; o < p; ++o) {
                g = h[o];
                if (g.wrapsItem) {
                    if (g.vetoEvent(b, j, l, q) === false) {
                        u.processSpecialEvent(q);
                        return false
                    }
                }
            }
            if (a && d !== "mouseover" && d !== "mouseout") {
                m = !((u["onBeforeCell" + t[d]](a, k, b, j, l, q) === false) || (u.fireEvent("beforecell" + d, u, a, k, b, j, l, q) === false) || (u["onCell" + t[d]](a, k, b, j, l, q) === false) || (u.fireEvent("cell" + d, u, a, k, b, j, l, q) === false))
            }
            if (m !== false) {
                m = u.fireEvent("row" + d, u, b, j, l, q)
            }
            return m
        } else {
            this.processSpecialEvent(q);
            q.preventDefault();
            return false
        }
    },
    processSpecialEvent: function (j) {
        var m = this, c = m.features, l = c.length, n = j.type, d, o, g, h, b, k, a = m.ownerCt;
        Ext.view.View.prototype.processSpecialEvent.apply(this, arguments);
        if (n === "mouseover" || n === "mouseout") {
            return
        }
        n = m.self.TouchEventMap[n] || n;
        for (d = 0; d < l; d++) {
            o = c[d];
            if (o.hasFeatureEvent) {
                h = j.getTarget(o.eventSelector, m.getTargetEl());
                if (h) {
                    g = o.eventPrefix;
                    b = o.getFireEventArgs("before" + g + n, m, h, j);
                    k = o.getFireEventArgs(g + n, m, h, j);
                    if ((m.fireEvent.apply(m, b) === false) || (a.fireEvent.apply(a, b) === false) || (m.fireEvent.apply(m, k) === false) || (a.fireEvent.apply(a, k) === false)) {
                        return false
                    }
                }
            }
        }
        return true
    },
    onCellMouseDown: Ext.emptyFn,
    onCellLongPress: Ext.emptyFn,
    onCellMouseUp: Ext.emptyFn,
    onCellClick: Ext.emptyFn,
    onCellDblClick: Ext.emptyFn,
    onCellContextMenu: Ext.emptyFn,
    onCellKeyDown: Ext.emptyFn,
    onCellKeyUp: Ext.emptyFn,
    onCellKeyPress: Ext.emptyFn,
    onBeforeCellMouseDown: Ext.emptyFn,
    onBeforeCellLongPress: Ext.emptyFn,
    onBeforeCellMouseUp: Ext.emptyFn,
    onBeforeCellClick: Ext.emptyFn,
    onBeforeCellDblClick: Ext.emptyFn,
    onBeforeCellContextMenu: Ext.emptyFn,
    onBeforeCellKeyDown: Ext.emptyFn,
    onBeforeCellKeyUp: Ext.emptyFn,
    onBeforeCellKeyPress: Ext.emptyFn,
    expandToFit: function (a) {
        this.autoSizeColumn(a)
    },
    autoSizeColumn: function (a) {
        if (Ext.isNumber(a)) {
            a = this.getGridColumns()[a]
        }
        if (a) {
            if (a.isGroupHeader) {
                a.autoSize();
                return
            }
            delete a.flex;
            a.setWidth(this.getMaxContentWidth(a))
        }
    },
    getMaxContentWidth: function (d) {
        var g = this, l = g.el.query(d.getCellInnerSelector()), b = d.getWidth(), c = 0, e = l.length,
            a = g.body.select(g.getColumnSizerSelector(d)), j = Math.max, h = 0, k;
        if (e > 0) {
            if (Ext.supports.ScrollWidthInlinePaddingBug) {
                h += g.getCellPaddingAfter(l[0])
            }
            if (g.columnLines) {
                h += Ext.fly(l[0].parentNode).getBorderWidth("lr")
            }
        }
        a.setWidth(1);
        d.textEl.setStyle({"text-overflow": "clip", display: "table-cell"});
        k = d.textEl.dom.offsetWidth + d.titleEl.getPadding("lr");
        d.textEl.setStyle({"text-overflow": "", display: ""});
        for (; c < e; c++) {
            k = j(k, l[c].scrollWidth)
        }
        k += h;
        k = j(k + 1, 40);
        a.setWidth(b);
        return k
    },
    getPositionByEvent: function (g) {
        var d = this, b = g.getTarget(d.cellSelector), c = g.getTarget(d.itemSelector), a = d.getRecord(c),
            h = d.getHeaderByCell(b);
        return d.getPosition(a, h)
    },
    getHeaderByCell: function (a) {
        if (a) {
            return this.ownerCt.getVisibleColumnManager().getHeaderById(Ext.getDom(a).getAttribute("data-columnId"))
        }
        return false
    },
    walkCells: function (h, i, c, j) {
        var g = this, k = h.clone(),
            e = g.lockingPartner && g.lockingPartner.grid.isVisible() ? g.lockingPartner : null, b = h.rowIdx,
            a = g.dataSource.getCount() - 1, d = g.ownerCt.getVisibleColumnManager().getColumns();
        switch (i.toLowerCase()) {
            case"right":
                if (h.isLastColumn()) {
                    b = e && g.isLockedView ? b : b + 1;
                    if (b > a) {
                        return false
                    }
                    if (e) {
                        k.view = e
                    }
                    k.setPosition(b, 0)
                } else {
                    k.navigate(+1)
                }
                break;
            case"left":
                if (h.isFirstColumn()) {
                    b = e && g.isNormalView ? b : b - 1;
                    if (b < 0) {
                        return false
                    }
                    if (e) {
                        k.view = e;
                        d = e.getVisibleColumnManager().getColumns()
                    }
                    k.setPosition(b, d[d.length - 1])
                } else {
                    k.navigate(-1)
                }
                break;
            case"up":
                if (b === 0) {
                    return false
                } else {
                    k.setRow(b - 1)
                }
                break;
            case"down":
                if (b === a) {
                    return false
                } else {
                    k.setRow(b + 1)
                }
                break
        }
        if (c && c.call(j || g, k) !== true) {
            return false
        }
        return k
    },
    walkRows: function (i, a) {
        var d = this, h = d.dataSource, e = 0, k = i, b, c = (a < 0) ? 0 : h.getCount() - 1, g = c ? 1 : -1, j = i;
        do {
            if (c ? j >= c : j <= c) {
                return k || c
            }
            j += g;
            if ((b = Ext.fly(d.getRow(j))) && b.isVisible(true)) {
                e += g;
                k = j
            }
        } while (e !== a);
        return j
    },
    walkRecs: function (b, a) {
        var h = this, k = h.dataSource, i = 0, l = b, c,
            e = (a < 0) ? 0 : (k.isBufferedStore ? k.getTotalCount() : k.getCount()) - 1, j = e ? 1 : -1,
            g = k.indexOf(b), d;
        do {
            if (e ? g >= e : g <= e) {
                return l
            }
            g += j;
            d = k.getAt(g);
            if (!d.isCollapsedPlaceholder && (c = Ext.fly(h.getNodeByRecord(d))) && c.isVisible(true)) {
                i += j;
                l = d
            }
        } while (i !== a);
        return l
    },
    getFirstVisibleRowIndex: function () {
        var c = this, b = (c.dataSource.isBufferedStore ? c.dataSource.getTotalCount() : c.dataSource.getCount()),
            a = c.indexOf(c.all.first()) - 1;
        do {
            a += 1;
            if (a === b) {
                return
            }
        } while (!Ext.fly(c.getRow(a)).isVisible(true));
        return a
    },
    getLastVisibleRowIndex: function () {
        var b = this, a = b.indexOf(b.all.last());
        do {
            a -= 1;
            if (a === -1) {
                return
            }
        } while (!Ext.fly(b.getRow(a)).isVisible(true));
        return a
    },
    getHeaderCt: function () {
        return this.headerCt
    },
    getPosition: function (a, b) {
        return new Ext.grid.CellContext(this).setPosition(a, b)
    },
    onDestroy: function () {
        var d = this, c = d.featuresMC, a, b;
        if (c) {
            for (b = 0, a = c.getCount(); b < a; ++b) {
                c.getAt(b).destroy()
            }
        }
        d.cellFly = d.featuresMC = null;
        Ext.view.View.prototype.onDestroy.apply(this, arguments);
        d.all.destroy();
        d.body.destroy();
        d.all = d.body = d.body.el = null;
        d.grid = d.ownerGrid = d.headerCt = d.panel = null;
        d.selection = d.actionPosition = d.eventPosition = d.lastFocused = null;
        d.actionRow = d.cellTpl = d.rowTpl = d.bufferedRenderer = null
    },
    onReplace: function (b, e, a, d) {
        var c = this, g = c.bufferedRenderer;
        if (c.rendered && g) {
            g.onReplace(b, e, a, d)
        } else {
            Ext.view.View.prototype.onReplace.apply(this, arguments)
        }
        c.setPendingStripe(e)
    },
    onAdd: function (b, a, c) {
        var d = this, e = d.bufferedRenderer;
        if (d.rendered && e && (e.bodyTop || d.dataSource.getCount() + a.length >= e.viewSize)) {
            e.onReplace(b, c, [], a)
        } else {
            Ext.view.View.prototype.onAdd.apply(this, arguments)
        }
        d.setPendingStripe(c)
    },
    onRemove: function (b, a, c) {
        var d = this, e = d.bufferedRenderer;
        if (d.rendered && e) {
            e.onReplace(b, c, a, [])
        } else {
            Ext.view.View.prototype.onRemove.apply(this, arguments)
        }
        d.setPendingStripe(c)
    },
    onDataRefresh: function (b) {
        var c = this, a = c.ownerCt;
        if (a && a.isCollapsingOrExpanding === 2) {
            a.on("expand", c.onDataRefresh, c, {single: true});
            return
        }
        Ext.view.View.prototype.onDataRefresh.call(this, b)
    },
    getViewRange: function () {
        var a = this;
        if (a.bufferedRenderer) {
            return a.bufferedRenderer.getViewRange()
        }
        return Ext.view.View.prototype.getViewRange.call(this)
    },
    setPendingStripe: function (a) {
        var b = this.stripeOnUpdate;
        if (b === null) {
            b = a
        } else {
            b = Math.min(b, a)
        }
        this.stripeOnUpdate = b
    },
    onEndUpdate: function () {
        var a = this, c = a.stripeOnUpdate, b = a.all.startIndex;
        if (a.rendered && (c || c === 0)) {
            if (c < b) {
                c = b
            }
            a.doStripeRows(c);
            a.stripeOnUpdate = null
        }
        Ext.view.View.prototype.onEndUpdate.apply(this, arguments)
    },
    doStripeRows: function (b, a) {
        var d = this, e, h, c, g;
        if (d.rendered && d.stripeRows) {
            e = d.getNodes(b, a);
            for (c = 0, h = e.length; c < h; c++) {
                g = e[c];
                g.className = g.className.replace(d.rowClsRe, " ");
                b++;
                if (b % 2 === 0) {
                    g.className += (" " + d.altRowCls)
                }
            }
        }
    },
    hasActiveFeature: function () {
        return (this.isGrouping && this.store.isGrouped()) || this.isRowWrapped
    },
    getCellPaddingAfter: function (a) {
        return Ext.fly(a).getPadding("r")
    },
    privates: {
        refreshScroll: function () {
            var a = this, b = a.bufferedRenderer;
            if (b) {
                b.refreshSize()
            } else {
                Ext.view.View.prototype.refreshScroll.call(this)
            }
        }, collectNodes: function (a) {
            this.all.fill(this.getNodeContainer().childNodes, this.all.startIndex)
        }, setActionableMode: function (j, g) {
            var l = this, a = l.getNavigationModel(), b, p, m, c, n = l.grid.actionables, h = n.length, d, e, o, k, q;
            if (l.actionableMode === j) {
                if (j && g.isEqual(l.actionPosition)) {
                    return false
                }
                q = false
            }
            if (j) {
                if (g && (g.view === l || (g.view === (k = l.lockingPartner) && k.actionableMode))) {
                    g = g.clone();
                    e = g.record;
                    b = l.all.item(g.rowIdx);
                    if (!k) {
                        p = Ext.fly(b).down(g.column.getCellSelector());
                        for (d = 0; d < h; d++) {
                            o = o || n[d].activateCell(g)
                        }
                    }
                    if (k || p.restoreTabbableState(true).length || o) {
                        for (d = 0; d < h; d++) {
                            if (n[d].activateRow) {
                                n[d].activateRow(b)
                            }
                        }
                        if (k || (m = p.findTabbableElements()).length) {
                            b.restoreTabbableState(true);
                            if (k) {
                                l.actionableMode = true;
                                return q
                            }
                            if (m) {
                                l.actionRow = b;
                                l.actionableMode = l.ownerGrid.actionableMode = true;
                                a.setPosition();
                                a.actionPosition = l.actionPosition = g;
                                m[0].focus();
                                return q
                            }
                        }
                    }
                }
                return false
            } else {
                c = Ext.fly(Ext.Element.getActiveElement());
                for (d = 0; d < h; d++) {
                    if (n[d].deactivate) {
                        n[d].deactivate()
                    }
                }
                if (l.actionRow) {
                    l.actionRow.saveTabbableState({skipSelf: true, includeSaved: false})
                }
                if (l.el.contains(c)) {
                    a.setPosition(new Ext.grid.CellContext(l).setPosition(l.getRecord(c) || 0, l.getHeaderByCell(c.findParent(l.getCellSelector())) || 0))
                }
                l.actionableMode = l.ownerGrid.actionableMode = false;
                l.actionPosition = a.actionPosition = l.actionRow = null
            }
        }, onRowExit: function (c, m, e) {
            var j = this, k = e ? "nextSibling" : "previousSibling", h = j.lockingPartner, l = j.grid.actionables,
                g = l.length, d, b, a;
            j.refreshing = j.actionableModeTabbing = true;
            for (d = 0; d < g; d++) {
                if (l[d].deactivate) {
                    l[d].deactivate()
                }
            }
            if (h && h.grid.isVisible()) {
                b = j.all.indexOf(c);
                if (e) {
                    a = 0;
                    if (j.isNormalView) {
                        b++
                    }
                } else {
                    a = h.getVisibleColumnManager().getColumns().length - 1;
                    if (j.isLockedView) {
                        b--
                    }
                }
                j = h;
                m = j.all.item(b, true)
            }
            j.findFirstActionableElement(m, k, e);
            j.refreshing = j.actionableModeTabbing = false;
            Ext.fly(c).saveTabbableState({skipSelf: true, includeSaved: false})
        }, findFirstActionableElement: function (a, m, h) {
            var l = this, c = l.getVisibleColumnManager().getColumns(), k = c.length, s, p, q = l.grid.actionables,
                o = q.length, e, d, b, g = new Ext.grid.CellContext(l), r, n;
            if (a) {
                g.setRow(a);
                for (e = 0; e < o; e++) {
                    if (q[e].activateRow) {
                        q[e].activateRow(a)
                    }
                }
                for (e = (h ? 0 : k - 1); (h ? e < k : e > -1) && !p; e = e + (h ? 1 : -1)) {
                    b = c[e];
                    g.setColumn(b);
                    s = Ext.fly(a).down(g.column.getCellSelector());
                    for (d = 0; d < o; d++) {
                        r = r || q[d].activateCell(g)
                    }
                    if (s.restoreTabbableState(true).length || r) {
                        n = s.findTabbableElements();
                        l.actionRow = Ext.get(a);
                        l.actionRow.restoreTabbableState(true);
                        p = n[h ? 0 : n.length - 1]
                    }
                }
                if (p) {
                    l.actionPosition = l.getNavigationModel().actionPosition = g;
                    p.focus();
                    if (Ext.isIE8) {
                        setTimeout(function () {
                            p.focus()
                        }, 0)
                    }
                } else {
                    l.onRowExit(a, l.all.item(g.rowIdx + (h ? 1 : -1)), h)
                }
            } else {
                l.grid.ensureVisible(h ? 0 : l.dataSource.getCount() - 1, {
                    callback: function (t, i, j) {
                        if (t) {
                            l.findFirstActionableElement(j, m, h)
                        } else {
                            l.ownerGrid.setActionableMode(false)
                        }
                    }
                })
            }
        }
    }
}, 1, ["tableview", "gridview"], ["component", "box", "dataview", "tableview", "gridview"], {
    component: true,
    box: true,
    dataview: true,
    tableview: true,
    gridview: true
}, ["widget.gridview", "widget.tableview"], 0, [Ext.view, "Table", Ext.grid, "View"], 0));
(Ext.cmd.derive("Ext.grid.Panel", Ext.panel.Table, {
    alternateClassName: ["Ext.list.ListView", "Ext.ListView", "Ext.grid.GridPanel"],
    viewType: "tableview",
    lockable: false,
    rowLines: true
}, 0, ["grid", "gridpanel"], ["component", "box", "container", "panel", "tablepanel", "gridpanel", "grid"], {
    component: true,
    box: true,
    container: true,
    panel: true,
    tablepanel: true,
    gridpanel: true,
    grid: true
}, ["widget.grid", "widget.gridpanel"], 0, [Ext.grid, "Panel", Ext.list, "ListView", Ext, "ListView", Ext.grid, "GridPanel"], 0));
(Ext.cmd.derive("Ext.grid.RowEditorButtons", Ext.container.Container, {
    frame: true, shrinkWrap: true, position: "bottom", constructor: function (b) {
        var d = this, a = b.rowEditor, e = "x-", c = a.editingPlugin;
        b = Ext.apply({
            baseCls: e + "grid-row-editor-buttons",
            defaults: {
                xtype: "button",
                ui: a.buttonUI,
                scope: c,
                flex: 1,
                minWidth: Ext.panel.Panel.prototype.minButtonWidth
            },
            items: [{
                cls: e + "row-editor-update-button",
                itemId: "update",
                handler: c.completeEdit,
                text: a.saveBtnText,
                disabled: a.updateButtonDisabled,
                listeners: {element: "el", keydown: d.onUpdateKeyDown, scope: d}
            }, {
                cls: e + "row-editor-cancel-button",
                itemId: "cancel",
                handler: c.cancelEdit,
                text: a.cancelBtnText,
                listeners: {element: "el", keydown: d.onCancelKeyDown, scope: d}
            }]
        }, b);
        Ext.container.Container.prototype.constructor.call(this, b);
        d.addClsWithUI(d.position)
    }, onUpdateKeyDown: function (a) {
        if (a.shiftKey && a.getKey() === a.TAB) {
            a.stopEvent();
            this.rowEditor.child(":focusable:not([isButton]):last").focus(false, true)
        }
    }, onCancelKeyDown: function (a) {
        if (!a.shiftKey && a.getKey() === a.TAB) {
            a.stopEvent();
            this.rowEditor.child(":focusable").focus(false, true)
        }
    }, setButtonPosition: function (b) {
        var e = this, a = this.rowEditor, h = a.getHeight(), d = a.body, c = "", g = "";
        e.removeClsWithUI(e.position);
        e.position = b;
        e.addClsWithUI(b);
        if (b === "top") {
            c = (h - d.getBorderWidth("t")) + "px"
        } else {
            g = (h - d.getBorderWidth("b")) + "px"
        }
        e.el.setStyle({top: g, bottom: c})
    }, privates: {
        getFramingInfoCls: function () {
            return this.baseCls + "-" + this.ui + "-" + this.position
        }, getFrameInfo: function () {
            var a = Ext.container.Container.prototype.getFrameInfo.call(this);
            a.top = true;
            return a
        }
    }
}, 1, ["roweditorbuttons"], ["component", "box", "container", "roweditorbuttons"], {
    component: true,
    box: true,
    container: true,
    roweditorbuttons: true
}, ["widget.roweditorbuttons"], 0, [Ext.grid, "RowEditorButtons"], 0));
(Ext.cmd.derive("Ext.grid.RowEditor", Ext.form.Panel, {
    saveBtnText: "Update",
    cancelBtnText: "Cancel",
    errorsText: "Errors",
    dirtyText: "You need to commit or cancel your changes",
    lastScrollLeft: 0,
    lastScrollTop: 0,
    border: false,
    _wrapCls: "x-grid-row-editor-wrap",
    errorCls: "x-grid-row-editor-errors-item",
    buttonUI: "default",
    hideMode: "offsets",
    initComponent: function () {
        var d = this, b = d.editingPlugin.grid, a = Ext.container.Container, c, e, g;
        d.cls = "x-grid-editor x-grid-row-editor";
        d.layout = {type: "hbox", align: "middle"};
        d.lockable = b.lockable;
        if (d.lockable) {
            d.items = [g = d.lockedColumnContainer = new a({
                id: b.id + "-locked-editor-cells",
                scrollable: {x: false, y: false},
                layout: {type: "hbox", align: "middle"},
                margin: "0 1 0 0"
            }), e = d.normalColumnContainer = new a({
                scrollable: {x: false, y: false},
                flex: 1,
                id: b.id + "-normal-editor-cells",
                layout: {type: "hbox", align: "middle"}
            })];
            g.getScrollable().addPartner(b.lockedGrid.view.getScrollable(), "x");
            e.getScrollable().addPartner(b.normalGrid.view.getScrollable(), "x")
        } else {
            d.setScrollable({x: false, y: false});
            d.getScrollable().addPartner(b.view.getScrollable(), "x");
            d.lockedColumnContainer = d.normalColumnContainer = d
        }
        Ext.form.Panel.prototype.initComponent.call(this);
        if (d.fields) {
            d.addFieldsForColumn(d.fields, true);
            d.insertColumnEditor(d.fields);
            delete d.fields
        }
        d.mon(Ext.GlobalEvents, {scope: d, show: d.repositionIfVisible});
        c = d.getForm();
        c.trackResetOnLoad = true;
        c.on("validitychange", d.onValidityChange, d);
        c.on("errorchange", d.onErrorChange, d)
    },
    onGridResize: function () {
        var c = this, e = c.getClientWidth(), a = c.editingPlugin.grid, d = a.body, b = c.getFloatingButtons();
        c.wrapEl.setLocalX(d.getOffsetsTo(a)[0] + d.getBorderWidth("l") - a.el.getBorderWidth("l"));
        c.setWidth(e);
        b.setLocalX((e - b.getWidth()) / 2);
        if (c.lockable) {
            c.lockedColumnContainer.setWidth(a.lockedGrid.view.el.dom.clientWidth)
        }
    },
    syncAllFieldWidths: function () {
        var e = this, d = e.query("[isEditorComponent]"), a = d.length, c, b;
        for (b = 0; b < a; ++b) {
            c = d[b].column;
            if (c.isVisible()) {
                e.onColumnShow(c)
            }
        }
    },
    syncFieldWidth: function (b) {
        var c = b.getEditor(), a;
        c._marginWidth = (c._marginWidth || c.el.getMargin("lr"));
        a = b.getWidth() - c._marginWidth;
        c.setWidth(a);
        if (c.xtype === "displayfield") {
            c.inputWidth = a
        }
    },
    onValidityChange: function (b, a) {
        this.updateButton(a)
    },
    onErrorChange: function () {
        var b = this, a;
        if (b.errorSummary && b.isVisible()) {
            a = b.getForm().isValid();
            b[a ? "hideToolTip" : "showToolTip"]()
        }
    },
    updateButton: function (b) {
        var a = this.floatingButtons;
        if (a) {
            a.child("#update").setDisabled(!b)
        } else {
            this.updateButtonDisabled = !b
        }
    },
    afterRender: function () {
        var d = this, c = d.editingPlugin, b = c.grid, a = b.lockable ? b.normalGrid.view : b.view;
        Ext.form.Panel.prototype.afterRender.apply(this, arguments);
        d.scrollingView = a;
        d.scrollingViewEl = a.el;
        a.on("scroll", d.onViewScroll, d);
        d.mon(d.el, {click: Ext.emptyFn, stopPropagation: true});
        d.mon(b, "resize", d.onGridResize, d);
        if (d.lockable) {
            b.lockedGrid.view.on("resize", "onGridResize", d)
        }
        d.el.swallowEvent(["keypress", "keydown"]);
        d.initKeyNav();
        d.mon(c.view, {
            beforerefresh: d.onBeforeViewRefresh,
            refresh: d.onViewRefresh,
            itemremove: d.onViewItemRemove,
            scope: d
        });
        d.preventReposition = true;
        d.syncAllFieldWidths();
        delete d.preventReposition
    },
    initKeyNav: function () {
        var b = this, a = b.editingPlugin;
        b.keyNav = new Ext.util.KeyNav(b.el, {
            tab: {fn: b.onFieldTab, scope: b},
            enter: a.onEnterKey,
            esc: a.onEscKey,
            scope: a
        })
    },
    onBeforeViewRefresh: function (b) {
        var c = this, a = b.el.dom;
        if (c.el.dom.parentNode === a) {
            a.removeChild(c.el.dom)
        }
    },
    onViewRefresh: function (a) {
        var c = this, b = c.context, d;
        if (b && (d = a.getRow(b.record))) {
            b.row = d;
            c.reposition();
            if (c.tooltip && c.tooltip.isVisible()) {
                c.tooltip.setTarget(b.row)
            }
        } else {
            c.editingPlugin.cancelEdit()
        }
    },
    onViewItemRemove: function (b, c, e, a) {
        if (!a.refreshing) {
            var d = this.context;
            if (d && b === d.record) {
                this.activeField = null;
                this.editingPlugin.cancelEdit()
            }
        }
    },
    onViewScroll: function () {
        var c = this, b = c.editingPlugin.view.el, h = c.scrollingView, d = h.getScrollY(), g = h.getScrollX(),
            a = d !== c.lastScrollTop, e;
        c.lastScrollTop = d;
        c.lastScrollLeft = g;
        if (c.isVisible()) {
            e = Ext.getDom(c.context.row);
            if (e && b.contains(e)) {
                if (a) {
                    c.context.row = e;
                    c.reposition(null, true);
                    if ((c.tooltip && c.tooltip.isVisible()) || c.hiddenTip) {
                        c.repositionTip()
                    }
                    c.syncEditorClip()
                }
            } else {
                c.setLocalY(-400)
            }
        }
    },
    onColumnResize: function (b, a) {
        var c = this;
        if (c.rendered && !c.editingPlugin.reconfiguring) {
            c.onGridResize();
            c.onViewScroll();
            if (!b.isGroupHeader) {
                c.syncFieldWidth(b);
                c.repositionIfVisible()
            }
        }
    },
    onColumnHide: function (a) {
        if (!this.editingPlugin.reconfiguring && !a.isGroupHeader) {
            a.getEditor().hide();
            this.repositionIfVisible()
        }
    },
    onColumnShow: function (a) {
        var b = this;
        if (b.rendered && !b.editingPlugin.reconfiguring && !a.isGroupHeader && a.getEditor) {
            a.getEditor().show();
            b.syncFieldWidth(a);
            if (!b.preventReposition) {
                this.repositionIfVisible()
            }
        }
    },
    onColumnMove: function (c, a, m) {
        var l = this, h = c.isLocked(), j = h ? l.lockedColumnContainer : l.normalColumnContainer, d, g, k, b, e;
        if (c.isGroupHeader) {
            Ext.suspendLayouts();
            b = m > a;
            e = b ? 1 : 0;
            d = c.getGridColumns();
            for (g = 0, k = d.length; g < k; ++g) {
                c = d[g];
                m = c.getIndex();
                if (b) {
                    ++e
                }
                l.setColumnEditor(c, m + e, j)
            }
            Ext.resumeLayouts(true)
        } else {
            l.setColumnEditor(c, c.getIndex(), j)
        }
    },
    setColumnEditor: function (b, a, c) {
        this.addFieldsForColumn(b);
        c.insert(a, b.getEditor())
    },
    onColumnAdd: function (a) {
        if (a.isGroupHeader) {
            a = a.getGridColumns()
        }
        this.addFieldsForColumn(a);
        this.insertColumnEditor(a);
        this.preventReposition = false
    },
    insertColumnEditor: function (c) {
        var d = this, e, g, a, b;
        if (Ext.isArray(c)) {
            for (b = 0, a = c.length; b < a; b++) {
                d.insertColumnEditor(c[b])
            }
            return
        }
        if (!c.getEditor) {
            return
        }
        g = c.isLocked() ? d.lockedColumnContainer : d.normalColumnContainer;
        g.insert(c.getIndex(), e = c.getEditor());
        e.on("focus", d.onFieldFocus, d);
        d.needsSyncFieldWidths = true
    },
    onFieldFocus: function (a) {
        this.activeField = a;
        this.context.setColumn(a.column);
        a.column.getView().getScrollable().scrollIntoView(a.el)
    },
    onFieldTab: function (h) {
        var d = this, a = d.activeField, c = d.context.rowIdx, b = !h.shiftKey,
            g = a[b ? "nextNode" : "previousNode"](":focusable");
        if (!g || !g.isDescendant(d)) {
            if (d.isDirty()) {
                h.preventDefault();
                d.floatingButtons.child("#update").focus()
            } else {
                c = c + (b ? 1 : -1);
                if (c >= 0 && c <= d.view.dataSource.getCount()) {
                    if (b) {
                        g = d.down(":focusable:not([isButton]):first");
                        a.column.getView().getScrollable().scrollIntoView(a.ownerCt.child(":focusable").el)
                    } else {
                        g = d.down(":focusable:not([isButton]):last")
                    }
                    d.editingPlugin.startEdit(c, g.column)
                }
            }
        }
    },
    destroyColumnEditor: function (a) {
        var b;
        if (a.hasEditor() && (b = a.getEditor())) {
            b.destroy()
        }
    },
    getFloatingButtons: function () {
        var b = this, a = b.floatingButtons;
        if (!a) {
            b.floatingButtons = a = new Ext.grid.RowEditorButtons({ownerCmp: b, rowEditor: b})
        }
        return a
    },
    repositionIfVisible: function (d) {
        var b = this, a = b.view;
        if (d && (d === b || !d.el.isAncestor(a.el))) {
            return
        }
        if (b.isVisible() && a.isVisible(true)) {
            b.reposition()
        }
    },
    isLayoutChild: function (a) {
        return false
    },
    getRefOwner: function () {
        return this.editingPlugin.grid
    },
    getRefItems: function (b) {
        var c = this, a;
        if (c.lockable) {
            a = [c.lockedColumnContainer];
            a.push.apply(a, c.lockedColumnContainer.getRefItems(b));
            a.push(c.normalColumnContainer);
            a.push.apply(a, c.normalColumnContainer.getRefItems(b))
        } else {
            a = Ext.form.Panel.prototype.getRefItems.apply(this, arguments)
        }
        a.push.apply(a, c.getFloatingButtons().getRefItems(b));
        return a
    },
    reposition: function (j, g) {
        var h = this, b = h.context, l = b && b.row, d = 0, k = h.wrapEl, a, c, e, i;
        if (l && Ext.isElement(l)) {
            e = h.syncButtonPosition(h.getScrollDelta());
            if (!h.editingPlugin.grid.rowLines) {
                d = -parseInt(Ext.fly(l).first().getStyle("border-bottom-width"), 10)
            }
            a = h.calculateLocalRowTop(l);
            c = h.calculateEditorTop(a) + d;
            if (!g) {
                i = function () {
                    if (e) {
                        h.scrollingViewEl.scrollBy(0, e, true)
                    }
                    h.focusColumnField(b.column)
                }
            }
            h.syncEditorClip();
            if (j) {
                k.animate(Ext.applyIf({to: {top: c}, duration: j.duration || 125, callback: i}, j))
            } else {
                k.setLocalY(c);
                if (i) {
                    i()
                }
            }
        }
    },
    getScrollDelta: function () {
        var e = this, d = e.scrollingViewEl.dom, c = e.context, b = e.body, a = 0;
        if (c) {
            a = Ext.fly(c.row).getOffsetsTo(d)[1];
            if (a < 0) {
                a -= b.getBorderPadding().beforeY
            } else {
                if (a > 0) {
                    a = Math.max(a + e.getHeight() + e.floatingButtons.getHeight() - d.clientHeight - b.getBorderWidth("b"), 0);
                    if (a > 0) {
                        a -= b.getBorderPadding().afterY
                    }
                }
            }
        }
        return a
    },
    calculateLocalRowTop: function (b) {
        var a = this.editingPlugin.grid;
        return Ext.fly(b).getOffsetsTo(a)[1] - a.el.getBorderWidth("t") + this.lastScrollTop
    },
    calculateEditorTop: function (a) {
        return a - this.body.getBorderPadding().beforeY - this.lastScrollTop
    },
    getClientWidth: function () {
        var c = this, b = c.editingPlugin.grid, a;
        if (c.lockable) {
            a = b.lockedGrid.getWidth() + b.normalGrid.view.el.dom.clientWidth
        } else {
            a = b.view.el.dom.clientWidth
        }
        return a
    },
    getEditor: function (a) {
        var b = this;
        if (Ext.isNumber(a)) {
            return b.query("[isEditorComponent]")[a]
        } else {
            if (a.isHeader && !a.isGroupHeader) {
                return a.getEditor()
            }
        }
    },
    addFieldsForColumn: function (c, a) {
        var e = this, b, d, g;
        if (Ext.isArray(c)) {
            for (b = 0, d = c.length; b < d; b++) {
                e.addFieldsForColumn(c[b], a)
            }
            return
        }
        if (c.getEditor) {
            g = c.getEditor(null, e.getDefaultFieldCfg());
            if (c.align === "right") {
                g.fieldStyle = "text-align:right"
            }
            if (c.xtype === "actioncolumn") {
                g.fieldCls += " x-form-action-col-field"
            }
            if (e.isVisible() && e.context) {
                if (g.is("displayfield")) {
                    e.renderColumnData(g, e.context.record, c)
                } else {
                    g.suspendEvents();
                    g.setValue(e.context.record.get(c.dataIndex));
                    g.resumeEvents()
                }
            }
            if (c.hidden) {
                e.onColumnHide(c)
            } else {
                if (c.rendered && !a) {
                    e.onColumnShow(c)
                }
            }
        }
    },
    getDefaultFieldCfg: function () {
        return {
            xtype: "displayfield", getModelData: function () {
                return null
            }
        }
    },
    loadRecord: function (d) {
        var j = this, a = j.getForm(), e = a.getFields(), h = e.items, b = h.length, c, g, l, k;
        for (c = 0; c < b; c++) {
            k = h[c];
            k.suspendEvents();
            k.resetToInitialValue()
        }
        a.loadRecord(d);
        for (c = 0; c < b; c++) {
            h[c].resumeEvents()
        }
        if (a.hasInvalidField() === a.wasValid) {
            delete a.wasValid
        }
        l = a.isValid();
        if (j.errorSummary) {
            if (l) {
                j.hideToolTip()
            } else {
                j.showToolTip()
            }
        }
        j.updateButton(l);
        g = j.query(">displayfield");
        b = g.length;
        for (c = 0; c < b; c++) {
            j.renderColumnData(g[c], d)
        }
    },
    renderColumnData: function (m, i, c) {
        var k = this, a = k.editingPlugin.grid, e = a.headerCt, l = k.scrollingView, o = l.dataSource,
            g = c || m.column, n = i.get(g.dataIndex), j = g.editRenderer || g.renderer, b, d, h,
            p = (g.usingDefaultRenderer && !g.scope) ? g : g.scope;
        if (j) {
            b = {tdCls: "", style: ""};
            d = o.indexOf(i);
            h = e.getHeaderIndex(g);
            n = j.call(p || e.ownerCt, n, b, i, d, h, o, l)
        }
        m.setRawValue(n)
    },
    beforeEdit: function () {
        var a = this, b;
        if (a.isVisible() && a.errorSummary && !a.autoCancel && a.isDirty()) {
            b = a.getScrollDelta();
            if (b) {
                a.scrollingViewEl.scrollBy(0, b, true)
            }
            a.showToolTip();
            return false
        }
    },
    startEdit: function (b, i) {
        var h = this, c = h.editingPlugin, e = c.grid, d = h.context = c.context, g = h.isVisible(), a = h.wrapEl;
        Ext.suspendLayouts();
        if (!h.rendered) {
            h.width = h.getClientWidth();
            h.render(e.el, e.el.dom.firstChild);
            a = h.wrapEl = h.el.wrap();
            a.setVisibilityMode(3);
            a.addCls(h._wrapCls);
            h.getFloatingButtons().render(a);
            h.onViewScroll()
        }
        d.grid.getSelectionModel().selectByPosition({row: b, column: i});
        h.onGridResize();
        h.loadRecord(b);
        Ext.resumeLayouts(g);
        if (g) {
            h.reposition(true)
        } else {
            e.ensureVisible(b);
            h.show()
        }
    },
    syncButtonPosition: function (c) {
        var b = this, a = b.getFloatingButtons(), e = b.scrollingView,
            d = b.getScrollDelta() - (e.getScrollable().getSize().y - e.getScrollY() - b.scrollingViewEl.dom.clientHeight);
        if (d > 0) {
            if (!b._buttonsOnTop) {
                a.setButtonPosition("top");
                b._buttonsOnTop = true
            }
            c = 0
        } else {
            if (b._buttonsOnTop !== false) {
                a.setButtonPosition("bottom");
                b._buttonsOnTop = false
            } else {
                a.setButtonPosition(a.position)
            }
        }
        return c
    },
    syncEditorClip: function () {
        var i = this, b = i.getScrollDelta(), a = i.el, e = i.floatingButtons, d = e.el, j = Math.max, g, c, h;
        if (b) {
            i.isOverflowing = true;
            g = i.body;
            c = e.getHeight();
            h = i.getHeight();
            j = Math.max;
            if (b > 0) {
                if (i._buttonsOnTop) {
                    b -= (c - g.getBorderWidth("b"));
                    i.clipBottom(a, j(h - b), 0);
                    b -= (h - g.getBorderWidth("t"));
                    if (b > 0) {
                        i.clipBottom(d, j(c - b, 0))
                    } else {
                        i.clearClip(d)
                    }
                } else {
                    i.clipBottom(d, j(c - b, 0));
                    b -= (c - g.getBorderWidth("b"));
                    if (b > 0) {
                        i.clipBottom(a, j(h - b, 0))
                    } else {
                        i.clearClip(a)
                    }
                }
            } else {
                if (b < 0) {
                    b = Math.abs(b);
                    i.clipTop(a, b);
                    b -= (h - g.getBorderWidth("b"));
                    if (b > 0) {
                        i.clipTop(d, b)
                    } else {
                        i.clearClip(d)
                    }
                }
            }
        } else {
            if (i.isOverflowing) {
                i.clearClip(d);
                i.clearClip(a);
                i.isOverflowing = false
            }
        }
    },
    focusColumnField: function (b) {
        var c, a;
        if (b && !b.destroyed) {
            if (b.isVisible()) {
                c = this.getEditor(b);
                if (c && c.isFocusable(true)) {
                    a = true;
                    c.focus()
                }
            }
            if (!a) {
                this.focusColumnField(b.next())
            }
        }
    },
    cancelEdit: function () {
        var g = this, e = g.getForm(), a = e.getFields(), b = a.items, d = b.length, c;
        g.hide();
        e.clearInvalid();
        for (c = 0; c < d; c++) {
            b[c].suspendEvents()
        }
        e.reset();
        for (c = 0; c < d; c++) {
            b[c].resumeEvents()
        }
    },
    completeEdit: function () {
        var b = this, a = b.getForm();
        if (!a.isValid()) {
            return false
        }
        a.updateRecord(b.context.record);
        b.hide();
        return true
    },
    onShow: function () {
        var a = this;
        a.wrapEl.show();
        Ext.form.Panel.prototype.onShow.apply(this, arguments);
        if (a.needsSyncFieldWidths) {
            a.suspendLayouts();
            a.syncAllFieldWidths();
            a.resumeLayouts(true)
        }
        delete a.needsSyncFieldWidths;
        a.reposition()
    },
    onHide: function () {
        var c = this, b, a;
        if (c.activeField) {
            b = c.activeField.column;
            a = new Ext.grid.CellContext(b.getView()).setPosition(c.context.record, b);
            a.view.getNavigationModel().setPosition(a);
            c.activeField = null
        }
        c.wrapEl.hide();
        Ext.form.Panel.prototype.onHide.apply(this, arguments);
        if (c.tooltip) {
            c.hideToolTip()
        }
    },
    onResize: function (b, a) {
        this.wrapEl.setSize(b, a)
    },
    isDirty: function () {
        return this.getForm().isDirty()
    },
    getToolTip: function () {
        var b = this, c = b.tooltip, a = b.editingPlugin.grid;
        if (!c) {
            b.tooltip = c = new Ext.tip.ToolTip({
                cls: "x-grid-row-editor-errors",
                title: b.errorsText,
                autoHide: false,
                closable: true,
                closeAction: "disable",
                anchor: "left",
                anchorToTarget: true,
                constrainPosition: true,
                constrainTo: document.body
            });
            a.add(c);
            b.mon(a, {afterlayout: b.onGridLayout, scope: b})
        }
        return c
    },
    hideToolTip: function () {
        var a = this, b = a.getToolTip();
        if (b.rendered) {
            b.disable()
        }
        a.hiddenTip = false
    },
    showToolTip: function () {
        var a = this, b = a.getToolTip();
        b.update(a.getErrors());
        a.repositionTip();
        b.enable()
    },
    onGridLayout: function () {
        if (this.tooltip && this.tooltip.isVisible()) {
            this.repositionTip()
        }
    },
    repositionTip: function () {
        var i = this, j = i.getToolTip(), c = i.context, l = Ext.get(c.row), k = i.scrollingViewEl,
            e = k.dom.clientHeight, g = k.getY(), h = g + e, b = l.getHeight(), a = l.getY(), d = a + b;
        if (d > g && a < h) {
            j.anchorTarget = k;
            j.mouseOffset = [0, l.getOffsetsTo(k)[1]];
            j.show();
            i.hiddenTip = false
        } else {
            j.hide();
            i.hiddenTip = true
        }
    },
    getErrors: function () {
        var e = this, h = [], b = e.query(">[isFormField]"), d = b.length, c, a, g;
        for (c = 0; c < d; c++) {
            g = b[c];
            a = g.getErrors();
            if (a.length) {
                h.push(e.createErrorListItem(a[0], g.column.text))
            }
        }
        if (!h.length && !e.autoCancel && e.isDirty()) {
            h[0] = e.createErrorListItem(e.dirtyText)
        }
        return '<ul class="x-list-plain">' + h.join("") + "</ul>"
    },
    createErrorListItem: function (b, a) {
        b = a ? a + ": " + b : b;
        return '<li class="' + this.errorCls + '">' + b + "</li>"
    },
    beforeDestroy: function () {
        Ext.destroy(this.floatingButtons, this.tooltip);
        Ext.form.Panel.prototype.beforeDestroy.call(this)
    },
    clipBottom: function (a, b) {
        a.setStyle("clip", "rect(0 auto " + b + "px 0)")
    },
    clipTop: function (a, b) {
        a.setStyle("clip", "rect(" + b + "px, auto, auto, 0)")
    },
    clearClip: function (a) {
        a.setStyle("clip", Ext.isIE8 ? "rect(-1000px auto 1000px auto)" : "auto")
    }
}, 0, ["roweditor"], ["component", "box", "container", "panel", "form", "roweditor"], {
    component: true,
    box: true,
    container: true,
    panel: true,
    form: true,
    roweditor: true
}, ["widget.roweditor"], 0, [Ext.grid, "RowEditor"], 0));
(Ext.cmd.derive("Ext.view.DropZone", Ext.dd.DropZone, {
    indicatorCls: "x-grid-drop-indicator",
    indicatorHtml: ['<div class="', "x-", 'grid-drop-indicator-left" role="presentation"></div>', '<div class="x-grid-drop-indicator-right" role="presentation"></div>'].join(""),
    constructor: function (a) {
        var b = this;
        Ext.apply(b, a);
        if (!b.ddGroup) {
            b.ddGroup = "view-dd-zone-" + b.view.id
        }
        Ext.dd.DropZone.prototype.constructor.call(this, b.view.el)
    },
    fireViewEvent: function () {
        var b = this, a;
        b.lock();
        a = b.view.fireEvent.apply(b.view, arguments);
        b.unlock();
        return a
    },
    getTargetFromEvent: function (k) {
        var j = k.getTarget(this.view.getItemSelector()), d, c, b, g, a, h;
        if (!j) {
            d = k.getY();
            for (g = 0, c = this.view.getNodes(), a = c.length; g < a; g++) {
                b = c[g];
                h = Ext.fly(b).getBox();
                if (d <= h.bottom) {
                    return b
                }
            }
        }
        return j
    },
    getIndicator: function () {
        var a = this;
        if (!a.indicator) {
            a.indicator = new Ext.Component({
                ariaRole: "presentation",
                html: a.indicatorHtml,
                cls: a.indicatorCls,
                ownerCt: a.view,
                floating: true,
                shadow: false
            })
        }
        return a.indicator
    },
    getPosition: function (c, a) {
        var g = c.getXY()[1], b = Ext.fly(a).getRegion(), d;
        if ((b.bottom - g) >= (b.bottom - b.top) / 2) {
            d = "before"
        } else {
            d = "after"
        }
        return d
    },
    containsRecordAtOffset: function (d, b, g) {
        if (!b) {
            return false
        }
        var a = this.view, c = a.indexOf(b), e = a.getNode(c + g), h = e ? a.getRecord(e) : null;
        return h && Ext.Array.contains(d, h)
    },
    positionIndicator: function (b, c, d) {
        var g = this, i = g.view, h = g.getPosition(d, b), k = i.getRecord(b), a = c.records, j;
        if (!Ext.Array.contains(a, k) && (h === "before" && !g.containsRecordAtOffset(a, k, -1) || h === "after" && !g.containsRecordAtOffset(a, k, 1))) {
            g.valid = true;
            if (g.overRecord !== k || g.currentPosition !== h) {
                j = Ext.fly(b).getY() - i.el.getY() - 1;
                if (h === "after") {
                    j += Ext.fly(b).getHeight()
                }
                if (i.touchScroll === 2) {
                    j += i.getScrollY()
                }
                g.getIndicator().setWidth(Ext.fly(i.el).getWidth()).showAt(0, j);
                g.overRecord = k;
                g.currentPosition = h
            }
        } else {
            g.invalidateDrop()
        }
    },
    invalidateDrop: function () {
        if (this.valid) {
            this.valid = false;
            this.getIndicator().hide()
        }
    },
    onNodeOver: function (c, a, g, d) {
        var b = this;
        if (!Ext.Array.contains(d.records, b.view.getRecord(c))) {
            b.positionIndicator(c, d, g)
        }
        return b.valid ? b.dropAllowed : b.dropNotAllowed
    },
    notifyOut: function (c, a, g, d) {
        var b = this;
        Ext.dd.DropZone.prototype.notifyOut.apply(this, arguments);
        b.overRecord = b.currentPosition = null;
        b.valid = false;
        if (b.indicator) {
            b.indicator.hide()
        }
    },
    onContainerOver: function (a, h, g) {
        var d = this, b = d.view, c = b.dataSource.getCount();
        if (c) {
            d.positionIndicator(b.all.last(), g, h)
        } else {
            d.overRecord = d.currentPosition = null;
            d.getIndicator().setWidth(Ext.fly(b.el).getWidth()).showAt(0, 0);
            d.valid = true
        }
        return d.dropAllowed
    },
    onContainerDrop: function (a, c, b) {
        return this.onNodeDrop(a, null, c, b)
    },
    onNodeDrop: function (i, a, h, g) {
        var d = this, c = false, b = {
            wait: false, processDrop: function () {
                d.invalidateDrop();
                d.handleNodeDrop(g, d.overRecord, d.currentPosition);
                c = true;
                d.fireViewEvent("drop", i, g, d.overRecord, d.currentPosition)
            }, cancelDrop: function () {
                d.invalidateDrop();
                c = true
            }
        }, j = false;
        if (d.valid) {
            j = d.fireViewEvent("beforedrop", i, g, d.overRecord, d.currentPosition, b);
            if (b.wait) {
                return
            }
            if (j !== false) {
                if (!c) {
                    b.processDrop()
                }
            }
        }
        return j
    },
    destroy: function () {
        this.indicator = Ext.destroy(this.indicator);
        Ext.dd.DropZone.prototype.destroy.call(this)
    }
}, 1, 0, 0, 0, 0, 0, [Ext.view, "DropZone"], 0));
(Ext.cmd.derive("Ext.grid.ViewDropZone", Ext.view.DropZone, {
    indicatorHtml: '<div class="x-grid-drop-indicator-left" role="presentation"></div><div class="x-grid-drop-indicator-right" role="presentation"></div>',
    indicatorCls: "x-grid-drop-indicator",
    handleNodeDrop: function (b, d, e) {
        var j = this.view, k = j.getStore(), h, a, c, g;
        if (b.copy) {
            a = b.records;
            b.records = [];
            for (c = 0, g = a.length; c < g; c++) {
                b.records.push(a[c].copy())
            }
        } else {
            b.view.store.remove(b.records, b.view === j)
        }
        if (d && e) {
            h = k.indexOf(d);
            if (e !== "before") {
                h++
            }
            k.insert(h, b.records)
        } else {
            k.add(b.records)
        }
        j.getSelectionModel().select(b.records);
        j.getNavigationModel().setPosition(b.records[0])
    }
}, 0, 0, 0, 0, 0, 0, [Ext.grid, "ViewDropZone"], 0));
(Ext.cmd.derive("Ext.grid.plugin.HeaderResizer", Ext.plugin.Abstract, {
    disabled: false,
    config: {dynamic: false},
    colHeaderCls: "x-column-header",
    minColWidth: 40,
    maxColWidth: 1000,
    eResizeCursor: "col-resize",
    init: function (b) {
        var a = this;
        a.headerCt = b;
        b.on("render", a.afterHeaderRender, a, {single: a});
        if (!a.minColWidth) {
            a.self.prototype.minColWidth = Ext.grid.column.Column.prototype.minWidth
        }
    },
    destroy: function () {
        var b = this, a = b.tracker;
        if (a) {
            a.destroy();
            b.tracker = null
        }
        b.headerCt.un("render", b.afterHeaderRender, b);
        b.headerCt = null;
        Ext.plugin.Abstract.prototype.destroy.call(this)
    },
    afterHeaderRender: function () {
        var b = this, c = b.headerCt, a = c.el;
        c.mon(a, "mousemove", b.onHeaderCtMouseMove, b);
        b.markerOwner = b.ownerGrid = b.headerCt.up("tablepanel").ownerGrid;
        b.tracker = new Ext.dd.DragTracker({
            disabled: b.disabled,
            onBeforeStart: b.onBeforeStart.bind(b),
            onStart: b.onStart.bind(b),
            onDrag: b.onDrag.bind(b),
            onEnd: b.onEnd.bind(b),
            tolerance: 3,
            autoStart: 300,
            el: a
        })
    },
    onHeaderCtMouseMove: function (b) {
        var a = this;
        if (a.headerCt.dragging || a.disabled) {
            if (a.activeHd) {
                a.activeHd.el.dom.style.cursor = "";
                delete a.activeHd
            }
        } else {
            if (b.pointerType !== "touch") {
                a.findActiveHeader(b)
            }
        }
    },
    findActiveHeader: function (d) {
        var g = this, i = d.getTarget("." + g.colHeaderCls, 3, true), j = g.ownerGrid, a = j.ownerLockable, k, h, b, c;
        g.activeHd = null;
        if (i) {
            k = Ext.getCmp(i.id);
            if (k.isAtEndEdge(d)) {
                if (g.headerCt.visibleColumnManager.getColumns().length === 1 && g.headerCt.forceFit) {
                    return
                }
                h = k
            } else {
                if (k.isAtStartEdge(d)) {
                    b = g.headerCt.visibleColumnManager.getColumns();
                    c = k.isGroupHeader ? k.getGridColumns()[0] : k;
                    h = b[Ext.Array.indexOf(b, c) - 1];
                    if (!h && a && !j.isLocked) {
                        b = a.lockedGrid.headerCt.visibleColumnManager.getColumns();
                        h = b[b.length - 1]
                    }
                }
            }
            if (h) {
                if (h.isGroupHeader) {
                    b = h.getGridColumns();
                    h = b[b.length - 1]
                }
                if (h && !(h.fixed || (h.resizable === false))) {
                    g.activeHd = h;
                    k.el.dom.style.cursor = g.eResizeCursor;
                    if (k.triggerEl) {
                        k.triggerEl.dom.style.cursor = g.eResizeCursor
                    }
                }
            } else {
                k.el.dom.style.cursor = "";
                if (k.triggerEl) {
                    k.triggerEl.dom.style.cursor = ""
                }
            }
        }
        return g.activeHd
    },
    onBeforeStart: function (b) {
        var a = this;
        a.dragHd = a.activeHd || b.pointerType === "touch" && a.findActiveHeader(b);
        if (a.dragHd && !a.headerCt.dragging) {
            a.xDelta = a.dragHd.getX() + a.dragHd.getWidth() - a.tracker.getXY()[0];
            a.tracker.constrainTo = a.getConstrainRegion();
            return true
        } else {
            a.headerCt.dragging = false;
            return false
        }
    },
    getConstrainRegion: function () {
        var g = this, b = g.dragHd.el, e, h = g.ownerGrid, d = h.getSizeModel().width,
            c = d.shrinkWrap ? g.headerCt.getWidth() - g.headerCt.visibleColumnManager.getColumns().length * g.minColWidth : g.maxColWidth,
            a;
        if (g.headerCt.forceFit) {
            e = g.dragHd.nextNode("gridcolumn:not([hidden]):not([isGroupHeader])");
            if (e && g.headerInSameGrid(e)) {
                c = b.getWidth() + (e.getWidth() - g.minColWidth)
            }
        } else {
            if (h.isLocked && d.shrinkWrap) {
                c = g.dragHd.up("[scrollerOwner]").getTargetEl().getWidth(true) - h.getWidth() - (h.ownerLockable.normalGrid.visibleColumnManager.getColumns().length * g.minColWidth + Ext.getScrollbarSize().width)
            }
        }
        a = g.adjustConstrainRegion(b.getRegion(), 0, 0, 0, g.minColWidth);
        a.right = b.getX() + c;
        return a
    },
    onStart: function (h) {
        var i = this, g = i.dragHd, b = g.el.getWidth(), d = g.getRootHeaderCt(), l, k, c, a, j, m;
        i.headerCt.dragging = true;
        i.origWidth = b;
        if (!i.dynamic) {
            c = i.markerOwner;
            if (c.frame && c.resizable) {
                i.gridOverflowSetting = c.el.dom.style.overflow;
                c.el.dom.style.overflow = "hidden"
            }
            l = i.getLeftMarkerX(c);
            a = c.getLhsMarker();
            j = c.getRhsMarker();
            m = i.ownerGrid.body.getHeight() + d.getHeight();
            k = d.getOffsetsTo(c)[1] - c.el.getBorderWidth("t");
            a.setLocalY(k);
            j.setLocalY(k);
            a.setHeight(m);
            j.setHeight(m);
            i.setMarkerX(a, l);
            i.setMarkerX(j, l + b)
        }
    },
    onDrag: function (b) {
        var a = this;
        if (a.dynamic) {
            a.doResize()
        } else {
            a.setMarkerX(a.getMovingMarker(a.markerOwner), a.calculateDragX(a.markerOwner))
        }
    },
    getMovingMarker: function (a) {
        return a.getRhsMarker()
    },
    onEnd: function (b) {
        var a = this, c = a.markerOwner;
        a.headerCt.dragging = false;
        if (a.dragHd) {
            if (!a.dynamic) {
                if ("gridOverflowSetting" in a) {
                    c.el.dom.style.overflow = a.gridOverflowSetting
                }
                a.setMarkerX(c.getLhsMarker(), -9999);
                a.setMarkerX(c.getRhsMarker(), -9999)
            }
            a.doResize();
            a.dragHd = a.activeHd = null
        }
        if (b.pointerType !== "touch") {
            a.onHeaderCtMouseMove(b)
        }
        a.headerCt.blockNextEvent()
    },
    doResize: function () {
        var c = this, b = c.dragHd, a, d = c.tracker.getOffset("point");
        if (b && d[0]) {
            if (b.flex) {
                delete b.flex
            }
            Ext.suspendLayouts();
            c.adjustColumnWidth(d[0] - c.xDelta);
            if (c.headerCt.forceFit) {
                a = b.nextNode("gridcolumn:not([hidden]):not([isGroupHeader])");
                if (a && !c.headerInSameGrid(a)) {
                    a = null
                }
                if (a) {
                    delete a.flex;
                    a.setWidth(a.getWidth() - d[0])
                }
            }
            Ext.resumeLayouts(true)
        }
    },
    headerInSameGrid: function (b) {
        var a = this.dragHd.up("tablepanel");
        return !!b.up(a)
    },
    disable: function () {
        var a = this.tracker;
        this.disabled = true;
        if (a) {
            a.disable()
        }
    },
    enable: function () {
        var a = this.tracker;
        this.disabled = false;
        if (a) {
            a.enable()
        }
    },
    calculateDragX: function (a) {
        return this.tracker.getXY("point")[0] + this.xDelta - a.getX() - a.el.getBorderWidth("l")
    },
    getLeftMarkerX: function (a) {
        return this.dragHd.getX() - a.getX() - a.el.getBorderWidth("l") - 1
    },
    setMarkerX: function (b, a) {
        b.setLocalX(a)
    },
    adjustConstrainRegion: function (g, d, e, a, c) {
        return g.adjust(d, e, a, c)
    },
    adjustColumnWidth: function (a) {
        this.dragHd.setWidth(this.origWidth + a)
    }
}, 0, 0, 0, 0, ["plugin.gridheaderresizer"], 0, [Ext.grid.plugin, "HeaderResizer"], 0));
(Ext.cmd.derive("Ext.grid.header.DragZone", Ext.dd.DragZone, {
    colHeaderSelector: ".x-column-header",
    colInnerSelector: ".x-column-header-inner",
    maxProxyWidth: 120,
    constructor: function (b) {
        var a = this;
        a.headerCt = b;
        a.ddGroup = a.getDDGroup();
        a.autoGroup = true;
        Ext.dd.DragZone.prototype.constructor.call(this, b.el);
        a.proxy.el.addCls("x-grid-col-dd")
    },
    getDDGroup: function () {
        return "header-dd-zone-" + this.headerCt.up("[scrollerOwner]").id
    },
    getDragData: function (b) {
        if (b.getTarget(this.colInnerSelector)) {
            var d = b.getTarget(this.colHeaderSelector), a, c;
            if (d) {
                a = Ext.getCmp(d.id);
                if (!this.headerCt.dragging && a.draggable && !(a.isAtStartEdge(b) || a.isAtEndEdge(b))) {
                    c = document.createElement("div");
                    c.role = "presentation";
                    c.innerHTML = a.text;
                    return {ddel: c, header: a}
                }
            }
        }
        return false
    },
    onBeforeDrag: function () {
        return !(this.headerCt.dragging || this.disabled)
    },
    onInitDrag: function () {
        this.headerCt.dragging = true;
        this.headerCt.hideMenu();
        Ext.dd.DragZone.prototype.onInitDrag.apply(this, arguments)
    },
    onDragDrop: function () {
        this.headerCt.dragging = false;
        Ext.dd.DragZone.prototype.onDragDrop.apply(this, arguments)
    },
    afterRepair: function () {
        Ext.dd.DragZone.prototype.afterRepair.call(this);
        this.headerCt.dragging = false
    },
    getRepairXY: function () {
        return this.dragData.header.el.getXY()
    },
    disable: function () {
        this.disabled = true
    },
    enable: function () {
        this.disabled = false
    }
}, 1, 0, 0, 0, 0, 0, [Ext.grid.header, "DragZone"], 0));
(Ext.cmd.derive("Ext.grid.header.DropZone", Ext.dd.DropZone, {
    colHeaderCls: "x-column-header", proxyOffsets: [-4, -9], constructor: function (b) {
        var a = this;
        a.headerCt = b;
        a.ddGroup = a.getDDGroup();
        a.autoGroup = true;
        Ext.dd.DropZone.prototype.constructor.call(this, b.el)
    }, destroy: function () {
        Ext.dd.DropZone.prototype.destroy.call(this);
        Ext.destroy(this.topIndicator, this.bottomIndicator)
    }, getDDGroup: function () {
        return "header-dd-zone-" + this.headerCt.up("[scrollerOwner]").id
    }, getTargetFromEvent: function (a) {
        return a.getTarget("." + this.colHeaderCls)
    }, getTopIndicator: function () {
        if (!this.topIndicator) {
            this.topIndicator = Ext.getBody().createChild({
                role: "presentation",
                cls: "x-col-move-top",
                html: "&#160;"
            });
            this.indicatorXOffset = Math.floor((this.topIndicator.dom.offsetWidth + 1) / 2)
        }
        return this.topIndicator
    }, getBottomIndicator: function () {
        if (!this.bottomIndicator) {
            this.bottomIndicator = Ext.getBody().createChild({
                role: "presentation",
                cls: "x-col-move-bottom",
                html: "&#160;"
            })
        }
        return this.bottomIndicator
    }, getLocation: function (d, b) {
        var a = d.getXY()[0], c = Ext.fly(b).getRegion(), g;
        if ((c.right - a) <= (c.right - c.left) / 2) {
            g = "after"
        } else {
            g = "before"
        }
        return {pos: g, header: Ext.getCmp(b.id), node: b}
    }, positionIndicator: function (z, p, v) {
        var y = this, q = z.header, g = y.getLocation(v, p), k = g.header, d = g.pos, c, u, m, s, t, a, b, l, n, x, w,
            o, j, r, h;
        if (k === y.lastTargetHeader && d === y.lastDropPos) {
            return
        }
        c = q.nextSibling("gridcolumn:not([hidden])");
        u = q.previousSibling("gridcolumn:not([hidden])");
        y.lastTargetHeader = k;
        y.lastDropPos = d;
        if (!k.draggable && d === "before" && k.getIndex() === 0) {
            return false
        }
        z.dropLocation = g;
        if ((q !== k) && ((d === "before" && c !== k) || (d === "after" && u !== k)) && !k.isDescendantOf(q)) {
            o = Ext.dd.DragDropManager.getRelated(y);
            j = o.length;
            r = 0;
            for (; r < j; r++) {
                h = o[r];
                if (h !== y && h.invalidateDrop) {
                    h.invalidateDrop()
                }
            }
            y.valid = true;
            m = y.getTopIndicator();
            s = y.getBottomIndicator();
            if (d === "before") {
                t = "bc-tl";
                a = "tc-bl"
            } else {
                t = "bc-tr";
                a = "tc-br"
            }
            b = m.getAlignToXY(k.el, t);
            l = s.getAlignToXY(k.el, a);
            n = y.headerCt.el;
            x = n.getX() - y.indicatorXOffset;
            w = n.getX() + n.getWidth();
            b[0] = Ext.Number.constrain(b[0], x, w);
            l[0] = Ext.Number.constrain(l[0], x, w);
            m.setXY(b);
            s.setXY(l);
            m.show();
            s.show()
        } else {
            y.invalidateDrop()
        }
    }, invalidateDrop: function () {
        this.valid = false;
        this.hideIndicators()
    }, onNodeOver: function (c, h, g, d) {
        var i = this, k = d.header, a, l, b, j;
        if (d.header.el.dom === c) {
            a = false
        } else {
            d.isLock = d.isUnlock = d.crossPanel = false;
            l = i.getLocation(g, c).header;
            a = (k.ownerCt === l.ownerCt);
            if (!a && (!k.ownerCt.sealed && !l.ownerCt.sealed)) {
                a = true;
                b = k.up("tablepanel");
                j = l.up("tablepanel");
                if (b !== j) {
                    d.crossPanel = true;
                    d.isLock = j.isLocked && !b.isLocked;
                    d.isUnlock = !j.isLocked && b.isLocked;
                    if ((d.isUnlock && k.lockable === false) || (d.isLock && !k.isLockable())) {
                        a = false
                    }
                }
            }
        }
        if (a) {
            i.positionIndicator(d, c, g)
        } else {
            i.valid = false
        }
        return i.valid ? i.dropAllowed : i.dropNotAllowed
    }, hideIndicators: function () {
        var a = this;
        a.getTopIndicator().hide();
        a.getBottomIndicator().hide();
        a.lastTargetHeader = a.lastDropPos = null
    }, onNodeOut: function () {
        this.hideIndicators()
    }, getNestedHeader: function (d, b) {
        var a = d.items, c;
        if (d.isGroupHeader && a.length) {
            c = !b ? "first" : "last";
            d = this.getNestedHeader(a[c](), b)
        }
        return d
    }, onNodeDrop: function (m, c, q, u) {
        this.headerCt.blockNextEvent();
        if (!this.valid) {
            return
        }
        var r = this, n = u.header, i = u.dropLocation, p = i.pos, j = i.header, t = n.ownerCt, l = t.getRootHeaderCt(),
            a = j.ownerCt, d = r.headerCt.visibleColumnManager, o = d.getHeaderIndex(n), b, k, s, h, g;
        if (u.isLock || u.isUnlock) {
            h = t.up("[scrollerOwner]");
            b = a.items.indexOf(j);
            if (p === "after") {
                b++
            }
            if (u.isLock) {
                h.lock(n, b, a)
            } else {
                h.unlock(n, b, a)
            }
        } else {
            b = p === "after" ? d.getHeaderIndex(r.getNestedHeader(j, 1)) + 1 : d.getHeaderIndex(r.getNestedHeader(j, 0));
            r.invalidateDrop();
            g = n.getWidth();
            Ext.suspendLayouts();
            t.isDDMoveInGrid = a.isDDMoveInGrid = !u.crossPanel;
            if (n.isGroupHeader && j.isGroupHeader) {
                n.setNestedParent(j)
            }
            if (p === "before") {
                j.insertNestedHeader(n)
            } else {
                s = "move" + p.charAt(0).toUpperCase() + p.substr(1);
                a[s](n, j)
            }
            if (b >= 0 && !(j.isGroupHeader && (!j.items || !j.items.length)) && o !== b) {
                k = n.isGroupHeader ? n.query(":not([hidden]):not([isGroupHeader])").length : 1;
                if ((o <= b) && k > 1) {
                    b -= k
                }
                a.getRootHeaderCt().grid.view.moveColumn(o, b, k)
            }
            l.fireEvent("columnmove", t, n, o, b);
            t.isDDMoveInGrid = a.isDDMoveInGrid = false;
            if (a.isGroupHeader && !t.isGroupHeader) {
                if (t !== a) {
                    n.savedFlex = n.flex;
                    delete n.flex;
                    n.width = g
                }
            } else {
                if (!t.isGroupHeader) {
                    if (n.savedFlex) {
                        n.flex = n.savedFlex;
                        delete n.width
                    }
                }
            }
            Ext.resumeLayouts(true)
        }
    }
}, 1, 0, 0, 0, 0, 0, [Ext.grid.header, "DropZone"], 0));
(Ext.cmd.derive("Ext.grid.plugin.HeaderReorderer", Ext.plugin.Abstract, {
    init: function (a) {
        this.headerCt = a;
        a.on({boxready: this.onHeaderCtRender, single: true, scope: this})
    }, destroy: function () {
        var a = this;
        a.headerCt.un("boxready", a.onHeaderCtRender, a);
        Ext.destroy(a.dragZone, a.dropZone);
        a.headerCt = a.dragZone = a.dropZone = null;
        Ext.plugin.Abstract.prototype.destroy.call(this)
    }, onHeaderCtRender: function () {
        var a = this;
        a.dragZone = new Ext.grid.header.DragZone(a.headerCt);
        a.dropZone = new Ext.grid.header.DropZone(a.headerCt);
        if (a.disabled) {
            a.dragZone.disable()
        }
    }, enable: function () {
        this.disabled = false;
        if (this.dragZone) {
            this.dragZone.enable()
        }
    }, disable: function () {
        this.disabled = true;
        if (this.dragZone) {
            this.dragZone.disable()
        }
    }
}, 0, 0, 0, 0, ["plugin.gridheaderreorderer"], 0, [Ext.grid.plugin, "HeaderReorderer"], 0));
(Ext.cmd.derive("Ext.grid.header.Container", Ext.container.Container, {
    border: true,
    baseCls: "x-grid-header-ct",
    dock: "top",
    weight: 100,
    defaultType: "gridcolumn",
    detachOnRemove: false,
    defaultWidth: 100,
    sortAscText: "Sort Ascending",
    sortDescText: "Sort Descending",
    sortClearText: "Clear Sort",
    columnsText: "Columns",
    headerOpenCls: "x-column-header-open",
    menuSortAscCls: "x-hmenu-sort-asc",
    menuSortDescCls: "x-hmenu-sort-desc",
    menuColsIcon: "x-cols-icon",
    blockEvents: false,
    dragging: false,
    sortOnClick: true,
    enableFocusableContainer: false,
    childHideCount: 0,
    sortable: true,
    enableColumnHide: true,
    initComponent: function () {
        var a = this;
        a.headerCounter = 0;
        a.plugins = a.plugins || [];
        a.defaults = a.defaults || {};
        if (!a.isColumn) {
            if (a.enableColumnResize) {
                a.resizer = new Ext.grid.plugin.HeaderResizer();
                a.plugins.push(a.resizer)
            }
            if (a.enableColumnMove) {
                a.reorderer = new Ext.grid.plugin.HeaderReorderer();
                a.plugins.push(a.reorderer)
            }
        }
        if (a.isColumn && !a.isGroupHeader) {
            if (!a.items || a.items.length === 0) {
                a.isContainer = a.isFocusableContainer = false;
                a.focusable = true;
                a.layout = {type: "container", calculate: Ext.emptyFn}
            }
        } else {
            a.layout = Ext.apply({type: "gridcolumn", align: "stretch"}, a.initialConfig.layout);
            a.defaults.columnLines = a.columnLines;
            if (!a.isGroupHeader) {
                a.isRootHeader = true;
                if (!a.hiddenHeaders) {
                    a.enableFocusableContainer = true;
                    a.ariaRole = "rowgroup"
                }
                a.columnManager = new Ext.grid.ColumnManager(false, a);
                a.visibleColumnManager = new Ext.grid.ColumnManager(true, a);
                if (a.grid) {
                    a.grid.columnManager = a.columnManager;
                    a.grid.visibleColumnManager = a.visibleColumnManager
                }
            } else {
                a.visibleColumnManager = new Ext.grid.ColumnManager(true, a);
                a.columnManager = new Ext.grid.ColumnManager(false, a)
            }
        }
        a.menuTask = new Ext.util.DelayedTask(a.updateMenuDisabledState, a);
        Ext.container.Container.prototype.initComponent.call(this)
    },
    insertNestedHeader: function (g) {
        var b = this, e = g.ownerCt, a = b.ownerCt, d = a.layout.owner, c;
        if (e) {
            if (b.isGroupHeader && !a.isNestedParent) {
                c = d.items.indexOf(b)
            }
            e.remove(g, false)
        }
        if (c === undefined) {
            c = d.items.indexOf(b)
        }
        d.insert(c, g)
    },
    isNested: function () {
        return !!this.getRootHeaderCt().down("[isNestedParent]")
    },
    isNestedGroupHeader: function () {
        var b = this, a = b.getRefOwner().query(">:not([hidden])");
        return (a.length === 1 && a[0] === b)
    },
    maybeShowNestedGroupHeader: function () {
        var a = this.items, b;
        if (a && a.length === 1 && (b = a.getAt(0)) && b.hidden) {
            b.show()
        }
    },
    setNestedParent: function (a) {
        a.isNestedParent = false;
        a.ownerCt.isNestedParent = !!(this.ownerCt.items.length === 1 && a.ownerCt.items.length === 1)
    },
    initEvents: function () {
        var c = this, a, b;
        Ext.container.Container.prototype.initEvents.call(this);
        if (!c.isColumn && !c.isGroupHeader) {
            a = c.onHeaderCtEvent;
            b = {
                click: a,
                dblclick: a,
                contextmenu: a,
                mouseover: c.onHeaderCtMouseOver,
                mouseout: c.onHeaderCtMouseOut,
                scope: c
            };
            if (Ext.supports.Touch) {
                b.longpress = c.onHeaderCtLongPress
            }
            c.mon(c.el, b)
        }
    },
    onHeaderCtEvent: function (d, b) {
        var c = this, i = c.getHeaderElByEvent(d), h, g, a;
        if (c.longPressFired) {
            c.longPressFired = false;
            return
        }
        if (i && !c.blockEvents) {
            h = Ext.getCmp(i.id);
            if (h) {
                g = h[h.clickTargetName];
                if ((!h.isGroupHeader && !h.isContainer) || d.within(g)) {
                    if (d.type === "click" || d.type === "tap") {
                        a = h.onTitleElClick(d, g, c.sortOnClick);
                        if (a) {
                            c.onHeaderTriggerClick(a, d, d.pointerType === "touch" ? a.el : a.triggerEl)
                        } else {
                            c.onHeaderClick(h, d, b)
                        }
                    } else {
                        if (d.type === "contextmenu") {
                            c.onHeaderContextMenu(h, d, b)
                        } else {
                            if (d.type === "dblclick" && h.resizable) {
                                h.onTitleElDblClick(d, g.dom)
                            }
                        }
                    }
                }
            }
        }
    },
    blockNextEvent: function () {
        this.blockEvents = true;
        Ext.asap(this.unblockEvents, this)
    },
    unblockEvents: function () {
        this.blockEvents = false
    },
    onHeaderCtMouseOver: function (b, a) {
        var g, d, c;
        if (!b.within(this.el, true)) {
            g = b.getTarget("." + Ext.grid.column.Column.prototype.baseCls);
            d = g && Ext.getCmp(g.id);
            if (d) {
                c = d[d.clickTargetName];
                if (b.within(c)) {
                    d.onTitleMouseOver(b, c.dom)
                }
            }
        }
    },
    onHeaderCtMouseOut: function (g, c) {
        var d = "." + Ext.grid.column.Column.prototype.baseCls, b = g.getTarget(d), a = g.getRelatedTarget(d), i, h;
        if (b !== a) {
            if (b) {
                i = Ext.getCmp(b.id);
                if (i) {
                    h = i[i.clickTargetName];
                    i.onTitleMouseOut(g, h.dom)
                }
            }
            if (a) {
                i = Ext.getCmp(a.id);
                if (i) {
                    h = i[i.clickTargetName];
                    i.onTitleMouseOver(g, h.dom)
                }
            }
        }
    },
    onHeaderCtLongPress: function (b) {
        var a = this, d = a.getHeaderElByEvent(b), c = Ext.getCmp(d.id);
        if (!c.menuDisabled) {
            a.longPressFired = true;
            a.showMenuBy(b, d, c)
        }
    },
    getHeaderElByEvent: function (a) {
        return a.getTarget("." + Ext.grid.column.Column.prototype.baseCls)
    },
    isLayoutRoot: function () {
        if (this.hiddenHeaders) {
            return false
        }
        return Ext.container.Container.prototype.isLayoutRoot.call(this)
    },
    getRootHeaderCt: function () {
        var a = this;
        return a.isRootHeader ? a : a.up("[isRootHeader]")
    },
    onDestroy: function () {
        var a = this;
        if (a.menu) {
            a.menu.un("hide", a.onMenuHide, a)
        }
        a.menuTask.cancel();
        Ext.container.Container.prototype.onDestroy.call(this);
        Ext.destroy(a.visibleColumnManager, a.columnManager, a.menu);
        a.columnManager = a.visibleColumnManager = null
    },
    applyColumnsState: function (h) {
        if (!h || !h.length) {
            return
        }
        var p = this, n = p.items.items, m = n.length, j = 0, b = h.length, o, d, a, l, q = false, k = [], e = {},
            g = [];
        for (o = 0; o < b; o++) {
            a = h[o];
            a.index = o;
            e[a.id] = a
        }
        for (j = 0; j < m; j++) {
            d = n[j];
            a = e[d.getStateId()];
            if (a) {
                l = a.index;
                k[l] = d;
                if (j !== l) {
                    q = true
                }
                if (d.applyColumnState) {
                    d.applyColumnState(a)
                }
            } else {
                g.push({index: j, column: d})
            }
        }
        k = Ext.Array.clean(k);
        b = g.length;
        if (b) {
            for (j = 0; j < b; j++) {
                a = g[j];
                l = a.index;
                if (l < k.length) {
                    q = true;
                    Ext.Array.splice(k, l, 0, a.column)
                } else {
                    k.push(a.column)
                }
            }
        }
        if (q) {
            p.removeAll(false);
            p.add(k);
            p.purgeCache()
        }
    },
    getColumnsState: function () {
        var b = this, a = [], c;
        b.items.each(function (d) {
            c = d.getColumnState && d.getColumnState();
            if (c) {
                a.push(c)
            }
        });
        return a
    },
    onAdd: function (b) {
        var a = this;
        if (!b.headerId) {
            b.headerId = b.initialConfig.id || Ext.id(null, "header-")
        }
        if (b.sortable === undefined) {
            b.sortable = a.sortable
        }
        if (!b.getStateId()) {
            b.stateId = b.initialConfig.id || ("h" + (++a.headerCounter))
        }
        Ext.container.Container.prototype.onAdd.apply(this, arguments);
        a.onHeadersChanged(b, a.isDDMoveInGrid)
    },
    move: function (c, e) {
        var d = this, b = d.items, a;
        if (c.isComponent) {
            a = c;
            c = b.indexOf(a)
        } else {
            a = b.getAt(c)
        }
        a.visibleFromIdx = d.getRootHeaderCt().visibleColumnManager.indexOf(a);
        Ext.container.Container.prototype.move.apply(this, arguments)
    },
    onMove: function (a, d, h) {
        var g = this, e = g.getRootHeaderCt(), b = e.visibleColumnManager, i = 1, c;
        g.onHeadersChanged(a, true);
        c = b.indexOf(a);
        if (c >= a.visibleFromIdx) {
            c++
        }
        Ext.container.Container.prototype.onMove.apply(this, arguments);
        if (a.isGroupHeader) {
            i = a.visibleColumnManager.getColumns().length
        }
        e.onHeaderMoved(a, i, a.visibleFromIdx, c)
    },
    onRemove: function (e, b) {
        var d = this, a = d.ownerCt;
        Ext.container.Container.prototype.onRemove.call(this, e, b);
        if (!d.destroying) {
            if (!d.isDDMoveInGrid) {
                d.onHeadersChanged(e, false)
            }
            if (d.isGroupHeader && !d.isNestedParent && a && !d.items.getCount()) {
                if (e.rendered) {
                    d.detachComponent(e)
                }
                Ext.suspendLayouts();
                a.remove(d);
                Ext.resumeLayouts(true)
            }
        }
    },
    onHeadersChanged: function (e, a) {
        var b, d = this.getRootHeaderCt();
        this.purgeHeaderCtCache(this);
        if (d) {
            d.onColumnsChanged();
            if (!e.isGroupHeader) {
                b = d.ownerCt;
                if (b && !a) {
                    b.onHeadersChanged(d, e)
                }
            }
        }
    },
    onHeaderMoved: function (g, a, c, e) {
        var d = this, b = d.ownerCt;
        if (d.rendered) {
            if (b && b.onHeaderMove) {
                b.onHeaderMove(d, g, a, c, e)
            }
            d.fireEvent("columnmove", d, g, c, e)
        }
    },
    onColumnsChanged: function () {
        var c = this, d = c.menu, a, b;
        if (c.rendered) {
            c.fireEvent("columnschanged", c);
            if (d && (a = d.child("#columnItemSeparator"))) {
                b = d.child("#columnItem");
                a.destroy();
                b.destroy()
            }
        }
    },
    lookupComponent: function (b) {
        var a = Ext.container.Container.prototype.lookupComponent.apply(this, arguments);
        if (!a.isGroupHeader && a.width === undefined && !a.flex) {
            a.width = this.defaultWidth
        }
        return a
    },
    setSortState: function () {
        var b = this.up("[store]").store, d = this.visibleColumnManager.getColumns(), a = d.length, c, g, e;
        for (c = 0; c < a; c++) {
            g = d[c];
            e = b.getSorters().get(g.getSortParam());
            g.setSortState(e)
        }
    },
    getHeaderMenu: function () {
        var b = this.getMenu(), a;
        if (b) {
            a = b.child("#columnItem");
            if (a) {
                return a.menu
            }
        }
        return null
    },
    onHeaderVisibilityChange: function (e, d) {
        var b = this, c = b.getHeaderMenu(), a;
        b.purgeHeaderCtCache(e.ownerCt);
        if (c) {
            a = b.getMenuItemForHeader(c, e);
            if (a) {
                a.setChecked(d, true)
            }
            if (c.isVisible()) {
                b.menuTask.delay(50)
            }
        }
    },
    updateMenuDisabledState: function (h) {
        var g = this, d = g.query(":not([hidden])"), c, a = d.length, e, b, j;
        if (!h) {
            h = g.getMenu()
        }
        for (c = 0; c < a; ++c) {
            e = d[c];
            b = g.getMenuItemForHeader(h, e);
            if (b) {
                j = e.isHideable() ? "enable" : "disable";
                if (b.menu) {
                    j += "CheckChange"
                }
                b[j]()
            }
        }
    },
    getMenuItemForHeader: function (a, b) {
        return b ? a.down("menucheckitem[headerId=" + b.id + "]") : null
    },
    onHeaderShow: function (c) {
        var b = this, a = b.ownerCt;
        if (!a) {
            return
        }
        if (b.forceFit) {
            delete b.flex
        }
        b.onHeaderVisibilityChange(c, true);
        a.onHeaderShow(b, c);
        b.fireEvent("columnshow", b, c);
        b.fireEvent("columnschanged", this)
    },
    onHeaderHide: function (c) {
        var b = this, a = b.ownerCt;
        if (!a) {
            return
        }
        b.onHeaderVisibilityChange(c, false);
        a.onHeaderHide(b, c);
        b.fireEvent("columnhide", b, c);
        b.fireEvent("columnschanged", this)
    },
    onHeaderResize: function (d, a) {
        var c = this, b = c.ownerCt;
        if (b) {
            b.onHeaderResize(c, d, a)
        }
        c.fireEvent("columnresize", c, d, a)
    },
    onHeaderClick: function (g, d, b) {
        var c = this, a = g.getView().getSelectionModel();
        g.fireEvent("headerclick", c, g, d, b);
        if (c.fireEvent("headerclick", c, g, d, b) !== false) {
            if (a.onHeaderClick) {
                a.onHeaderClick(c, g, d)
            }
        }
    },
    onHeaderContextMenu: function (c, b, a) {
        c.fireEvent("headercontextmenu", this, c, b, a);
        this.fireEvent("headercontextmenu", this, c, b, a)
    },
    onHeaderTriggerClick: function (d, c, a) {
        var b = this;
        if (d.fireEvent("headertriggerclick", b, d, c, a) !== false && b.fireEvent("headertriggerclick", b, d, c, a) !== false) {
            if (d.activeMenu) {
                if (c.pointerType) {
                    d.activeMenu.hide()
                } else {
                    d.activeMenu.focus()
                }
            } else {
                b.showMenuBy(c, a, d)
            }
        }
    },
    showMenuBy: function (a, c, h) {
        var e = this.getMenu(), g = e.down("#ascItem"), d = e.down("#descItem"), b;
        e.activeHeader = e.ownerCmp = h;
        h.setMenuActive(e);
        b = h.sortable ? "enable" : "disable";
        if (g) {
            g[b]()
        }
        if (d) {
            d[b]()
        }
        e.autoFocus = !a || !a.pointerType;
        e.showBy(c, "tl-bl?");
        if (!e.isVisible()) {
            this.onMenuHide(e)
        }
    },
    hideMenu: function () {
        if (this.menu) {
            this.menu.hide()
        }
    },
    onMenuHide: function (a) {
        a.activeHeader.setMenuActive(false)
    },
    purgeHeaderCtCache: function (a) {
        while (a) {
            a.purgeCache();
            if (a.isRootHeader) {
                return
            }
            a = a.ownerCt
        }
    },
    purgeCache: function () {
        var c = this, b = c.visibleColumnManager, a = c.columnManager;
        c.gridVisibleColumns = c.gridDataColumns = c.hideableColumns = null;
        if (b) {
            b.invalidate();
            a.invalidate()
        }
    },
    getMenu: function () {
        var b = this, a = b.view && b.view.ownerGrid;
        if (!b.menu) {
            b.menu = new Ext.menu.Menu({
                hideOnParentHide: false,
                items: b.getMenuItems(),
                listeners: {beforeshow: b.beforeMenuShow, hide: b.onMenuHide, scope: b}
            });
            b.fireEvent("menucreate", b, b.menu);
            if (a) {
                a.fireEvent("headermenucreate", a, b.menu, b)
            }
        }
        return b.menu
    },
    beforeMenuShow: function (e) {
        var c = this, b = e.child("#columnItem"), a, d;
        if (!b) {
            a = c.enableColumnHide ? c.getColumnMenu(c) : null;
            d = c.sortable ? 2 : 0;
            if (a && a.length) {
                e.insert(d, [{itemId: "columnItemSeparator", xtype: "menuseparator"}, {
                    itemId: "columnItem",
                    text: c.columnsText,
                    iconCls: c.menuColsIcon,
                    menu: {items: a},
                    hideOnClick: false
                }])
            }
        }
        c.updateMenuDisabledState(c.menu)
    },
    getMenuItems: function () {
        var c = this, b = [], a = c.enableColumnHide ? c.getColumnMenu(c) : null;
        if (c.sortable) {
            b = [{
                itemId: "ascItem",
                text: c.sortAscText,
                iconCls: c.menuSortAscCls,
                handler: c.onSortAscClick,
                scope: c
            }, {
                itemId: "descItem",
                text: c.sortDescText,
                iconCls: c.menuSortDescCls,
                handler: c.onSortDescClick,
                scope: c
            }]
        }
        if (a && a.length) {
            if (c.sortable) {
                b.push({itemId: "columnItemSeparator", xtype: "menuseparator"})
            }
            b.push({itemId: "columnItem", text: c.columnsText, iconCls: c.menuColsIcon, menu: a, hideOnClick: false})
        }
        return b
    },
    onSortAscClick: function () {
        var b = this.getMenu(), a = b.activeHeader;
        a.sort("ASC")
    },
    onSortDescClick: function () {
        var b = this.getMenu(), a = b.activeHeader;
        a.sort("DESC")
    },
    getColumnMenu: function (g) {
        var c = [], b = 0, e, a = g.query(">gridcolumn[hideable]"), h = a.length, d;
        for (; b < h; b++) {
            e = a[b];
            d = new Ext.menu.CheckItem({
                text: e.menuText || e.text,
                checked: !e.hidden,
                hideOnClick: false,
                headerId: e.id,
                menu: e.isGroupHeader ? this.getColumnMenu(e) : undefined,
                checkHandler: this.onColumnCheckChange,
                scope: this
            });
            c.push(d)
        }
        return c.length ? c : null
    },
    onColumnCheckChange: function (a, c) {
        var d = Ext.getCmp(a.headerId), b;
        if (d.rendered) {
            d[c ? "show" : "hide"]();
            b = d.lastCheckedHeaderId;
            if (c && b) {
                d.getRootHeaderCt().getMenu().down("[headerId=" + b + "]").setChecked(true);
                d.lastCheckedHeaderId = null
            }
        } else {
            d.hidden = !c
        }
    },
    getColumnCount: function () {
        return this.getGridColumns().length
    },
    getTableWidth: function () {
        var c = 0, b = this.getVisibleGridColumns(), d = b.length, a;
        for (a = 0; a < d; a++) {
            c += b[a].getCellWidth() || 0
        }
        return c
    },
    getVisibleGridColumns: function () {
        var h = this, c, e, b, a, d, g;
        if (h.gridVisibleColumns) {
            return h.gridVisibleColumns
        }
        c = h.getGridColumns();
        e = h.getRootHeaderCt();
        b = [];
        a = c.length;
        for (d = 0; d < a; d++) {
            g = c[d];
            if (!g.hidden && !g.isColumnHidden(e)) {
                b[b.length] = g
            }
        }
        h.gridVisibleColumns = b;
        return b
    },
    isColumnHidden: function (b) {
        var a = this.getRefOwner();
        while (a && a !== b) {
            if (a.hidden) {
                return true
            }
            a = a.getRefOwner()
        }
        return false
    },
    getGridColumns: function (h, a) {
        if (!h && this.gridDataColumns) {
            return this.gridDataColumns
        }
        var g = this, k = h || [], e, b, d, j, c;
        a = a || g.hidden;
        if (g.items) {
            e = g.items.items;
            if (e) {
                for (b = 0, d = e.length; b < d; b++) {
                    j = e[b];
                    if (j.isGroupHeader) {
                        j.visibleIndex = k.length;
                        j.getGridColumns(k, a)
                    } else {
                        j.hiddenAncestor = a;
                        k.push(j)
                    }
                }
            }
        }
        if (!h) {
            g.gridDataColumns = k
        }
        if (!h && d) {
            for (b = 0, d = k.length; b < d; b++) {
                j = k[b];
                j.fullColumnIndex = b;
                j.isFirstVisible = j.isLastVisible = false;
                if (!(j.hidden || j.hiddenAncestor)) {
                    if (!c) {
                        j.isFirstVisible = true
                    }
                    c = j
                }
            }
            if (c) {
                c.isLastVisible = true
            }
        }
        return k
    },
    getHideableColumns: function () {
        var b = this, a = b.hideableColumns;
        if (!a) {
            a = b.hideableColumns = b.query("[hideable]")
        }
        return a
    },
    getHeaderIndex: function (a) {
        if (!this.columnManager) {
            this.columnManager = this.getRootHeaderCt().columnManager
        }
        return this.columnManager.getHeaderIndex(a)
    },
    getHeaderAtIndex: function (a) {
        if (!this.columnManager) {
            this.columnManager = this.getRootHeaderCt().columnManager
        }
        return this.columnManager.getHeaderAtIndex(a)
    },
    getVisibleHeaderClosestToIndex: function (a) {
        if (!this.visibleColumnManager) {
            this.visibleColumnManager = this.getRootHeaderCt().visibleColumnManager
        }
        return this.visibleColumnManager.getVisibleHeaderClosestToIndex(a)
    },
    applyForceFit: function (h) {
        var n = this, o = n.view, b = Ext.grid.plugin.HeaderResizer.prototype.minColWidth, d = false,
            s = Ext.grid.header.Container.prototype.defaultWidth,
            a = n.el.dom.clientWidth - (o.el.dom.scrollHeight > o.el.dom.clientHeight ? Ext.getScrollbarSize().width : 0),
            e = 0, m = n.getVisibleGridColumns(), j = h.hidden, l, g, r, k, c;

        function p() {
            for (g = 0, l = m.length; g < l; g++) {
                r = m[g];
                if (r === h) {
                    continue
                }
                r.flex = r.flex || r.width || r.getWidth();
                e += r.flex;
                r.width = null
            }
        }

        function q() {
            var i;
            for (g = 0, l = m.length; g < l; g++) {
                r = m[g];
                i = (r === h);
                if (d && !i) {
                    r.flex = b;
                    r.width = null
                } else {
                    if (!i) {
                        c = r.flex || s;
                        r.flex = Math.max(Math.ceil((c / e) * a), b);
                        r.width = null
                    }
                }
                r.setWidth(r.width || r.flex)
            }
        }

        Ext.suspendLayouts();
        k = (a - ((m.length + 1) * b));
        h.flex = null;
        if (j) {
            c = h.width || h.savedWidth;
            h.savedWidth = null
        } else {
            c = o.getMaxContentWidth(h)
        }
        if (c > k) {
            h.width = k;
            d = true
        } else {
            h.width = c;
            a -= c + s;
            p()
        }
        q();
        Ext.resumeLayouts(true)
    },
    autoSizeColumn: function (b) {
        var a = this.view;
        if (a) {
            a.autoSizeColumn(b);
            if (this.forceFit) {
                this.applyForceFit(b)
            }
        }
    },
    privates: {
        beginChildHide: function () {
            ++this.childHideCount
        }, endChildHide: function () {
            --this.childHideCount
        }, getFocusables: function () {
            return this.isRootHeader ? this.getVisibleGridColumns() : this.items.items
        }, createFocusableContainerKeyNav: function (a) {
            var b = this;
            return new Ext.util.KeyNav(a, {
                scope: b,
                down: b.showHeaderMenu,
                left: b.onFocusableContainerLeftKey,
                right: b.onFocusableContainerRightKey,
                home: b.onHomeKey,
                end: b.onEndKey,
                space: b.onHeaderActivate,
                enter: b.onHeaderActivate
            })
        }, onHomeKey: function (a) {
            return this.focusChild(null, true, a)
        }, onEndKey: function (a) {
            return this.focusChild(null, false, a)
        }, showHeaderMenu: function (b) {
            var a = this.getFocusableFromEvent(b);
            if (a && a.isColumn && a.triggerEl) {
                this.onHeaderTriggerClick(a, b, a.triggerEl)
            }
        }, onHeaderActivate: function (d) {
            var c = this.getFocusableFromEvent(d), a, b;
            if (c && c.isColumn) {
                a = c.getView();
                if (c.sortable && this.sortOnClick) {
                    b = a.getNavigationModel().getLastFocused();
                    c.toggleSortState();
                    if (b) {
                        a.ownerCt.ensureVisible(b.record)
                    }
                }
                this.onHeaderClick(c, d, c.el)
            }
        }, onFocusableContainerMousedown: function (c, b) {
            var a = Ext.Component.fromElement(b);
            if (a === this) {
                c.preventDefault()
            } else {
                a.focus()
            }
        }
    }
}, 0, ["headercontainer"], ["component", "box", "container", "headercontainer"], {
    component: true,
    box: true,
    container: true,
    headercontainer: true
}, ["widget.headercontainer"], [[Ext.util.FocusableContainer.prototype.mixinId || Ext.util.FocusableContainer.$className, Ext.util.FocusableContainer]], [Ext.grid.header, "Container"], 0));
(Ext.cmd.derive("Ext.grid.column.Column", Ext.grid.header.Container, {
    alternateClassName: "Ext.grid.Column",
    config: {triggerVisible: false},
    baseCls: "x-column-header",
    hoverCls: "x-column-header-over",
    handleWidth: Ext.supports.Touch ? 10 : 4,
    ariaRole: "columnheader",
    enableFocusableContainer: false,
    sortState: null,
    possibleSortStates: ["ASC", "DESC"],
    ariaSortStates: {ASC: "ascending", DESC: "descending"},
    childEls: ["titleEl", "triggerEl", "textEl", "textContainerEl"],
    headerWrap: false,
    renderTpl: ['<div id="{id}-titleEl" data-ref="titleEl" role="presentation"', '{tipMarkup}class="', "x-", 'column-header-inner<tpl if="!$comp.isContainer"> ', "x-", "leaf-column-header</tpl>", '<tpl if="empty"> ', "x-", 'column-header-inner-empty</tpl>">', '<div id="{id}-textContainerEl" data-ref="textContainerEl" role="presentation" class="', "x-", 'column-header-text-container">', '<div role="presentation" class="', "x-", 'column-header-text-wrapper">', '<div id="{id}-textEl" data-ref="textEl" role="presentation" class="', "x-", "column-header-text", '{childElCls}">', '<span role="presentation" class="', "x-", 'column-header-text-inner">{text}</span>', "</div>", "</div>", "</div>", '<tpl if="!menuDisabled">', '<div id="{id}-triggerEl" data-ref="triggerEl" role="presentation" class="', "x-", "column-header-trigger", '{childElCls}" style="{triggerStyle}"></div>', "</tpl>", "</div>", "{%this.renderContainer(out,values)%}"],
    dataIndex: null,
    text: "&#160;",
    menuText: null,
    emptyCellText: "&#160;",
    sortable: true,
    resizable: true,
    hideable: true,
    menuDisabled: false,
    renderer: false,
    align: "left",
    draggable: true,
    tooltipType: "qtip",
    initDraggable: Ext.emptyFn,
    tdCls: "",
    producesHTML: true,
    ignoreExport: false,
    isHeader: true,
    isColumn: true,
    tabIndex: -1,
    ascSortCls: "x-column-header-sort-ASC",
    descSortCls: "x-column-header-sort-DESC",
    componentLayout: "columncomponent",
    groupSubHeaderCls: "x-group-sub-header",
    groupHeaderCls: "x-group-header",
    clickTargetName: "titleEl",
    detachOnRemove: true,
    initResizable: Ext.emptyFn,
    rendererNames: {column: "renderer", edit: "editRenderer", summary: "summaryRenderer"},
    formatterNames: {column: "formatter", edit: "editFormatter", summary: "summaryFormatter"},
    initComponent: function () {
        var a = this;
        if (!a.rendererScope) {
            a.rendererScope = a.scope
        }
        if (a.header != null) {
            a.text = a.header;
            a.header = null
        }
        if (a.cellWrap) {
            a.tdCls = (a.tdCls || "") + " x-wrap-cell"
        }
        if (a.columns != null) {
            a.isGroupHeader = true;
            a.ariaRole = "presentation";
            a.items = a.columns;
            a.columns = a.flex = a.width = null;
            a.cls = (a.cls || "") + " " + a.groupHeaderCls;
            a.sortable = a.resizable = false;
            a.align = "center"
        } else {
            if (a.flex) {
                a.minWidth = a.minWidth || Ext.grid.plugin.HeaderResizer.prototype.minColWidth
            }
        }
        a.addCls("x-column-header-align-" + a.align);
        a.setupRenderer();
        a.setupRenderer("edit");
        a.setupRenderer("summary");
        Ext.grid.header.Container.prototype.initComponent.apply(this, arguments)
    },
    bindFormatter: function (b) {
        var a = this;
        return function (c) {
            return b.format(c, b.scope || a.rendererScope || a.resolveListenerScope())
        }
    },
    bindRenderer: function (b) {
        var a = this;
        a.hasCustomRenderer = true;
        return function () {
            return Ext.callback(b, a.rendererScope, arguments, 0, a)
        }
    },
    setupRenderer: function (b) {
        b = b || "column";
        var c = this, e = c[c.formatterNames[b]], d = c[c.rendererNames[b]], a = b === "column", g;
        if (!e) {
            if (d) {
                if (typeof d === "string") {
                    d = c[c.rendererNames[b]] = c.bindRenderer(d)
                }
                if (a) {
                    c.hasCustomRenderer = d.length > 1
                }
            } else {
                if (a && c.defaultRenderer) {
                    c.renderer = c.defaultRenderer;
                    c.usingDefaultRenderer = true
                }
            }
        } else {
            g = e.indexOf("this.") === 0;
            if (g) {
                e = e.substring(5)
            }
            e = Ext.app.bind.Template.prototype.parseFormat(e);
            c[c.formatterNames[b]] = null;
            if (g) {
                e.scope = null
            }
            c[c.rendererNames[b]] = c.bindFormatter(e)
        }
    },
    getView: function () {
        var a = this.getRootHeaderCt();
        if (a) {
            return a.view
        }
    },
    onResize: function (d, a, c, h) {
        var e = this, b, g;
        Ext.grid.header.Container.prototype.onResize.apply(this, arguments);
        if (c && e.cellWrap) {
            b = e.getView();
            if (b) {
                g = b.bufferedRenderer;
                if (g) {
                    g.onWrappedColumnWidthChange(c, d)
                }
            }
        }
    },
    onFocusLeave: function (a) {
        Ext.grid.header.Container.prototype.onFocusLeave.call(this, a);
        if (this.activeMenu) {
            this.activeMenu.hide()
        }
    },
    initItems: function () {
        var a = this;
        Ext.grid.header.Container.prototype.initItems.apply(this, arguments);
        if (a.isGroupHeader) {
            if (a.config.hidden || !a.hasVisibleChildColumns()) {
                a.hide()
            }
        }
    },
    hasVisibleChildColumns: function () {
        var b = this.items.items, a = b.length, c, d;
        for (c = 0; c < a; ++c) {
            d = b[c];
            if (d.isColumn && !d.hidden) {
                return true
            }
        }
        return false
    },
    onAdd: function (b) {
        var a = this;
        if (b.isColumn) {
            b.isSubHeader = true;
            b.addCls(a.groupSubHeaderCls)
        }
        if (a.isGroupHeader && a.hidden && a.hasVisibleChildColumns()) {
            a.show()
        }
        Ext.grid.header.Container.prototype.onAdd.call(this, b)
    },
    onRemove: function (c, a) {
        var b = this;
        if (c.isSubHeader) {
            c.isSubHeader = false;
            c.removeCls(b.groupSubHeaderCls)
        }
        Ext.grid.header.Container.prototype.onRemove.call(this, c, a);
        if (!(b.destroyed || b.destroying) && !b.hasVisibleChildColumns() && !b.ownerCt.isNested()) {
            b.hide()
        }
    },
    initRenderData: function () {
        var b = this, e = "", c = b.tooltip, d = b.text, a = b.tooltipType === "qtip" ? "data-qtip" : "title";
        if (!Ext.isEmpty(c)) {
            e = a + '="' + c + '" '
        }
        return Ext.applyIf(Ext.grid.header.Container.prototype.initRenderData.apply(this, arguments), {
            text: d,
            empty: d === "&#160;" || d === " " || d === "",
            menuDisabled: b.menuDisabled,
            tipMarkup: e,
            triggerStyle: this.getTriggerVisible() ? "display:block" : ""
        })
    },
    applyColumnState: function (b) {
        var a = this;
        a.applyColumnsState(b.columns);
        if (b.hidden != null) {
            a.hidden = b.hidden
        }
        if (b.locked != null) {
            a.locked = b.locked
        }
        if (b.sortable != null) {
            a.sortable = b.sortable
        }
        if (b.width != null) {
            a.flex = null;
            a.width = b.width
        } else {
            if (b.flex != null) {
                a.width = null;
                a.flex = b.flex
            }
        }
    },
    getColumnState: function () {
        var e = this, b = e.items.items, a = b ? b.length : 0, d, c = [], g = {id: e.stateId || e.getStateId()};
        e.savePropsToState(["hidden", "sortable", "locked", "flex", "width"], g);
        if (e.isGroupHeader) {
            for (d = 0; d < a; d++) {
                c.push(b[d].getColumnState())
            }
            if (c.length) {
                g.columns = c
            }
        }
        if ("width" in g) {
            delete g.flex
        }
        return g
    },
    getStateId: function () {
        return (this.stateId = this.stateId || this.headerId)
    },
    setText: function (a) {
        this.text = a;
        if (this.rendered) {
            this.textEl.setHtml(a)
        }
    },
    getIndex: function () {
        return this.isGroupColumn ? false : this.getRootHeaderCt().getHeaderIndex(this)
    },
    getVisibleIndex: function () {
        return this.visibleIndex != null ? this.visibleIndex : this.isGroupColumn ? false : Ext.Array.indexOf(this.getRootHeaderCt().getVisibleGridColumns(), this)
    },
    getLabelChain: function () {
        var c = this, b = [], a;
        while (a = c.up("headercontainer")) {
            if (a.text) {
                b.unshift(Ext.util.Format.stripTags(a.text))
            }
            c = a
        }
        return b
    },
    beforeRender: function () {
        var c = this, a = c.getRootHeaderCt(), d = c.isSortable(), e = [], b;
        Ext.grid.header.Container.prototype.beforeRender.call(this);
        if (!d && !c.groupable && !c.lockable && (a.grid.enableColumnHide === false || !a.getHideableColumns().length)) {
            c.menuDisabled = true
        }
        if (c.cellWrap) {
            c.variableRowHeight = true
        }
        b = c.ariaRenderAttributes || (c.ariaRenderAttributes = {});
        b["aria-readonly"] = true;
        if (d) {
            b["aria-sort"] = c.ariaSortStates[c.sortState]
        }
        if (c.isSubHeader) {
            e = c.getLabelChain();
            if (c.text) {
                e.push(Ext.util.Format.stripTags(c.text))
            }
            if (e.length) {
                b["aria-label"] = e.join(" ")
            }
        }
        c.protoEl.unselectable()
    },
    getTriggerElWidth: function () {
        var c = this, b = c.triggerEl, a = c.self.triggerElWidth;
        if (b && a === undefined) {
            b.setStyle("display", "block");
            a = c.self.triggerElWidth = b.getWidth();
            b.setStyle("display", "")
        }
        return a
    },
    afterComponentLayout: function (d, a, b, g) {
        var e = this, c = e.getRootHeaderCt();
        Ext.grid.header.Container.prototype.afterComponentLayout.apply(this, arguments);
        if (c && (b != null || e.flex) && d !== b) {
            c.onHeaderResize(e, d)
        }
    },
    onDestroy: function () {
        var a = this;
        Ext.destroy(a.field);
        a.field = null;
        Ext.grid.header.Container.prototype.onDestroy.apply(this, arguments)
    },
    onTitleMouseOver: function () {
        this.titleEl.addCls(this.hoverCls)
    },
    onTitleMouseOut: function () {
        this.titleEl.removeCls(this.hoverCls)
    },
    onDownKey: function (a) {
        if (this.triggerEl) {
            this.onTitleElClick(a, this.triggerEl.dom || this.el.dom)
        }
    },
    onEnterKey: function (a) {
        this.onTitleElClick(a, this.el.dom)
    },
    onTitleElDblClick: function (d) {
        var b = this, a, c, g;
        if (b.isAtStartEdge(d)) {
            a = b.previousNode("gridcolumn:not([hidden]):not([isGroupHeader])");
            if (a && a.getRootHeaderCt() === b.getRootHeaderCt()) {
                a.autoSize()
            }
        } else {
            if (b.isAtEndEdge(d)) {
                if (b.isGroupHeader && d.getPoint().isContainedBy(b.layout.innerCt)) {
                    c = b.query("gridcolumn:not([hidden]):not([isGroupHeader])");
                    b.getRootHeaderCt().autoSizeColumn(c[c.length - 1]);
                    return
                } else {
                    g = b.getRootHeaderCt();
                    if (g.visibleColumnManager.getColumns().length === 1 && g.forceFit) {
                        return
                    }
                }
                b.autoSize()
            }
        }
    },
    autoSize: function () {
        var b = this, c, e, a, d;
        if (b.isGroupHeader) {
            c = b.query("gridcolumn:not([hidden]):not([isGroupHeader])");
            e = c.length;
            d = b.getRootHeaderCt();
            Ext.suspendLayouts();
            for (a = 0; a < e; a++) {
                d.autoSizeColumn(c[a])
            }
            Ext.resumeLayouts(true);
            return
        }
        b.getRootHeaderCt().autoSizeColumn(b)
    },
    onTitleElClick: function (h, c, d) {
        var g = this, a, b;
        if (h.pointerType === "touch") {
            b = g.previousSibling(":not([hidden])");
            if (!g.menuDisabled && g.isAtEndEdge(h, parseInt(g.triggerEl.getStyle("width"), 10))) {
                if (!g.menuDisabled) {
                    a = g
                }
            } else {
                if (b && !b.menuDisabled && g.isAtStartEdge(h)) {
                    a = b
                }
            }
        } else {
            a = g.triggerEl && (h.target === g.triggerEl.dom || c === g.triggerEl || h.within(g.triggerEl)) ? g : null
        }
        if (d !== false && (!a && !g.isAtStartEdge(h) && !g.isAtEndEdge(h) || h.getKey())) {
            g.toggleSortState()
        }
        return a
    },
    processEvent: function (g, b, a, c, d, h) {
        return this.fireEvent.apply(this, arguments)
    },
    isSortable: function () {
        var b = this.getRootHeaderCt(), a = b ? b.grid : null, c = this.sortable;
        if (a && a.sortableColumns === false) {
            c = false
        }
        return c
    },
    toggleSortState: function () {
        if (this.isSortable()) {
            this.sort()
        }
    },
    sort: function (d) {
        var c = this, b = c.up("tablepanel"), a = b.store;
        Ext.suspendLayouts();
        c.sorting = true;
        a.sort(c.getSortParam(), d, b.multiColumnSort ? "multi" : "replace");
        delete c.sorting;
        Ext.resumeLayouts(true)
    },
    getSortParam: function () {
        return this.dataIndex
    },
    setSortState: function (i) {
        var d = this, e = i && i.getDirection(), h = d.ascSortCls, b = d.descSortCls, c = d.getRootHeaderCt(),
            a = d.ariaEl.dom, g;
        switch (e) {
            case"DESC":
                if (!d.hasCls(b)) {
                    d.addCls(b);
                    d.sortState = "DESC";
                    g = true
                }
                d.removeCls(h);
                break;
            case"ASC":
                if (!d.hasCls(h)) {
                    d.addCls(h);
                    d.sortState = "ASC";
                    g = true
                }
                d.removeCls(b);
                break;
            default:
                d.removeCls([h, b]);
                d.sortState = null;
                break
        }
        if (a) {
            if (d.sortState) {
                a.setAttribute("aria-sort", d.ariaSortStates[d.sortState])
            } else {
                a.removeAttribute("aria-sort")
            }
        }
        if (g) {
            c.fireEvent("sortchange", c, d, e)
        }
    },
    isHideable: function () {
        var a = {hideCandidate: this, result: this.hideable};
        if (a.result) {
            this.ownerCt.bubble(this.hasOtherMenuEnabledChildren, null, [a])
        }
        return a.result
    },
    hasOtherMenuEnabledChildren: function (a) {
        var b, c;
        if (!this.isXType("headercontainer")) {
            a.result = false;
            return false
        }
        b = this.query(">:not([hidden]):not([menuDisabled])");
        c = b.length;
        if (Ext.Array.contains(b, a.hideCandidate)) {
            c--
        }
        if (c) {
            return false
        }
        a.hideCandidate = this
    },
    isLockable: function () {
        var a = {result: this.lockable !== false};
        if (a.result) {
            this.ownerCt.bubble(this.hasMultipleVisibleChildren, null, [a])
        }
        return a.result
    },
    isLocked: function () {
        return this.locked || !!this.up("[isColumn][locked]", "[isRootHeader]")
    },
    hasMultipleVisibleChildren: function (a) {
        if (!this.isXType("headercontainer")) {
            a.result = false;
            return false
        }
        if (this.query(">:not([hidden])").length > 1) {
            return false
        }
    },
    hide: function () {
        var c = this, b = c.getRootHeaderCt(), a = c.getRefOwner();
        if (a.constructing) {
            Ext.grid.header.Container.prototype.hide.call(this);
            return c
        }
        if (c.rendered && !c.isVisible()) {
            return c
        }
        if (b.forceFit) {
            c.visibleSiblingCount = b.getVisibleGridColumns().length - 1;
            if (c.flex) {
                c.savedWidth = c.getWidth();
                c.flex = null
            }
        }
        b.beginChildHide();
        Ext.suspendLayouts();
        if (a.isGroupHeader) {
            if (c.isNestedGroupHeader()) {
                a.hide()
            }
            if (c.isSubHeader && !c.isGroupHeader && a.query(">:not([hidden])").length === 1) {
                a.lastCheckedHeaderId = c.id
            }
        }
        Ext.grid.header.Container.prototype.hide.call(this);
        b.endChildHide();
        b.onHeaderHide(c);
        Ext.resumeLayouts(true);
        return c
    },
    show: function () {
        var c = this, a = c.getRootHeaderCt(), b = c.ownerCt;
        if (c.isVisible()) {
            return c
        }
        if (c.rendered) {
            if (a.forceFit) {
                a.applyForceFit(c)
            }
        }
        Ext.suspendLayouts();
        if (c.isSubHeader && b.hidden) {
            b.show(false, true)
        }
        Ext.grid.header.Container.prototype.show.apply(this, arguments);
        if (c.isGroupHeader) {
            c.maybeShowNestedGroupHeader()
        }
        b = c.getRootHeaderCt();
        if (b) {
            b.onHeaderShow(c)
        }
        Ext.resumeLayouts(true);
        return c
    },
    getCellWidth: function () {
        var b = this, a;
        if (b.rendered && b.componentLayout && b.componentLayout.lastComponentSize) {
            a = b.componentLayout.lastComponentSize.width
        } else {
            if (b.width) {
                a = b.width
            } else {
                if (!b.isColumn) {
                    a = b.getTableWidth()
                }
            }
        }
        return a
    },
    getCellId: function () {
        return "x-grid-cell-" + this.getItemId()
    },
    getCellSelector: function () {
        var a = this.getView();
        return (a ? a.getCellSelector() : "") + "." + this.getCellId()
    },
    getCellInnerSelector: function () {
        return this.getCellSelector() + " .x-grid-cell-inner"
    },
    isAtStartEdge: function (a) {
        return (a.getXY()[0] - this.getX() < this.handleWidth)
    },
    isAtEndEdge: function (b, a) {
        return (this.getX() + this.getWidth() - b.getXY()[0] <= (a || this.handleWidth))
    },
    setMenuActive: function (a) {
        this.activeMenu = a;
        this.titleEl[a ? "addCls" : "removeCls"](this.headerOpenCls)
    },
    deprecated: {
        5: {
            methods: {
                bindRenderer: function (a) {
                    return function (b) {
                        return Ext.util.Format[a](b)
                    }
                }
            }
        }
    }
}, 0, ["gridcolumn"], ["component", "box", "container", "headercontainer", "gridcolumn"], {
    component: true,
    box: true,
    container: true,
    headercontainer: true,
    gridcolumn: true
}, ["widget.gridcolumn"], 0, [Ext.grid.column, "Column", Ext.grid, "Column"], 0));
(Ext.cmd.derive("Ext.grid.column.Action", Ext.grid.column.Column, {
    alternateClassName: "Ext.grid.ActionColumn",
    stopSelection: true,
    actionIdRe: new RegExp("x-action-col-(\\\\d+)"),
    altText: "",
    menuText: "<i>Actions</i>",
    ignoreExport: true,
    sortable: false,
    innerCls: "x-grid-cell-inner-action-col",
    actionIconCls: "x-action-col-icon",
    constructor: function (d) {
        var g = this, b = Ext.apply({}, d), c = b.items || g.items || [g], h, e, a;
        g.origRenderer = b.renderer || g.renderer;
        g.origScope = b.scope || g.scope;
        g.renderer = g.scope = b.renderer = b.scope = null;
        b.items = null;
        Ext.grid.column.Column.prototype.constructor.call(this, b);
        g.items = c;
        for (e = 0, a = c.length; e < a; ++e) {
            if (c[e].getClass) {
                h = true;
                break
            }
        }
        if (g.origRenderer || h) {
            g.hasCustomRenderer = true
        }
    },
    initComponent: function () {
        var a = this;
        Ext.grid.column.Column.prototype.initComponent.call(this);
        if (a.sortable && !a.dataIndex) {
            a.sortable = false
        }
    },
    defaultRenderer: function (j, m, c, b, l, g, k) {
        var s = this, a = s.origScope || s, n = s.items, p = n.length, o, r, t, d, e, h, q;
        t = Ext.isFunction(s.origRenderer) ? s.origRenderer.apply(a, arguments) || "" : "";
        m.tdCls += " x-action-col-cell";
        for (o = 0; o < p; o++) {
            r = n[o];
            q = r.icon;
            d = r.disabled || (r.isDisabled ? r.isDisabled.call(r.scope || a, k, b, l, r, c) : false);
            e = d ? null : (r.tooltip || (r.getTip ? r.getTip.apply(r.scope || a, arguments) : null));
            h = r.getAltText ? r.getAltText.apply(r.scope || a, arguments) : r.altText || s.altText;
            if (!r.hasActionConfiguration) {
                r.stopSelection = s.stopSelection;
                r.disable = Ext.Function.bind(s.disableAction, s, [o], 0);
                r.enable = Ext.Function.bind(s.enableAction, s, [o], 0);
                r.hasActionConfiguration = true
            }
            t += "<" + (q ? "img" : "div") + ' tabIndex="0" role="button"' + (q ? (' alt="' + h + '" src="' + r.icon + '"') : "") + ' class="' + s.actionIconCls + " x-action-col-" + String(o) + " " + (d ? s.disabledCls + " " : " ") + (Ext.isFunction(r.getClass) ? r.getClass.apply(r.scope || a, arguments) : (r.iconCls || s.iconCls || "")) + '"' + (e ? ' data-qtip="' + e + '"' : "") + (q ? "/>" : "></div>")
        }
        return t
    },
    updater: function (a, e, c, b, g) {
        var d = {};
        Ext.fly(a).addCls(d.tdCls).down(this.getView().innerSelector, true).innerHTML = this.defaultRenderer(e, d, c, null, null, g, b)
    },
    enableAction: function (b, a) {
        var c = this;
        if (!b) {
            b = 0
        } else {
            if (!Ext.isNumber(b)) {
                b = Ext.Array.indexOf(c.items, b)
            }
        }
        c.items[b].disabled = false;
        c.up("tablepanel").el.select(".x-action-col-" + b).removeCls(c.disabledCls);
        if (!a) {
            c.fireEvent("enable", c)
        }
    },
    disableAction: function (b, a) {
        var c = this;
        if (!b) {
            b = 0
        } else {
            if (!Ext.isNumber(b)) {
                b = Ext.Array.indexOf(c.items, b)
            }
        }
        c.items[b].disabled = true;
        c.up("tablepanel").el.select(".x-action-col-" + b).addCls(c.disabledCls);
        if (!a) {
            c.fireEvent("disable", c)
        }
    },
    beforeDestroy: function () {
        this.renderer = this.items = null;
        return Ext.grid.column.Column.prototype.beforeDestroy.apply(this, arguments)
    },
    processEvent: function (k, m, o, b, l, i, d, q) {
        var j = this, h = i.getTarget(), n = k === "keydown" && i.getKey(), c, p, a, g = Ext.fly(o);
        i.stopSelection = !n && j.stopSelection;
        if (n && (h === o || !g.contains(h))) {
            h = g.query("." + j.actionIconCls, true);
            if (h.length === 1) {
                h = h[0]
            } else {
                return
            }
        }
        if (h && (c = h.className.match(j.actionIdRe))) {
            p = j.items[parseInt(c[1], 10)];
            a = p.disabled || (p.isDisabled ? p.isDisabled.call(p.scope || j.origScope || j, m, b, l, p, d) : false);
            if (p && !a) {
                if (k === "mousedown" && !j.getView().actionableMode) {
                    i.preventDefault()
                } else {
                    if (k === "click" || (n === i.ENTER || n === i.SPACE)) {
                        Ext.callback(p.handler || j.handler, p.scope || j.origScope, [m, b, l, p, i, d, q], undefined, j);
                        if (!m.el.contains(Ext.Element.getActiveElement())) {
                            return false
                        }
                    }
                }
            }
        }
        return Ext.grid.column.Column.prototype.processEvent.apply(this, arguments)
    },
    cascade: function (b, a) {
        b.call(a || this, this)
    },
    getRefItems: function () {
        return []
    },
    privates: {
        getFocusables: function () {
            return []
        }
    }
}, 1, ["actioncolumn"], ["component", "box", "container", "headercontainer", "gridcolumn", "actioncolumn"], {
    component: true,
    box: true,
    container: true,
    headercontainer: true,
    gridcolumn: true,
    actioncolumn: true
}, ["widget.actioncolumn"], 0, [Ext.grid.column, "Action", Ext.grid, "ActionColumn"], 0));
(Ext.cmd.derive("Ext.grid.column.Boolean", Ext.grid.column.Column, {
    alternateClassName: "Ext.grid.BooleanColumn",
    trueText: "true",
    falseText: "false",
    undefinedText: "&#160;",
    defaultFilterType: "boolean",
    producesHTML: false,
    defaultRenderer: function (a) {
        if (a === undefined) {
            return this.undefinedText
        }
        if (!a || a === "false") {
            return this.falseText
        }
        return this.trueText
    },
    updater: function (a, b) {
        Ext.fly(a).down(this.getView().innerSelector, true).innerHTML = Ext.grid.column.Boolean.prototype.defaultRenderer.call(this, b)
    }
}, 0, ["booleancolumn"], ["component", "box", "container", "headercontainer", "gridcolumn", "booleancolumn"], {
    component: true,
    box: true,
    container: true,
    headercontainer: true,
    gridcolumn: true,
    booleancolumn: true
}, ["widget.booleancolumn"], 0, [Ext.grid.column, "Boolean", Ext.grid, "BooleanColumn"], 0));
(Ext.cmd.derive("Ext.grid.column.Check", Ext.grid.column.Column, {
    alternateClassName: ["Ext.ux.CheckColumn", "Ext.grid.column.CheckColumn"],
    align: "center",
    ignoreExport: true,
    stopSelection: true,
    tdCls: "x-grid-cell-checkcolumn",
    innerCls: "x-grid-cell-inner-checkcolumn",
    clickTargetName: "el",
    defaultFilterType: "boolean",
    constructor: function () {
        this.scope = this;
        Ext.grid.column.Column.prototype.constructor.apply(this, arguments)
    },
    processEvent: function (j, l, o, c, k, h, d, p) {
        var i = this, n = j === "keydown" && h.getKey(), a = j === "mousedown", b = i.disabled, g, m;
        h.stopSelection = !n && i.stopSelection;
        if (!b && (a || (n === h.ENTER || n === h.SPACE))) {
            m = !i.isRecordChecked(d);
            if (i.fireEvent("beforecheckchange", i, c, m) !== false) {
                i.setRecordCheck(d, m, o, p, h);
                i.fireEvent("checkchange", i, c, m);
                if (a && !i.getView().actionableMode) {
                    h.preventDefault()
                }
            }
        } else {
            g = Ext.grid.column.Column.prototype.processEvent.apply(this, arguments)
        }
        return g
    },
    onEnable: function () {
        Ext.grid.column.Column.prototype.onEnable.apply(this, arguments);
        this._setDisabled(false)
    },
    onDisable: function () {
        this._setDisabled(true)
    },
    _setDisabled: function (c) {
        var d = this, a = d.disabledCls, b;
        b = d.up("tablepanel").el.select(d.getCellSelector());
        if (c) {
            b.addCls(a)
        } else {
            b.removeCls(a)
        }
    },
    defaultRenderer: function (c, b) {
        var d = "x-", a = d + "grid-checkcolumn";
        if (this.disabled) {
            b.tdCls += " " + this.disabledCls
        }
        if (c) {
            a += " " + d + "grid-checkcolumn-checked"
        }
        return '<div class="' + a + '" role="button" tabIndex="0"></div>'
    },
    isRecordChecked: function (a) {
        var b = this.property;
        if (b) {
            return a[b]
        }
        return a.get(this.dataIndex)
    },
    setRecordCheck: function (b, d, a, h, g) {
        var c = this, i = c.property;
        if (i) {
            b[i] = d;
            c.updater(a, d)
        } else {
            b.set(c.dataIndex, d)
        }
    },
    updater: function (a, b) {
        a = Ext.fly(a);
        a[this.disabled ? "addCls" : "removeCls"](this.disabledCls);
        Ext.fly(a.down(this.getView().innerSelector, true).firstChild)[b ? "addCls" : "removeCls"]("x-grid-checkcolumn-checked")
    }
}, 1, ["checkcolumn"], ["component", "box", "container", "headercontainer", "gridcolumn", "checkcolumn"], {
    component: true,
    box: true,
    container: true,
    headercontainer: true,
    gridcolumn: true,
    checkcolumn: true
}, ["widget.checkcolumn"], 0, [Ext.grid.column, "Check", Ext.ux, "CheckColumn", Ext.grid.column, "CheckColumn"], 0));
(Ext.cmd.derive("Ext.grid.column.Date", Ext.grid.column.Column, {
    alternateClassName: "Ext.grid.DateColumn",
    isDateColumn: true,
    defaultFilterType: "date",
    producesHTML: false,
    initComponent: function () {
        if (!this.format) {
            this.format = Ext.Date.defaultFormat
        }
        Ext.grid.column.Column.prototype.initComponent.apply(this, arguments)
    },
    defaultRenderer: function (a) {
        return Ext.util.Format.date(a, this.format)
    },
    updater: function (a, b) {
        Ext.fly(a).down(this.getView().innerSelector, true).innerHTML = Ext.grid.column.Date.prototype.defaultRenderer.call(this, b)
    }
}, 0, ["datecolumn"], ["component", "box", "container", "headercontainer", "gridcolumn", "datecolumn"], {
    component: true,
    box: true,
    container: true,
    headercontainer: true,
    gridcolumn: true,
    datecolumn: true
}, ["widget.datecolumn"], 0, [Ext.grid.column, "Date", Ext.grid, "DateColumn"], 0));
(Ext.cmd.derive("Ext.grid.column.Number", Ext.grid.column.Column, {
    alternateClassName: "Ext.grid.NumberColumn",
    defaultFilterType: "number",
    format: "0,000.00",
    producesHTML: false,
    defaultRenderer: function (a) {
        return Ext.util.Format.number(a, this.format)
    },
    updater: function (a, b) {
        Ext.fly(a).down(this.getView().innerSelector, true).innerHTML = Ext.grid.column.Number.prototype.defaultRenderer.call(this, b)
    }
}, 0, ["numbercolumn"], ["component", "box", "container", "headercontainer", "gridcolumn", "numbercolumn"], {
    component: true,
    box: true,
    container: true,
    headercontainer: true,
    gridcolumn: true,
    numbercolumn: true
}, ["widget.numbercolumn"], 0, [Ext.grid.column, "Number", Ext.grid, "NumberColumn"], 0));
(Ext.cmd.derive("Ext.grid.column.RowNumberer", Ext.grid.column.Column, {
    alternateClassName: "Ext.grid.RowNumberer",
    isRowNumberer: true,
    text: "&#160;",
    width: 23,
    sortable: false,
    draggable: false,
    autoLock: true,
    lockable: false,
    align: "right",
    producesHTML: false,
    ignoreExport: true,
    constructor: function (a) {
        var b = this;
        b.width = b.width;
        Ext.grid.column.Column.prototype.constructor.apply(this, arguments);
        b.sortable = false;
        b.scope = b
    },
    resizable: false,
    hideable: false,
    menuDisabled: true,
    dataIndex: "",
    cls: "x-row-numberer",
    tdCls: "x-grid-cell-row-numberer x-grid-cell-special",
    innerCls: "x-grid-cell-inner-row-numberer",
    rowspan: undefined,
    defaultRenderer: function (j, b, g, c, e, a, i) {
        var d = this.rowspan, h = a.currentPage, k = i.store.indexOf(g);
        if (b && d) {
            b.tdAttr = 'rowspan="' + d + '"'
        }
        if (h > 1) {
            k += (h - 1) * a.pageSize
        }
        return k + 1
    },
    updater: function (a, d, c, b, e) {
        Ext.fly(a).down(this.getView().innerSelector, true).innerHTML = this.defaultRenderer(d, null, c, null, null, e, b)
    }
}, 1, ["rownumberer"], ["component", "box", "container", "headercontainer", "gridcolumn", "rownumberer"], {
    component: true,
    box: true,
    container: true,
    headercontainer: true,
    gridcolumn: true,
    rownumberer: true
}, ["widget.rownumberer"], 0, [Ext.grid.column, "RowNumberer", Ext.grid, "RowNumberer"], 0));
(Ext.cmd.derive("Ext.grid.column.Template", Ext.grid.column.Column, {
    alternateClassName: "Ext.grid.TemplateColumn",
    initComponent: function () {
        var a = this;
        a.tpl = (!Ext.isPrimitive(a.tpl) && a.tpl.compile) ? a.tpl : new Ext.XTemplate(a.tpl);
        a.hasCustomRenderer = true;
        Ext.grid.column.Column.prototype.initComponent.apply(this, arguments)
    },
    defaultRenderer: function (c, d, a) {
        var b = Ext.apply({}, a.data, a.getAssociatedData());
        return this.tpl.apply(b)
    },
    updater: function (a, b) {
        Ext.fly(a).down(this.getView().innerSelector, true).innerHTML = Ext.grid.column.CheckColumn.prototype.defaultRenderer.call(this, b)
    }
}, 0, ["templatecolumn"], ["component", "box", "container", "headercontainer", "gridcolumn", "templatecolumn"], {
    component: true,
    box: true,
    container: true,
    headercontainer: true,
    gridcolumn: true,
    templatecolumn: true
}, ["widget.templatecolumn"], 0, [Ext.grid.column, "Template", Ext.grid, "TemplateColumn"], 0));
(Ext.cmd.derive("Ext.grid.column.Widget", Ext.grid.column.Column, {
    config: {defaultWidgetUI: {}},
    ignoreExport: true,
    sortable: false,
    onWidgetAttach: null,
    stopSelection: true,
    preventUpdate: true,
    initComponent: function () {
        var a = this, b;
        Ext.grid.column.Column.prototype.initComponent.apply(this, arguments);
        b = a.widget;
        a.widget = b = Ext.apply({}, b);
        if (!b.ui) {
            b.ui = a.getDefaultWidgetUI()[b.xtype] || "default"
        }
        a.isFixedSize = Ext.isNumber(b.width)
    },
    processEvent: function (g, i, j, a, h, d, b, k) {
        var c;
        if (this.stopSelection && g === "click") {
            c = d.getTarget(i.innerSelector);
            if (c && c !== d.target) {
                d.stopSelection = true
            }
        }
    },
    beforeRender: function () {
        var a = this, c = a.tdCls, b;
        a.listenerScopeFn = function (d) {
            if (d === "this") {
                return this
            }
            return a.resolveListenerScope(d)
        };
        a.liveWidgets = {};
        a.cachedStyles = {};
        a.freeWidgetStack = [b = a.getFreeWidget()];
        c = c ? c + " " : "";
        a.tdCls = c + b.getTdCls();
        a.setupViewListeners(a.getView());
        Ext.grid.column.Column.prototype.beforeRender.call(this)
    },
    afterRender: function () {
        var a = this.getView();
        Ext.grid.column.Column.prototype.afterRender.call(this);
        if (a && a.viewReady && !a.ownerGrid.reconfiguring) {
            this.onViewRefresh(a, a.getViewRange())
        }
    },
    defaultRenderer: Ext.emptyFn,
    updater: function (a, c, b) {
        this.updateWidget(b)
    },
    onResize: function (e) {
        var d = this, b = d.liveWidgets, c = d.getView(), g, a;
        if (!d.isFixedSize && d.rendered && c && c.viewReady) {
            a = c.getEl().down(d.getCellInnerSelector());
            if (a) {
                e -= parseInt(d.getCachedStyle(a, "padding-left"), 10) + parseInt(d.getCachedStyle(a, "padding-right"), 10);
                for (g in b) {
                    b[g].setWidth(e)
                }
            }
        }
    },
    onAdded: function () {
        var b = this, a;
        Ext.grid.column.Column.prototype.onAdded.apply(this, arguments);
        a = b.getView();
        if (a) {
            b.setupViewListeners(a);
            if (a && a.viewReady && b.rendered && a.getEl().down(b.getCellSelector())) {
                b.onViewRefresh(a, a.getViewRange())
            }
        }
    },
    onRemoved: function (c) {
        var d = this, a = d.liveWidgets, b = d.viewListeners, e;
        if (d.rendered) {
            d.viewListeners = b && Ext.destroy(b);
            if (!c) {
                for (e in a) {
                    a[e].detachFromBody()
                }
            }
        }
        Ext.grid.column.Column.prototype.onRemoved.apply(this, arguments)
    },
    onDestroy: function () {
        var c = this, h = c.liveWidgets, g = c.freeWidgetStack, e, d, b, a;
        if (c.rendered) {
            for (e in h) {
                d = h[e];
                d.$widgetRecord = d.$widgetColumn = null;
                delete d.getWidgetRecord;
                delete d.getWidgetColumn;
                d.destroy()
            }
            for (b = 0, a = g.length; b < a; ++b) {
                g[b].destroy()
            }
        }
        c.freeWidgetStack = c.liveWidgets = null;
        Ext.grid.column.Column.prototype.onDestroy.call(this)
    },
    getWidget: function (b) {
        var a = this.liveWidgets, c;
        if (b && a) {
            c = a[b.internalId]
        }
        return c || null
    },
    privates: {
        getCachedStyle: function (b, a) {
            var c = this.cachedStyles;
            return c[a] || (c[a] = Ext.fly(b).getStyle(a))
        }, getFreeWidget: function () {
            var b = this, a = b.freeWidgetStack ? b.freeWidgetStack.pop() : null;
            if (!a) {
                a = Ext.widget(b.widget);
                a.resolveListenerScope = b.listenerScopeFn;
                a.getWidgetRecord = b.widgetRecordDecorator;
                a.getWidgetColumn = b.widgetColumnDecorator;
                a.dataIndex = b.dataIndex;
                a.measurer = b;
                a.ownerCmp = b.getView();
                a.isLayoutChild = b.returnFalse
            }
            return a
        }, onBeforeRefresh: function () {
            var a = this.liveWidgets, b;
            for (b in a) {
                a[b].detachFromBody()
            }
        }, onItemAdd: function (c, k, m) {
            var n = this, o = n.getView(), l = !!n.onWidgetAttach, p = n.dataIndex, q = n.isFixedSize, j = c.length, d,
                g, s, r, e, b, h, a;
            if (n.isVisible(true)) {
                for (d = 0; d < j; d++) {
                    g = c[d];
                    if (g.isNonData) {
                        continue
                    }
                    s = o.getRowFromItem(m[d]);
                    if (s) {
                        r = s.cells[n.getVisibleIndex()].firstChild;
                        if (!q && !a) {
                            a = n.lastBox.width - parseInt(n.getCachedStyle(r, "padding-left"), 10) - parseInt(n.getCachedStyle(r, "padding-right"), 10)
                        }
                        e = n.liveWidgets[g.internalId] = n.getFreeWidget();
                        e.$widgetColumn = n;
                        e.$widgetRecord = g;
                        Ext.fly(r).empty();
                        if (e.defaultBindProperty && p) {
                            e.setConfig(e.defaultBindProperty, g.get(p))
                        }
                        if (l) {
                            Ext.callback(n.onWidgetAttach, n.scope, [n, e, g], 0, n)
                        }
                        b = e.el || e.element;
                        if (b) {
                            r.appendChild(b.dom);
                            if (!q) {
                                e.setWidth(a)
                            }
                            e.reattachToBody()
                        } else {
                            if (!q) {
                                e.width = a
                            }
                            e.render(r)
                        }
                        h = e.getFocusEl();
                        if (h) {
                            if (o.actionableMode) {
                                if (!h.isTabbable()) {
                                    h.restoreTabbableState()
                                }
                            } else {
                                if (h.isTabbable()) {
                                    h.saveTabbableState()
                                }
                            }
                        }
                    }
                }
            }
        }, onItemRemove: function (b, j, k) {
            var l = this, c = l.liveWidgets, e, m, a, h, d, g;
            if (l.rendered) {
                k = Ext.Array.from(k);
                h = k.length;
                for (d = 0; d < h; d++) {
                    m = k[d];
                    a = m.getAttribute("data-recordId");
                    if (a && (e = c[a])) {
                        delete c[a];
                        l.freeWidgetStack.unshift(e);
                        e.$widgetRecord = e.$widgetColumn = null;
                        g = e.getFocusEl();
                        if (g) {
                            if (g.isTabbable()) {
                                g.saveTabbableState()
                            }
                            g.blur()
                        }
                        e.detachFromBody()
                    }
                }
            }
        }, onItemUpdate: function (a, b, c) {
            this.updateWidget(a)
        }, onViewRefresh: function (k, n) {
            var r = this, i = k.all, h = !!r.onWidgetAttach, j = r.liveWidgets, s = r.dataIndex, t = r.isFixedSize, b,
                g, c, m, a, q, e, d, l, p, o;
            if (r.isVisible(true)) {
                r.liveWidgets = {};
                Ext.suspendLayouts();
                for (q = i.startIndex, e = 0; q <= i.endIndex; q++, e++) {
                    d = n[e];
                    if (d.isNonData) {
                        continue
                    }
                    a = d.internalId;
                    b = k.getRow(i.item(q)).cells[r.getVisibleIndex()].firstChild;
                    g = r.liveWidgets[a] = j[a] || r.getFreeWidget();
                    g.$widgetRecord = d;
                    g.$widgetColumn = r;
                    delete j[a];
                    p = r.lastBox;
                    if (p && !t && m === undefined) {
                        m = p.width - parseInt(r.getCachedStyle(b, "padding-left"), 10) - parseInt(r.getCachedStyle(b, "padding-right"), 10)
                    }
                    if (g.defaultBindProperty && s) {
                        g.setConfig(g.defaultBindProperty, n[e].get(s))
                    }
                    if (h) {
                        Ext.callback(r.onWidgetAttach, r.scope, [r, g, d], 0, r)
                    }
                    c = g.el || g.element;
                    if (c) {
                        o = c.dom;
                        if (o.parentNode !== b) {
                            Ext.fly(b).empty();
                            b.appendChild(c.dom)
                        }
                        if (!t) {
                            g.setWidth(m)
                        }
                        g.reattachToBody()
                    } else {
                        if (!t) {
                            g.width = m
                        }
                        Ext.fly(b).empty();
                        g.render(b)
                    }
                }
                Ext.resumeLayouts(true);
                for (l in j) {
                    g = j[l];
                    g.$widgetRecord = g.$widgetColumn = null;
                    r.freeWidgetStack.unshift(g);
                    g.detachFromBody()
                }
            }
        }, returnFalse: function () {
            return false
        }, setupViewListeners: function (a) {
            var b = this;
            b.viewListeners = a.on({
                refresh: b.onViewRefresh,
                itemupdate: b.onItemUpdate,
                itemadd: b.onItemAdd,
                itemremove: b.onItemRemove,
                scope: b,
                destroyable: true
            });
            if (Ext.isIE8) {
                a.on("beforerefresh", b.onBeforeRefresh, b)
            }
        }, updateWidget: function (a) {
            var b = this.dataIndex, c;
            if (this.rendered) {
                c = this.liveWidgets[a.internalId];
                if (c && c.defaultBindProperty && b) {
                    c.setConfig(c.defaultBindProperty, a.get(b))
                }
            }
        }, widgetRecordDecorator: function () {
            return this.$widgetRecord
        }, widgetColumnDecorator: function () {
            return this.$widgetColumn
        }
    }
}, 0, ["widgetcolumn"], ["component", "box", "container", "headercontainer", "gridcolumn", "widgetcolumn"], {
    component: true,
    box: true,
    container: true,
    headercontainer: true,
    gridcolumn: true,
    widgetcolumn: true
}, ["widget.widgetcolumn"], 0, [Ext.grid.column, "Widget"], 0));
(Ext.cmd.derive("Ext.grid.feature.Feature", Ext.util.Observable, {
    wrapsItem: false,
    isFeature: true,
    disabled: false,
    hasFeatureEvent: true,
    eventPrefix: null,
    eventSelector: null,
    view: null,
    grid: null,
    constructor: function (a) {
        this.initialConfig = a;
        Ext.util.Observable.prototype.constructor.apply(this, arguments)
    },
    clone: function () {
        return new this.self(this.initialConfig)
    },
    init: Ext.emptyFn,
    getFireEventArgs: function (b, a, c, d) {
        return [b, a, c, d]
    },
    vetoEvent: Ext.emptyFn,
    enable: function () {
        this.disabled = false
    },
    disable: function () {
        this.disabled = true
    }
}, 1, 0, 0, 0, ["feature.feature"], 0, [Ext.grid.feature, "Feature"], 0));
(Ext.cmd.derive("Ext.grid.feature.AbstractSummary", Ext.grid.feature.Feature, {
    summaryRowCls: "x-grid-row-summary",
    readDataOptions: {recordCreator: Ext.identityFn},
    summaryRowTpl: {
        fn: function (b, a, c) {
            if (a.record.isSummary && this.summaryFeature.showSummaryRow) {
                this.summaryFeature.outputSummaryRecord(a.record, a, b, c)
            } else {
                this.nextTpl.applyOut(a, b, c)
            }
        }, priority: 1000
    },
    showSummaryRow: true,
    init: function () {
        var a = this;
        a.view.summaryFeature = a;
        a.rowTpl = a.view.self.prototype.rowTpl;
        a.view.addRowTpl(a.summaryRowTpl).summaryFeature = a;
        a.summaryData = {};
        a.groupInfo = {};
        if (!a.summaryTableCls) {
            a.summaryTableCls = "x-grid-item"
        }
        a.summaryRowSelector = "." + a.summaryRowCls
    },
    bindStore: function (b, a) {
        var c = this;
        Ext.destroy(c.readerListeners);
        if (c.remoteRoot) {
            c.readerListeners = a.getProxy().getReader().on({scope: c, destroyable: true, rawdata: c.onReaderRawData})
        }
    },
    onReaderRawData: function (a) {
        this.summaryRows = null;
        this.readerRawData = a
    },
    toggleSummaryRow: function (e, a) {
        var d = this, c = d.showSummaryRow, b;
        e = e != null ? !!e : !d.showSummaryRow;
        d.showSummaryRow = e;
        if (e && e !== c) {
            d.updateNext = true
        }
        if (d.lockingPartner) {
            if (!a) {
                d.lockingPartner.toggleSummaryRow(e, true);
                b = true
            }
        } else {
            b = true
        }
        if (b) {
            d.grid.ownerGrid.getView().refresh()
        }
    },
    createRenderer: function (e, b) {
        var g = this, c = b.ownerGroup, a = c ? g.summaryData[c] : g.summaryData, d = e.dataIndex || e.getItemId();
        return function (i, h) {
            return e.summaryRenderer ? e.summaryRenderer(b.data[d], a, d, h) : b.data[d]
        }
    },
    outputSummaryRecord: function (g, l, d) {
        var h = l.view, a = h.rowValues, c = l.columns || h.headerCt.getVisibleGridColumns(), k = c.length, e, b, j = {
            view: h,
            record: g,
            rowStyle: "",
            rowClasses: [this.summaryRowCls],
            itemClasses: [],
            recordIndex: -1,
            rowId: h.getRowId(g),
            columns: c
        };
        for (e = 0; e < k; e++) {
            b = c[e];
            b.savedRenderer = b.renderer;
            if (b.summaryType || b.summaryRenderer) {
                b.renderer = this.createRenderer(b, g)
            } else {
                b.renderer = Ext.emptyFn
            }
        }
        h.rowValues = j;
        h.self.prototype.rowTpl.applyOut(j, d, parent);
        h.rowValues = a;
        for (e = 0; e < k; e++) {
            b = c[e];
            b.renderer = b.savedRenderer;
            b.savedRenderer = null
        }
    },
    getSummary: function (a, b, g, e) {
        var d = !!e, c = d ? e : a;
        if (b) {
            if (Ext.isFunction(b)) {
                if (d) {
                    return c.aggregate(g, b)
                } else {
                    return c.aggregate(b, null, false, [g])
                }
            }
            switch (b) {
                case"count":
                    return c.count(g);
                case"min":
                    return c.min(g);
                case"max":
                    return c.max(g);
                case"sum":
                    return c.sum(g);
                case"average":
                    return c.average(g);
                default:
                    return ""
            }
        }
    },
    getRawData: function () {
        var a = this.readerRawData;
        if (a) {
            return a
        }
        return this.view.getStore().getProxy().getReader().rawData
    },
    generateSummaryData: function (b) {
        var g = this, n = g.summaryRows, k = {}, j = {}, h, d, a, c, e, n, m, l;
        if (!n) {
            a = g.getRawData();
            if (!a) {
                return
            }
            h = g.view.store.getProxy().getReader();
            d = Ext.create("reader." + h.type, h.getConfig());
            d.setRootProperty(g.remoteRoot);
            n = d.getRoot(a);
            if (n) {
                m = [];
                if (!Ext.isArray(n)) {
                    n = [n]
                }
                e = n.length;
                for (c = 0; c < e; ++c) {
                    l = d.extractRecordData(n[c], g.readDataOptions);
                    m.push(l)
                }
                g.summaryRows = n = m
            }
            d.destroy();
            g.readerRawData = null
        }
        if (n) {
            for (c = 0, e = n.length; c < e; c++) {
                k = n[c];
                if (b) {
                    j[k[b]] = k
                }
            }
        }
        return b ? j : k
    },
    setSummaryData: function (c, d, b, e) {
        var a = this.summaryData;
        if (e) {
            if (!a[e]) {
                a[e] = {}
            }
            a[e][d] = b
        } else {
            a[d] = b
        }
    },
    destroy: function () {
        Ext.destroy(this.readerListeners);
        this.readerRawData = this.summaryRows = null;
        Ext.grid.feature.Feature.prototype.destroy.call(this)
    }
}, 0, 0, 0, 0, ["feature.abstractsummary"], 0, [Ext.grid.feature, "AbstractSummary"], 0));
(Ext.cmd.derive("Ext.grid.feature.GroupStore", Ext.util.Observable, {
    isStore: true,
    defaultViewSize: 100,
    isFeatureStore: true,
    badGrouperKey: "[object Object]",
    constructor: function (b, a) {
        Ext.util.Observable.prototype.constructor.call(this);
        this.groupingFeature = b;
        this.bindStore(a)
    },
    bindStore: function (a) {
        var b = this;
        if (!a || b.store !== a) {
            Ext.destroy(b.storeListeners);
            b.store = null
        }
        if (a) {
            b.storeListeners = a.on({
                groupchange: b.onGroupChange,
                remove: b.onRemove,
                add: b.onAdd,
                idchanged: b.onIdChanged,
                update: b.onUpdate,
                refresh: b.onRefresh,
                clear: b.onClear,
                scope: b,
                destroyable: true
            });
            b.store = a;
            b.processStore(a)
        }
    },
    processStore: function (g) {
        var x = this, o = x.groupingFeature, s = o.startCollapsed, z = x.data, a = Ext.Array, d = a.indexOf,
            y = a.splice, u = g.getGroups(), e = u ? u.length : 0, w = g.getGroupField(),
            k = u && a.unique(Ext.Object.getValues(u.itemGroupKeys)), c = false, v = o.getCache(), t, b, q, r, j, h, m,
            p, A, n, l;
        o.invalidateCache();
        b = o.getCache();
        if (z) {
            z.clear()
        } else {
            z = x.data = new Ext.util.Collection({
                rootProperty: "data",
                extraKeys: {byInternalId: {property: "internalId", rootProperty: ""}}
            })
        }
        if (g.getCount()) {
            o.startCollapsed = false;
            if (e > 0) {
                l = g.getModel();
                for (q = 0; q < e; q++) {
                    h = u.getAt(q);
                    A = h.getGroupKey();
                    if (x.badGrouperKey === A && (j = o.getGrouper(w))) {
                        o.startCollapsed = s;
                        g.group(j);
                        return
                    }
                    t = b[A] = v[A] || o.getMetaGroup(A);
                    y(k, d(k, A), 1);
                    c = t.isCollapsed = s || t.isCollapsed;
                    if (c) {
                        n = {};
                        n[w] = A;
                        t.placeholder = p = new l(n);
                        p.isNonData = p.isCollapsedPlaceholder = true;
                        p.group = h;
                        z.add(p)
                    } else {
                        z.insert(x.data.length, h.items)
                    }
                }
                if (k.length) {
                    for (q = 0, r = k.length; q < r; q++) {
                        m = k[q];
                        b[m] = v[m]
                    }
                }
                v = null
            } else {
                z.add(g.getRange())
            }
        }
    },
    isCollapsed: function (a) {
        return this.groupingFeature.getCache()[a].isCollapsed
    },
    isLoading: function () {
        return false
    },
    getData: function () {
        return this.data
    },
    getCount: function () {
        return this.data.getCount()
    },
    getTotalCount: function () {
        return this.data.getCount()
    },
    rangeCached: function (b, a) {
        return a < this.getCount()
    },
    getRange: function (d, b, c) {
        var a = this.data.getRange(d, Ext.isNumber(b) ? b + 1 : b);
        if (c && c.callback) {
            c.callback.call(c.scope || this, a, d, b, c)
        }
        return a
    },
    getAt: function (a) {
        return this.data.getAt(a)
    },
    getById: function (a) {
        return this.store.getById(a)
    },
    getByInternalId: function (a) {
        return this.store.getByInternalId(a) || this.data.byInternalId.get(a)
    },
    expandGroup: function (g) {
        var d = this, e = d.groupingFeature, b, h, c, a;
        if (typeof g === "string") {
            g = e.getGroup(g)
        }
        if (g) {
            a = g.items;
            b = e.getMetaGroup(g);
            h = b.placeholder
        }
        if (a.length && (c = d.data.indexOf(h)) !== -1) {
            b.isCollapsed = false;
            d.isExpandingOrCollapsing = 1;
            d.data.removeAt(c);
            d.data.insert(c, g.items);
            d.fireEvent("replace", d, c, [h], g.items);
            d.fireEvent("groupexpand", d, g);
            d.isExpandingOrCollapsing = 0
        }
    },
    collapseGroup: function (g) {
        var d = this, e = d.groupingFeature, c, h, a, b;
        if (typeof g === "string") {
            g = e.getGroup(g)
        }
        if (g) {
            b = g.items
        }
        if (b && (a = b.length) && (c = d.data.indexOf(b[0])) !== -1) {
            e.getMetaGroup(g).isCollapsed = true;
            d.isExpandingOrCollapsing = 2;
            d.data.removeAt(c, a);
            d.data.insert(c, h = d.getGroupPlaceholder(g));
            d.fireEvent("replace", d, c, b, [h]);
            d.fireEvent("groupcollapse", d, g);
            d.isExpandingOrCollapsing = 0
        }
    },
    getGroupPlaceholder: function (e) {
        var b = this.groupingFeature.getMetaGroup(e);
        if (!b.placeholder) {
            var a = this.store, h = a.getModel(), d = {}, c = e.getGroupKey(), g;
            d[a.getGroupField()] = c;
            g = b.placeholder = new h(d);
            g.isNonData = g.isCollapsedPlaceholder = true;
            g.group = e
        }
        return b.placeholder
    },
    indexOf: function (a) {
        var b = -1;
        if (!a.isCollapsedPlaceholder) {
            b = this.data.indexOf(a)
        }
        return b
    },
    indexOfPlaceholder: function (a) {
        return this.data.indexOf(a)
    },
    indexOfId: function (a) {
        return this.data.indexOfKey(a)
    },
    indexOfTotal: function (a) {
        return this.store.indexOf(a)
    },
    onRefresh: function (a) {
        this.processStore(this.store);
        this.fireEvent("refresh", this)
    },
    onRemove: function (c, b, d, a) {
        var e = this;
        if (c.isMoving()) {
            return
        }
        e.processStore(e.store);
        e.fireEvent("refresh", e)
    },
    onClear: function (b, a, d) {
        var c = this;
        c.processStore(c.store);
        c.fireEvent("clear", c)
    },
    onAdd: function (b, a, d) {
        var c = this;
        c.processStore(c.store);
        c.fireEvent("replace", c, c.indexOf(a[0]), [], a)
    },
    onIdChanged: function (a, d, c, b) {
        this.data.updateKey(d, c)
    },
    onUpdate: function (k, g, c, e) {
        var j = this, a = j.groupingFeature, l, d, i, b, h;
        if (k.isGrouped()) {
            l = g.group = a.getGroup(g);
            if (l) {
                d = a.getMetaGroup(g);
                if (e && Ext.Array.contains(e, a.getGroupField())) {
                    return j.onRefresh(j.store)
                }
                if (d.isCollapsed) {
                    j.fireEvent("update", j, d.placeholder)
                } else {
                    Ext.suspendLayouts();
                    j.fireEvent("update", j, g, c, e);
                    h = l.items;
                    i = h[0];
                    b = h[h.length - 1];
                    if (i !== g) {
                        i.group = l;
                        j.fireEvent("update", j, i, "edit", e);
                        delete i.group
                    }
                    if (b !== g && b !== i && a.showSummaryRow) {
                        b.group = l;
                        j.fireEvent("update", j, b, "edit", e);
                        delete b.group
                    }
                    Ext.resumeLayouts(true)
                }
            }
            delete g.group
        } else {
            j.fireEvent("update", j, g, c, e)
        }
    },
    onGroupChange: function (b, a) {
        if (!a) {
            this.processStore(b)
        }
        this.fireEvent("groupchange", b, a)
    },
    destroy: function () {
        var a = this;
        a.bindStore(null);
        Ext.destroyMembers(a, "data", "groupingFeature");
        Ext.util.Observable.prototype.destroy.call(this)
    }
}, 1, 0, 0, 0, 0, 0, [Ext.grid.feature, "GroupStore"], 0));
(Ext.cmd.derive("Ext.grid.feature.Grouping", Ext.grid.feature.Feature, {
    eventPrefix: "group",
    eventSelector: ".x-grid-group-hd",
    refreshData: {},
    wrapsItem: true,
    groupHeaderTpl: "{columnName}: {name}",
    depthToIndent: 17,
    collapsedCls: "x-grid-group-collapsed",
    hdCollapsedCls: "x-grid-group-hd-collapsed",
    hdNotCollapsibleCls: "x-grid-group-hd-not-collapsible",
    collapsibleCls: "x-grid-group-hd-collapsible",
    ctCls: "x-group-hd-container",
    groupByText: "Group by this field",
    showGroupsText: "Show in groups",
    hideGroupedHeader: false,
    startCollapsed: false,
    enableGroupingMenu: true,
    enableNoGroups: true,
    collapsible: true,
    groupers: null,
    expandTip: "Click to expand. CTRL key collapses all others",
    collapseTip: "Click to collapse. CTRL/click collapses all others",
    showSummaryRow: false,
    outerTpl: ["{%", "if (!(this.groupingFeature.disabled || values.rows.length === 1 && values.rows[0].isSummary)) {", "this.groupingFeature.setup(values.rows, values.view.rowValues);", "}", "this.nextTpl.applyOut(values, out, parent);", "if (!(this.groupingFeature.disabled || values.rows.length === 1 && values.rows[0].isSummary)) {", "this.groupingFeature.cleanup(values.rows, values.view.rowValues);", "}", "%}", {priority: 200}],
    groupRowTpl: ["{%", "var me = this.groupingFeature,", 'colspan = "colspan=" + values.columns.length;', "if (me.disabled || parent.rows.length === 1 && parent.rows[0].isSummary) {", "values.needsWrap = false;", "} else {", "me.setupRowData(values.record, values.rowIndex, values);", "}", "%}", '<tpl if="needsWrap">', '<tpl if="isFirstRow">', "{% values.view.renderColumnSizer(values, out); %}", '<tr data-boundView="{view.id}" data-recordId="{record.internalId:htmlEncode}" data-recordIndex="{[values.isCollapsedGroup ? -1 : values.recordIndex]}" class="{groupHeaderCls}">', '<td class="{[me.ctCls]}" {[colspan]}>', "{%", 'var groupTitleStyle = (!values.view.lockingPartner || (values.view.ownerCt === values.view.ownerCt.ownerLockable.lockedGrid) || (values.view.lockingPartner.headerCt.getVisibleGridColumns().length === 0)) ? "" : "visibility:hidden";', "%}", '<div data-groupname="{groupName:htmlEncode}" class="', "x-", 'grid-group-hd {collapsibleCls}" nottabindex="0" hidefocus="on" {ariaCellInnerAttr}>', '<div class="', "x-", 'grid-group-title" style="{[groupTitleStyle]}" {ariaGroupTitleAttr}>', '{[values.groupHeaderTpl.apply(values.metaGroupCache, parent) || "&#160;"]}', "</div>", "</div>", "</td>", "</tr>", "</tpl>", '<tpl if="!isCollapsedGroup">', "{%", "values.itemClasses.length = 0;", "this.nextTpl.applyOut(values, out, parent);", "%}", "</tpl>", '<tpl if="summaryRecord">', "{%me.outputSummaryRecord(values.summaryRecord, values, out, parent);%}", "</tpl>", "<tpl else>", "{%this.nextTpl.applyOut(values, out, parent);%}", "</tpl>", {
        priority: 200,
        beginRowSync: function (a) {
            var b = this.groupingFeature;
            a.add("header", b.eventSelector);
            a.add("summary", b.summaryRowSelector)
        },
        syncContent: function (b, i, a) {
            b = Ext.fly(b, "syncDest");
            i = Ext.fly(i, "syncSrc");
            var e = this.groupingFeature, d = b.down(e.eventSelector, true), c = i.down(e.eventSelector, true),
                h = b.down(e.summaryRowSelector, true), g = i.down(e.summaryRowSelector, true);
            if (d && c) {
                Ext.fly(d).syncContent(c)
            }
            if (h && g) {
                if (a) {
                    this.groupingFeature.view.updateColumns(h, g, a)
                } else {
                    Ext.fly(h).syncContent(g)
                }
            }
        }
    }],
    init: function (c) {
        var e = this, a = e.view, b = e.getGridStore(), d, g;
        a.isGrouping = b.isGrouped();
        e.mixins.summary.init.call(e);
        Ext.grid.feature.Feature.prototype.init.call(this, c);
        a.headerCt.on({
            columnhide: e.onColumnHideShow,
            columnshow: e.onColumnHideShow,
            columnmove: e.onColumnMove,
            scope: e
        });
        a.addTpl(Ext.XTemplate.getTpl(e, "outerTpl")).groupingFeature = e;
        a.addRowTpl(Ext.XTemplate.getTpl(e, "groupRowTpl")).groupingFeature = e;
        a.preserveScrollOnRefresh = true;
        if (b.isBufferedStore) {
            e.collapsible = false
        } else {
            d = e.lockingPartner;
            if (d && d.dataSource) {
                e.dataSource = a.dataSource = g = d.dataSource
            } else {
                e.dataSource = a.dataSource = g = new Ext.grid.feature.GroupStore(e, b)
            }
        }
        c = c.ownerLockable || c;
        c.on("beforereconfigure", e.beforeReconfigure, e);
        a.on({afterrender: e.afterViewRender, scope: e, single: true});
        if (g) {
            g.on("groupchange", e.onGroupChange, e)
        } else {
            e.setupStoreListeners(b)
        }
        e.mixins.summary.bindStore.call(e, c, c.getStore())
    },
    getGridStore: function () {
        return this.view.getStore()
    },
    indexOf: function (a) {
        return this.dataSource.indexOf(a)
    },
    indexOfPlaceholder: function (a) {
        return this.dataSource.indexOfPlaceholder(a)
    },
    isInCollapsedGroup: function (b) {
        var e = this, d = e.getGridStore(), a = false, c;
        if (d.isGrouped() && (c = e.getMetaGroup(b))) {
            a = !!(c && c.isCollapsed)
        }
        return a
    },
    createCache: function () {
        var a = this.metaGroupCache = {}, b = this.lockingPartner;
        if (b) {
            b.metaGroupCache = a
        }
        return a
    },
    getCache: function () {
        return this.metaGroupCache || this.createCache()
    },
    invalidateCache: function () {
        var a = this.lockingPartner;
        this.metaGroupCache = null;
        if (a) {
            a.metaGroupCache = null
        }
    },
    vetoEvent: function (a, c, d, b) {
        if (b.type !== "mouseover" && b.type !== "mouseout" && b.type !== "mouseenter" && b.type !== "mouseleave" && b.getTarget(this.eventSelector)) {
            return false
        }
    },
    enable: function () {
        var c = this, a = c.view, b = c.getGridStore(), e = c.hideGroupedHeader && c.getGroupedHeader(), d;
        a.isGrouping = true;
        if (a.lockingPartner) {
            a.lockingPartner.isGrouping = true
        }
        Ext.grid.feature.Feature.prototype.enable.call(this);
        if (c.lastGrouper) {
            b.group(c.lastGrouper);
            c.lastGrouper = null
        }
        if (e) {
            e.hide()
        }
        d = c.view.headerCt.getMenu().down("#groupToggleMenuItem");
        if (d) {
            d.setChecked(true, true)
        }
    },
    disable: function () {
        var c = this, a = c.view, b = c.getGridStore(), g = c.hideGroupedHeader && c.getGroupedHeader(),
            e = b.getGrouper(), d;
        a.isGrouping = false;
        if (a.lockingPartner) {
            a.lockingPartner.isGrouping = false
        }
        Ext.grid.feature.Feature.prototype.disable.call(this);
        if (e) {
            c.lastGrouper = e;
            b.clearGrouping()
        }
        if (g) {
            g.show()
        }
        d = c.view.headerCt.getMenu().down("#groupToggleMenuItem");
        if (d) {
            d.setChecked(false, true);
            d.disable()
        }
    },
    afterViewRender: function () {
        var b = this, a = b.view;
        a.on({scope: b, groupclick: b.onGroupClick});
        if (b.enableGroupingMenu) {
            b.injectGroupingMenu()
        }
        b.pruneGroupedHeader();
        b.lastGrouper = b.getGridStore().getGrouper();
        if (b.disabled) {
            b.disable()
        }
    },
    injectGroupingMenu: function () {
        var a = this, b = a.view.headerCt;
        b.showMenuBy = a.showMenuBy;
        b.getMenuItems = a.getMenuItems()
    },
    onColumnHideShow: function (d, h) {
        var l = this, m = l.view, b = m.headerCt, a = b.getMenu(), c = a.activeHeader, n = a.down("#groupMenuItem"), g,
            o = l.grid.getVisibleColumnManager().getColumns().length, k, j, e;
        if (c && n) {
            g = c.groupable === false || !c.dataIndex || l.view.headerCt.getVisibleGridColumns().length < 2 ? "disable" : "enable";
            n[g]()
        }
        if (m.rendered && o) {
            k = m.el.query("." + l.ctCls);
            for (e = 0, j = k.length; e < j; ++e) {
                k[e].colSpan = o
            }
        }
    },
    onColumnMove: function () {
        var e = this, b = e.view, i, a, g, h, d, c;
        if (b.getStore().isGrouped()) {
            a = e.getCache().map;
            Ext.suspendLayouts();
            for (i in a) {
                g = e.getGroup(i);
                h = g.first();
                d = g.last();
                c = e.getMetaGroup(i);
                if (c.isCollapsed) {
                    h = d = e.dataSource.getGroupPlaceholder(i)
                }
                b.refreshNode(h);
                if (e.showSummaryRow && d !== h) {
                    b.refreshNode(d)
                }
            }
            Ext.resumeLayouts(true)
        }
    },
    showMenuBy: function (i, j, c) {
        var e = this, a = e.getMenu(), g = a.down("#groupMenuItem"),
            d = c.groupable === false || !c.dataIndex || e.view.headerCt.getVisibleGridColumns().length < 2 ? "disable" : "enable",
            b = a.down("#groupToggleMenuItem"), h = e.grid.getStore().isGrouped();
        g[d]();
        if (b) {
            b.setChecked(h, true);
            b[h ? "enable" : "disable"]()
        }
        Ext.grid.header.Container.prototype.showMenuBy.apply(e, arguments)
    },
    getMenuItems: function () {
        var g = this, c = g.groupByText, e = g.disabled || !g.getGroupField(), a = g.showGroupsText,
            d = g.enableNoGroups, b = g.view.headerCt.getMenuItems;
        return function () {
            var h = b.call(this);
            h.push("-", {
                iconCls: "x-group-by-icon",
                itemId: "groupMenuItem",
                text: c,
                handler: g.onGroupMenuItemClick,
                scope: g
            });
            if (d) {
                h.push({
                    itemId: "groupToggleMenuItem",
                    text: a,
                    checked: !e,
                    checkHandler: g.onGroupToggleMenuItemClick,
                    scope: g
                })
            }
            return h
        }
    },
    onGroupMenuItemClick: function (c, g) {
        var d = this, h = c.parentMenu, i = h.activeHeader, a = d.view, b = d.getGridStore();
        if (d.disabled) {
            d.lastGrouper = null;
            d.block();
            d.enable();
            d.unblock()
        }
        a.isGrouping = true;
        b.group(d.getGrouper(i.dataIndex) || i.dataIndex);
        d.pruneGroupedHeader()
    },
    block: function (a) {
        var b = this;
        b.blockRefresh = b.view.blockRefresh = true;
        if (b.lockingPartner && !a) {
            b.lockingPartner.block(true)
        }
    },
    unblock: function (a) {
        var b = this;
        b.blockRefresh = b.view.blockRefresh = false;
        if (b.lockingPartner && !a) {
            b.lockingPartner.unblock(true)
        }
    },
    onGroupToggleMenuItemClick: function (a, b) {
        this[b ? "enable" : "disable"]()
    },
    pruneGroupedHeader: function () {
        var a = this, b = a.getGroupedHeader();
        if (a.hideGroupedHeader && b) {
            Ext.suspendLayouts();
            if (a.prunedHeader && a.prunedHeader !== b) {
                a.prunedHeader.show()
            }
            a.prunedHeader = b;
            if (b.rendered) {
                b.hide()
            }
            Ext.resumeLayouts(true)
        }
    },
    getHeaderNode: function (g) {
        var d = this.view.getEl(), b, c, a, e;
        if (d) {
            g = Ext.htmlEncode(g);
            b = d.query(this.eventSelector);
            for (c = 0, a = b.length; c < a; ++c) {
                e = b[c];
                if (e.getAttribute("data-groupName") === g) {
                    return e
                }
            }
        }
    },
    getGroup: function (b) {
        var a = this.getGridStore(), c = b, d;
        if (a.isGrouped()) {
            if (b.isModel) {
                b = b.get(a.getGroupField())
            }
            if (typeof b !== "string") {
                b = a.getGrouper().getGroupString(c)
            }
            d = a.getGroups().getByKey(b)
        }
        return d
    },
    getGrouper: function (a) {
        var b = this.groupers;
        if (!b) {
            return null
        }
        return Ext.Array.findBy(b, function (c) {
            return c.property === a
        })
    },
    getGroupField: function () {
        return this.getGridStore().getGroupField()
    },
    getMetaGroup: function (d) {
        var a = this.metaGroupCache || this.createCache(), c, b;
        if (d.isModel) {
            d = this.getGroup(d)
        }
        if (d != null) {
            c = (typeof d === "string") ? d : d.getGroupKey();
            b = a[c];
            if (!b) {
                b = a[c] = {
                    isCollapsed: false,
                    lastGroup: null,
                    lastGroupGeneration: null,
                    lastFilterGeneration: null,
                    aggregateRecord: new Ext.data.Model()
                };
                if (!a.map) {
                    a.map = {}
                }
                a.map[c] = true
            }
        }
        return b
    },
    isExpanded: function (a) {
        return !this.getMetaGroup(a).isCollapsed
    },
    expand: function (b, a) {
        this.doCollapseExpand(false, b, a)
    },
    expandAll: function () {
        var c = this, a = c.getCache(), b = c.lockingPartner, d;
        for (d in a) {
            if (a.hasOwnProperty(d)) {
                a[d].isCollapsed = false
            }
        }
        Ext.suspendLayouts();
        c.dataSource.onRefresh();
        Ext.resumeLayouts(true);
        for (d in a) {
            if (a.hasOwnProperty(d)) {
                c.afterCollapseExpand(false, d);
                if (b) {
                    b.afterCollapseExpand(false, d)
                }
            }
        }
    },
    collapse: function (b, a) {
        this.doCollapseExpand(true, b, a)
    },
    isAllCollapsed: function () {
        var b = this, a = b.getCache(), c;
        for (c in a) {
            if (a.hasOwnProperty(c)) {
                if (!a[c].isCollapsed) {
                    return false
                }
            }
        }
        return true
    },
    isAllExpanded: function () {
        var b = this, a = b.getCache(), c;
        for (c in a) {
            if (a.hasOwnProperty(c)) {
                if (a[c].isCollapsed) {
                    return false
                }
            }
        }
        return true
    },
    collapseAll: function () {
        var c = this, a = c.getCache(), d, b = c.lockingPartner;
        for (d in a) {
            if (a.hasOwnProperty(d)) {
                a[d].isCollapsed = true
            }
        }
        Ext.suspendLayouts();
        c.dataSource.onRefresh();
        if (b && !b.isAllCollapsed()) {
            b.collapseAll()
        }
        Ext.resumeLayouts(true);
        for (d in a) {
            if (a.hasOwnProperty(d)) {
                c.afterCollapseExpand(true, d);
                if (b) {
                    b.afterCollapseExpand(true, d)
                }
            }
        }
    },
    doCollapseExpand: function (e, g, a) {
        var c = this, b = c.lockingPartner, d = c.getGroup(g);
        if (c.getMetaGroup(d).isCollapsed !== e) {
            c.isExpandingOrCollapsing = true;
            Ext.suspendLayouts();
            if (e) {
                c.dataSource.collapseGroup(d)
            } else {
                c.dataSource.expandGroup(d)
            }
            Ext.resumeLayouts(true);
            c.afterCollapseExpand(e, g, a);
            if (b) {
                b.afterCollapseExpand(e, g, false)
            }
            c.isExpandingOrCollapsing = false
        }
    },
    afterCollapseExpand: function (d, h, b) {
        var c = this, a = c.view, g = a.bufferedRenderer, e;
        e = c.getHeaderNode(h);
        a.fireEvent(d ? "groupcollapse" : "groupexpand", a, e, h);
        if (b) {
            if (e) {
                a.scrollElIntoView(Ext.fly(e).up(a.getItemSelector()), false, true)
            } else {
                if (g) {
                    g.scrollTo(c.getGroup(h).getAt(0))
                }
            }
        }
    },
    onGroupChange: function (b, a) {
        if (!a) {
            this.view.ownerGrid.getView().refresh()
        } else {
            this.lastGrouper = a
        }
    },
    getMenuItem: function (b) {
        var a = this.view, d = a.headerCt.down("gridcolumn[dataIndex=" + b + "]"), c = a.headerCt.getMenu();
        return d ? c.down("menuitem[headerId=" + d.id + "]") : null
    },
    onGroupKey: function (c, b) {
        var a = this, d = a.getGroupName(b.target);
        if (d) {
            a.onGroupClick(a.view, b.target, d, b)
        }
    },
    onGroupClick: function (i, a, k, d) {
        var h = this, j = h.getCache(), l = j.map, c = !h.isExpanded(k), b;
        if (h.collapsible) {
            if (d.ctrlKey) {
                Ext.suspendLayouts();
                for (b in l) {
                    if (b === k) {
                        if (c) {
                            h.expand(k)
                        }
                    } else {
                        if (!j[b].isCollapsed) {
                            h.doCollapseExpand(true, b, false)
                        }
                    }
                }
                Ext.resumeLayouts(true);
                return
            }
            if (c) {
                h.expand(k)
            } else {
                h.collapse(k)
            }
        }
    },
    setupRowData: function (b, j, m) {
        var t = this, c = m.recordIndex, u = t.refreshData, a = t.getCache(), q = u.header, s = u.groupField,
            g = t.getGridStore(), r = t.view.dataSource, p = r.isBufferedStore, h = b.group,
            d = t.grid.columnManager.getHeaderByDataIndex(s), e = !!(d && d.renderer), o, i, l, n, k;
        m.isCollapsedGroup = false;
        m.summaryRecord = m.groupHeaderCls = null;
        if (u.doGrouping) {
            o = g.getGrouper();
            if (b.isCollapsedPlaceholder) {
                i = h.getGroupKey();
                k = h.items;
                m.isFirstRow = m.isLastRow = true;
                m.groupHeaderCls = t.hdCollapsedCls;
                m.isCollapsedGroup = m.needsWrap = true;
                m.groupName = i;
                m.metaGroupCache = a;
                a.groupField = s;
                a.name = a.renderedGroupValue = e ? d.renderer(h.getAt(0).get(s), {}, b) : i;
                a.groupValue = k[0].get(s);
                a.columnName = q ? q.text : s;
                m.collapsibleCls = t.collapsible ? t.collapsibleCls : t.hdNotCollapsibleCls;
                a.rows = a.children = k;
                if (t.showSummaryRow) {
                    m.summaryRecord = u.summaryData[i]
                }
                return
            }
            i = o.getGroupString(b);
            if (h) {
                k = h.items;
                m.isFirstRow = b === k[0];
                m.isLastRow = b === k[k.length - 1]
            } else {
                m.isFirstRow = c === 0;
                if (!m.isFirstRow) {
                    l = g.getAt(c - 1);
                    if (l) {
                        m.isFirstRow = !l.isEqual(o.getGroupString(l), i)
                    }
                }
                m.isLastRow = c === (p ? g.getTotalCount() : g.getCount()) - 1;
                if (!m.isLastRow) {
                    n = g.getAt(c + 1);
                    if (n) {
                        m.isLastRow = !n.isEqual(o.getGroupString(n), i)
                    }
                }
            }
            if (m.isFirstRow) {
                a.groupField = s;
                a.name = a.renderedGroupValue = e ? d.renderer(b.get(s), {}, b) : i;
                a.groupValue = b.get(s);
                a.columnName = q ? q.text : s;
                m.collapsibleCls = t.collapsible ? t.collapsibleCls : t.hdNotCollapsibleCls;
                m.groupName = i;
                if (!t.isExpanded(i)) {
                    m.itemClasses.push(t.hdCollapsedCls);
                    m.isCollapsedGroup = true
                }
                if (p) {
                    a.rows = a.children = []
                } else {
                    a.rows = a.children = t.getRecordGroup(b).items
                }
                m.metaGroupCache = a
            }
            if (m.isLastRow) {
                if (t.showSummaryRow) {
                    m.summaryRecord = u.summaryData[i];
                    m.itemClasses.push("x-grid-group-last")
                }
            }
            m.needsWrap = (m.isFirstRow || m.summaryRecord)
        }
    },
    setup: function (e, g) {
        var c = this, d = c.refreshData, a = g.view, b = a.isGrouping = !c.disabled && c.getGridStore().isGrouped(),
            h = a.bufferedRenderer;
        c.skippedRows = 0;
        if (h) {
            h.variableRowHeight = a.bufferedRenderer.variableRowHeight || b
        }
        d.groupField = c.getGroupField();
        d.header = c.getGroupedHeader(d.groupField);
        d.doGrouping = b;
        g.groupHeaderTpl = Ext.XTemplate.getTpl(c, "groupHeaderTpl");
        if (b && c.showSummaryRow) {
            d.summaryData = c.generateSummaryData()
        }
    },
    cleanup: function (b, c) {
        var a = this.refreshData;
        c.metaGroupCache = c.groupHeaderTpl = c.isFirstRow = null;
        a.groupField = a.header = a.summaryData = null
    },
    getAggregateRecord: function (a, b) {
        var c;
        if (b === true || !a.aggregateRecord) {
            c = new Ext.data.Model();
            a.aggregateRecord = c;
            c.isNonData = c.isSummary = true
        }
        return a.aggregateRecord
    },
    generateSummaryData: function () {
        var o = this, r = o.getGridStore(), c = r.getFilters(), d = r.getGroups().items, l = r.getProxy().getReader(),
            a = o.getGroupField(), n = o.lockingPartner, p = o.updateNext, j = {}, e = o.view.ownerCt, h, m, s, g, k, b,
            q;
        if (o.remoteRoot) {
            q = o.mixins.summary.generateSummaryData.call(o, a);
            b = !!q
        }
        for (h = 0, m = d.length; h < m; ++h) {
            s = d[h];
            g = o.getMetaGroup(s);
            if (p || b || r.updating || o.didGroupChange(s, g, c)) {
                k = o.populateRecord(s, g, q);
                if (!n || (e === e.ownerLockable.normalGrid)) {
                    g.lastGroup = s;
                    g.lastGroupGeneration = s.generation;
                    g.lastFilterGeneration = c.generation
                }
            } else {
                k = o.getAggregateRecord(g)
            }
            j[s.getGroupKey()] = k
        }
        o.updateNext = false;
        return j
    },
    getGroupName: function (b) {
        var d = this, a = d.view, c = d.eventSelector, g, e;
        g = Ext.fly(b).findParent(c);
        if (!g) {
            e = Ext.fly(b).findParent(a.itemSelector);
            if (e) {
                g = e.down(c, true)
            }
        }
        if (g) {
            return Ext.htmlDecode(g.getAttribute("data-groupname"))
        }
    },
    getRecordGroup: function (a) {
        var c = this.getGridStore(), b = c.getGrouper();
        if (b) {
            return c.getGroups().getByKey(b.getGroupString(a))
        }
    },
    getGroupedHeader: function (b) {
        var d = this, e = d.view.headerCt, c = d.lockingPartner, a, g;
        b = b || d.getGroupField();
        if (b) {
            a = "[dataIndex=" + b + "]";
            g = e.down(a);
            if (!g && c) {
                g = c.view.headerCt.down(a)
            }
        }
        return g || null
    },
    getFireEventArgs: function (b, a, d, c) {
        return [b, a, d, this.getGroupName(d), c]
    },
    destroy: function () {
        var a = this, b = a.dataSource;
        a.storeListeners = Ext.destroy(a.storeListeners);
        a.view = a.prunedHeader = a.grid = a.dataSource = a.groupers = null;
        a.invalidateCache();
        Ext.grid.feature.Feature.prototype.destroy.call(this);
        if (b) {
            b.bindStore(null);
            Ext.destroy(b)
        }
    },
    beforeReconfigure: function (c, j, d, a, e) {
        var h = this, i = h.view, b = h.dataSource, g;
        if (j && j !== a) {
            g = j.isBufferedStore;
            if (!b) {
                Ext.destroy(h.storeListeners);
                h.setupStoreListeners(j)
            }
            if (g !== a.isBufferedStore) {
                Ext.raise("Cannot reconfigure grouping switching between buffered and non-buffered stores")
            }
            i.isGrouping = !!j.getGrouper();
            b.bindStore(j)
        }
    },
    populateRecord: function (p, e, n) {
        var k = this, l = k.grid.ownerLockable ? k.grid.ownerLockable.view : k.view, o = k.getGridStore(),
            h = k.getAggregateRecord(e), d = l.headerCt.getGridColumns(), j = d.length, r = p.getGroupKey(), c, m, g, b,
            q, a;
        h.beginEdit();
        if (n) {
            c = n[r];
            for (m in c) {
                if (c.hasOwnProperty(m)) {
                    if (m !== h.idProperty) {
                        h.set(m, c[m])
                    }
                }
            }
        }
        for (g = 0; g < j; ++g) {
            b = d[g];
            q = b.dataIndex || b.getItemId();
            if (!n) {
                a = k.getSummary(o, b.summaryType, q, p);
                h.set(q, a)
            } else {
                a = h.get(b.dataIndex)
            }
            k.setSummaryData(h, b.getItemId(), a, r)
        }
        h.ownerGroup = r;
        h.endEdit(true);
        h.commit();
        return h
    },
    privates: {
        didGroupChange: function (d, a, c) {
            var b = true;
            if (d === a.lastGroup) {
                b = a.lastGroupGeneration !== d.generation || a.lastFilterGeneration !== c.generation
            }
            return b
        }, setupStoreListeners: function (a) {
            var b = this;
            b.storeListeners = a.on({groupchange: b.onGroupChange, scope: b, destroyable: true})
        }
    }
}, 0, 0, 0, 0, ["feature.grouping"], [["summary", Ext.grid.feature.AbstractSummary]], [Ext.grid.feature, "Grouping"], 0));
(Ext.cmd.derive("Ext.grid.feature.GroupingSummary", Ext.grid.feature.Grouping, {
    showSummaryRow: true,
    vetoEvent: function (b, d, g, c) {
        var a = Ext.grid.feature.Grouping.prototype.vetoEvent.apply(this, arguments);
        if (a !== false && c.getTarget(this.summaryRowSelector)) {
            a = false
        }
        return a
    }
}, 0, 0, 0, 0, ["feature.groupingsummary"], 0, [Ext.grid.feature, "GroupingSummary"], 0));
(Ext.cmd.derive("Ext.grid.feature.RowBody", Ext.grid.feature.Feature, {
    rowBodyCls: "x-grid-row-body",
    rowBodyHiddenCls: "x-grid-row-body-hidden",
    rowBodyTdSelector: "td.x-grid-cell-rowbody",
    eventPrefix: "rowbody",
    eventSelector: "tr.x-grid-rowbody-tr",
    colSpanDecrement: 0,
    bodyBefore: false,
    outerTpl: {
        fn: function (c, b, d) {
            var a = b.view, e = a.rowValues;
            this.rowBody.setup(b.rows, e);
            this.nextTpl.applyOut(b, c, d);
            this.rowBody.cleanup(b.rows, e)
        }, priority: 100
    },
    extraRowTpl: ["{%", "if(this.rowBody.bodyBefore) {", "values.view.renderColumnSizer(values, out);", "} else {", "this.nextTpl.applyOut(values, out, parent);", "}", "values.view.rowBodyFeature.setupRowData(values.record, values.recordIndex, values);", "%}", '<tr class="x-grid-rowbody-tr {rowBodyCls}" {ariaRowAttr}>', '<td class="x-grid-td x-grid-cell-rowbody" colspan="{rowBodyColspan}" {ariaCellAttr}>', '<div class="x-grid-rowbody {rowBodyDivCls}" {ariaCellInnerAttr}>{rowBody}</div>', "</td>", "</tr>", "{%", "if(this.rowBody.bodyBefore) {", "this.nextTpl.applyOut(values, out, parent);", "}", "%}", {
        priority: 100,
        beginRowSync: function (a) {
            a.add("rowBody", this.owner.eventSelector)
        },
        syncContent: function (c, g, b) {
            var a = this.owner, d = Ext.fly(c).down(a.eventSelector, true), e;
            if (d && (e = Ext.fly(g).down(a.eventSelector, true))) {
                Ext.fly(d).syncContent(e)
            }
        }
    }],
    init: function (b) {
        var c = this, a = c.view = b.getView();
        b.variableRowHeight = a.variableRowHeight = true;
        a.rowBodyFeature = c;
        b.mon(a, {element: "el", click: c.onClick, scope: c});
        a.headerCt.on({columnschanged: c.onColumnsChanged, scope: c});
        a.addTpl(c.outerTpl).rowBody = c;
        a.addRowTpl(Ext.XTemplate.getTpl(this, "extraRowTpl")).rowBody = c;
        Ext.grid.feature.Feature.prototype.init.apply(this, arguments)
    },
    onClick: function (c) {
        var b = this, a = c.getTarget(b.eventSelector);
        if (a && Ext.fly(a = (a.previousSibling || a.nextSibling)).is(b.view.rowSelector)) {
            c.target = a;
            b.view.handleEvent(c)
        }
    },
    getSelectedRow: function (a, c) {
        var b = a.getNode(c);
        if (b) {
            return Ext.fly(b).down(this.eventSelector)
        }
        return null
    },
    onColumnsChanged: function (d) {
        var b = this.view.el.query(this.rowBodyTdSelector), e = d.getVisibleGridColumns().length, a = b.length, c;
        for (c = 0; c < a; ++c) {
            b[c].setAttribute("colSpan", e)
        }
    },
    setupRowData: function (a, c, b) {
        if (this.getAdditionalData) {
            Ext.apply(b, this.getAdditionalData(a.data, c, a, b))
        }
    },
    setup: function (a, b) {
        b.rowBodyCls = this.rowBodyCls;
        b.rowBodyColspan = this.view.headerCt.visibleColumnManager.getColumns().length - this.colSpanDecrement
    },
    cleanup: function (a, b) {
        b.rowBodyCls = b.rowBodyColspan = b.rowBody = null
    }
}, 0, 0, 0, 0, ["feature.rowbody"], 0, [Ext.grid.feature, "RowBody"], 0));
(Ext.cmd.derive("Ext.grid.feature.Summary", Ext.grid.feature.AbstractSummary, {
    dock: undefined,
    dockedSummaryCls: "x-docked-summary",
    panelBodyCls: "x-summary-",
    hasFeatureEvent: false,
    fullSummaryTpl: ["{%", "var me = this.summaryFeature,", "    record = me.summaryRecord,", "    view = values.view,", "    bufferedRenderer = view.bufferedRenderer;", "this.nextTpl.applyOut(values, out, parent);", "if (!me.disabled && me.showSummaryRow && view.store.isLast(values.record)) {", "if (bufferedRenderer) {", "    bufferedRenderer.variableRowHeight = true;", "}", "me.outputSummaryRecord((record && record.isModel) ? record : me.createSummaryRecord(view), values, out, parent);", "}", "%}", {
        priority: 300,
        beginRowSync: function (a) {
            a.add("fullSummary", this.summaryFeature.summaryRowSelector)
        },
        syncContent: function (d, h, c) {
            d = Ext.fly(d, "syncDest");
            h = Ext.fly(h, "sycSrc");
            var b = this.owner, a = b.summaryRowSelector, g = d.down(a, true), e = h.down(a, true);
            if (g && e) {
                if (c) {
                    this.summaryFeature.view.updateColumns(g, e, c)
                } else {
                    Ext.fly(g).syncContent(e)
                }
            }
        }
    }],
    init: function (b) {
        var d = this, a = d.view, c = d.dock;
        Ext.grid.feature.AbstractSummary.prototype.init.apply(this, arguments);
        if (c) {
            b.headerCt.on({add: d.onStoreUpdate, afterlayout: d.onStoreUpdate, scope: d});
            b.on({
                beforerender: function () {
                    var e = [d.summaryTableCls];
                    if (a.columnLines) {
                        e[e.length] = a.ownerCt.colLinesCls
                    }
                    d.summaryBar = b.addDocked({
                        childEls: ["innerCt", "item"],
                        renderTpl: ['<div id="{id}-innerCt" data-ref="innerCt" role="presentation">', '<table id="{id}-item" data-ref="item" cellPadding="0" cellSpacing="0" class="' + e.join(" ") + '">', '<tr class="' + d.summaryRowCls + '"></tr>', "</table>", "</div>"],
                        scrollable: {x: false, y: false},
                        hidden: !d.showSummaryRow,
                        itemId: "summaryBar",
                        cls: [d.dockedSummaryCls, d.dockedSummaryCls + "-" + c],
                        xtype: "component",
                        dock: c,
                        weight: 10000000
                    })[0]
                }, afterrender: function () {
                    b.body.addCls(d.panelBodyCls + c);
                    a.on("scroll", d.onViewScroll, d);
                    d.onStoreUpdate()
                }, single: true
            });
            b.headerCt.afterComponentLayout = Ext.Function.createSequence(b.headerCt.afterComponentLayout, function () {
                var e = this.getTableWidth(), g = d.summaryBar.innerCt;
                d.summaryBar.item.setWidth(e);
                if (this.tooNarrow) {
                    e += Ext.getScrollbarSize().width
                }
                g.setWidth(e)
            })
        } else {
            if (b.bufferedRenderer) {
                d.wrapsItem = true;
                a.addRowTpl(Ext.XTemplate.getTpl(d, "fullSummaryTpl")).summaryFeature = d;
                a.on("refresh", d.onViewRefresh, d)
            } else {
                d.wrapsItem = false;
                d.view.addFooterFn(d.renderSummaryRow)
            }
        }
        b.ownerGrid.on({beforereconfigure: d.onBeforeReconfigure, columnmove: d.onStoreUpdate, scope: d});
        d.bindStore(b, b.getStore())
    },
    onBeforeReconfigure: function (b, a) {
        this.summaryRecord = null;
        if (a) {
            this.bindStore(b, a)
        }
    },
    bindStore: function (b, a) {
        var c = this;
        Ext.destroy(c.storeListeners);
        c.storeListeners = a.on({scope: c, destroyable: true, update: c.onStoreUpdate, datachanged: c.onStoreUpdate});
        Ext.grid.feature.AbstractSummary.prototype.bindStore.call(this, b, a)
    },
    renderSummaryRow: function (c, d, e) {
        var b = c.view, g = b.findFeature("summary"), a, h;
        if (!g.disabled && g.showSummaryRow) {
            a = g.summaryRecord;
            d.push('<table cellpadding="0" cellspacing="0" class="' + g.summaryItemCls + '" style="table-layout: fixed; width: 100%;">');
            g.outputSummaryRecord((a && a.isModel) ? a : g.createSummaryRecord(b), c, d, e);
            d.push("</table>")
        }
    },
    toggleSummaryRow: function (d, a) {
        var c = this, b = c.summaryBar;
        Ext.grid.feature.AbstractSummary.prototype.toggleSummaryRow.call(this, d, a);
        if (b) {
            b.setVisible(c.showSummaryRow);
            c.onViewScroll()
        }
    },
    getSummaryBar: function () {
        return this.summaryBar
    },
    vetoEvent: function (a, c, d, b) {
        return !b.getTarget(this.summaryRowSelector)
    },
    onViewScroll: function () {
        this.summaryBar.setScrollX(this.view.getScrollX())
    },
    onViewRefresh: function (b) {
        var c = this, a, d;
        if (!c.disabled && c.showSummaryRow && !b.all.getCount()) {
            a = c.createSummaryRecord(b);
            d = Ext.fly(b.getNodeContainer()).createChild({
                tag: "table",
                cellpadding: 0,
                cellspacing: 0,
                cls: c.summaryItemCls,
                style: "table-layout: fixed; width: 100%"
            }, false, true);
            d.appendChild(Ext.fly(b.createRowElement(a, -1)).down(c.summaryRowSelector, true))
        }
    },
    createSummaryRecord: function (j) {
        var h = this, d = j.headerCt.getVisibleGridColumns(), a = h.remoteRoot, g = h.summaryRecord, l = d.length, e, c,
            k, b, m;
        if (!g) {
            m = {id: j.id + "-summary-record"};
            g = h.summaryRecord = new Ext.data.Model(m)
        }
        g.beginEdit();
        if (a) {
            b = h.generateSummaryData();
            if (b) {
                g.set(b)
            }
        } else {
            for (e = 0; e < l; e++) {
                c = d[e];
                k = c.dataIndex || c.getItemId();
                b = h.getSummary(j.store, c.summaryType, k);
                g.set(k, b);
                h.setSummaryData(g, c.getItemId(), b)
            }
        }
        g.endEdit(true);
        g.commit(true);
        g.isSummary = true;
        return g
    },
    onStoreUpdate: function () {
        var h = this, c = h.view, a = h.summaryRowSelector, g = h.dock, b, e, d, i;
        if (!c.rendered) {
            return
        }
        b = h.createSummaryRecord(c);
        e = Ext.fly(c.createRowElement(b, -1)).down(a, true);
        if (!e) {
            return
        }
        if (g) {
            i = h.summaryBar.item.dom.firstChild;
            d = i.firstChild
        } else {
            d = h.view.el.down(a, true);
            i = d ? d.parentNode : null
        }
        if (i) {
            i.insertBefore(e, d);
            i.removeChild(d)
        }
        if (g) {
            h.onColumnHeaderLayout()
        }
    },
    onColumnHeaderLayout: function () {
        var b = this.view, d = b.headerCt.getVisibleGridColumns(), g, a = d.length, c, h = this.summaryBar.el, e;
        for (c = 0; c < a; c++) {
            g = d[c];
            e = h.down(b.getCellSelector(g), true);
            if (e) {
                Ext.fly(e).setWidth(g.width || (g.lastBox ? g.lastBox.width : 100))
            }
        }
    },
    destroy: function () {
        var a = this;
        a.summaryRecord = a.storeListeners = Ext.destroy(a.storeListeners);
        Ext.grid.feature.AbstractSummary.prototype.destroy.call(this)
    }
}, 0, 0, 0, 0, ["feature.summary"], 0, [Ext.grid.feature, "Summary"], 0));
(Ext.cmd.derive("Ext.menu.Item", Ext.Component, {
    alternateClassName: "Ext.menu.TextItem",
    isMenuItem: true,
    activated: false,
    activeCls: "x-menu-item-active",
    clickHideDelay: 0,
    destroyMenu: true,
    disabledCls: "x-menu-item-disabled",
    hideOnClick: true,
    menuAlign: "tl-tr?",
    menuExpandDelay: 200,
    menuHideDelay: 200,
    tooltipType: "qtip",
    focusable: true,
    ariaRole: "menuitem",
    ariaEl: "itemEl",
    baseCls: "x-menu-item",
    arrowCls: "x-menu-item-arrow",
    baseIconCls: "x-menu-item-icon",
    textCls: "x-menu-item-text",
    indentCls: "x-menu-item-indent",
    indentNoSeparatorCls: "x-menu-item-indent-no-separator",
    indentRightIconCls: "x-menu-item-indent-right-icon",
    indentRightArrowCls: "x-menu-item-indent-right-arrow",
    linkCls: "x-menu-item-link",
    linkHrefCls: "x-menu-item-link-href",
    childEls: ["itemEl", "iconEl", "textEl", "arrowEl"],
    renderTpl: '<tpl if="plain">{text}<tpl else><a id="{id}-itemEl" data-ref="itemEl" class="{linkCls}<tpl if="hasHref"> {linkHrefCls}</tpl>{childElCls}" href="{href}" <tpl if="hrefTarget"> target="{hrefTarget}"</tpl> hidefocus="true" unselectable="on"<tpl if="tabIndex != null"> tabindex="{tabIndex}"</tpl><tpl foreach="ariaAttributes"> {$}="{.}"</tpl>><span id="{id}-textEl" data-ref="textEl" class="{textCls} {textCls}-{ui} {indentCls}{childElCls}" unselectable="on">{text}</span><tpl if="hasIcon"><div role="presentation" id="{id}-iconEl" data-ref="iconEl" class="{baseIconCls}-{ui} {baseIconCls}{[values.rightIcon ? "-right" : ""]} {iconCls}{childElCls} {glyphCls}" style="<tpl if="icon">background-image:url({icon});</tpl><tpl if="glyph && glyphFontFamily">font-family:{glyphFontFamily};</tpl>"><tpl if="glyph">&#{glyph};</tpl></div></tpl><tpl if="showCheckbox"><div role="presentation" id="{id}-checkEl" data-ref="checkEl" class="{baseIconCls}-{ui} {baseIconCls}{[(values.hasIcon && !values.rightIcon) ? "-right" : ""]} {groupCls} {checkboxCls}{childElCls}"></div></tpl><tpl if="hasMenu"><div role="presentation" id="{id}-arrowEl" data-ref="arrowEl" class="{arrowCls} {arrowCls}-{ui}{childElCls}"></div></tpl></a></tpl>',
    maskOnDisable: false,
    iconAlign: "left",
    initComponent: function () {
        var b = this, a = b.cls ? [b.cls] : [], c;
        if (b.hasOwnProperty("canActivate")) {
            b.focusable = b.canActivate
        }
        if (b.plain) {
            a.push("x-menu-item-plain")
        }
        if (a.length) {
            b.cls = a.join(" ")
        }
        if (b.menu) {
            c = b.menu;
            b.menu = null;
            b.setMenu(c)
        }
        Ext.Component.prototype.initComponent.apply(this, arguments)
    },
    canFocus: function () {
        var a = this;
        return a.focusable && a.rendered && a.canActivate !== false && !a.destroying && !a.destroyed && a.isVisible(true)
    },
    onFocus: function (b) {
        var a = this;
        Ext.Component.prototype.onFocus.call(this, b);
        if (!a.disabled) {
            if (!a.plain) {
                a.addCls(a.activeCls)
            }
            a.activated = true;
            if (a.hasListeners.activate) {
                a.fireEvent("activate", a)
            }
        }
    },
    onFocusLeave: function (b) {
        var a = this;
        Ext.Component.prototype.onFocusLeave.call(this, b);
        if (a.activated) {
            if (!a.plain) {
                a.removeCls(a.activeCls)
            }
            a.doHideMenu();
            a.activated = false;
            if (a.hasListeners.deactivate) {
                a.fireEvent("deactivate", a)
            }
        }
    },
    doHideMenu: function () {
        var a = this.menu;
        this.cancelDeferExpand();
        if (a && a.isVisible()) {
            a.hide()
        }
    },
    deferHideParentMenus: function () {
        var a = this.getRefOwner();
        if (a.floating) {
            a.bubble(function (b) {
                if (!b.floating && !b.isMenuItem) {
                    return false
                }
                if (b.isMenu) {
                    a = b
                }
            });
            a.hide()
        }
    },
    expandMenu: function (c, a) {
        var b = this;
        if (b.activated && b.menu) {
            b.hideOnClick = false;
            b.cancelDeferHide();
            a = a == null ? b.menuExpandDelay : a;
            if (a === 0) {
                b.doExpandMenu(c)
            } else {
                b.cancelDeferExpand();
                b.expandMenuTimer = Ext.defer(b.doExpandMenu, a, b, [c])
            }
        }
    },
    doExpandMenu: function (a) {
        var b = this, c = b.menu;
        if (!c.isVisible()) {
            b.parentMenu.activeChild = c;
            c.ownerCmp = b;
            c.parentMenu = b.parentMenu;
            c.constrainTo = document.body;
            c.autoFocus = !a || !a.pointerType;
            c.showBy(b, b.menuAlign)
        }
    },
    getRefItems: function (a) {
        var c = this.menu, b;
        if (c) {
            b = c.getRefItems(a);
            b.unshift(c)
        }
        return b || []
    },
    getValue: function () {
        return this.value
    },
    hideMenu: function (a) {
        var b = this;
        if (b.menu) {
            b.cancelDeferExpand();
            b.hideMenuTimer = Ext.defer(b.doHideMenu, Ext.isNumber(a) ? a : b.menuHideDelay, b)
        }
    },
    onClick: function (g) {
        var d = this, c = d.clickHideDelay, h = g.browserEvent, b, a;
        if (!d.href || d.disabled) {
            g.stopEvent();
            if (d.disabled) {
                return false
            }
        }
        if (d.disabled || d.handlingClick) {
            return
        }
        if (d.hideOnClick) {
            if (!c) {
                d.deferHideParentMenus()
            } else {
                d.deferHideParentMenusTimer = Ext.defer(d.deferHideParentMenus, c, d)
            }
        }
        b = d.fireEvent("click", d, g);
        if (d.destroyed) {
            return
        }
        if (b !== false && d.handler) {
            Ext.callback(d.handler, d.scope, [d, g], 0, d)
        }
        if (Ext.isIE9m) {
            a = h.returnValue === false ? true : false
        } else {
            a = !!h.defaultPrevented
        }
        if (d.href && g.type !== "click" && !a) {
            d.handlingClick = true;
            d.itemEl.dom.click();
            d.handlingClick = false
        }
        if (!d.hideOnClick) {
            d.focus()
        }
        return b
    },
    onRemoved: function () {
        var a = this;
        if (a.activated && a.parentMenu.activeItem === a) {
            a.parentMenu.deactivateActiveItem()
        }
        Ext.Component.prototype.onRemoved.apply(this, arguments);
        a.parentMenu = a.ownerCmp = null
    },
    beforeDestroy: function () {
        var a = this;
        if (a.rendered) {
            a.clearTip()
        }
        Ext.Component.prototype.beforeDestroy.call(this)
    },
    onDestroy: function () {
        var a = this;
        a.cancelDeferExpand();
        a.cancelDeferHide();
        clearTimeout(a.deferHideParentMenusTimer);
        a.setMenu(null);
        Ext.Component.prototype.onDestroy.apply(this, arguments)
    },
    beforeRender: function () {
        var j = this, k = j.glyph, i = Ext._glyphFontFamily, e = !!(j.icon || j.iconCls || k), l = !!j.menu,
            g = ((j.iconAlign === "right") && !l), c = j.isMenuCheckItem, a = [], d = j.ownerCt, h = d.plain, b;
        if (j.plain) {
            j.ariaEl = "el"
        }
        Ext.Component.prototype.beforeRender.call(this);
        if (e) {
            if (l && j.showCheckbox) {
                e = false
            }
        }
        if (typeof k === "string") {
            b = k.split("@");
            k = b[0];
            i = b[1]
        }
        if (!h || (e && !g) || c) {
            if (d.showSeparator && !h) {
                a.push(j.indentCls)
            } else {
                a.push(j.indentNoSeparatorCls)
            }
        }
        if (l) {
            a.push(j.indentRightArrowCls)
        } else {
            if (e && (g || c)) {
                a.push(j.indentRightIconCls)
            }
        }
        Ext.applyIf(j.renderData, {
            hasHref: !!j.href,
            href: j.href || "#",
            hrefTarget: j.hrefTarget,
            icon: j.icon,
            iconCls: j.iconCls,
            glyph: k,
            glyphCls: k ? "x-menu-item-glyph" : undefined,
            glyphFontFamily: i,
            hasIcon: e,
            hasMenu: l,
            indent: !h || e || c,
            isCheckItem: c,
            rightIcon: g,
            plain: j.plain,
            text: j.text,
            arrowCls: j.arrowCls,
            baseIconCls: j.baseIconCls,
            textCls: j.textCls,
            indentCls: a.join(" "),
            linkCls: j.linkCls,
            linkHrefCls: j.linkHrefCls,
            groupCls: j.group ? j.groupCls : "",
            tabIndex: j.tabIndex
        })
    },
    onRender: function () {
        var a = this;
        Ext.Component.prototype.onRender.apply(this, arguments);
        if (a.tooltip) {
            a.setTooltip(a.tooltip, true)
        }
    },
    getMenu: function () {
        return this.menu || null
    },
    setMenu: function (i, h) {
        var g = this, c = g.menu, b = g.arrowEl, a = g.ariaEl.dom, e, d;
        if (c) {
            c.ownerCmp = c.parentMenu = null;
            if (h === true || (h !== false && g.destroyMenu)) {
                Ext.destroy(c)
            }
            if (a) {
                a.removeAttribute("aria-haspopup");
                a.removeAttribute("aria-owns")
            } else {
                e = (g.ariaRenderAttributes || (g.ariaRenderAttributes = {}));
                delete e["aria-haspopup"];
                delete e["aria-owns"]
            }
        }
        if (i) {
            d = i.isMenu;
            i = g.menu = Ext.menu.Manager.get(i, {ownerCmp: g, focusOnToFront: false});
            i.setOwnerCmp(g, d);
            if (a) {
                a.setAttribute("aria-haspopup", true);
                a.setAttribute("aria-owns", i.id)
            } else {
                e = (g.ariaRenderAttributes || (g.ariaRenderAttributes = {}));
                e["aria-haspopup"] = true;
                e["aria-owns"] = i.id
            }
        } else {
            i = g.menu = null
        }
        if (i && g.rendered && !g.destroying && b) {
            b[i ? "addCls" : "removeCls"](g.arrowCls)
        }
    },
    setHandler: function (b, a) {
        this.handler = b || null;
        this.scope = a
    },
    setIcon: function (b) {
        var a = this.iconEl, c = this.icon;
        if (a) {
            a.src = b || Ext.BLANK_IMAGE_URL
        }
        this.icon = b;
        this.fireEvent("iconchange", this, c, b)
    },
    setIconCls: function (b) {
        var d = this, a = d.iconEl, c = d.iconCls;
        if (a) {
            if (d.iconCls) {
                a.removeCls(d.iconCls)
            }
            if (b) {
                a.addCls(b)
            }
        }
        d.iconCls = b;
        d.fireEvent("iconchange", d, c, b)
    },
    setText: function (d) {
        var c = this, b = c.textEl || c.el, a = c.text;
        c.text = d;
        if (c.rendered) {
            b.setHtml(d || "");
            c.updateLayout()
        }
        c.fireEvent("textchange", c, a, d)
    },
    getTipAttr: function () {
        return this.tooltipType === "qtip" ? "data-qtip" : "title"
    },
    clearTip: function () {
        if (Ext.quickTipsActive && Ext.isObject(this.tooltip)) {
            Ext.tip.QuickTipManager.unregister(this.itemEl)
        }
    },
    setTooltip: function (c, a) {
        var b = this;
        if (b.rendered) {
            if (!a) {
                b.clearTip()
            }
            if (Ext.quickTipsActive && Ext.isObject(c)) {
                Ext.tip.QuickTipManager.register(Ext.apply({target: b.itemEl.id}, c));
                b.tooltip = c
            } else {
                b.itemEl.dom.setAttribute(b.getTipAttr(), c)
            }
        } else {
            b.tooltip = c
        }
        return b
    },
    privates: {
        cancelDeferExpand: function () {
            window.clearTimeout(this.expandMenuTimer)
        }, cancelDeferHide: function () {
            window.clearTimeout(this.hideMenuTimer)
        }, getFocusEl: function () {
            return this.plain ? this.el : this.itemEl
        }
    }
}, 0, ["menuitem"], ["component", "box", "menuitem"], {
    component: true,
    box: true,
    menuitem: true
}, ["widget.menuitem"], [[Ext.mixin.Queryable.prototype.mixinId || Ext.mixin.Queryable.$className, Ext.mixin.Queryable]], [Ext.menu, "Item", Ext.menu, "TextItem"], 0));
(Ext.cmd.derive("Ext.menu.CheckItem", Ext.menu.Item, {
    checkedCls: "x-menu-item-checked",
    uncheckedCls: "x-menu-item-unchecked",
    groupCls: "x-menu-group-icon",
    hideOnClick: false,
    checkChangeDisabled: false,
    submenuText: "{0} submenu",
    ariaRole: "menuitemcheckbox",
    childEls: ["checkEl"],
    showCheckbox: true,
    isMenuCheckItem: true,
    checkboxCls: "x-menu-item-checkbox",
    initComponent: function () {
        var a = this;
        a.checked = !!a.checked;
        Ext.menu.Item.prototype.initComponent.apply(this, arguments);
        if (a.group) {
            Ext.menu.Manager.registerCheckable(a);
            if (a.initialConfig.hideOnClick !== false) {
                a.hideOnClick = true
            }
        }
    },
    beforeRender: function () {
        var b = this, a;
        Ext.menu.Item.prototype.beforeRender.call(this);
        Ext.apply(b.renderData, {checkboxCls: b.checkboxCls, showCheckbox: b.showCheckbox});
        a = (b.ariaRenderAttributes || (b.ariaRenderAttributes = {}));
        a["aria-checked"] = b.menu ? "mixed" : b.checked;
        if (b.menu) {
            a["aria-label"] = Ext.String.formatEncode(b.submenuText, b.text)
        }
    },
    afterRender: function () {
        var a = this;
        Ext.menu.Item.prototype.afterRender.call(this);
        a.checked = !a.checked;
        a.setChecked(!a.checked, true);
        if (a.checkChangeDisabled) {
            a.disableCheckChange()
        }
    },
    disableCheckChange: function () {
        var b = this, a = b.checkEl;
        if (a) {
            a.addCls(b.disabledCls)
        }
        if (Ext.isIE8 && b.rendered) {
            b.el.repaint()
        }
        b.checkChangeDisabled = true
    },
    enableCheckChange: function () {
        var b = this, a = b.checkEl;
        if (a) {
            a.removeCls(b.disabledCls)
        }
        b.checkChangeDisabled = false
    },
    onClick: function (b) {
        var a = this;
        if (!a.disabled && !a.checkChangeDisabled && !(a.checked && a.group)) {
            a.setChecked(!a.checked);
            if (b.type === "keydown" && a.menu) {
                return false
            }
        }
        Ext.menu.Item.prototype.onClick.call(this, b)
    },
    onDestroy: function () {
        Ext.menu.Manager.unregisterCheckable(this);
        Ext.menu.Item.prototype.onDestroy.apply(this, arguments)
    },
    setText: function (c) {
        var b = this, a = b.ariaEl.dom;
        Ext.menu.Item.prototype.setText.call(this, c);
        if (a && b.menu) {
            a.setAttribute("aria-label", Ext.String.formatEncode(b.submenuText, c))
        }
    },
    setChecked: function (e, c) {
        var d = this, g = d.checkedCls, h = d.uncheckedCls, b = d.el, a = d.ariaEl.dom;
        if (d.checked !== e && (c || d.fireEvent("beforecheckchange", d, e) !== false)) {
            if (b) {
                if (e) {
                    b.addCls(g);
                    b.removeCls(h)
                } else {
                    b.addCls(h);
                    b.removeCls(g)
                }
            }
            if (a) {
                a.setAttribute("aria-checked", d.menu ? "mixed" : !!e)
            }
            d.checked = e;
            Ext.menu.Manager.onCheckChange(d, e);
            if (!c) {
                Ext.callback(d.checkHandler, d.scope, [d, e], 0, d);
                d.fireEvent("checkchange", d, e)
            }
        }
    }
}, 0, ["menucheckitem"], ["component", "box", "menuitem", "menucheckitem"], {
    component: true,
    box: true,
    menuitem: true,
    menucheckitem: true
}, ["widget.menucheckitem"], 0, [Ext.menu, "CheckItem"], 0));
(Ext.cmd.derive("Ext.menu.Separator", Ext.menu.Item, {
    focusable: false,
    canActivate: false,
    hideOnClick: false,
    plain: true,
    separatorCls: "x-menu-item-separator",
    text: "&#160;",
    ariaRole: "separator",
    beforeRender: function (a, c) {
        var b = this;
        Ext.menu.Item.prototype.beforeRender.call(this);
        b.addCls(b.separatorCls)
    }
}, 0, ["menuseparator"], ["component", "box", "menuitem", "menuseparator"], {
    component: true,
    box: true,
    menuitem: true,
    menuseparator: true
}, ["widget.menuseparator"], 0, [Ext.menu, "Separator"], 0));
(Ext.cmd.derive("Ext.menu.Menu", Ext.panel.Panel, {
    enableKeyNav: true,
    allowOtherMenus: false,
    ariaRole: "menu",
    floating: true,
    constrain: true,
    hidden: true,
    hideMode: "visibility",
    ignoreParentClicks: false,
    isMenu: true,
    showSeparator: true,
    minWidth: undefined,
    defaultMinWidth: 120,
    defaultAlign: "tl-bl?",
    focusOnToFront: false,
    bringParentToFront: false,
    defaultFocus: ":focusable",
    menuClickBuffer: 0,
    baseCls: "x-menu",
    _iconSeparatorCls: "x-menu-icon-separator",
    _itemCmpCls: "x-menu-item-cmp",
    layout: {type: "vbox", align: "stretchmax", overflowHandler: "Scroller"},
    initComponent: function () {
        var c = this, a = ["x-menu"], d = c.bodyCls ? [c.bodyCls] : [], e = c.floating !== false,
            b = {element: "el", click: c.onClick, mouseover: c.onMouseOver, scope: c};
        if (Ext.supports.Touch) {
            b.pointerdown = c.onMouseOver
        }
        c.on(b);
        c.on({beforeshow: c.onBeforeShow, scope: c});
        if (c.plain) {
            a.push("x-menu-plain")
        }
        c.cls = a.join(" ");
        d.push("x-menu-body", Ext.dom.Element.unselectableCls);
        c.bodyCls = d.join(" ");
        if (e) {
            if (c.minWidth === undefined) {
                c.minWidth = c.defaultMinWidth
            }
        } else {
            c.hidden = !!c.initialConfig.hidden;
            c.constrain = false
        }
        Ext.panel.Panel.prototype.initComponent.apply(this, arguments);
        Ext.override(c.getLayout(), {configureItem: c.configureItem})
    },
    initFloatConstrain: Ext.emptyFn,
    getInherited: function () {
        var a = Ext.panel.Panel.prototype.getInherited.call(this);
        a.hidden = this.hidden;
        return a
    },
    beforeRender: function () {
        var a = this;
        Ext.panel.Panel.prototype.beforeRender.apply(this, arguments);
        if (!a.getSizeModel().width.shrinkWrap) {
            a.layout.align = "stretch"
        }
        if (a.floating) {
            a.ariaRenderAttributes = a.ariaRenderAttributes || {};
            a.ariaRenderAttributes["aria-expanded"] = !!a.autoShow
        }
    },
    onBoxReady: function () {
        var a = this, b = a._iconSeparatorCls;
        a.focusableKeyNav.map.processEvent = function (c) {
            if (c.keyCode === c.ESC) {
                c.target = a.el.dom
            }
            return c
        };
        a.focusableKeyNav.map.addBinding([{key: 27, handler: a.onEscapeKey, scope: a}, {
            key: /[\\w]/,
            handler: a.onShortcutKey,
            scope: a,
            shift: false,
            ctrl: false,
            alt: false
        }]);
        Ext.panel.Panel.prototype.onBoxReady.apply(this, arguments);
        if (a.showSeparator) {
            a.iconSepEl = a.body.insertFirst({role: "presentation", cls: b + " " + b + "-" + a.ui, html: "&#160;"})
        }
        if (Ext.supports.MSPointerEvents || Ext.supports.PointerEvents) {
            a.el.on({scope: a, click: a.preventClick, translate: false})
        }
        a.mouseMonitor = a.el.monitorMouseLeave(100, a.onMouseLeave, a)
    },
    onFocusLeave: function (b) {
        var a = this;
        Ext.panel.Panel.prototype.onFocusLeave.call(this, b);
        a.mixins.focusablecontainer.onFocusLeave.call(a, b);
        if (a.floating) {
            a.hide()
        }
    },
    canActivateItem: function (a) {
        return a && a.isFocusable()
    },
    deactivateActiveItem: function () {
        var a = this, b = a.lastFocusedChild;
        if (b) {
            b.blur()
        }
    },
    getItemFromEvent: function (d) {
        var a = this, c = a.layout.getRenderTarget().dom, b = d.getTarget();
        while (b.parentNode !== c) {
            b = b.parentNode;
            if (!b) {
                return
            }
        }
        return Ext.getCmp(b.id)
    },
    lookupComponent: function (b) {
        var a = this;
        if (typeof b === "string") {
            b = a.lookupItemFromString(b)
        } else {
            if (Ext.isObject(b)) {
                b = a.lookupItemFromObject(b)
            }
        }
        if (!b.dock) {
            b.minWidth = b.minWidth || a.minWidth
        }
        return b
    },
    lookupItemFromObject: function (b) {
        var a = this;
        if (!b.isComponent) {
            if (!b.xtype) {
                b = Ext.create("Ext.menu." + (Ext.isBoolean(b.checked) ? "Check" : "") + "Item", b)
            } else {
                b = Ext.ComponentManager.create(b, b.xtype)
            }
        }
        if (b.isMenuItem) {
            b.parentMenu = a
        }
        return b
    },
    lookupItemFromString: function (a) {
        return (a === "separator" || a === "-") ? new Ext.menu.Separator() : new Ext.menu.Item({
            canActivate: false,
            hideOnClick: false,
            plain: true,
            text: a
        })
    },
    configureItem: function (c) {
        var b = this.owner, e = "x-", d = b.ui, a, g;
        if (c.isMenuItem) {
            c.setUI(d)
        } else {
            if (b.items.getCount() > 1 && !c.rendered && !c.dock) {
                g = b._itemCmpCls;
                a = [g + " " + g + "-" + d];
                if (!b.plain && (c.indent !== false || c.iconCls === "no-icon")) {
                    a.push(e + "menu-item-indent-" + d)
                }
                if (c.rendered) {
                    c.el.addCls(a)
                } else {
                    c.cls = (c.cls || "") + " " + a.join(" ")
                }
                c.$extraMenuCls = a
            }
        }
        this.callParent(arguments)
    },
    onRemove: function (a) {
        Ext.panel.Panel.prototype.onRemove.call(this, a);
        if (!a.destroyed && a.$extraMenuCls) {
            a.el.removeCls(a.$extraMenuCls)
        }
    },
    onClick: function (h) {
        var g = this, c = h.type, d, b, a = c === "keydown";
        if (g.disabled) {
            h.stopEvent();
            return
        }
        d = g.getItemFromEvent(h);
        if (d && d.isMenuItem) {
            if (!d.menu || !g.ignoreParentClicks) {
                b = d.onClick(h)
            } else {
                h.stopEvent()
            }
            if (d.menu && b !== false && a) {
                d.expandMenu(h, 0)
            }
        }
        if (!d || d.disabled) {
            d = undefined
        }
        g.fireEvent("click", g, d, h)
    },
    onDestroy: function () {
        var a = this;
        a.parentMenu = a.ownerCmp = null;
        if (a.rendered) {
            a.el.un(a.mouseMonitor);
            Ext.destroy(a.iconSepEl)
        }
        Ext.menu.Manager.onHide(a);
        Ext.panel.Panel.prototype.onDestroy.apply(this, arguments)
    },
    onMouseLeave: function (a) {
        if (this.disabled) {
            return
        }
        this.fireEvent("mouseleave", this, a)
    },
    onMouseOver: function (h) {
        var g = this, i = h.getRelatedTarget(), b = !g.el.contains(i), d = g.getItemFromEvent(h), c = g.parentMenu,
            a = g.ownerCmp;
        if (b && c) {
            c.setActiveItem(a);
            a.cancelDeferHide();
            c.mouseMonitor.mouseenter()
        }
        if (g.disabled) {
            return
        }
        if (d) {
            if (!d.containsFocus) {
                d.focus()
            }
            if (d.expandMenu) {
                d.expandMenu(h)
            }
        }
        if (b) {
            g.fireEvent("mouseenter", g, h)
        }
        g.fireEvent("mouseover", g, d, h)
    },
    setActiveItem: function (b) {
        var a = this;
        if (b && (b !== a.lastFocusedChild)) {
            a.focusChild(b, 1)
        }
    },
    onEscapeKey: function () {
        if (this.floating) {
            this.hide()
        }
    },
    onShortcutKey: function (j, h) {
        var b = String.fromCharCode(h.getCharCode()), c = this.query(">[text]"), a = c.length,
            g = this.lastFocusedChild, k = Ext.Array.indexOf(c, g), d = k;
        for (; ;) {
            if (++d === a) {
                d = 0
            }
            g = c[d];
            if (d === k) {
                return
            }
            if (g.text && g.text[0].toUpperCase() === b) {
                g.focus();
                return
            }
        }
    },
    onFocusableContainerTabKey: function (a) {
        if (this.floating) {
            this.hide()
        }
    },
    onFocusableContainerEnterKey: function (a) {
        this.onClick(a)
    },
    onFocusableContainerSpaceKey: function (a) {
        this.onClick(a)
    },
    onFocusableContainerLeftKey: function (a) {
        if (this.parentMenu) {
            this.ownerCmp.focus();
            this.hide()
        }
    },
    onFocusableContainerRightKey: function (b) {
        var a = this, c = a.lastFocusedChild;
        if (c && c.expandMenu) {
            c.expandMenu(b, 0)
        }
    },
    onBeforeShow: function () {
        if (Ext.Date.getElapsed(this.lastHide) < this.menuClickBuffer) {
            return false
        }
    },
    beforeShow: function () {
        var b = this, c, a;
        if (b.floating) {
            if (!b.hasFloatMenuParent() && !b.allowOtherMenus) {
                Ext.menu.Manager.hideAll()
            }
            c = Ext.Element.getActiveElement();
            b.focusAnchor = c === document.body ? null : c;
            b.savedMaxHeight = b.maxHeight;
            a = b.container.getViewSize().height;
            b.maxHeight = Math.min(b.maxHeight || a, a)
        }
        Ext.panel.Panel.prototype.beforeShow.apply(this, arguments)
    },
    afterShow: function () {
        var b = this, a = b.ariaEl.dom;
        Ext.panel.Panel.prototype.afterShow.apply(this, arguments);
        Ext.menu.Manager.onShow(b);
        if (b.floating && a) {
            a.setAttribute("aria-expanded", true)
        }
        if (b.floating && b.autoFocus) {
            b.maxHeight = b.savedMaxHeight;
            b.focus()
        }
    },
    onHide: function (g, c, d) {
        var e = this, b = e.ariaEl.dom, a;
        if (e.el.contains(Ext.Element.getActiveElement())) {
            a = e.focusAnchor || e.ownerCmp || e.up(":focusable");
            if (a) {
                e.previousFocus = a
            }
        }
        Ext.panel.Panel.prototype.onHide.call(this, g, c, d);
        e.lastHide = Ext.Date.now();
        Ext.menu.Manager.onHide(e);
        if (e.floating && b) {
            b.setAttribute("aria-expanded", false)
        }
    },
    preventClick: function (b) {
        var a = this.getItemFromEvent(b);
        if (a && a.isMenuItem && !a.href) {
            b.preventDefault()
        }
    },
    privates: {
        hasFloatMenuParent: function () {
            return this.parentMenu || this.up("menu[floating=true]")
        }, setOwnerCmp: function (b, a) {
            var c = this;
            c.parentMenu = b.isMenuItem ? b : null;
            c.ownerCmp = b;
            c.registerWithOwnerCt();
            delete c.hierarchicallyHidden;
            c.onInheritedAdd(b, a);
            c.containerOnAdded(b, a)
        }
    }
}, 0, ["menu"], ["component", "box", "container", "panel", "menu"], {
    component: true,
    box: true,
    container: true,
    panel: true,
    menu: true
}, ["widget.menu"], [[Ext.util.FocusableContainer.prototype.mixinId || Ext.util.FocusableContainer.$className, Ext.util.FocusableContainer]], [Ext.menu, "Menu"], 0));
(Ext.cmd.derive("Ext.grid.filters.filter.Base", Ext.Base, {
    factoryConfig: {type: "grid.filter"},
    $configPrefixed: false,
    $configStrict: false,
    config: {itemDefaults: null, menuDefaults: {xtype: "menu"}, updateBuffer: 500},
    active: false,
    type: "string",
    dataIndex: null,
    menu: null,
    isGridFilter: true,
    defaultRoot: "data",
    filterIdPrefix: "x-gridfilter",
    constructor: function (a) {
        var c = this, b;
        c.initConfig(a);
        b = c.column;
        b.on("destroy", c.destroy, c);
        c.dataIndex = c.dataIndex || b.dataIndex;
        c.task = new Ext.util.DelayedTask(c.setValue, c)
    },
    destroy: function () {
        this.grid = this.menu = Ext.destroy(this.menu);
        this.callParent()
    },
    addStoreFilter: function (a) {
        this.getGridStore().getFilters().add(a)
    },
    createFilter: function (a, b) {
        return new Ext.util.Filter(this.getFilterConfig(a, b))
    },
    getFilterConfig: function (a, b) {
        a.id = this.getBaseIdPrefix();
        if (!a.property) {
            a.property = this.dataIndex
        }
        if (!a.root) {
            a.root = this.defaultRoot
        }
        if (b) {
            a.id += "-" + b
        }
        return a
    },
    createMenu: function () {
        this.menu = Ext.widget(this.getMenuConfig())
    },
    getActiveState: function (a, b) {
        var c = a.active;
        return (c !== undefined) ? c : b !== undefined
    },
    getBaseIdPrefix: function () {
        return this.filterIdPrefix + "-" + this.dataIndex
    },
    getMenuConfig: function () {
        return Ext.apply({}, this.getMenuDefaults())
    },
    getGridStore: function () {
        return this.grid.getStore()
    },
    getStoreFilter: function (a) {
        var b = this.getBaseIdPrefix();
        if (a) {
            b += "-" + a
        }
        return this.getGridStore().getFilters().get(b)
    },
    onValueChange: function (d, c) {
        var b = this, a = b.updateBuffer;
        if (d.isValid()) {
            if (c.getKey() === c.RETURN) {
                b.menu.hide();
                return
            }
            if (a) {
                b.task.delay(a, null, null, [b.getValue(d)])
            } else {
                b.setValue(b.getValue(d))
            }
        }
    },
    preprocess: Ext.emptyFn,
    removeStoreFilter: function (a) {
        this.getGridStore().getFilters().remove(a)
    },
    getValue: Ext.emptyFn,
    setActive: function (c) {
        var b = this, a = b.owner.activeFilterMenuItem, d;
        if (b.active !== c) {
            b.active = c;
            b.preventDefault = true;
            d = b.getGridStore().getFilters();
            d.beginUpdate();
            if (c) {
                b.activate()
            } else {
                b.deactivate()
            }
            d.endUpdate();
            b.preventDefault = false;
            if (a && a.activeFilter === b) {
                a.setChecked(c)
            }
            b.setColumnActive(c)
        }
    },
    setColumnActive: function (a) {
        this.column[a ? "addCls" : "removeCls"](this.owner.filterCls)
    },
    showMenu: function (a) {
        var b = this;
        if (!b.menu) {
            b.createMenu()
        }
        a.activeFilter = b;
        a.setMenu(b.menu, false);
        a.setChecked(b.active);
        a.setDisabled(b.disabled === true);
        b.activate(true)
    },
    updateStoreFilter: function () {
        this.getGridStore().getFilters().notify("endupdate")
    }
}, 1, 0, 0, 0, 0, [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.grid.filters.filter, "Base"], 0));
(Ext.cmd.derive("Ext.grid.filters.filter.SingleFilter", Ext.grid.filters.filter.Base, {
    constructor: function (a) {
        var c = this, b, d;
        Ext.grid.filters.filter.Base.prototype.constructor.call(this, a);
        d = c.value;
        b = c.getStoreFilter();
        if (b) {
            c.active = true
        } else {
            if (c.grid.stateful && c.getGridStore().saveStatefulFilters) {
                d = undefined
            }
            c.active = c.getActiveState(a, d);
            b = c.createFilter({operator: c.operator, value: d});
            if (c.active) {
                c.addStoreFilter(b)
            }
        }
        if (c.active) {
            c.setColumnActive(true)
        }
        c.filter = b
    }, activate: function (a) {
        if (a) {
            this.activateMenu()
        } else {
            this.addStoreFilter(this.filter)
        }
    }, deactivate: function () {
        this.removeStoreFilter(this.filter)
    }, getValue: function (a) {
        return a.getValue()
    }, onFilterRemove: function () {
        if (!this.menu || this.active) {
            this.active = false
        }
    }
}, 1, 0, 0, 0, 0, 0, [Ext.grid.filters.filter, "SingleFilter"], 0));
(Ext.cmd.derive("Ext.grid.filters.filter.Boolean", Ext.grid.filters.filter.SingleFilter, {
    type: "boolean",
    operator: "=",
    defaultValue: false,
    yesText: "Yes",
    noText: "No",
    updateBuffer: 0,
    createMenu: function (a) {
        var c = this, d = Ext.id(), b = {scope: c, click: c.onClick}, e = c.getItemDefaults();
        Ext.grid.filters.filter.SingleFilter.prototype.createMenu.apply(this, arguments);
        c.menu.add([Ext.apply({
            text: c.yesText,
            filterKey: 1,
            group: d,
            checked: !!c.defaultValue,
            listeners: b
        }, e), Ext.apply({text: c.noText, filterKey: 0, group: d, checked: !c.defaultValue, listeners: b}, e)])
    },
    onClick: function (a) {
        this.setValue(!!a.filterKey)
    },
    setValue: function (b) {
        var a = this;
        a.filter.setValue(b);
        if (b !== undefined && a.active) {
            a.value = b;
            a.updateStoreFilter()
        } else {
            a.setActive(true)
        }
    },
    activateMenu: Ext.emptyFn
}, 0, 0, 0, 0, ["grid.filter.boolean"], 0, [Ext.grid.filters.filter, "Boolean"], 0));
(Ext.cmd.derive("Ext.grid.filters.filter.TriFilter", Ext.grid.filters.filter.Base, {
    menuItems: ["lt", "gt", "-", "eq"], constructor: function (d) {
        var i = this, g = false, a = {}, e, h, c, j, b;
        Ext.grid.filters.filter.Base.prototype.constructor.call(this, d);
        j = i.value;
        h = i.getStoreFilter("lt");
        e = i.getStoreFilter("gt");
        c = i.getStoreFilter("eq");
        if (h || e || c) {
            g = i.active = true;
            if (h) {
                i.onStateRestore(h)
            }
            if (e) {
                i.onStateRestore(e)
            }
            if (c) {
                i.onStateRestore(c)
            }
        } else {
            if (i.grid.stateful && i.getGridStore().saveStatefulFilters) {
                j = undefined
            }
            i.active = i.getActiveState(d, j)
        }
        a.lt = h || i.createFilter({operator: "lt", value: (!g && j && j.lt) || null}, "lt");
        a.gt = e || i.createFilter({operator: "gt", value: (!g && j && j.gt) || null}, "gt");
        a.eq = c || i.createFilter({operator: "eq", value: (!g && j && j.eq) || null}, "eq");
        i.filter = a;
        if (i.active) {
            i.setColumnActive(true);
            if (!g) {
                for (b in j) {
                    i.addStoreFilter(i.filter[b])
                }
            }
        }
    }, activate: function (e) {
        var g = this, b = g.filter, d = g.fields, a, i, c, j, h;
        if (g.preventFilterRemoval) {
            return
        }
        for (c in b) {
            a = b[c];
            i = d[c];
            j = a.getValue();
            if (j) {
                i.setValue(j);
                if (h === undefined) {
                    h = g.owner.activeFilterMenuItem === i.up("menuitem")
                }
                if (!h) {
                    i.up("menuitem").setChecked(true, true)
                }
                if (!e) {
                    g.addStoreFilter(a)
                }
            }
        }
    }, deactivate: function () {
        var c = this, b = c.filter, d, a;
        if (!c.countActiveFilters() || c.preventFilterRemoval) {
            return
        }
        c.preventFilterRemoval = true;
        for (d in b) {
            a = b[d];
            if (a.getValue()) {
                c.removeStoreFilter(a)
            }
        }
        c.preventFilterRemoval = false
    }, countActiveFilters: function () {
        var c = this.filter, e = this.getGridStore().getFilters(), d = this.getBaseIdPrefix(), a = 0, b;
        if (e.length) {
            for (b in c) {
                if (e.get(d + "-" + b)) {
                    a++
                }
            }
        }
        return a
    }, onFilterRemove: function (a) {
        var b = this, c;
        if (!b.menu && b.countActiveFilters()) {
            b.active = false
        } else {
            if (b.menu) {
                c = {};
                c[a] = null;
                b.setValue(c)
            }
        }
    }, onStateRestore: Ext.emptyFn, setValue: function (m) {
        var k = this, b = k.filter, p = [], h = [], d = false, g = k.getGridStore().getFilters(), l, a, o, e, j, n, c;
        if (k.preventFilterRemoval) {
            return
        }
        k.preventFilterRemoval = true;
        if ("eq" in m) {
            o = b.lt.getValue();
            if (o || o === 0) {
                h.push(b.lt)
            }
            o = b.gt.getValue();
            if (o || o === 0) {
                h.push(b.gt)
            }
            o = m.eq;
            if (o || o === 0) {
                p.push(b.eq);
                b.eq.setValue(o)
            } else {
                h.push(b.eq)
            }
        } else {
            o = b.eq.getValue();
            if (o || o === 0) {
                h.push(b.eq)
            }
            if ("lt" in m) {
                o = m.lt;
                if (o || o === 0) {
                    p.push(b.lt);
                    b.lt.setValue(o)
                } else {
                    h.push(b.lt)
                }
            }
            if ("gt" in m) {
                o = m.gt;
                if (o || o === 0) {
                    p.push(b.gt);
                    b.gt.setValue(o)
                } else {
                    h.push(b.gt)
                }
            }
        }
        n = h.length;
        c = p.length;
        d = !!(k.countActiveFilters() + c - n);
        if (n || c || d !== k.active) {
            g.beginUpdate();
            if (n) {
                for (e = 0; e < n; e++) {
                    a = h[e];
                    k.fields[a.getOperator()].setValue(null);
                    a.setValue(null);
                    k.removeStoreFilter(a)
                }
            }
            if (c) {
                for (e = 0; e < c; e++) {
                    k.addStoreFilter(p[e])
                }
            }
            k.setActive(d);
            g.endUpdate()
        }
        k.preventFilterRemoval = false
    }
}, 1, 0, 0, 0, 0, 0, [Ext.grid.filters.filter, "TriFilter"], 0));
(Ext.cmd.derive("Ext.grid.filters.filter.Date", Ext.grid.filters.filter.TriFilter, {
    type: "date",
    config: {
        fields: {lt: {text: "Before"}, gt: {text: "After"}, eq: {text: "On"}},
        pickerDefaults: {xtype: "datepicker", border: 0},
        updateBuffer: 0,
        dateFormat: undefined
    },
    itemDefaults: {xtype: "menucheckitem", selectOnFocus: true, width: 125, menu: {layout: "auto", plain: true}},
    applyDateFormat: function (a) {
        return a || Ext.Date.defaultFormat
    },
    createMenu: function (b) {
        var k = this, l = {scope: k, checkchange: k.onCheckChange}, a = k.menuItems, g, c, d, e, j, n, o, h, m;
        Ext.grid.filters.filter.TriFilter.prototype.createMenu.apply(this, arguments);
        c = k.getItemDefaults();
        g = k.getFields();
        d = Ext.apply({
            minDate: k.minDate,
            maxDate: k.maxDate,
            format: k.dateFormat,
            listeners: {scope: k, select: k.onMenuSelect}
        }, k.getPickerDefaults());
        k.fields = {};
        for (e = 0, j = a.length; e < j; e++) {
            n = a[e];
            if (n !== "-") {
                h = {menu: {items: [Ext.apply({itemId: n}, d)]}};
                if (c) {
                    Ext.merge(h, c)
                }
                if (g) {
                    Ext.merge(h, g[n])
                }
                o = k.menu.add(h);
                m = k.fields[n] = o.down("datepicker");
                m.filter = k.filter[n];
                m.filterKey = n;
                o.on(l)
            } else {
                k.menu.add(n)
            }
        }
    },
    getPicker: function (a) {
        return this.fields[a]
    },
    onCheckChange: function (d, c) {
        var b = d.down("datepicker").filter, a;
        if (!c && b.getValue()) {
            a = {};
            a[b.getOperator()] = null;
            this.setValue(a)
        }
    },
    onFilterRemove: function (b) {
        var a = {};
        a[b] = null;
        this.setValue(a);
        this.fields[b].up("menuitem").setChecked(false, true)
    },
    onStateRestore: function (a) {
        a.setSerializer(this.getSerializer());
        a.setConvert(this.convertDateOnly)
    },
    getFilterConfig: function (a, b) {
        a = Ext.grid.filters.filter.TriFilter.prototype.getFilterConfig.call(this, a, b);
        a.serializer = this.getSerializer();
        a.convert = this.convertDateOnly;
        return a
    },
    convertDateOnly: function (b) {
        var a = null;
        if (b) {
            a = Ext.Date.clearTime(b, true).getTime()
        }
        return a
    },
    getSerializer: function () {
        var a = this;
        return function (c) {
            var b = c.value;
            if (b) {
                c.value = Ext.Date.format(b, a.getDateFormat())
            }
        }
    },
    onMenuSelect: function (g, c) {
        var h = this, e = h.fields, b = h.filter, i = e[g.itemId], a = e.gt, d = e.lt, k = e.eq, j = {};
        i.up("menuitem").setChecked(true, true);
        if (i === k) {
            d.up("menuitem").setChecked(false, true);
            a.up("menuitem").setChecked(false, true)
        } else {
            k.up("menuitem").setChecked(false, true);
            if (i === a && (+d.value < +c)) {
                d.up("menuitem").setChecked(false, true);
                if (b.lt.getValue() != null) {
                    j.lt = null
                }
            } else {
                if (i === d && (+a.value > +c)) {
                    a.up("menuitem").setChecked(false, true);
                    if (b.gt.getValue() != null) {
                        j.gt = null
                    }
                }
            }
        }
        j[i.filterKey] = c;
        h.setValue(j);
        g.up("menu").hide()
    }
}, 0, 0, 0, 0, ["grid.filter.date"], 0, [Ext.grid.filters.filter, "Date"], 0));
(Ext.cmd.derive("Ext.grid.filters.filter.List", Ext.grid.filters.filter.SingleFilter, {
    type: "list",
    operator: "in",
    itemDefaults: {checked: false, hideOnClick: false},
    idField: "id",
    labelField: "text",
    labelIndex: null,
    loadingText: "Loading...",
    loadOnShow: true,
    single: false,
    plain: true,
    constructor: function (c) {
        var d = this, b, a;
        Ext.grid.filters.filter.SingleFilter.prototype.constructor.call(this, c);
        d.labelIndex = d.labelIndex || d.column.dataIndex
    },
    destroy: function () {
        var c = this, a = c.store, b = c.autoStore, d = c.gridStoreListeners;
        if (a) {
            if (b || a.autoDestroy) {
                a.destroy()
            } else {
                a.un("load", c.bindMenuStore, c)
            }
            c.store = null
        }
        if (d) {
            c.getGridStore().un(d);
            c.gridStoreListeners = null
        }
        Ext.grid.filters.filter.SingleFilter.prototype.destroy.call(this)
    },
    activateMenu: function () {
        var e = this, g = e.filter.getValue(), c, d, a, b;
        if (!g || !g.length) {
            return
        }
        c = e.menu.items;
        for (d = 0, a = c.length; d < a; d++) {
            b = c.getAt(d);
            if (Ext.Array.indexOf(g, b.value) > -1) {
                b.setChecked(true, true)
            }
        }
    },
    bindMenuStore: function (a) {
        var b = this;
        if (b.grid.destroyed || b.preventFilterRemoval) {
            return
        }
        b.createListStore(a);
        b.createMenuItems(b.store);
        b.loaded = true
    },
    createListStore: function (n) {
        var h = this, m = h.store, j = n.isStore, b = h.idField, d = h.labelField, k = false, a, c, e, g, l;
        if (j) {
            if (n !== h.getGridStore()) {
                k = true;
                m = h.store = n
            } else {
                h.autoStore = true;
                a = h.getOptionsFromStore(n)
            }
        } else {
            a = [];
            for (e = 0, g = n.length; e < g; e++) {
                l = n[e];
                switch (Ext.typeOf(l)) {
                    case"array":
                        a.push(l);
                        break;
                    case"object":
                        a.push(l);
                        break;
                    default:
                        if (l != null) {
                            c = {};
                            c[b] = l;
                            c[d] = l;
                            a.push(c)
                        }
                }
            }
        }
        if (!k) {
            if (m) {
                m.destroy()
            }
            m = h.store = new Ext.data.Store({fields: [b, d], data: a});
            h.getGridStore().on(h.getGridStoreListeners());
            h.loaded = true
        }
        h.setStoreFilter(m)
    },
    createMenu: function (c) {
        var e = this, d = e.getGridStore(), a = e.store, b = e.options, g;
        if (a) {
            e.store = a = Ext.StoreManager.lookup(a)
        }
        Ext.grid.filters.filter.SingleFilter.prototype.createMenu.call(this, c);
        g = e.menu;
        if (a) {
            if (!a.getCount()) {
                g.add({text: e.loadingText, iconCls: "x-mask-msg-text"});
                g.on("show", e.show, e);
                a.on("load", e.bindMenuStore, e, {single: true})
            } else {
                e.createMenuItems(a)
            }
        } else {
            if (b) {
                e.bindMenuStore(b)
            } else {
                if (d.getCount() || d.data.filtered) {
                    e.bindMenuStore(d)
                } else {
                    d.on("load", e.bindMenuStore, e, {single: true})
                }
            }
        }
    },
    createMenuItems: function (q) {
        var o = this, c = o.menu, n = q.getCount(), h = Ext.Array.contains, p, d, l, m, b, a, j, g, k, r, e;
        if (n && c) {
            p = {checkchange: o.onCheckChange, scope: o};
            d = o.getItemDefaults();
            c.suspendLayouts();
            c.removeAll(true);
            m = o.single ? Ext.id() : null;
            a = o.idField;
            g = o.labelField;
            e = [];
            for (k = 0; k < n; k++) {
                l = q.getAt(k);
                b = l.get(a);
                j = l.get(g);
                if (j == null || h(e, b)) {
                    continue
                }
                e.push(j);
                r = c.add(Ext.apply({text: j, group: m, value: b, listeners: p}, d))
            }
            c.resumeLayouts(true)
        }
    },
    getFilterConfig: function (a, b) {
        a.value = a.value || [];
        return Ext.grid.filters.filter.SingleFilter.prototype.getFilterConfig.call(this, a, b)
    },
    getGridStoreListeners: function () {
        var a = this;
        return a.gridStoreListeners = {
            scope: a,
            add: a.onDataChanged,
            refresh: a.onDataChanged,
            remove: a.onDataChanged,
            update: a.onDataChanged
        }
    },
    getOptionsFromStore: function (n) {
        var l = this, h = n.getData(), b = {}, j = [], m = l.dataIndex, a = l.labelIndex, k, g, d, o, c, e;
        if (n.isFiltered()) {
            h = h.getSource()
        }
        k = h.items;
        d = k.length;
        for (g = 0; g < d; ++g) {
            o = k[g].data;
            c = o[m];
            e = o[a];
            if (e === undefined) {
                e = c
            }
            if (!b[c]) {
                b[c] = 1;
                j.push([c, e])
            }
        }
        return j
    },
    onCheckChange: function () {
        var b = this, a = b.updateBuffer;
        if (a) {
            b.task.delay(a, null, null)
        } else {
            b.setValue()
        }
    },
    onDataChanged: function (a) {
        if (!this.preventDefault) {
            this.bindMenuStore(a)
        }
    },
    setStoreFilter: function (a) {
        var c = this, d = c.value, b = c.filter;
        if (d) {
            if (!Ext.isArray(d)) {
                d = [d]
            }
            b.setValue(d)
        }
        if (c.active) {
            c.preventFilterRemoval = true;
            c.addStoreFilter(b);
            c.preventFilterRemoval = false
        }
    },
    setValue: function () {
        var e = this, c = e.menu.items, g = [], d, a, b;
        e.preventDefault = true;
        for (d = 0, a = c.length; d < a; d++) {
            b = c.getAt(d);
            if (b.checked) {
                g.push(b.value)
            }
        }
        e.filter.setValue(g);
        a = g.length;
        if (a && e.active) {
            e.updateStoreFilter()
        } else {
            e.setActive(!!a)
        }
        e.preventDefault = false
    },
    show: function () {
        var a = this.store;
        if (this.loadOnShow && !this.loaded && !a.hasPendingLoad()) {
            a.load()
        }
    }
}, 1, 0, 0, 0, ["grid.filter.list"], 0, [Ext.grid.filters.filter, "List"], 0));
(Ext.cmd.derive("Ext.grid.filters.filter.Number", Ext.grid.filters.filter.TriFilter, {
    type: "number",
    config: {
        fields: {
            gt: {iconCls: "x-grid-filters-gt", margin: "0 0 3px 0"},
            lt: {iconCls: "x-grid-filters-lt", margin: "0 0 3px 0"},
            eq: {iconCls: "x-grid-filters-eq", margin: 0}
        }
    },
    emptyText: "Enter Number...",
    itemDefaults: {
        xtype: "numberfield",
        enableKeyEvents: true,
        hideEmptyLabel: false,
        labelSeparator: "",
        labelWidth: 29,
        selectOnFocus: false
    },
    menuDefaults: {bodyPadding: 3, showSeparator: false},
    createMenu: function () {
        var h = this,
            j = {scope: h, keyup: h.onValueChange, spin: {fn: h.onInputSpin, buffer: 200}, el: {click: h.stopFn}},
            b = h.getItemDefaults(), a = h.menuItems, d = h.getFields(), k, c, g, l, m, e;
        Ext.grid.filters.filter.TriFilter.prototype.createMenu.call(this);
        h.fields = {};
        for (c = 0, g = a.length; c < g; c++) {
            l = a[c];
            if (l !== "-") {
                k = d[l];
                e = {labelClsExtra: "x-grid-filters-icon " + k.iconCls};
                if (b) {
                    Ext.merge(e, b)
                }
                Ext.merge(e, k);
                e.emptyText = e.emptyText || h.emptyText;
                delete e.iconCls;
                h.fields[l] = m = h.menu.add(e);
                m.filter = h.filter[l];
                m.filterKey = l;
                m.on(j)
            } else {
                h.menu.add(l)
            }
        }
    },
    getValue: function (b) {
        var a = {};
        a[b.filterKey] = b.getValue();
        return a
    },
    onInputSpin: function (c, b) {
        var a = {};
        a[c.filterKey] = c.getValue();
        this.setValue(a)
    },
    stopFn: function (a) {
        a.stopPropagation()
    }
}, 0, 0, 0, 0, ["grid.filter.number", "grid.filter.numeric"], 0, [Ext.grid.filters.filter, "Number"], 0));
(Ext.cmd.derive("Ext.grid.filters.filter.String", Ext.grid.filters.filter.SingleFilter, {
    type: "string",
    operator: "like",
    emptyText: "Enter Filter Text...",
    itemDefaults: {
        xtype: "textfield",
        enableKeyEvents: true,
        hideEmptyLabel: false,
        iconCls: "x-grid-filters-find",
        labelSeparator: "",
        labelWidth: 29,
        margin: 0,
        selectOnFocus: true
    },
    menuDefaults: {bodyPadding: 3, showSeparator: false},
    createMenu: function () {
        var b = this, a;
        Ext.grid.filters.filter.SingleFilter.prototype.createMenu.call(this);
        a = Ext.apply({}, b.getItemDefaults());
        if (a.iconCls && !("labelClsExtra" in a)) {
            a.labelClsExtra = "x-grid-filters-icon " + a.iconCls
        }
        delete a.iconCls;
        a.emptyText = a.emptyText || b.emptyText;
        b.inputItem = b.menu.add(a);
        b.inputItem.on({
            scope: b, keyup: b.onValueChange, el: {
                click: function (c) {
                    c.stopPropagation()
                }
            }
        })
    },
    setValue: function (b) {
        var a = this;
        if (a.inputItem) {
            a.inputItem.setValue(b)
        }
        a.filter.setValue(b);
        if (b && a.active) {
            a.value = b;
            a.updateStoreFilter()
        } else {
            a.setActive(!!b)
        }
    },
    activateMenu: function () {
        this.inputItem.setValue(this.filter.getValue())
    }
}, 0, 0, 0, 0, ["grid.filter.string"], 0, [Ext.grid.filters.filter, "String"], 0));
(Ext.cmd.derive("Ext.grid.filters.Filters", Ext.plugin.Abstract, {
    pluginId: "gridfilters",
    defaultFilterTypes: {"boolean": "boolean", "int": "number", date: "date", number: "number"},
    filterCls: "x-grid-filters-filtered-column",
    menuFilterText: "Filters",
    showMenu: true,
    stateId: undefined,
    init: function (b) {
        var c = this, a, d;
        c.grid = b;
        b.filters = c;
        if (c.grid.normalGrid) {
            c.isLocked = true
        }
        b.clearFilters = c.clearFilters.bind(c);
        a = b.store;
        d = b.headerCt;
        d.on({scope: c, add: c.onAdd, menucreate: c.onMenuCreate});
        b.on({scope: c, destroy: c.onGridDestroy, reconfigure: c.onReconfigure});
        c.bindStore(a);
        if (b.stateful) {
            a.statefulFilters = true
        }
        c.initColumns()
    },
    initColumns: function () {
        var e = this.grid, b = e.getStore(), d = e.columnManager.getColumns(), a = d.length, c, h, g, j;
        for (c = 0; c < a; c++) {
            h = d[c];
            g = h.filter;
            if (g && !g.isGridFilter) {
                if (!j) {
                    j = b.getFilters();
                    j.beginUpdate()
                }
                this.createColumnFilter(h)
            }
        }
        if (j) {
            j.endUpdate()
        }
    },
    createColumnFilter: function (e) {
        var g = this, a = e.filter, d = {column: e, grid: g.grid, owner: g}, h, b, c;
        if (Ext.isString(a)) {
            d.type = a
        } else {
            Ext.apply(d, a)
        }
        if (!d.type) {
            b = g.store.getModel();
            h = b && b.getField(e.dataIndex);
            c = h && h.type;
            d.type = (c && g.defaultFilterTypes[c]) || e.defaultFilterType || "string"
        }
        e.filter = Ext.Factory.gridFilter(d)
    },
    onAdd: function (d, c, a) {
        var b = c.filter;
        if (b && !b.isGridFilter) {
            this.createColumnFilter(c)
        }
    },
    onMenuCreate: function (b, a) {
        a.on({beforeshow: this.onMenuBeforeShow, scope: this})
    },
    onMenuBeforeShow: function (g) {
        var e = this, c, b, d, a;
        if (e.showMenu) {
            if (!e.filterMenuItem) {
                e.filterMenuItem = {}
            }
            d = g.up("tablepanel");
            a = d.id;
            c = e.filterMenuItem[a];
            if (!c || c.destroyed) {
                c = e.createMenuItem(g, a)
            }
            e.activeFilterMenuItem = c;
            b = e.getMenuFilter(d.headerCt);
            if (b) {
                b.showMenu(c)
            }
            c.setVisible(!!b);
            e.sep.setVisible(!!b)
        }
    },
    createMenuItem: function (d, a) {
        var c = this, b;
        c.sep = d.add("-");
        b = d.add({
            checked: false,
            itemId: "filters",
            text: c.menuFilterText,
            listeners: {scope: c, checkchange: c.onCheckChange}
        });
        return (c.filterMenuItem[a] = b)
    },
    onGridDestroy: function () {
        var c = this, a = c.filterMenuItem, b;
        c.bindStore(null);
        c.sep = Ext.destroy(c.sep);
        for (b in a) {
            a[b].destroy()
        }
        c.grid = null
    },
    onUnbindStore: function (a) {
        a.getFilters().un("remove", this.onFilterRemove, this)
    },
    onBindStore: function (a, b, c) {
        this.local = !a.getRemoteFilter();
        a.getFilters().on("remove", this.onFilterRemove, this)
    },
    onFilterRemove: function (j, g) {
        var b = g.items.length, a = this.grid.columnManager, c, e, h, d;
        for (c = 0; c < b; c++) {
            e = g.items[c];
            h = a.getHeaderByDataIndex(e.getProperty());
            if (h) {
                d = h.filter;
                if (!d || !d.menu || e.getId().indexOf(d.getBaseIdPrefix()) === -1) {
                    continue
                }
                if (!d.preventFilterRemoval) {
                    d.onFilterRemove(e.getOperator())
                }
            }
        }
    },
    getMenuFilter: function (a) {
        return a.getMenu().activeHeader.filter
    },
    onCheckChange: function (c, d) {
        var b = this.isLocked ? c.up("tablepanel") : this.grid, a = this.getMenuFilter(b.headerCt);
        a.setActive(d)
    },
    getHeaders: function () {
        return this.grid.view.headerCt.columnManager.getColumns()
    },
    isStateful: function () {
        return this.grid.stateful
    },
    addFilter: function (c) {
        var j = this, a = j.grid, l = j.store, d = false, m = true, k, e, g, h, b, n;
        if (!Ext.isArray(c)) {
            c = [c]
        }
        for (g = 0, h = c.length; g < h; g++) {
            b = c[g];
            k = b.dataIndex;
            e = a.columnManager.getHeaderByDataIndex(k);
            if (e) {
                d = true;
                if (b.value) {
                    m = false
                }
                n = e.filter;
                if (n && n.isGridFilter) {
                    n.deactivate();
                    n.destroy();
                    if (j.activeFilterMenuItem) {
                        j.activeFilterMenuItem.menu = null
                    }
                }
                e.filter = b
            }
        }
        if (d) {
            l.suppressNextFilter = m;
            j.initColumns();
            l.suppressNextFilter = false
        }
    },
    addFilters: function (a) {
        if (a) {
            this.addFilter(a)
        }
    },
    clearFilters: function () {
        var e = this.grid, d = e.columnManager.getColumns(), b = e.store, h, g, c, a, j;
        for (c = 0, a = d.length; c < a; c++) {
            h = d[c];
            g = h.filter;
            if (g && g.isGridFilter) {
                if (!j) {
                    j = b.getFilters();
                    j.beginUpdate()
                }
                g.setActive(false)
            }
        }
        if (j) {
            j.endUpdate()
        }
    },
    onReconfigure: function (e, a, d, g) {
        var c = this.filterMenuItem, b;
        for (b in c) {
            c[b].setMenu(null)
        }
        if (a && g !== a) {
            this.bindStore(a)
        }
    }
}, 0, 0, 0, 0, ["plugin.gridfilters"], [[Ext.util.StoreHolder.prototype.mixinId || Ext.util.StoreHolder.$className, Ext.util.StoreHolder]], [Ext.grid.filters, "Filters"], 0));
(Ext.cmd.derive("Ext.grid.locking.HeaderContainer", Ext.grid.header.Container, {
    headerCtRelayEvents: ["blur", "focus", "move", "resize", "destroy", "beforedestroy", "boxready", "afterrender", "render", "beforerender", "removed", "hide", "beforehide", "show", "beforeshow", "enable", "disable", "added", "deactivate", "beforedeactivate", "activate", "beforeactivate", "remove", "add", "beforeremove", "beforeadd", "afterlayout", "menucreate", "sortchange", "columnschanged", "columnshow", "columnhide", "columnmove", "headertriggerclick", "headercontextmenu", "headerclick", "columnresize", "statesave", "beforestatesave", "staterestore", "beforestaterestore"],
    constructor: function (b) {
        var a = this, d = b.lockedGrid, c = b.normalGrid;
        a.lockable = b;
        Ext.grid.header.Container.prototype.constructor.call(this);
        d.visibleColumnManager.rootColumns = c.visibleColumnManager.rootColumns = b.visibleColumnManager = a.visibleColumnManager = new Ext.grid.ColumnManager(true, d.headerCt, c.headerCt);
        d.columnManager.rootColumns = c.columnManager.rootColumns = b.columnManager = a.columnManager = new Ext.grid.ColumnManager(false, d.headerCt, c.headerCt);
        a.lockedEventRelayers = a.relayEvents(d.headerCt, a.headerCtRelayEvents);
        a.normalEventRelayers = a.relayEvents(c.headerCt, a.headerCtRelayEvents)
    },
    destroy: function () {
        var a = this;
        Ext.destroy(a.lockedEventRelayers, a.normalEventRelayers);
        a.lockedEventRelayers = a.normalEventRelayers = null;
        Ext.grid.header.Container.prototype.destroy.call(this)
    },
    getRefItems: function () {
        return this.lockable.lockedGrid.headerCt.getRefItems().concat(this.lockable.normalGrid.headerCt.getRefItems())
    },
    getGridColumns: function () {
        return this.lockable.lockedGrid.headerCt.getGridColumns().concat(this.lockable.normalGrid.headerCt.getGridColumns())
    },
    getColumnsState: function () {
        var b = this, a = b.lockable.lockedGrid.headerCt.getColumnsState(),
            c = b.lockable.normalGrid.headerCt.getColumnsState();
        return a.concat(c)
    },
    applyColumnsState: function (h) {
        var p = this, e = p.lockable.lockedGrid, g = e.headerCt, n = p.lockable.normalGrid.headerCt,
            q = Ext.Array.toValueMap(g.items.items, "stateId"), j = Ext.Array.toValueMap(n.items.items, "stateId"),
            m = [], o = [], l = 1, b = h.length, k, a, d, c;
        for (k = 0; k < b; k++) {
            c = h[k];
            d = q[c.id];
            a = d || j[c.id];
            if (a) {
                if (a.applyColumnState) {
                    a.applyColumnState(c)
                }
                if (a.locked === undefined) {
                    a.locked = !!d
                }
                if (a.locked) {
                    m.push(a);
                    if (!a.hidden && typeof a.width === "number") {
                        l += a.width
                    }
                } else {
                    o.push(a)
                }
            }
        }
        if (m.length + o.length === g.items.getCount() + n.items.getCount()) {
            g.removeAll(false);
            n.removeAll(false);
            g.add(m);
            n.add(o);
            e.setWidth(l)
        }
    },
    disable: function () {
        var a = this.lockable;
        a.lockedGrid.headerCt.disable();
        a.normalGrid.headerCt.disable()
    },
    enable: function () {
        var a = this.lockable;
        a.lockedGrid.headerCt.enable();
        a.normalGrid.headerCt.enable()
    }
}, 1, 0, ["component", "box", "container", "headercontainer"], {
    component: true,
    box: true,
    container: true,
    headercontainer: true
}, 0, 0, [Ext.grid.locking, "HeaderContainer"], 0));
(Ext.cmd.derive("Ext.grid.locking.View", Ext.Base, {
    alternateClassName: "Ext.grid.LockingView",
    isLockingView: true,
    loadMask: true,
    eventRelayRe: /^(beforeitem|beforecontainer|item|container|cell|refresh)/,
    constructor: function (a) {
        var c = Ext, e = this, d, b;
        e.ownerGrid = a.ownerGrid;
        e.ownerGrid.view = e;
        e.navigationModel = a.locked.xtype === "treepanel" ? new c.tree.NavigationModel(e) : new c.grid.NavigationModel(e);
        a.locked.viewConfig.bindStore = c.emptyFn;
        a.normal.viewConfig.bindStore = e.subViewBindStore;
        a.normal.viewConfig.isNormalView = a.locked.viewConfig.isLockedView = true;
        a.locked.viewConfig.beforeLayout = a.normal.viewConfig.beforeLayout = e.beforeLayout;
        a.locked.viewConfig.navigationModel = a.normal.viewConfig.navigationModel = e.navigationModel;
        e.lockedGrid = e.ownerGrid.lockedGrid = c.ComponentManager.create(a.locked);
        e.lockedView = d = e.lockedGrid.getView();
        e.selModel = a.normal.viewConfig.selModel = d.getSelectionModel();
        if (e.lockedGrid.isTree) {
            e.lockedView.animate = false;
            a.normal.store = d.store;
            a.normal.viewConfig.stripeRows = e.lockedView.stripeRows;
            a.normal.rowLines = e.lockedGrid.rowLines
        }
        e.normalGrid = e.ownerGrid.normalGrid = c.ComponentManager.create(a.normal);
        d.lockingPartner = b = e.normalView = e.normalGrid.getView();
        b.lockingPartner = d;
        e.loadMask = (a.loadMask !== undefined) ? a.loadMask : e.loadMask;
        e.mixins.observable.constructor.call(e);
        e.lockedViewEventRelayers = e.relayEvents(d, c.view.Table.events);
        e.normalViewEventRelayers = e.relayEvents(b, c.view.Table.events.concat(c.view.Table.normalSideEvents));
        b.on({scope: e, itemmouseleave: e.onItemMouseLeave, itemmouseenter: e.onItemMouseEnter});
        d.on({scope: e, itemmouseleave: e.onItemMouseLeave, itemmouseenter: e.onItemMouseEnter});
        e.ownerGrid.on({render: e.onPanelRender, scope: e});
        e.loadingText = b.loadingText;
        e.loadingCls = b.loadingCls;
        e.loadingUseMsg = b.loadingUseMsg;
        e.itemSelector = e.getItemSelector();
        e.all = b.all;
        e.bindStore(b.dataSource, true, "dataSource")
    },
    subViewBindStore: function (c) {
        var b = this, a;
        if (b.destroying || b.destroyed) {
            return
        }
        a = b.getSelectionModel();
        if (c !== null && !b.ownerGrid.reconfiguring) {
            c = b.store
        }
        a.bindStore(c);
        a.bindComponent(b)
    },
    beforeLayout: function () {
        var c = this.ownerCt.ownerLockable.view, b = c.lockedGrid.view, a = c.normalGrid.view;
        if (!c.relayingOperation) {
            if (c.lockedGrid.isVisible()) {
                if (b.refreshNeeded) {
                    b.doFirstRefresh(b.dataSource)
                }
            }
            if (a.refreshNeeded) {
                a.doFirstRefresh(a.dataSource)
            }
        }
    },
    onPanelRender: function () {
        var c = this, b = c.loadMask, a = {
            target: c.ownerGrid,
            msg: c.loadingText,
            msgCls: c.loadingCls,
            useMsg: c.loadingUseMsg,
            store: c.ownerGrid.store
        };
        c.el = c.ownerGrid.getTargetEl();
        c.rendered = true;
        c.initFocusableEvents();
        c.fireEvent("render", c);
        if (b) {
            if (Ext.isObject(b)) {
                a = Ext.apply(a, b)
            }
            c.loadMask = new Ext.LoadMask(a)
        }
    },
    getRefOwner: function () {
        return this.ownerGrid
    },
    getVisibleColumnManager: function () {
        return this.ownerGrid.getVisibleColumnManager()
    },
    getTopLevelVisibleColumnManager: function () {
        return this.ownerGrid.getVisibleColumnManager()
    },
    getGridColumns: function () {
        return this.getVisibleColumnManager().getColumns()
    },
    getEl: function (a) {
        return this.getViewForColumn(a).getEl()
    },
    getCellSelector: function () {
        return this.normalView.getCellSelector()
    },
    getItemSelector: function () {
        return this.normalView.getItemSelector()
    },
    getViewForColumn: function (b) {
        var a = this.lockedView, c;
        a.headerCt.cascade(function (d) {
            if (d === b) {
                c = true;
                return false
            }
        });
        return c ? a : this.normalView
    },
    onItemMouseEnter: function (c, b) {
        var g = this, d = g.lockedView, a = g.normalView, e;
        if (c.trackOver) {
            if (c !== d) {
                a = d
            }
            e = a.getNode(b);
            a.highlightItem(e)
        }
    },
    onItemMouseLeave: function (c, b) {
        var e = this, d = e.lockedView, a = e.normalView;
        if (c.trackOver) {
            if (c !== d) {
                a = d
            }
            a.clearHighlight()
        }
    },
    relayFn: function (c, b) {
        b = b || [];
        var d = this, a = d.lockedView;
        d.relayingOperation = true;
        a[c].apply(a, b);
        a = d.normalView;
        a[c].apply(a, b);
        d.relayingOperation = false
    },
    getSelectionModel: function () {
        return this.normalView.getSelectionModel()
    },
    getNavigationModel: function () {
        return this.navigationModel
    },
    getStore: function () {
        return this.ownerGrid.store
    },
    onBindStore: function (a, b, g) {
        var e = this, d = e.lockedView, c = e.normalView;
        if (c.componentLayoutCounter && !(d.blockRefresh && c.blockRefresh)) {
            Ext.suspendLayouts();
            d.doFirstRefresh(a);
            c.doFirstRefresh(a);
            Ext.resumeLayouts(true)
        }
    },
    getStoreListeners: function () {
        var a = this;
        return {
            priority: 1000,
            refresh: a.onDataRefresh,
            replace: a.onReplace,
            add: a.onAdd,
            remove: a.onRemove,
            update: a.onUpdate,
            clear: a.refresh,
            beginupdate: a.onBeginUpdate,
            endupdate: a.onEndUpdate
        }
    },
    onBeginUpdate: function () {
        Ext.suspendLayouts();
        this.relayFn("onBeginUpdate", arguments);
        Ext.resumeLayouts(true)
    },
    onEndUpdate: function () {
        Ext.suspendLayouts();
        this.relayFn("onEndUpdate", arguments);
        Ext.resumeLayouts(true)
    },
    onDataRefresh: function () {
        Ext.suspendLayouts();
        this.relayFn("onDataRefresh", arguments);
        Ext.resumeLayouts(true)
    },
    onReplace: function () {
        Ext.suspendLayouts();
        this.relayFn("onReplace", arguments);
        Ext.resumeLayouts(true)
    },
    onAdd: function () {
        Ext.suspendLayouts();
        this.relayFn("onAdd", arguments);
        Ext.resumeLayouts(true)
    },
    onRemove: function () {
        Ext.suspendLayouts();
        this.relayFn("onRemove", arguments);
        Ext.resumeLayouts(true)
    },
    setActionableMode: function (d, b) {
        var a, c;
        if (d) {
            if (!b) {
                b = this.getNavigationModel().getPosition()
            }
            if (b) {
                b = b.clone();
                b.view = c = b.column.getView();
                a = c.setActionableMode(d, b);
                if (a !== false && c.lockingPartner.grid.isVisible()) {
                    c.lockingPartner.setActionableMode(d, b);
                    if (!c.lockingPartner.actionableMode) {
                        c.setActionableMode(false);
                        a = false
                    }
                }
                return a
            } else {
                return false
            }
        } else {
            this.relayFn("setActionableMode", [false])
        }
    },
    onUpdate: function () {
        var a = this.normalGrid.view;
        Ext.suspendLayouts();
        this.relayFn("onUpdate", arguments);
        if (a.hasVariableRowHeight() && a.bufferedRenderer) {
            Ext.on({afterlayout: a.bufferedRenderer.refreshSize, scope: a.bufferedRenderer, single: true})
        }
        Ext.resumeLayouts(true)
    },
    refresh: function () {
        Ext.suspendLayouts();
        this.relayFn("refresh", arguments);
        Ext.resumeLayouts(true)
    },
    getNode: function (a) {
        return this.normalView.getNode(a)
    },
    getRow: function (a) {
        return this.normalView.getRow(a)
    },
    getCell: function (b, c) {
        var a = this.getViewForColumn(c), d = a.getRow(b);
        return Ext.fly(d).down(c.getCellSelector())
    },
    indexOf: function (b) {
        var a = this.lockedView.indexOf(b);
        if (!a) {
            a = this.normalView.indexOf(b)
        }
        return a
    },
    focus: function () {
        var a = this.ownerGrid.down(">tablepanel:not(hidden)>tableview");
        if (a) {
            a.focus()
        }
    },
    focusRow: function (c) {
        var a, b = this.getNavigationModel().lastFocused;
        a = b ? b.view : this.normalView;
        a.focusRow(c)
    },
    focusCell: function (a) {
        a.view.focusCell(a)
    },
    onRowFocus: function () {
        this.relayFn("onRowFocus", arguments)
    },
    isVisible: function (a) {
        return this.ownerGrid.isVisible(a)
    },
    getFocusEl: function () {
        var a, b = this.getNavigationModel().lastFocused;
        a = b ? b.view : this.normalView;
        return a.getFocusEl()
    },
    getCellInclusive: function (d, b) {
        var a = d.column, c = this.lockedGrid.getColumnManager().getColumns().length;
        if (a >= c) {
            d = Ext.apply({}, d);
            d.column -= c;
            return this.normalView.getCellInclusive(d, b)
        } else {
            return this.lockedView.getCellInclusive(d, b)
        }
    },
    getHeaderByCell: function (a) {
        if (a) {
            return this.getVisibleColumnManager().getHeaderById(a.getAttribute("data-columnId"))
        }
        return false
    },
    onRowSelect: function () {
        this.relayFn("onRowSelect", arguments)
    },
    onRowDeselect: function () {
        this.relayFn("onRowDeselect", arguments)
    },
    onCellSelect: function (a) {
        a.column.getView().onCellSelect({record: a.record, column: a.column})
    },
    onCellDeselect: function (a) {
        a.column.getView().onCellDeselect({record: a.record, column: a.column})
    },
    getCellByPosition: function (e, c) {
        var d = this, a = e.view, b = e.column;
        if (a === d) {
            e = new Ext.grid.CellContext(b.getView()).setPosition(e.record, e.column)
        }
        return a.getCellByPosition(e, c)
    },
    getRecord: function (b) {
        var a = this.lockedView.getRecord(b);
        if (!a) {
            a = this.normalView.getRecord(b)
        }
        return a
    },
    scrollBy: function () {
        var a = this.normalView;
        a.scrollBy.apply(a, arguments)
    },
    ensureVisible: function () {
        var a = this.normalView;
        a.ensureVisible.apply(a, arguments)
    },
    disable: function () {
        this.relayFn("disable", arguments)
    },
    enable: function () {
        this.relayFn("enable", arguments)
    },
    addElListener: function () {
        this.relayFn("addElListener", arguments)
    },
    refreshNode: function () {
        this.relayFn("refreshNode", arguments)
    },
    addRowCls: function () {
        this.relayFn("addRowCls", arguments)
    },
    removeRowCls: function () {
        this.relayFn("removeRowCls", arguments)
    },
    destroy: function () {
        var a = this;
        a.rendered = false;
        a.bindStore(null, false, "dataSource");
        Ext.destroy(a.lockedViewEventRelayers, a.normalViewEventRelayers);
        a.lockedViewEventRelayers = a.normalViewEventRelayers = null;
        a.callParent();
        Ext.destroy(a.loadMask, a.navigationModel, a.selModel);
        a.lockedView.lockingPartner = a.normalView.lockingPartner = null;
        a.lockedGrid = a.lockedView = a.normalGrid = a.normalView = null;
        a.loadMask = a.navigationModel = a.selModel = a.headerCt = null;
        a.ownerGrid = a.storeListeners = null
    }
}, 1, 0, 0, 0, 0, [[Ext.util.Observable.prototype.mixinId || Ext.util.Observable.$className, Ext.util.Observable], [Ext.util.StoreHolder.prototype.mixinId || Ext.util.StoreHolder.$className, Ext.util.StoreHolder], [Ext.util.Focusable.prototype.mixinId || Ext.util.Focusable.$className, Ext.util.Focusable]], [Ext.grid.locking, "View", Ext.grid, "LockingView"], function () {
    this.borrow(Ext.Component, ["up"]);
    this.borrow(Ext.view.AbstractView, ["doFirstRefresh", "applyFirstRefresh"]);
    this.borrow(Ext.view.Table, ["cellSelector", "selectedCellCls", "selectedItemCls"])
}));
(Ext.cmd.derive("Ext.grid.locking.Lockable", Ext.Base, {
    alternateClassName: "Ext.grid.Lockable",
    syncRowHeight: true,
    headerCounter: 0,
    scrollDelta: 40,
    lockedGridCls: "x-grid-inner-locked",
    normalGridCls: "x-grid-inner-normal",
    lockingBodyCls: "x-grid-locking-body",
    unlockText: "Unlock",
    lockText: "Lock",
    bothCfgCopy: ["invalidateScrollerOnRefresh", "hideHeaders", "enableColumnHide", "enableColumnMove", "enableColumnResize", "sortableColumns", "multiColumnSort", "columnLines", "rowLines", "variableRowHeight", "numFromEdge", "trailingBufferZone", "leadingBufferZone", "scrollToLoadBuffer"],
    normalCfgCopy: ["verticalScroller", "verticalScrollDock", "verticalScrollerType", "scroll"],
    lockedCfgCopy: [],
    determineXTypeToCreate: function (e) {
        var c = this, h, d, b, g, a;
        if (c.subGridXType) {
            h = c.subGridXType
        } else {
            if (!e) {
                return "gridpanel"
            }
            d = this.getXTypes().split("/");
            b = d.length;
            g = d[b - 1];
            a = d[b - 2];
            if (a !== "tablepanel") {
                h = a
            } else {
                h = g
            }
        }
        return h
    },
    injectLockable: function () {
        this.focusable = false;
        this.lockable = true;
        this.hasView = true;
        var v = this, k = Ext.getScrollbarSize(), o = k.width, d = v.store = Ext.StoreManager.lookup(v.store),
            c = v.lockedViewConfig, u = v.normalViewConfig, m = Ext.Object, h, j, s, g, l, b, e, r, t = v.viewConfig,
            a = t && t.loadMask, n = (a !== undefined) ? a : v.loadMask, p = v.bufferedRenderer,
            q = o > 0 && Ext.supports.touchScroll !== 2;
        h = v.constructLockableFeatures();
        v.features = null;
        j = v.constructLockablePlugins();
        v.plugins = j.topPlugins;
        s = {
            id: v.id + "-locked",
            $initParent: v,
            isLocked: true,
            bufferedRenderer: p,
            ownerGrid: v,
            ownerLockable: v,
            xtype: v.determineXTypeToCreate(true),
            store: d,
            reserveScrollbar: q,
            scrollable: {indicators: {x: true, y: false}},
            scrollerOwner: false,
            animate: false,
            border: false,
            cls: v.lockedGridCls,
            isLayoutRoot: function () {
                return this.floatedFromCollapse || v.normalGrid.floatedFromCollapse
            },
            features: h.lockedFeatures,
            plugins: j.lockedPlugins
        };
        g = {
            id: v.id + "-normal",
            $initParent: v,
            isLocked: false,
            bufferedRenderer: p,
            ownerGrid: v,
            ownerLockable: v,
            xtype: v.determineXTypeToCreate(),
            store: d,
            reserveScrollbar: v.reserveScrollbar,
            scrollerOwner: false,
            border: false,
            cls: v.normalGridCls,
            isLayoutRoot: function () {
                return this.floatedFromCollapse || v.lockedGrid.floatedFromCollapse
            },
            features: h.normalFeatures,
            plugins: j.normalPlugins
        };
        v.addCls("x-grid-locked");
        Ext.copyTo(g, v, v.bothCfgCopy, true);
        Ext.copyTo(s, v, v.bothCfgCopy, true);
        Ext.copyTo(g, v, v.normalCfgCopy, true);
        Ext.copyTo(s, v, v.lockedCfgCopy, true);
        Ext.apply(g, v.normalGridConfig);
        Ext.apply(s, v.lockedGridConfig);
        for (l = 0; l < v.normalCfgCopy.length; l++) {
            delete v[v.normalCfgCopy[l]]
        }
        for (l = 0; l < v.lockedCfgCopy.length; l++) {
            delete v[v.lockedCfgCopy[l]]
        }
        v.addStateEvents(["lockcolumn", "unlockcolumn"]);
        b = v.processColumns(v.columns || [], s);
        s.columns = b.locked;
        if (!s.columns.items.length) {
            s.hidden = true
        }
        g.columns = b.normal;
        if (!g.columns.items.length) {
            g.hidden = true
        }
        g.flex = 1;
        s.viewConfig = c = (c ? m.chain(c) : {});
        g.viewConfig = u = (u ? m.chain(u) : {});
        c.loadingUseMsg = false;
        c.loadMask = false;
        if (q) {
            c.margin = "0 -" + o + " 0 0"
        }
        u.loadMask = false;
        Ext.applyIf(c, t);
        Ext.applyIf(u, t);
        if (!v.initialConfig.layout) {
            v.layout = {type: "hbox", align: "stretch"}
        }
        v.getLayout();
        if (v.layout.type === "border") {
            if (v.split) {
                s.split = true
            }
            if (!s.region) {
                s.region = "west"
            }
            if (!g.region) {
                g.region = "center"
            }
            v.addCls("x-grid-locked-split")
        }
        if (!(v.layout instanceof Ext.layout.container.Box)) {
            v.split = false
        }
        v.view = new Ext.grid.locking.View({loadMask: n, locked: s, normal: g, ownerGrid: v});
        s = v.lockedGrid;
        g = v.normalGrid;
        g.getView().getScrollable().addPartner(s.getView().getScrollable(), "y");
        if (k.height && Ext.supports.touchScroll !== 2) {
            s.on({afterlayout: v.afterLockedViewLayout, scope: v});
            s.getView().getOverflowStyle()
        }
        e = s.headerCt;
        r = g.headerCt;
        if (q) {
            e.reserveScrollbar = false
        }
        v.headerCt = v.view.headerCt = new Ext.grid.locking.HeaderContainer(v);
        e.lockedCt = true;
        e.lockableInjected = true;
        r.lockableInjected = true;
        e.on({
            add: v.delaySyncLockedWidth,
            remove: v.delaySyncLockedWidth,
            columnshow: v.delaySyncLockedWidth,
            columnhide: v.delaySyncLockedWidth,
            sortchange: v.onLockedHeaderSortChange,
            columnresize: v.delaySyncLockedWidth,
            scope: v
        });
        r.on({
            add: v.delaySyncLockedWidth,
            remove: v.delaySyncLockedWidth,
            columnshow: v.delaySyncLockedWidth,
            columnhide: v.delaySyncLockedWidth,
            sortchange: v.onNormalHeaderSortChange,
            scope: v
        });
        v.modifyHeaderCt();
        v.items = [s];
        if (v.split) {
            v.addCls("x-grid-locked-split");
            v.items[1] = {xtype: "splitter"}
        }
        v.items.push(g);
        v.relayHeaderCtEvents(e);
        v.relayHeaderCtEvents(r);
        v.storeRelayers = v.relayEvents(d, ["filterchange", "groupchange"]);
        v.gridRelayers = v.relayEvents(g, ["viewready"])
    },
    afterInjectLockable: function () {
        delete this.lockedGrid.$initParent;
        delete this.normalGrid.$initParent
    },
    getLockingViewConfig: function () {
        return {xclass: "Ext.grid.locking.View", locked: this.lockedGrid, normal: this.normalGrid, panel: this}
    },
    processColumns: function (g, d) {
        var n = this, h, k, e, m = new Ext.grid.header.Container({"$initParent": n}), l = [], c = [],
            b = {itemId: "lockedHeaderCt", stretchMaxPartner: "^^>>#normalHeaderCt", items: l},
            j = {itemId: "normalHeaderCt", stretchMaxPartner: "^^>>#lockedHeaderCt", items: c},
            o = {locked: b, normal: j}, a;
        if (Ext.isObject(g)) {
            Ext.applyIf(b, g);
            Ext.applyIf(j, g);
            a = Ext.apply({}, g);
            delete a.items;
            Ext.apply(m, a);
            g = g.items
        }
        m.constructing = true;
        for (h = 0, k = g.length; h < k; ++h) {
            e = g[h];
            if (!e.isComponent) {
                e = m.applyDefaults(e);
                e.$initParent = m;
                e = m.lookupComponent(e);
                delete e.$initParent
            }
            e.processed = true;
            if (e.locked || e.autoLock) {
                l.push(e)
            } else {
                c.push(e)
            }
            if (!e.headerId) {
                e.headerId = (e.initialConfig || e).id || ("h" + (++n.headerCounter))
            }
        }
        n.fireEvent("processcolumns", n, l, c);
        m.destroy();
        return o
    },
    afterLockedViewLayout: function () {
        var d = this, a = d.lockedGrid, c = d.normalGrid, j = a.getView(), b = c.getView(),
            i = j.scrollFlags.x && a.headerCt.tooNarrow, h = b.scrollFlags.x && c.headerCt.tooNarrow,
            e = b.getScrollable(), g = j.getScrollable();
        if (i !== h) {
            if (i) {
                e.setX("scroll");
                g.setX(true)
            } else {
                g.setX("scroll");
                e.setX(true)
            }
        } else {
            g.setX(h ? "scroll" : true);
            e.setX(true)
        }
    },
    ensureLockedVisible: function () {
        this.lockedGrid.ensureVisible.apply(this.lockedGrid, arguments);
        this.normalGrid.ensureVisible.apply(this.normalGrid, arguments)
    },
    onLockedViewMouseWheel: function (j) {
        var d = this, a = -d.scrollDelta * j.getWheelDeltas().y, c = d.lockedGrid.getView(), g = c.el.dom, i, b, h;
        if (!d.ignoreMousewheel) {
            if (g) {
                i = c.getScrollY();
                b = i !== g.scrollHeight - g.clientHeight;
                h = i !== 0
            }
            if ((a < 0 && h) || (a > 0 && b)) {
                j.stopEvent();
                i += a;
                c.setScrollY(i);
                d.normalGrid.getView().setScrollY(i);
                d.onNormalViewScroll()
            }
        }
    },
    onLockedViewScroll: function () {
        var g = this, e = g.lockedGrid.getView(), d = g.normalGrid.getView(), c = e.getScrollY(), h = d.getScrollY(), a,
            b;
        if (h !== c) {
            d.setScrollY(c);
            if (d.bufferedRenderer) {
                b = e.body.dom;
                a = d.body.dom;
                a.style.position = "absolute";
                a.style.top = b.style.top
            }
        }
    },
    onNormalViewScroll: function () {
        var d = this, c = d.lockedGrid.getView(), b = d.normalGrid.getView(), a = c.getScrollY(), g = b.getScrollY(), e;
        if (g !== a) {
            c.setScrollY(g);
            if (b.bufferedRenderer) {
                e = c.body;
                if (e.dom) {
                    e.dom.style.position = "absolute";
                    e.translate(null, b.bufferedRenderer.bodyTop)
                }
            }
        }
    },
    syncRowHeights: function () {
        if (!this.destroyed) {
            var d = this, b = d.normalGrid.getView(), c = d.lockedGrid.getView(), g = b.syncRowHeightBegin(),
                a = c.syncRowHeightBegin(), e;
            b.syncRowHeightMeasure(g);
            c.syncRowHeightMeasure(a);
            b.syncRowHeightFinish(g, a);
            c.syncRowHeightFinish(a, g);
            e = b.getScrollY();
            c.setScrollY(e)
        }
    },
    modifyHeaderCt: function () {
        var a = this;
        a.lockedGrid.headerCt.getMenuItems = a.getMenuItems(a.lockedGrid.headerCt.getMenuItems, true);
        a.normalGrid.headerCt.getMenuItems = a.getMenuItems(a.normalGrid.headerCt.getMenuItems, false);
        a.lockedGrid.headerCt.showMenuBy = Ext.Function.createInterceptor(a.lockedGrid.headerCt.showMenuBy, a.showMenuBy);
        a.normalGrid.headerCt.showMenuBy = Ext.Function.createInterceptor(a.normalGrid.headerCt.showMenuBy, a.showMenuBy)
    },
    onUnlockMenuClick: function () {
        this.unlock()
    },
    onLockMenuClick: function () {
        this.lock()
    },
    showMenuBy: function (a, c, h) {
        var g = this.getMenu(), d = g.down("#unlockItem"), e = g.down("#lockItem"), b = d.prev();
        if (h.lockable === false) {
            b.hide();
            d.hide();
            e.hide()
        } else {
            b.show();
            d.show();
            e.show();
            if (!d.initialConfig.disabled) {
                d.setDisabled(h.lockable === false)
            }
            if (!e.initialConfig.disabled) {
                e.setDisabled(!h.isLockable())
            }
        }
    },
    getMenuItems: function (g, c) {
        var h = this, i = h.unlockText, a = h.lockText, j = "x-hmenu-unlock", b = "x-hmenu-lock",
            e = h.onUnlockMenuClick.bind(h), d = h.onLockMenuClick.bind(h);
        return function () {
            var k = g.call(this);
            k.push("-", {itemId: "unlockItem", iconCls: j, text: i, handler: e, disabled: !c});
            k.push({itemId: "lockItem", iconCls: b, text: a, handler: d, disabled: c});
            return k
        }
    },
    delaySyncLockedWidth: function () {
        var b = this, a = b.syncLockedWidthTask;
        if (!a) {
            a = b.syncLockedWidthTask = new Ext.util.DelayedTask(b.syncLockedWidth, b)
        }
        a.delay(1)
    },
    syncLockedWidth: function () {
        var e = this, i = e.rendered, c = e.lockedGrid, d = c.view, h = e.normalGrid,
            g = c.getVisibleColumnManager().getColumns().length, a = h.getVisibleColumnManager().getColumns().length,
            b = e.syncLockedWidthTask;
        if (b) {
            b.cancel()
        }
        Ext.suspendLayouts();
        if (a) {
            h.show();
            if (g) {
                if (i && c.shrinkWrapColumns && !c.headerCt.forceFit) {
                    delete c.flex;
                    c.setWidth(c.headerCt.getTableWidth() + c.gridPanelBorderWidth)
                }
                c.addCls(e.lockedGridCls);
                c.show();
                if (c.split) {
                    e.child("splitter").show();
                    e.addCls("x-grid-locked-split")
                }
            } else {
                if (i) {
                    c.getView().clearViewEl(true)
                }
                c.hide();
                if (c.split) {
                    e.child("splitter").hide();
                    e.removeCls("x-grid-locked-split")
                }
            }
            if (Ext.supports.touchScroll !== 2 && Ext.Component.pendingLayouts) {
                d.getScrollable().setX(true)
            }
            if (i) {
                e.ignoreMousewheel = d.scrollFlags.y
            }
        } else {
            h.hide();
            c.flex = 1;
            delete c.width;
            c.removeCls(e.lockedGridCls);
            c.show();
            e.ignoreMousewheel = true
        }
        Ext.resumeLayouts(true);
        return [g, a]
    },
    onLockedHeaderSortChange: Ext.emptyFn,
    onNormalHeaderSortChange: Ext.emptyFn,
    lock: function (g, l, e) {
        var i = this, h = i.normalGrid, c = i.lockedGrid, d = h.view, m = c.view, k = h.headerCt, j, a, b;
        g = g || k.getMenu().activeHeader;
        b = g.hasFocus;
        e = e || c.headerCt;
        a = g.ownerCt;
        if (!g.isLockable()) {
            return
        }
        if (g.flex && c.shrinkWrapColumns) {
            g.width = g.getWidth();
            g.flex = null
        }
        Ext.suspendLayouts();
        if (c.hidden) {
            c.show()
        }
        d.blockRefresh = m.blockRefresh = true;
        g.ownerCmp = g.ownerCt;
        a.remove(g, false);
        g.locked = true;
        if (Ext.isDefined(l)) {
            e.insert(l, g)
        } else {
            e.add(g)
        }
        d.blockRefresh = m.blockRefresh = false;
        g.ownerCmp = null;
        j = i.syncLockedWidth();
        if (j[0]) {
            c.getView().refreshView()
        }
        if (j[1]) {
            h.getView().refreshView()
        }
        i.fireEvent("lockcolumn", i, g);
        Ext.resumeLayouts(true);
        if (b) {
            g.focus()
        }
    },
    unlock: function (e, k, d) {
        var h = this, g = h.normalGrid, b = h.lockedGrid, c = g.view, l = b.view, j = b.headerCt, i, a;
        if (!Ext.isDefined(k)) {
            k = 0
        }
        e = e || j.getMenu().activeHeader;
        a = e.hasFocus;
        d = d || g.headerCt;
        Ext.suspendLayouts();
        c.blockRefresh = l.blockRefresh = true;
        e.ownerCmp = e.ownerCt;
        e.ownerCt.remove(e, false);
        e.locked = false;
        d.insert(k, e);
        c.blockRefresh = l.blockRefresh = false;
        e.ownerCmp = null;
        i = h.syncLockedWidth();
        if (i[0]) {
            b.getView().refreshView()
        }
        if (i[1]) {
            g.getView().refreshView()
        }
        h.fireEvent("unlockcolumn", h, e);
        Ext.resumeLayouts(true);
        if (a) {
            e.focus()
        }
    },
    reconfigureLockable: function (b, c) {
        var d = this, h = d.store, g = d.lockedGrid, e = d.normalGrid, a;
        if (b && b !== h) {
            b = Ext.data.StoreManager.lookup(b);
            d.store = b;
            g.view.blockRefresh = e.view.blockRefresh = true;
            g.bindStore(b);
            a = g.view;
            a.store = b;
            if (!a.dataSource.isFeatureStore) {
                a.dataSource = b
            }
            if (a.bufferedRenderer) {
                a.bufferedRenderer.bindStore(b)
            }
            e.bindStore(b);
            a = e.view;
            a.store = b;
            if (!a.dataSource.isFeatureStore) {
                a.dataSource = b
            }
            if (a.bufferedRenderer) {
                a.bufferedRenderer.bindStore(b)
            }
            d.view.store = b;
            d.view.bindStore(e.view.dataSource, false, "dataSource");
            g.view.blockRefresh = e.view.blockRefresh = false
        }
        if (c) {
            g.reconfiguring = e.reconfiguring = true;
            g.headerCt.removeAll();
            e.headerCt.removeAll();
            c = d.processColumns(c, g);
            g.headerCt.add(c.locked.items);
            e.headerCt.add(c.normal.items);
            g.reconfiguring = e.reconfiguring = false;
            d.syncLockedWidth()
        }
        d.refreshCounter = g.view.refreshCounter
    },
    afterReconfigureLockable: function () {
        var a = this.lockedGrid.getView();
        if (this.refreshCounter === a.refreshCounter) {
            this.view.refresh()
        }
    },
    constructLockableFeatures: function () {
        var e = this.features, c, d, g, h, b = 0, a;
        if (e) {
            if (!Ext.isArray(e)) {
                e = [e]
            }
            g = [];
            h = [];
            a = e.length;
            for (; b < a; b++) {
                c = e[b];
                if (!c.isFeature) {
                    c = Ext.create("feature." + c.ftype, c)
                }
                switch (c.lockableScope) {
                    case"locked":
                        g.push(c);
                        break;
                    case"normal":
                        h.push(c);
                        break;
                    default:
                        c.lockableScope = "both";
                        g.push(c);
                        h.push(d = c.clone());
                        d.lockingPartner = c;
                        c.lockingPartner = d
                }
            }
        }
        return {normalFeatures: h, lockedFeatures: g}
    },
    constructLockablePlugins: function () {
        var c = this.plugins, h, b, a, k, l, e, g = 0, j, m, d;
        if (c) {
            if (!Ext.isArray(c)) {
                c = [c]
            }
            k = [];
            l = [];
            e = [];
            j = c.length;
            for (; g < j; g++) {
                h = c[g];
                if (h.init) {
                    m = h.lockableScope
                } else {
                    d = h.ptype ? Ext.ClassManager.getByAlias(("plugin." + h.ptype)) : Ext.ClassManager.get(h.xclass);
                    m = d.prototype.lockableScope
                }
                switch (m) {
                    case"both":
                        l.push(a = h.clonePlugin());
                        e.push(b = h.clonePlugin());
                        a.lockingPartner = b;
                        b.lockingPartner = a;
                        Ext.destroy(h);
                        break;
                    case"locked":
                        l.push(h);
                        break;
                    case"normal":
                        e.push(h);
                        break;
                    default:
                        k.push(h)
                }
            }
        }
        return {topPlugins: k, normalPlugins: e, lockedPlugins: l}
    },
    destroyLockable: function () {
        var b = this, a = b.syncLockedWidthTask;
        if (a) {
            a.cancel();
            b.syncLockedWidthTask = null
        }
        if (b.lockedGrid && b.lockedGrid.headerCt) {
            b.lockedGrid.headerCt.showMenuBy = null
        }
        if (b.normalGrid && b.normalGrid.headerCt) {
            b.normalGrid.headerCt.showMenuBy = null
        }
        Ext.destroy(b.view, b.headerCt)
    }
}, 0, 0, 0, 0, 0, 0, [Ext.grid.locking, "Lockable", Ext.grid, "Lockable"], function () {
    this.borrow(Ext.Component, ["constructPlugin"])
}));
(Ext.cmd.derive("Ext.grid.plugin.BufferedRenderer", Ext.AbstractPlugin, {
    isBufferedRenderer: true,
    lockableScope: "both",
    numFromEdge: 2,
    trailingBufferZone: 10,
    leadingBufferZone: 20,
    synchronousRender: true,
    scrollToLoadBuffer: 200,
    viewSize: 100,
    rowHeight: 21,
    position: 0,
    lastScrollDirection: 1,
    bodyTop: 0,
    scrollHeight: 0,
    loadId: 0,
    init: function (c) {
        var d = this, a = c.view, b = {
            scroll: d.onViewScroll,
            scrollend: d.onViewScrollEnd,
            resize: d.onViewResize,
            refresh: d.onViewRefresh,
            columnschanged: d.checkVariableRowHeight,
            boxready: d.onViewBoxReady,
            scope: d,
            destroyable: true
        }, e = a.initialConfig;
        if (c.isTree || (c.ownerLockable && c.ownerLockable.isTree)) {
            a.blockRefresh = false;
            if (e && e.loadMask === undefined) {
                a.loadMask = true
            }
        }
        if (a.positionBody) {
            b.refresh = d.onViewRefresh
        }
        d.grid = c;
        d.view = a;
        d.isRTL = a.getInherited().rtl;
        a.bufferedRenderer = d;
        a.preserveScrollOnRefresh = true;
        a.animate = false;
        d.bindStore(a.dataSource);
        if (a.hasOwnProperty("rowHeight")) {
            d.rowHeight = a.rowHeight
        }
        d.position = 0;
        d.gridListeners = c.on({reconfigure: "onReconfigure", scope: d, destroyable: true});
        d.viewListeners = a.on(b)
    },
    checkVariableRowHeight: function () {
        var b = this, a = b.grid;
        b.variableRowHeight = b.view.hasVariableRowHeight();
        if (a.ownerLockable) {
            a.ownerLockable.syncRowHeight = b.variableRowHeight
        }
    },
    bindStore: function (c) {
        var d = this, b = d.view, e = b.dataSource, a = e && e.isFeatureStore;
        if (a === c.isFeatureStore) {
            if (d.store) {
                d.unbindStore()
            }
            d.storeListeners = c.on({
                scope: d,
                groupchange: d.onStoreGroupChange,
                clear: d.onStoreClear,
                beforeload: d.onBeforeStoreLoad,
                load: d.onStoreLoad,
                destroyable: true
            });
            d.store = c
        }
        if (d.view.componentLayout.layoutCount) {
            delete d.viewSize;
            if (c.isBufferedStore) {
                c.setViewSize(d.viewSize)
            }
            d.onViewResize(d.view, 0, d.view.getHeight())
        }
    },
    onReconfigure: function (b, a) {
        if (a && a !== this.store) {
            this.bindStore(a)
        }
    },
    unbindStore: function () {
        this.storeListeners.destroy();
        this.storeListeners = this.store = null
    },
    onBeforeStoreLoad: function (b) {
        var c = this, a = c.view;
        if (a && a.refreshCounter) {
            if (b.isTreeStore || a.preserveScrollOnReload) {
                c.nextRefreshStartIndex = a.all.startIndex
            } else {
                if (c.scrollTop !== 0) {
                    c.setBodyTop(c.bodyTop = c.scrollTop = c.position = c.scrollHeight = c.nextRefreshStartIndex = 0);
                    a.setScrollY(0)
                }
            }
            c.lastScrollDirection = c.scrollOffset = null;
            if (!a.hasOwnProperty("rowHeight")) {
                delete c.rowHeight
            }
        }
        c.disable()
    },
    onStoreLoad: function () {
        this.enable()
    },
    onStoreClear: function () {
        var b = this, a = b.view;
        if (a.rendered && !b.store.destroyed) {
            if (b.scrollTop !== 0) {
                b.bodyTop = b.scrollTop = b.position = b.scrollHeight = 0;
                b.nextRefreshStartIndex = null;
                a.setScrollY(0)
            }
            a.refresh();
            b.lastScrollDirection = b.scrollOffset = null;
            if (!a.hasOwnProperty("rowHeight")) {
                delete b.rowHeight
            }
        }
    },
    onStoreGroupChange: function (a) {
        this.refreshSize()
    },
    onViewBoxReady: function (a) {
        this.refreshScroller(a, this.scrollHeight)
    },
    onViewRefresh: function (b, c) {
        var d = this, e = b.all, a;
        d.checkVariableRowHeight();
        if (!b.componentLayoutCounter && (b.headerCt.down("{flex}") || d.variableRowHeight)) {
            b.on({boxready: Ext.Function.pass(d.onViewRefresh, [b, c], d), single: true});
            d.skipNextRefreshSize = true;
            return
        }
        d.skipNextRefreshSize = false;
        if (!b.hasOwnProperty("rowHeight") && e.getCount()) {
            delete d.rowHeight
        }
        d.refreshSize();
        if (d.refreshing) {
            return
        }
        if (d.scrollTop !== b.getScrollY()) {
            d.onViewScroll();
            d.onViewScrollEnd()
        } else {
            if (!d.hasOwnProperty("bodyTop")) {
                d.bodyTop = e.startIndex * d.rowHeight;
                b.setScrollY(d.bodyTop)
            }
            d.setBodyTop(d.bodyTop);
            a = b.getHeight();
            if (e.getCount() && a > 0) {
                d.onViewResize(b, null, a);
                if (c && (e.getCount() !== c.length)) {
                    c.length = 0;
                    c.push.apply(c, d.store.getRange(e.startIndex, e.endIndex))
                }
            }
        }
    },
    refreshSize: function () {
        var b = this, a = b.view, c = b.skipNextRefreshSize;
        b.skipNextRefreshSize = false;
        if (c) {
            return
        }
        b.scrollHeight = b.getScrollHeight();
        b.stretchView(a, b.scrollHeight)
    },
    onViewResize: function (c, e, a, b, h) {
        var g = this, d;
        if (!h || a !== h) {
            d = Math.ceil(a / g.rowHeight) + g.trailingBufferZone + g.leadingBufferZone;
            g.viewSize = g.setViewSize(d);
            g.viewClientHeight = c.el.dom.clientHeight
        }
    },
    onWrappedColumnWidthChange: function (b, d) {
        var c = this, a = c.view;
        if (c.store.getCount() && c.bodyTop) {
            c.refreshSize();
            c.setViewSize(Math.ceil(a.getHeight() / c.rowHeight) + c.trailingBufferZone + c.leadingBufferZone);
            if (c.viewSize >= c.store.getCount()) {
                c.setBodyTop(0)
            } else {
                if (d > b && c.bodyTop + a.body.dom.offsetHeight - 1 > c.scrollHeight) {
                    c.setBodyTop(Math.max(0, c.scrollHeight - a.body.dom.offsetHeight))
                } else {
                    if (c.bodyTop > c.scrollTop || c.bodyTop + a.body.dom.offsetHeight < c.scrollTop + a.getHeight(true)) {
                        c.setBodyTop(c.scrollTop - c.trailingBufferZone * c.rowHeight)
                    }
                }
            }
        }
    },
    stretchView: function (b, a) {
        var e = this, d = e.store.getCount(), c, g;
        if (e.scrollTop > a) {
            e.position = e.scrollTop = Math.max(a - b.body.dom.offsetHeight, 0);
            b.setScrollY(e.scrollTop)
        }
        if (e.bodyTop > a) {
            b.body.translate(null, e.bodyTop = e.position)
        }
        if (b.touchScroll) {
            if (b.getScrollable()) {
                e.refreshScroller(b, a)
            } else {
                if (!e.pendingScrollerRefresh) {
                    b.on({
                        boxready: function () {
                            e.refreshScroller(b, a);
                            e.pendingScrollerRefresh = false
                        }, single: true
                    });
                    e.pendingScrollerRefresh = true
                }
            }
        }
        if (!Ext.supports.touchScroll || Ext.supports.touchScroll === 1) {
            if (!e.stretcher) {
                c = b.getTargetEl();
                if (b.refreshCounter) {
                    b.fixedNodes++
                }
                g = {
                    role: "presentation",
                    style: {width: "1px", height: "1px", marginTop: (a - 1) + "px", position: "absolute"}
                };
                g.style[e.isRTL ? "right" : "left"] = 0;
                e.stretcher = c.createChild(g, c.dom.firstChild)
            }
            if (e.hasOwnProperty("viewSize") && d <= e.viewSize) {
                e.stretcher.dom.style.display = "none"
            } else {
                e.stretcher.dom.style.marginTop = (a - 1) + "px";
                e.stretcher.dom.style.display = ""
            }
        }
    },
    refreshScroller: function (c, b) {
        var a = c.getScrollable();
        if (c.touchScroll === 2 && a) {
            a.setElementSize();
            a.setSize({x: c.headerCt.getTableWidth(), y: b});
            if (c.touchScroll === 2) {
                a.setRefreshOnIdle(false)
            }
        }
    },
    setViewSize: function (p, c) {
        var o = this, s = o.store, q = o.view, t = q.all, g = t.getCount(), b, e,
            m = o.view.lockingPartner && o.view.lockingPartner.bufferedRenderer, r = g - p, k, h, d, a, l, n;
        if (m && !c && m.view.componentLayoutCounter) {
            if (m.viewSize > p) {
                p = m.viewSize
            } else {
                m.setViewSize(p, true)
            }
        }
        r = g - p;
        if (r) {
            o.scrollTop = q.getScrollY();
            o.viewSize = p;
            if (s.isBufferedStore) {
                s.setViewSize(p)
            }
            if (g) {
                n = s.getCount();
                b = t.startIndex;
                e = Math.min(b + p - 1, n - 1);
                if (b === t.startIndex && e === t.endIndex) {
                    if (r < 0) {
                        o.handleViewScroll(-1)
                    }
                } else {
                    if (m) {
                        m.disable()
                    }
                    if (r < 0) {
                        if (n > g) {
                            s.getRange(t.endIndex + 1, e, {
                                callback: function (i, j) {
                                    l = q.doAdd(i, j);
                                    q.fireEvent("itemadd", i, j, l)
                                }
                            })
                        } else {
                            o.refreshView(0)
                        }
                    } else {
                        b = t.endIndex - (r - 1);
                        e = t.endIndex;
                        a = t.slice(b, e + 1);
                        t.removeRange(b, e, true);
                        if (q.hasListeners.itemremove) {
                            d = s.getRange(b, e);
                            for (k = e, h = d.length - 1; h >= 0; --k, --h) {
                                q.fireEvent("itemremove", d[h], k, a[h])
                            }
                        }
                    }
                    if (m) {
                        m.enable()
                    }
                }
            }
        }
        return p
    },
    getViewRange: function () {
        var b = this, c = b.view.all, a = b.store, d = 0;
        if (c.getCount()) {
            d = c.startIndex
        } else {
            if (a.isBufferedStore) {
                if (!a.currentPage) {
                    a.currentPage = 1
                }
                d = c.startIndex = (a.currentPage - 1) * (a.pageSize || 1);
                a.currentPage = 1
            }
        }
        if (a.data.getCount()) {
            return a.getRange(d, d + (b.viewSize || a.defaultViewSize) - 1)
        } else {
            return []
        }
    },
    onReplace: function (j, k, e, g) {
        var h = this, i = h.view, m = i.all, a, d = m.getCount(), c = k + e.length - 1, l = g.length - e.length,
            b = l * h.rowHeight;
        if (k >= m.startIndex + h.viewSize) {
            h.refreshSize();
            return
        }
        if (d && c < m.startIndex && m.getCount() >= h.viewSize) {
            m.moveBlock(l);
            h.refreshSize();
            a = m.startIndex;
            if (l > 0) {
                h.doNotMirror = true;
                h.handleViewScroll(-1);
                h.doNotMirror = false
            }
            if (m.startIndex === a) {
                if (m.startIndex) {
                    h.setBodyTop(h.bodyTop += b);
                    i.suspendEvent("scroll");
                    i.scrollBy(0, b);
                    i.resumeEvent("scroll");
                    h.position = h.scrollTop = i.getScrollY()
                }
            } else {
                i.suspendEvent("scroll");
                i.scrollBy(0, (a - m.startIndex) * h.rowHeight);
                i.resumeEvent("scroll")
            }
            i.refreshSize(m.getCount() !== d);
            return
        }
        if (d && k > m.endIndex) {
            h.refreshSize();
            if (l > 0) {
                h.onRangeFetched(null, m.startIndex, Math.min(j.getCount(), m.startIndex + h.viewSize) - 1, null, true)
            }
            i.refreshSize(m.getCount() !== d);
            return
        }
        if (k < m.startIndex && c <= m.endIndex) {
            h.refreshView(m.startIndex - e.length + g.length);
            return
        }
        if (k < m.startIndex && c <= m.endIndex && b) {
            i.suspendEvent("scroll");
            i.setScrollY(h.position = h.scrollTop += b);
            i.resumeEvent("scroll")
        }
        h.refreshView()
    },
    scrollTo: function (r, d) {
        var b = arguments, w = this, o = w.view,
            n = o.lockingPartner && o.lockingPartner.grid.isVisible() && o.lockingPartner.bufferedRenderer,
            t = o.el.dom, m = w.store, y = m.getCount(), l, x, g, e, q, u, c, v, k = 0, s, p, j, h, i, a;
        if (d && typeof d === "object") {
            s = d.select;
            p = d.focus;
            h = d.highlight;
            j = d.animate;
            i = d.callback;
            a = d.scope
        } else {
            s = b[1];
            i = b[2];
            a = b[3]
        }
        if ((q = o.dataSource.groupingFeature) && (q.collapsible)) {
            if (r.isEntity) {
                c = r
            } else {
                c = o.store.getAt(Math.min(Math.max(r, 0), o.store.getCount() - 1))
            }
            u = q.getMetaGroup(c);
            if (u && u.isCollapsed) {
                if (!q.isExpandingOrCollapsing) {
                    q.expand(q.getGroup(c).getGroupKey());
                    y = m.getCount();
                    r = q.indexOf(c)
                } else {
                    c = u.placeholder;
                    r = q.indexOfPlaceholder(c)
                }
            } else {
                r = q.indexOf(c)
            }
        } else {
            if (r.isEntity) {
                c = r;
                r = m.indexOf(c);
                if (r === -1) {
                    return
                }
            } else {
                r = Math.min(Math.max(r, 0), y - 1);
                c = m.getAt(r)
            }
        }
        if (c && (g = o.getNode(c))) {
            o.getScrollable().scrollIntoView(g, null, j, h);
            w.onViewScroll();
            w.onViewScrollEnd();
            if (s) {
                o.selModel.select(c)
            }
            if (p) {
                o.getNavigationModel().setPosition(c, 0)
            }
            if (i) {
                i.call(a || w, r, c, g)
            }
            return
        }
        if (r < o.all.startIndex) {
            v = -1;
            l = Math.max(Math.min(r - (Math.floor((w.leadingBufferZone + w.trailingBufferZone) / 2)), y - w.viewSize + 1), 0);
            x = Math.min(l + w.viewSize - 1, y - 1)
        } else {
            v = 1;
            x = Math.min(r + (Math.floor((w.leadingBufferZone + w.trailingBufferZone) / 2)), y - 1);
            l = Math.max(x - (w.viewSize - 1), 0)
        }
        e = Math.max(l * w.rowHeight, 0);
        m.getRange(l, x, {
            callback: function (B, C, A) {
                var z = o.getScrollable();
                w.renderRange(C, A, true, true);
                c = m.data.getRange(r, r + 1)[0];
                g = o.getNode(c);
                o.body.translate(null, w.bodyTop = e);
                if (v === 1) {
                    w.refreshSize()
                }
                if (n) {
                    n.renderRange(C, A, true, true);
                    w.syncRowHeights();
                    n.view.body.translate(null, n.bodyTop = e);
                    if (v === 1) {
                        n.refreshSize()
                    }
                }
                if (!g) {
                    return
                }
                if (v === 1) {
                    k = t.clientHeight - g.offsetHeight
                }
                w.position = w.scrollTop = Math.min(Math.max(0, e - o.body.getOffsetsTo(g)[1]) - k, z.getSize().y - t.clientHeight);
                if (n) {
                    n.position = n.scrollTop = w.scrollTop
                }
                z.scrollIntoView(g, null, j, h);
                if (s) {
                    o.selModel.select(c)
                }
                if (p) {
                    o.getNavigationModel().setPosition(c, 0)
                }
                if (i) {
                    i.call(a || w, r, c, g)
                }
            }
        })
    },
    onViewScroll: function () {
        var d = this, b = d.store, a = (b.getCount()), c, g, e = d.scrollTop = d.view.getScrollY();
        d.view.body.dom.style.pointerEvents = "none";
        if (!(d.disabled || a < d.viewSize)) {
            c = e - d.position;
            g = c > 0 ? 1 : -1;
            if (Math.abs(c) >= 20 || (g !== d.lastScrollDirection)) {
                d.lastScrollDirection = g;
                d.handleViewScroll(d.lastScrollDirection)
            }
        }
    },
    onViewScrollEnd: function () {
        this.view.body.dom.style.pointerEvents = ""
    },
    handleViewScroll: function (h) {
        var e = this, g = e.view.all, a = e.store, i = e.viewSize, c = (a.getCount()) - 1, d, b;
        if (h === -1) {
            if (g.startIndex) {
                if (e.topOfViewCloseToEdge()) {
                    d = Math.max(0, e.getLastVisibleRowIndex() + e.trailingBufferZone - i)
                }
            }
        } else {
            if (g.endIndex < c) {
                if (e.bottomOfViewCloseToEdge()) {
                    d = Math.max(0, e.getFirstVisibleRowIndex() - e.trailingBufferZone)
                }
            }
        }
        if (d == null) {
            e.loadId++
        } else {
            b = Math.min(d + i - 1, c);
            if (e.variableRowHeight && b === g.endIndex && b < c) {
                b++;
                e.viewSize = i++;
                if (a.isBufferedStore) {
                    a.setViewSize(e.viewSize)
                }
            }
            if (d !== g.startIndex || b !== g.endIndex) {
                e.renderRange(d, b);
                return true
            }
        }
    },
    bottomOfViewCloseToEdge: function () {
        var a = this;
        if (a.variableRowHeight) {
            return a.bodyTop + a.view.body.dom.offsetHeight < a.scrollTop + a.view.lastBox.height + (a.numFromEdge * a.rowHeight)
        } else {
            return (a.view.all.endIndex - a.getLastVisibleRowIndex()) < a.numFromEdge
        }
    },
    topOfViewCloseToEdge: function () {
        var a = this;
        if (a.variableRowHeight) {
            return a.bodyTop > a.scrollTop - (a.numFromEdge * a.rowHeight)
        } else {
            return (a.getFirstVisibleRowIndex() - a.view.all.startIndex) < a.numFromEdge
        }
    },
    refreshView: function (g) {
        var c = this, i = c.viewSize, e = c.view.all, a = c.store, h = a.getCount(), b = Math.max(0, h - 1), d;
        if (!h) {
            return c.doRefreshView([], 0, 0)
        } else {
            if (h < i) {
                g = 0;
                d = b
            } else {
                if (g == null) {
                    if (c.nextRefreshStartIndex != null) {
                        g = c.nextRefreshStartIndex;
                        c.nextRefreshStartIndex = null
                    } else {
                        g = e.startIndex
                    }
                }
                g = Math.max(0, Math.min(g, b - (i - c.leadingBufferZone) + 1));
                d = Math.min(g + i - 1, b);
                if (d - g + 1 > i) {
                    g = d - i + 1
                }
            }
        }
        if (g === 0 && d === 0 && h === 0) {
            c.doRefreshView([], 0, 0)
        } else {
            a.getRange(g, d, {callback: c.doRefreshView, scope: c})
        }
    },
    doRefreshView: function (n, h, c, e) {
        var s = this, m = s.view, d = m.getNavigationModel(), r = d.getPosition(), k = m.all, q = k.startIndex,
            g = k.endIndex, i, a, b = k.getCount(), l, j = h !== k.startIndex, p, o;
        if (m.refreshCounter) {
            if (m.hasListeners.beforerefresh && m.fireEvent("beforerefresh", m) === false) {
                return
            }
            m.refreshing = s.refreshing = true;
            if (r && r.view === m) {
                if (r.rowIdx < h || r.rowIdx > c) {
                    r = null
                } else {
                    r = r.clone()
                }
                d.setPosition()
            } else {
                r = null
            }
            m.clearViewEl(true);
            m.refreshCounter++;
            if (n.length) {
                l = m.doAdd(n, h);
                if (j) {
                    i = k.item(q, true);
                    a = k.item(g, true);
                    if (i) {
                        o = -i.offsetTop
                    } else {
                        if (a) {
                            o = k.last(true).offsetTop - a.offsetTop
                        }
                    }
                    if (o) {
                        s.bodyTop = Math.max(s.bodyTop + o, 0);
                        s.scrollTop = s.bodyTop ? s.scrollTop + o : 0
                    } else {
                        s.bodyTop = p = h * s.rowHeight;
                        s.scrollTop = Math.max(p - s.rowHeight * (p < s.bodyTop ? s.leadingBufferZone : s.trailingBufferZone, 0))
                    }
                }
            } else {
                if (s.scrollTop) {
                    s.bodyTop = s.scrollTop = 0
                }
                m.addEmptyText()
            }
            if (j) {
                s.setBodyTop(s.bodyTop);
                m.suspendEvent("scroll");
                m.setScrollY(s.position = s.scrollTop);
                m.resumeEvent("scroll")
            }
            s.refreshSize();
            m.refreshSize(k.getCount() !== b);
            m.fireEvent("refresh", m, n);
            if (r) {
                m.cellFocused = true;
                d.setPosition(r, null, null, null, true)
            }
            m.headerCt.setSortState();
            m.refreshNeeded = m.refreshing = s.refreshing = false
        } else {
            m.refresh()
        }
    },
    renderRange: function (h, a, g, c) {
        var d = this, e = d.view.all, b = d.store;
        if (!(h === e.startIndex && a === e.endIndex)) {
            if (b.rangeCached(h, a)) {
                d.cancelLoad();
                if (d.synchronousRender || g) {
                    d.onRangeFetched(null, h, a, null, c)
                } else {
                    if (!d.renderTask) {
                        d.renderTask = new Ext.util.DelayedTask(d.onRangeFetched, d, null, false)
                    }
                    d.renderTask.delay(1, null, null, [null, h, a, null, c])
                }
            } else {
                d.attemptLoad(h, a)
            }
        }
    },
    onRangeFetched: function (q, h, e, d, s) {
        var z = this, p = z.view, l = p.el, c, o = p.all, k, y = 0, v, m,
            n = (p.lockingPartner && !s && !z.doNotMirror) && p.lockingPartner.bufferedRenderer, w, b, x, a, u,
            t = z.variableRowHeight, g, r, j;
        if (p.destroyed) {
            return
        }
        if (q) {
            z.scrollTop = z.view.getScrollY()
        } else {
            q = z.store.getRange(h, e);
            if (!q) {
                return
            }
        }
        g = Ext.Element.getActiveElement();
        r = l.contains(g);
        v = h * z.rowHeight;
        if (h < o.startIndex && e > o.endIndex) {
            x = o.startIndex - h;
            p.clearViewEl(true);
            w = p.doAdd(q, h);
            p.fireEvent("itemadd", q, h, w);
            for (u = 0; u < x; u++) {
                y -= w[u].offsetHeight
            }
            m = z.bodyTop + y
        } else {
            if (z.teleported || h > o.endIndex || e < o.startIndex) {
                m = v;
                if (t) {
                    a = z.scrollTop < z.position ? z.leadingBufferZone : z.trailingBufferZone;
                    if (h > a) {
                        m = z.scrollTop - z.rowHeight * a
                    }
                }
                p.clearViewEl(true);
                z.teleported = false
            }
            if (!o.getCount()) {
                w = p.doAdd(q, h);
                p.fireEvent("itemadd", q, h, w)
            } else {
                if (e > o.endIndex) {
                    k = Math.max(h - o.startIndex, 0);
                    if (t) {
                        y = o.item(o.startIndex + k, true).offsetTop
                    }
                    w = o.scroll(Ext.Array.slice(q, o.endIndex + 1 - h), 1, k);
                    if (t) {
                        m = z.bodyTop + y
                    } else {
                        m = v
                    }
                } else {
                    k = Math.max(o.endIndex - e, 0);
                    c = o.startIndex;
                    w = o.scroll(Ext.Array.slice(q, 0, o.startIndex - h), -1, k);
                    if (t) {
                        m = z.bodyTop - o.item(c, true).offsetTop;
                        if (!o.startIndex) {
                            if (m) {
                                p.setScrollY(z.position = (z.scrollTop -= m));
                                m = 0
                            }
                        } else {
                            if (m < 0) {
                                y = o.startIndex * z.rowHeight;
                                p.setScrollY(z.position = (z.scrollTop += y));
                                m = z.bodyTop + y
                            }
                        }
                    } else {
                        m = v
                    }
                }
            }
            z.position = z.scrollTop
        }
        if (r && !l.contains(g)) {
            j = p.actionableMode ? p.actionPosition : p.lastFocused;
            if (j && j.column) {
                p.onFocusLeave({});
                j.column.focus()
            }
        }
        m = Math.max(Math.floor(m), 0);
        if (p.positionBody) {
            z.setBodyTop(m)
        }
        if (w && n && !n.disabled) {
            n.scrollTop = n.position = z.scrollTop;
            b = n.onRangeFetched(null, h, e, d, true);
            if (n.bodyTop !== m) {
                n.setBodyTop(m)
            }
            n.view.setScrollY(z.scrollTop);
            if (t && p.ownerGrid.syncRowHeights) {
                z.syncRowHeights(w, b)
            }
        }
        return w
    },
    syncRowHeights: function (g, a) {
        var j = this, h = 0, l = 1, k = [], b = [], d = Ext.grid.locking.RowSynchronizer, c, e;
        if (g && a) {
            h = g.length;
            l = a.length
        }
        if (h !== l) {
            g = j.view.all.slice();
            a = j.view.lockingPartner.all.slice();
            h = l = g.length
        }
        for (c = 0; c < h; c++) {
            k[c] = e = new d(j.view, g[c]);
            e.measure()
        }
        for (c = 0; c < l; c++) {
            b[c] = e = new d(j.view.lockingPartner, a[c]);
            e.measure()
        }
        for (c = 0; c < h; c++) {
            k[c].finish(b[c]);
            b[c].finish(k[c])
        }
        j.syncRowHeightsFinish()
    },
    syncRowHeightsFinish: function () {
        var c = this, a = c.view, b = a.lockingPartner.bufferedRenderer;
        delete c.rowHeight;
        c.refreshSize();
        if (b.rowHeight !== c.rowHeight) {
            delete b.rowHeight;
            b.refreshSize()
        }
    },
    setBodyTop: function (d) {
        var e = this, b = e.view, c = e.store, a = b.body;
        if (!a.dom) {
            return
        }
        e.translateBody(a, d);
        if (e.variableRowHeight) {
            if (b.all.endIndex === (c.getCount()) - 1) {
                e.stretchView(b, e.scrollHeight = e.bodyTop + a.dom.offsetHeight - 1)
            } else {
                if (e.bodyTop + a.dom.offsetHeight - 1 > e.scrollHeight) {
                    e.stretchView(b, e.scrollHeight += ((c.getCount()) - b.all.endIndex) * e.rowHeight)
                }
            }
        }
    },
    translateBody: function (a, b) {
        a.translate(null, this.bodyTop = b)
    },
    getFirstVisibleRowIndex: function (k, c, b, g) {
        var h = this, i = h.view, m = i.all, a = m.elements, d = h.viewClientHeight, e, l, j = h.bodyTop;
        if (m.getCount() && h.variableRowHeight) {
            if (!arguments.length) {
                k = m.startIndex;
                c = m.endIndex;
                b = h.scrollTop;
                g = b + d;
                if (j > g || j + i.body.dom.offsetHeight < b) {
                    h.teleported = true;
                    return Math.floor(h.scrollTop / h.rowHeight)
                }
                e = k + Math.min(h.numFromEdge + ((h.lastScrollDirection === -1) ? h.leadingBufferZone : h.trailingBufferZone), Math.floor((c - k) / 2))
            } else {
                e = k + Math.floor((c - k) / 2)
            }
            l = j + a[e].offsetTop;
            if (l + a[e].offsetHeight <= b) {
                return h.getFirstVisibleRowIndex(e + 1, c, b, g)
            }
            if (l <= b) {
                return e
            } else {
                if (e !== k) {
                    return h.getFirstVisibleRowIndex(k, e - 1, b, g)
                }
            }
        }
        return Math.floor(h.scrollTop / h.rowHeight)
    },
    getLastVisibleRowIndex: function (l, c, b, g) {
        var i = this, j = i.view, n = j.all, a = n.elements, d = i.viewClientHeight, e, m, h, k = i.bodyTop;
        if (n.getCount() && i.variableRowHeight) {
            if (!arguments.length) {
                l = n.startIndex;
                c = n.endIndex;
                b = i.scrollTop;
                g = b + d;
                if (k > g || k + j.body.dom.offsetHeight < b) {
                    i.teleported = true;
                    return Math.floor(i.scrollTop / i.rowHeight) + Math.ceil(d / i.rowHeight)
                }
                e = c - Math.min(i.numFromEdge + ((i.lastScrollDirection === 1) ? i.leadingBufferZone : i.trailingBufferZone), Math.floor((c - l) / 2))
            } else {
                e = l + Math.floor((c - l) / 2)
            }
            m = k + a[e].offsetTop;
            if (m > g) {
                return i.getLastVisibleRowIndex(l, e - 1, b, g)
            }
            h = m + a[e].offsetHeight;
            if (h >= g) {
                return e
            } else {
                if (e !== c) {
                    return i.getLastVisibleRowIndex(e + 1, c, b, g)
                }
            }
        }
        return i.getFirstVisibleRowIndex() + Math.ceil(d / i.rowHeight)
    },
    getScrollHeight: function () {
        var g = this, a = g.view, h = a.all, c = g.store, d = c.getCount(), b, e;
        if (!d) {
            return 0
        }
        if (!g.hasOwnProperty("rowHeight")) {
            b = h.getCount();
            if (b) {
                g.rowHeight = g.variableRowHeight ? Math.floor(a.body.dom.clientHeight / b) : h.first(true).offsetHeight
            }
        }
        e = Math.floor(d * g.rowHeight);
        if (e && (h.endIndex === d - 1)) {
            e = Math.max(e, g.bodyTop + a.body.dom.offsetHeight)
        }
        return (g.scrollHeight = e)
    },
    attemptLoad: function (c, a) {
        var b = this;
        if (b.scrollToLoadBuffer) {
            if (!b.loadTask) {
                b.loadTask = new Ext.util.DelayedTask(b.doAttemptLoad, b, [])
            }
            b.loadTask.delay(b.scrollToLoadBuffer, b.doAttemptLoad, b, [c, a])
        } else {
            b.doAttemptLoad(c, a)
        }
    },
    cancelLoad: function () {
        if (this.loadTask) {
            this.loadTask.cancel()
        }
    },
    doAttemptLoad: function (c, a) {
        var b = this;
        if (!b.destroyed) {
            b.store.getRange(c, a, {
                loadId: ++b.loadId, callback: function (e, h, d, g) {
                    if (g.loadId === b.loadId) {
                        b.onRangeFetched(e, h, d, g)
                    }
                }, fireEvent: false
            })
        }
    },
    destroy: function () {
        var b = this, a = b.view;
        b.cancelLoad();
        if (a && a.el) {
            a.un("scroll", b.onViewScroll, b)
        }
        if (b.store) {
            b.unbindStore()
        }
        Ext.destroy(b.viewListeners, b.gridListeners, b.stretcher);
        b.viewListeners = b.gridListeners = b.stretcher = null;
        b.view = b.grid = null;
        Ext.plugin.Abstract.prototype.destroy.call(this)
    }
}, 0, 0, 0, 0, ["plugin.bufferedrenderer"], 0, [Ext.grid.plugin, "BufferedRenderer"], function (a) {
    if (Ext.supports.Touch) {
        a.prototype.leadingBufferZone = a.prototype.trailingBufferZone = 2;
        a.prototype.numFromEdge = 1
    }
}));
(Ext.cmd.derive("Ext.grid.plugin.Editing", Ext.plugin.Abstract, {
    clicksToEdit: 2,
    triggerEvent: undefined,
    relayedEvents: ["beforeedit", "edit", "validateedit", "canceledit"],
    defaultFieldUI: "default",
    defaultFieldXType: "textfield",
    editStyle: "",
    constructor: function (a) {
        var b = this;
        Ext.plugin.Abstract.prototype.constructor.call(this, a);
        b.mixins.observable.constructor.call(b);
        b.on("edit", function (c, d) {
            b.fireEvent("afteredit", c, d)
        })
    },
    init: function (a) {
        var b = this, c = a.ownerLockable;
        b.grid = a;
        b.view = a.view;
        b.initEvents();
        if (a.rendered) {
            b.setup()
        } else {
            b.mon(a, {
                beforereconfigure: b.onBeforeReconfigure,
                reconfigure: b.onReconfigure,
                scope: b,
                beforerender: {fn: b.onBeforeRender, single: true, scope: b}
            })
        }
        a.editorEventRelayers = a.relayEvents(b, b.relayedEvents);
        if (c) {
            c.editorEventRelayers = c.relayEvents(b, b.relayedEvents)
        }
        a.isEditable = true;
        a.editingPlugin = a.view.editingPlugin = b
    },
    onBeforeReconfigure: function () {
        this.reconfiguring = true
    },
    onReconfigure: function () {
        this.setup();
        delete this.reconfiguring
    },
    onBeforeRender: function () {
        this.setup()
    },
    setup: function () {
        this.initFieldAccessors(this.grid.getTopLevelColumnManager().getColumns())
    },
    destroy: function () {
        var b = this, a = b.grid;
        Ext.destroy(b.keyNav);
        b.clearListeners();
        if (a) {
            if (a.ownerLockable) {
                Ext.destroy(a.ownerLockable.editorEventRelayers);
                a.ownerLockable.editorEventRelayers = null
            }
            Ext.destroy(a.editorEventRelayers);
            a.editorEventRelayers = null;
            a.editingPlugin = a.view.editingPlugin = b.grid = b.view = b.editor = b.keyNav = null
        }
        Ext.plugin.Abstract.prototype.destroy.call(this)
    },
    getEditStyle: function () {
        return this.editStyle
    },
    initFieldAccessors: function (d) {
        if (d.isGroupHeader) {
            d = d.getGridColumns()
        } else {
            if (!Ext.isArray(d)) {
                d = [d]
            }
        }
        var h = this, j, i = d.length, b = function (c, k) {
            return h.getColumnField(this, k)
        }, a = function () {
            return h.hasColumnField(this)
        }, g = function (c) {
            h.setColumnField(this, c)
        }, e;
        for (j = 0; j < i; j++) {
            e = d[j];
            if (!e.getEditor) {
                e.getEditor = b
            }
            if (!e.hasEditor) {
                e.hasEditor = a
            }
            if (!e.setEditor) {
                e.setEditor = g
            }
        }
    },
    removeFieldAccessors: function (a) {
        if (a.isGroupHeader) {
            a = a.getGridColumns()
        } else {
            if (!Ext.isArray(a)) {
                a = [a]
            }
        }
        var e, d = a.length, b;
        for (e = 0; e < d; e++) {
            b = a[e];
            b.getEditor = b.hasEditor = b.setEditor = b.field = b.editor = null
        }
    },
    getColumnField: function (c, a) {
        var b = this, d = c.field;
        if (!(d && d.isFormField)) {
            d = c.field = b.createColumnField(c, a)
        }
        if (d && d.ui === "default" && !d.hasOwnProperty("ui")) {
            d.ui = b.defaultFieldUI
        }
        return d
    },
    hasColumnField: function (a) {
        return !!(a.field && a.field.isComponent)
    },
    setColumnField: function (a, b) {
        a.field = b;
        a.field = this.createColumnField(a)
    },
    createColumnField: function (c, a) {
        var d = c.field, b;
        if (!d && c.editor) {
            d = c.editor;
            c.editor = null
        }
        if (!d && a) {
            d = a
        }
        if (d) {
            b = c.dataIndex;
            if (d.isComponent) {
                d.column = c
            } else {
                if (Ext.isString(d)) {
                    d = {name: b, xtype: d, column: c}
                } else {
                    d = Ext.apply({name: b, column: c}, d)
                }
                d = Ext.ComponentManager.create(d, this.defaultFieldXType)
            }
            d.dataIndex = b;
            d.isEditorComponent = true;
            c.field = d
        }
        return d
    },
    initEvents: function () {
        var a = this;
        a.initEditTriggers();
        a.initCancelTriggers()
    },
    initCancelTriggers: Ext.emptyFn,
    initEditTriggers: function () {
        var b = this, a = b.view;
        if (b.triggerEvent === "cellfocus") {
            b.mon(a, "cellfocus", b.onCellFocus, b)
        } else {
            if (b.triggerEvent === "rowfocus") {
                b.mon(a, "rowfocus", b.onRowFocus, b)
            } else {
                if (a.getSelectionModel().isCellModel) {
                    a.onCellFocus = b.beforeViewCellFocus.bind(b)
                }
                b.mon(a, b.triggerEvent || ("cell" + (b.clicksToEdit === 1 ? "click" : "dblclick")), b.onCellClick, b)
            }
        }
        b.initAddRemoveHeaderEvents();
        b.view.getNavigationModel().addKeyBindings({esc: b.onEscKey, scope: b})
    },
    beforeViewCellFocus: function (a) {
        if (this.view.selModel.keyNavigation || !this.editing || !this.isCellEditable || !this.isCellEditable(a.row, a.columnHeader)) {
            this.view.focusCell.apply(this.view, arguments)
        }
    },
    onRowFocus: function (a, c, b) {
        this.startEdit(c, 0)
    },
    onCellFocus: function (c, b, a) {
        this.startEdit(a.row, a.column)
    },
    onCellClick: function (j, k, c, g, l, a, i) {
        var d = j.expanderSelector, b = j.ownerCt.getColumnManager().getHeaderAtIndex(c), h = b.getEditor(g);
        if (this.shouldStartEdit(h) && (!d || !i.getTarget(d))) {
            j.ownerGrid.setActionableMode(true, i.position)
        }
    },
    initAddRemoveHeaderEvents: function () {
        var a = this, b = a.grid.headerCt;
        a.mon(b, {scope: a, add: a.onColumnAdd, columnmove: a.onColumnMove, beforedestroy: a.beforeGridHeaderDestroy})
    },
    onColumnAdd: function (a, b) {
        this.initFieldAccessors(b)
    },
    onColumnMove: Ext.emptyFn,
    onEscKey: function (b) {
        if (this.editing) {
            var a = Ext.getCmp(b.getTarget().getAttribute("componentId"));
            if (!(a && a.isPickerField && a.isExpanded)) {
                return this.cancelEdit()
            }
        }
    },
    beforeEdit: Ext.emptyFn,
    shouldStartEdit: function (a) {
        return !!a
    },
    getEditingContext: function (e, c) {
        var h = this, a = h.grid, g = a.visibleColumnManager, i, j, b, d, l, k = h.grid.lockable ? h.grid : h.view;
        if (!k.componentLayoutCounter) {
            k.on({boxready: Ext.Function.bind(h.startEdit, h, [e, c]), single: true});
            return
        }
        if (h.disabled || h.grid.collapsed || !h.grid.view.isVisible(true)) {
            return
        }
        if (Ext.isNumber(c)) {
            c = g.getHeaderAtIndex(c)
        }
        if (!c) {
            return
        }
        if (c.hidden) {
            c = c.next(":not([hidden])") || c.prev(":not([hidden])")
        }
        i = c.getView();
        a = i.ownerCt;
        j = i.getRow(e);
        if (!j) {
            return
        }
        d = g.getHeaderIndex(c);
        if (Ext.isNumber(e)) {
            b = e;
            e = i.getRecord(j)
        } else {
            b = i.indexOf(j)
        }
        if (!e) {
            return
        }
        l = new Ext.grid.CellContext(i).setAll(i, b, d, e, c);
        l.grid = a;
        l.store = i.dataSource;
        l.field = c.dataIndex;
        l.value = l.originalValue = e.get(c.dataIndex);
        l.row = j;
        l.node = i.getNode(e);
        l.cell = i.getCellByPosition(l, true);
        return l
    },
    cancelEdit: function () {
        var a = this;
        a.editing = false;
        a.fireEvent("canceledit", a, a.context)
    },
    completeEdit: function () {
        var a = this;
        if (a.editing && a.validateEdit()) {
            a.fireEvent("edit", a, a.context)
        }
        a.context = null;
        a.editing = false
    },
    validateEdit: function (a) {
        var b = this;
        return b.fireEvent("validateedit", b, a) !== false && !a.cancel
    }
}, 1, 0, 0, 0, ["editing.editing"], [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Ext.grid.plugin, "Editing"], 0));
(Ext.cmd.derive("Ext.grid.plugin.CellEditing", Ext.grid.plugin.Editing, {
    init: function (a) {
        var b = this;
        a.registerActionable(b);
        Ext.grid.plugin.Editing.prototype.init.apply(this, arguments);
        b.editors = new Ext.util.MixedCollection(false, function (c) {
            return c.editorId
        })
    }, beforeGridHeaderDestroy: function (h) {
        var g = this, c = g.grid.getColumnManager().getColumns(), a = c.length, b, e, d;
        for (b = 0; b < a; b++) {
            e = c[b];
            d = g.editors.getByKey(e.getItemId());
            if (!d) {
                d = e.editor || e.field
            }
            Ext.destroy(d);
            g.removeFieldAccessors(e)
        }
    }, onReconfigure: function (c, a, b) {
        if (b) {
            this.editors.clear()
        }
        Ext.grid.plugin.Editing.prototype.onReconfigure.call(this)
    }, destroy: function () {
        var a = this;
        if (a.editors) {
            a.editors.each(Ext.destroy, Ext);
            a.editors.clear()
        }
        Ext.grid.plugin.Editing.prototype.destroy.call(this)
    }, initCancelTriggers: function () {
        var b = this, a = b.grid;
        b.mon(a, {columnresize: b.cancelEdit, columnmove: b.cancelEdit, scope: b})
    }, isCellEditable: function (a, d) {
        var c = this, b = c.getEditingContext(a, d);
        if (b.view.isVisible(true) && b) {
            d = b.column;
            a = b.record;
            if (d && c.getEditor(a, d)) {
                return true
            }
        }
    }, activateCell: function (b) {
        var h = this, c = b.record, g = b.column, d, a, e;
        d = h.getEditingContext(c, g);
        if (!d) {
            return
        }
        if (!h.preventBeforeCheck) {
            if (!g.getEditor(c) || h.beforeEdit(d) === false || h.fireEvent("beforeedit", h, d) === false || d.cancel) {
                return
            }
        }
        e = h.getEditor(c, g);
        if (e) {
            a = d.cell;
            if (!e.rendered) {
                e.hidden = true;
                e.render(a, 0)
            } else {
                if (e.container !== a) {
                    e.container = a;
                    a.insertBefore(e.el.dom, a.firstChild)
                }
                e.hide()
            }
            h.setEditingContext(d);
            e.startEdit(a, d.value, false);
            if (e.editing) {
                h.setActiveEditor(e);
                h.setActiveRecord(c);
                h.setActiveColumn(g);
                h.editing = true;
                h.scroll = b.view.el.getScroll()
            }
            return e.editing
        }
    }, activateRow: Ext.emptyFn, deactivate: function () {
        var d = this, c = d.editors.items, a = c.length, b;
        for (b = 0; b < a; b++) {
            c[b].hide()
        }
    }, startEdit: function (a, b) {
        this.startEditByPosition(new Ext.grid.CellContext(this.view).setPosition(a, b))
    }, completeEdit: function (a) {
        var b = this.getActiveEditor();
        if (b) {
            b.completeEdit(a)
        }
    }, setEditingContext: function (a) {
        this.context = a
    }, setActiveEditor: function (a) {
        this.activeEditor = a
    }, getActiveEditor: function () {
        return this.activeEditor
    }, setActiveColumn: function (a) {
        this.activeColumn = a
    }, getActiveColumn: function () {
        return this.activeColumn
    }, setActiveRecord: function (a) {
        this.activeRecord = a
    }, getActiveRecord: function () {
        return this.activeRecord
    }, getEditor: function (a, d) {
        var g = this, e = g.editors, c = d.getItemId(), b = e.getByKey(c);
        if (!b) {
            b = d.getEditor(a);
            if (!b) {
                return false
            }
            if (b instanceof Ext.grid.CellEditor) {
                b.floating = true
            } else {
                b = new Ext.grid.CellEditor({floating: true, editorId: c, field: b})
            }
            b.field.excludeForm = true;
            if (b.column !== d) {
                b.column = d;
                b.on({scope: g, complete: g.onEditComplete, canceledit: g.cancelEdit});
                d.on("removed", g.onColumnRemoved, g)
            }
            e.add(b)
        }
        b.ownerCmp = g.grid.ownerGrid;
        if (d.isTreeColumn) {
            b.isForTree = d.isTreeColumn;
            b.addCls("x-tree-cell-editor")
        }
        b.setGrid(g.grid);
        b.editingPlugin = g;
        return b
    }, onColumnRemoved: function (b) {
        var c = this, a = c.context;
        if (a && a.column === b) {
            c.cancelEdit()
        }
        b.un("removed", c.onColumnRemoved, c)
    }, setColumnField: function (b, c) {
        var a = this.editors.getByKey(b.getItemId());
        Ext.destroy(a, b.field);
        this.editors.removeAtKey(b.getItemId());
        Ext.grid.plugin.Editing.prototype.setColumnField.apply(this, arguments)
    }, getCell: function (a, b) {
        return this.grid.getView().getCell(a, b)
    }, onEditComplete: function (d, h, c) {
        var g = this, e = d.context, b, a;
        b = e.view;
        a = e.record;
        e.value = h;
        if (!g.validateEdit(e)) {
            g.editing = false;
            return
        }
        if (!a.isEqual(h, c)) {
            a.set(e.column.dataIndex, h);
            e.rowIdx = b.indexOf(a)
        }
        g.fireEvent("edit", g, e);
        if (g.context === e) {
            g.setActiveEditor(null);
            g.setActiveColumn(null);
            g.setActiveRecord(null);
            g.editing = false
        }
    }, cancelEdit: function (c) {
        var b = this, a = b.context;
        if (c && c.isCellEditor) {
            b.context.value = ("editedValue" in c) ? c.editedValue : c.getValue();
            Ext.grid.plugin.Editing.prototype.cancelEdit.apply(this, arguments);
            if (c.context === a) {
                b.setActiveEditor(null);
                b.setActiveColumn(null);
                b.setActiveRecord(null)
            } else {
                b.editing = true
            }
        } else {
            c = b.getActiveEditor();
            if (c && c.field) {
                c.cancelEdit()
            }
        }
    }, startEditByPosition: function (b) {
        var e = this, a = e.grid.getColumnManager(), c, d = e.getActiveEditor();
        if (!b.isCellContext) {
            b = new Ext.grid.CellContext(e.view).setPosition(b.row, e.grid.getColumnManager().getColumns()[b.column])
        }
        c = a.getHeaderIndex(b.column);
        b.column = a.getVisibleHeaderClosestToIndex(c);
        if (e.grid.actionableMode) {
            if (e.editing && b.isEqual(e.context)) {
                return
            }
            if (d) {
                d.completeEdit()
            }
            if (e.activateCell(b)) {
                e.activateRow(e.view.all.item(b.rowIdx, true));
                d = e.getEditor(b.record, b.column);
                if (d) {
                    d.field.focus()
                }
            }
        } else {
            return e.grid.setActionableMode(true, b)
        }
    }
}, 0, 0, 0, 0, ["plugin.cellediting"], 0, [Ext.grid.plugin, "CellEditing"], 0));
(Ext.cmd.derive("Ext.plugin.AbstractClipboard", Ext.plugin.Abstract, {
    cachedConfig: {formats: {text: {get: "getTextData", put: "putTextData"}}},
    config: {memory: null, source: "system", system: "text"},
    destroy: function () {
        var a = this, c = a.keyMap, b = a.shared;
        if (c) {
            a.keyMap = Ext.destroy(c);
            if (!--b.counter) {
                b.textArea = Ext.destroy(b.textArea)
            }
        } else {
            a.renderListener = Ext.destroy(a.renderListener)
        }
        Ext.plugin.Abstract.prototype.destroy.call(this)
    },
    init: function (a) {
        var b = this;
        if (a.rendered) {
            this.finishInit(a)
        } else {
            b.renderListener = a.on({
                render: function () {
                    b.renderListener = null;
                    b.finishInit(a)
                }, destroyable: true, single: true
            })
        }
    },
    getTarget: function (a) {
        return a.el
    },
    privates: {
        shared: {counter: 0, data: null, textArea: null}, applyMemory: function (a) {
            a = this.applySource(a);
            return a
        }, applySource: function (a) {
            if (a) {
                if (Ext.isString(a)) {
                    a = [a]
                } else {
                    if (a.length === 0) {
                        a = null
                    }
                }
            }
            return a || null
        }, doCutCopy: function (e, b) {
            var d = this, a = d.allFormats || d.syncFormats(), h = d.getData(b, a), i = d.getMemory(),
                c = d.getSystem(), g;
            d.shared.data = i && h;
            if (c) {
                g = h[c];
                if (a[c] < 3) {
                    delete h[c]
                }
                d.setClipboardData(g)
            }
        }, doPaste: function (c, b) {
            var a = this.getFormats();
            this[a[c].put](b, c)
        }, finishInit: function (a) {
            var b = this;
            b.keyMap = new Ext.util.KeyMap({
                target: b.getTarget(a),
                binding: [{ctrl: true, key: "x", fn: b.onCut, scope: b}, {
                    ctrl: true,
                    key: "c",
                    fn: b.onCopy,
                    scope: b
                }, {ctrl: true, key: "v", fn: b.onPaste, scope: b}]
            });
            ++b.shared.counter;
            a.on({destroy: "destroy", scope: b})
        }, getData: function (d, j) {
            var e = this, a = e.getFormats(), g, c, b, h;
            if (Ext.isString(j)) {
                g = e[a[j].get](j, d)
            } else {
                g = {};
                h = [];
                if (j) {
                    for (b in j) {
                        h.push(b)
                    }
                } else {
                    h = Ext.Object.getAllKeys(a)
                }
                for (c = h.length; c-- > 0;) {
                    g[b] = e[a[b].get](b, d && !c)
                }
            }
            return g
        }, getHiddenTextArea: function () {
            var b = this.shared, a = b.textArea;
            if (!a) {
                b.textArea = a = Ext.getBody().createChild({
                    tag: "textarea",
                    tabIndex: -1,
                    style: {position: "absolute", top: "-1000px", width: "1px"}
                })
            }
            return a
        }, onCopy: function (a) {
            this.doCutCopy(a, false)
        }, onCut: function (a) {
            this.doCutCopy(a, true)
        }, onPaste: function () {
            var d = this, a = d.shared.data, e = d.getSource(), b, g, c;
            if (e) {
                for (b = 0, g = e.length; b < g; ++b) {
                    c = e[b];
                    if (c === "system") {
                        c = d.getSystem();
                        d.pasteClipboardData(c);
                        break
                    } else {
                        if (a && (c in a)) {
                            d.doPaste(c, a[c]);
                            break
                        }
                    }
                }
            }
        }, pasteClipboardData: function (e) {
            var d = this, a = window.clipboardData, c, b;
            if (a && a.getData) {
                d.doPaste(e, a.getData("text"))
            } else {
                b = Ext.Element.getActiveElement();
                c = d.getHiddenTextArea().dom;
                c.value = "";
                c.focus();
                Ext.defer(function () {
                    if (b) {
                        b.focus()
                    }
                    d.doPaste(e, c.value);
                    c.value = ""
                }, 100, d)
            }
        }, setClipboardData: function (e) {
            var a = window.clipboardData;
            if (a && a.setData) {
                a.setData("text", e)
            } else {
                var d = this, c = d.getHiddenTextArea().dom, b = Ext.Element.getActiveElement();
                c.value = e;
                c.focus();
                c.select();
                Ext.defer(function () {
                    c.value = "";
                    if (b) {
                        b.focus()
                    }
                }, 50)
            }
        }, syncFormats: function () {
            var d = this, e = {}, g = d.getMemory(), c = d.getSystem(), a, b;
            if (c) {
                e[c] = 1
            }
            if (g) {
                for (a = g.length; a-- > 0;) {
                    b = g[a];
                    e[b] = e[b] ? 3 : 2
                }
            }
            return d.allFormats = e
        }, updateMemory: function () {
            this.allFormats = null
        }, updateSystem: function () {
            this.allFormats = null
        }
    }
}, 0, 0, 0, 0, 0, 0, [Ext.plugin, "AbstractClipboard"], 0));
(Ext.cmd.derive("Ext.grid.plugin.Clipboard", Ext.plugin.AbstractClipboard, {
    formats: {cell: {get: "getCells"}, html: {get: "getCellData"}, raw: {get: "getCellData"}},
    getCellData: function (n, b) {
        var k = this.getCmp(), h = k.getSelectionModel(), i = [], m = n === "raw", g = n === "text", q, o, d, l, a, c,
            e, p, j;
        h.getSelected().eachCell(function (r) {
            c = r.column, j = r.column.getView();
            e = r.record;
            if (c.ignoreExport) {
                return
            }
            if (a !== e) {
                a = e;
                i.push(p = [])
            }
            l = c.dataIndex;
            if (m) {
                d = e.data[l]
            } else {
                q = j.all.item(r.rowIdx);
                if (!q) {
                    q = Ext.fly(j.createRowElement(e, r.rowIdx))
                }
                o = q.down(c.getCellInnerSelector());
                d = o.dom.innerHTML;
                if (g) {
                    d = Ext.util.Format.stripTags(d)
                }
            }
            p.push(d);
            if (b && l) {
                e.set(l, null)
            }
        });
        return Ext.util.TSV.encode(i)
    },
    getCells: function (i, b) {
        var g = this.getCmp(), d = g.getSelectionModel(), e = [], h, a, c, j;
        d.getSelected().eachCell(function (k) {
            c = k.record;
            if (a !== c) {
                a = c;
                e.push(j = {model: c.self, fields: []})
            }
            h = k.column.dataIndex;
            j.fields.push({name: h, value: c.data[h]});
            if (b && h) {
                c.set(h, null)
            }
        });
        return e
    },
    getTextData: function (b, a) {
        return this.getCellData(b, a)
    },
    putCellData: function (g, m) {
        var o = Ext.util.TSV.decode(g), p, q = o.length, n = q ? o[0].length : 0, h, k, j = this.getCmp().getView(),
            a = j.dataSource.getCount() - 1, e = j.getVisibleColumnManager().getColumns().length - 1,
            c = j.getNavigationModel(), i = c.getPosition(), l, b, d = {};
        if (i) {
            i = new Ext.grid.CellContext(j).setPosition(i.record, i.column)
        } else {
            i = new Ext.grid.CellContext(j).setPosition(0, 0)
        }
        b = i.colIdx;
        for (h = 0; h < q; h++) {
            p = o[h];
            for (k = 0; k < n; k++) {
                l = i.column.dataIndex;
                if (l) {
                    switch (m) {
                        case"raw":
                            d[l] = p[k];
                            break;
                        case"text":
                            d[l] = p[k];
                            break;
                        case"html":
                            break
                    }
                }
                if (i.colIdx === e) {
                    break
                }
                i.setColumn(i.colIdx + 1)
            }
            i.record.set(d);
            if (i.rowIdx === a) {
                break
            }
            i.setPosition(i.rowIdx + 1, b)
        }
    },
    putTextData: function (a, b) {
        this.putCellData(a, b)
    },
    getTarget: function (a) {
        return a.body
    }
}, 0, 0, 0, 0, ["plugin.clipboard"], 0, [Ext.grid.plugin, "Clipboard"], 0));
(Ext.cmd.derive("Ext.grid.plugin.DragDrop", Ext.plugin.Abstract, {
    dragText: "{0} selected row{1}",
    ddGroup: "GridDD",
    enableDrop: true,
    enableDrag: true,
    containerScroll: false,
    init: function (a) {
        a.on("render", this.onViewRender, this, {single: true})
    },
    destroy: function () {
        var a = this;
        a.dragZone = a.dropZone = Ext.destroy(a.dragZone, a.dropZone);
        Ext.plugin.Abstract.prototype.destroy.call(this)
    },
    enable: function () {
        var a = this;
        if (a.dragZone) {
            a.dragZone.unlock()
        }
        if (a.dropZone) {
            a.dropZone.unlock()
        }
        (arguments.callee.$previous || Ext.plugin.Abstract.prototype.enable).call(this)
    },
    disable: function () {
        var a = this;
        if (a.dragZone) {
            a.dragZone.lock()
        }
        if (a.dropZone) {
            a.dropZone.lock()
        }
        (arguments.callee.$previous || Ext.plugin.Abstract.prototype.disable).call(this)
    },
    onViewRender: function (a) {
        var b = this, c;
        if (b.enableDrag) {
            if (b.containerScroll) {
                c = a.getEl()
            }
            b.dragZone = new Ext.view.DragZone(Ext.apply({
                view: a,
                ddGroup: b.dragGroup || b.ddGroup,
                dragText: b.dragText,
                containerScroll: b.containerScroll,
                scrollEl: c
            }, b.dragZone))
        }
        if (b.enableDrop) {
            b.dropZone = new Ext.grid.ViewDropZone(Ext.apply({view: a, ddGroup: b.dropGroup || b.ddGroup}, b.dropZone))
        }
    }
}, 0, 0, 0, 0, ["plugin.gridviewdragdrop"], 0, [Ext.grid.plugin, "DragDrop"], 0));
(Ext.cmd.derive("Ext.grid.plugin.RowEditing", Ext.grid.plugin.Editing, {
    lockableScope: "top", editStyle: "row", autoCancel: true, errorSummary: true, constructor: function () {
        var a = this;
        Ext.grid.plugin.Editing.prototype.constructor.apply(this, arguments);
        if (!a.clicksToMoveEditor) {
            a.clicksToMoveEditor = a.clicksToEdit
        }
        a.autoCancel = !!a.autoCancel
    }, init: function (a) {
        Ext.grid.plugin.Editing.prototype.init.call(this, a);
        if (a.lockedGrid) {
            a.lockedGrid.registerActionable(this);
            a.normalGrid.registerActionable(this)
        } else {
            a.registerActionable(this)
        }
    }, destroy: function () {
        Ext.destroy(this.editor);
        Ext.grid.plugin.Editing.prototype.destroy.call(this)
    }, onBeforeReconfigure: function () {
        Ext.grid.plugin.Editing.prototype.onBeforeReconfigure.apply(this, arguments);
        this.cancelEdit()
    }, onReconfigure: function (d, b, c) {
        var a = this.editor;
        Ext.grid.plugin.Editing.prototype.onReconfigure.apply(this, arguments);
        if (c && a && a.rendered) {
            a.needsSyncFieldWidths = true
        }
    }, shouldStartEdit: function (a) {
        return true
    }, startEdit: function (a, e) {
        var d = this, c = d.getEditor(), b;
        if (Ext.isEmpty(e)) {
            e = d.grid.getTopLevelVisibleColumnManager().getHeaderAtIndex(0)
        }
        if (c.beforeEdit() !== false) {
            b = d.getEditingContext(a, e);
            if (b && d.beforeEdit(b) !== false && d.fireEvent("beforeedit", d, b) !== false && !b.cancel) {
                d.context = b;
                if (d.lockingPartner) {
                    d.lockingPartner.cancelEdit()
                }
                c.startEdit(b.record, b.column, b);
                d.editing = true;
                return true
            }
        }
        return false
    }, activateCell: function (a) {
        if (!a.getCell().query('[tabIndex="-1"]').length) {
            this.startEdit(a.record, a.column);
            return true
        }
    }, onEnterKey: function (c) {
        var a = this, b;
        if (!a.grid.ownerGrid.actionableMode && a.editing) {
            b = Ext.getCmp(c.getTarget().getAttribute("componentId"));
            if (!(b && b.isPickerField && b.isExpanded)) {
                a.completeEdit()
            }
        }
    }, cancelEdit: function () {
        var a = this;
        if (a.editing) {
            a.getContextFieldValues();
            a.getEditor().cancelEdit();
            Ext.grid.plugin.Editing.prototype.cancelEdit.apply(this, arguments);
            return
        }
        return true
    }, completeEdit: function () {
        var b = this, a = b.context;
        if (b.editing && b.validateEdit(a)) {
            b.editing = false;
            b.fireEvent("edit", b, a)
        }
    }, validateEdit: function () {
        this.getContextFieldValues();
        return Ext.grid.plugin.Editing.prototype.validateEdit.apply(this, arguments) && this.getEditor().completeEdit()
    }, getEditor: function () {
        var a = this;
        if (!a.editor) {
            a.editor = a.initEditor()
        }
        return a.editor
    }, getContextFieldValues: function () {
        var g = this.editor, b = this.context, e = b.record, l = {}, c = {}, j = g.query(">[isFormField]"),
            h = j.length, d, a, k;
        for (d = 0; d < h; d++) {
            k = j[d];
            a = k.dataIndex;
            l[a] = k.getValue();
            c[a] = e.get(a)
        }
        Ext.apply(b, {newValues: l, originalValues: c})
    }, initEditor: function () {
        return new Ext.grid.RowEditor(this.initEditorConfig())
    }, initEditorConfig: function () {
        var h = this, c = h.grid, i = h.view, d = c.headerCt,
            e = ["saveBtnText", "cancelBtnText", "errorsText", "dirtyText"], j, a = e.length, g = {
                autoCancel: h.autoCancel,
                errorSummary: h.errorSummary,
                fields: d.getGridColumns(),
                hidden: true,
                view: i,
                editingPlugin: h
            }, k;
        for (j = 0; j < a; j++) {
            k = e[j];
            if (Ext.isDefined(h[k])) {
                g[k] = h[k]
            }
        }
        return g
    }, initEditTriggers: function () {
        var b = this, a = b.view, c = b.clicksToMoveEditor === 1 ? "click" : "dblclick";
        Ext.grid.plugin.Editing.prototype.initEditTriggers.apply(this, arguments);
        if (b.clicksToMoveEditor !== b.clicksToEdit) {
            b.mon(a, "cell" + c, b.moveEditorByClick, b)
        }
        a.on({
            render: function () {
                b.mon(b.grid.headerCt, {
                    scope: b,
                    columnresize: b.onColumnResize,
                    columnhide: b.onColumnHide,
                    columnshow: b.onColumnShow
                })
            }, single: true
        })
    }, moveEditorByClick: function () {
        var a = this;
        if (a.editing) {
            a.superclass.onCellClick.apply(a, arguments)
        }
    }, onColumnAdd: function (a, c) {
        if (c.isHeader) {
            var d = this, b;
            d.initFieldAccessors(c);
            b = d.editor;
            if (b) {
                b.onColumnAdd(c)
            }
        }
    }, beforeGridHeaderDestroy: function (g) {
        var c = this.grid.getColumnManager().getColumns(), a = c.length, b, d, e;
        for (b = 0; b < a; b++) {
            d = c[b];
            if (d.hasEditor) {
                if (d.hasEditor() && (e = d.getEditor())) {
                    e.destroy()
                }
                this.removeFieldAccessors(d)
            }
        }
    }, onColumnResize: function (a, d, c) {
        if (d.isHeader) {
            var e = this, b = e.getEditor();
            if (b) {
                b.onColumnResize(d, c)
            }
        }
    }, onColumnHide: function (a, c) {
        var d = this, b = d.getEditor();
        if (b) {
            b.onColumnHide(c)
        }
    }, onColumnShow: function (a, c) {
        var d = this, b = d.getEditor();
        if (b) {
            b.onColumnShow(c)
        }
    }, onColumnMove: function (a, d, c, g) {
        var e = this, b = e.getEditor();
        e.initFieldAccessors(d);
        if (b) {
            b.onColumnMove(d, c, g)
        }
    }, setColumnField: function (b, d) {
        var c = this, a = c.getEditor();
        if (a) {
            a.destroyColumnEditor(b)
        }
        Ext.grid.plugin.Editing.prototype.setColumnField.apply(this, arguments);
        if (a) {
            a.insertColumnEditor(b)
        }
    }, createColumnField: function (c, a) {
        var b = this.editor, d;
        if (b) {
            d = b.getDefaultFieldCfg()
        }
        return Ext.grid.plugin.Editing.prototype.createColumnField.call(this, c, a || d)
    }
}, 1, 0, 0, 0, ["plugin.rowediting"], 0, [Ext.grid.plugin, "RowEditing"], 0));
(Ext.cmd.derive("Ext.grid.plugin.RowExpander", Ext.plugin.Abstract, {
    lockableScope: "normal",
    columnWidth: 24,
    rowBodyTpl: null,
    lockedTpl: null,
    expandOnDblClick: true,
    selectRowOnExpand: false,
    headerWidth: 24,
    bodyBefore: false,
    rowBodyTrSelector: ".x-grid-rowbody-tr",
    rowBodyHiddenCls: "x-grid-row-body-hidden",
    rowCollapsedCls: "x-grid-row-collapsed",
    addCollapsedCls: {
        fn: function (b, a, c) {
            var d = this.rowExpander;
            if (!d.recordsExpanded[a.record.internalId]) {
                a.itemClasses.push(d.rowCollapsedCls)
            }
            this.nextTpl.applyOut(a, b, c)
        }, syncRowHeights: function (a, b) {
            this.rowExpander.syncRowHeights(a, b)
        }, priority: 20000
    },
    setCmp: function (a) {
        var c = this, b;
        Ext.plugin.Abstract.prototype.setCmp.apply(this, arguments);
        c.recordsExpanded = {};
        c.rowBodyTpl = Ext.XTemplate.getTpl(c, "rowBodyTpl");
        b = c.getFeatureConfig(a);
        if (a.features) {
            a.features = Ext.Array.push(b, a.features)
        } else {
            a.features = b
        }
    },
    getFeatureConfig: function (a) {
        var c = this, b = [], d = {
            ftype: "rowbody",
            rowExpander: c,
            bodyBefore: c.bodyBefore,
            recordsExpanded: c.recordsExpanded,
            rowBodyHiddenCls: c.rowBodyHiddenCls,
            rowCollapsedCls: c.rowCollapsedCls,
            setupRowData: c.getRowBodyFeatureData,
            setup: c.setup
        };
        b.push(Ext.apply({lockableScope: "normal", getRowBodyContents: c.getRowBodyContentsFn(c.rowBodyTpl)}, d));
        if (a.enableLocking) {
            b.push(Ext.apply({
                lockableScope: "locked",
                getRowBodyContents: c.lockedTpl ? c.getRowBodyContentsFn(c.lockedTpl) : function () {
                    return ""
                }
            }, d))
        }
        return b
    },
    getRowBodyContentsFn: function (a) {
        var b = this;
        return function (c) {
            a.owner = b;
            return a.applyTemplate(c.record.getData())
        }
    },
    init: function (b) {
        if (b.lockable) {
            b = b.normalGrid
        }
        var d = this, e = b.ownerLockable, a, c;
        Ext.plugin.Abstract.prototype.init.apply(this, arguments);
        d.grid = b;
        a = d.view = b.getView();
        d.bindView(a);
        a.addRowTpl(d.addCollapsedCls).rowExpander = d;
        if (e) {
            d.addExpander(e.lockedGrid.headerCt.items.getCount() ? e.lockedGrid : b);
            c = e.lockedGrid.getView();
            d.bindView(c);
            c.addRowTpl(d.addCollapsedCls).rowExpander = d;
            e.syncRowHeight = true;
            e.mon(e, {
                processcolumns: d.onLockableProcessColumns,
                lockcolumn: d.onColumnLock,
                unlockcolumn: d.onColumnUnlock,
                scope: d
            });
            d.viewListeners = a.on({itemadd: Ext.Function.createAnimationFrame(e.syncRowHeights, e)})
        } else {
            d.addExpander(b);
            b.on("beforereconfigure", d.beforeReconfigure, d)
        }
    },
    beforeReconfigure: function (d, a, c, g, b) {
        var e = this;
        if (e.viewListeners) {
            e.viewListeners.destroy()
        }
        if (c) {
            e.expanderColumn = new Ext.grid.Column(e.getHeaderConfig());
            c.unshift(e.expanderColumn)
        }
    },
    onLockableProcessColumns: function (c, b, a) {
        this.addExpander(b.length ? c.lockedGrid : c.normalGrid)
    },
    addExpander: function (b) {
        var a = this;
        a.grid = b;
        a.expanderColumn = b.headerCt.insert(0, a.getHeaderConfig());
        b.getSelectionModel().injectCheckbox = 1
    },
    getRowBodyFeatureData: function (b, a, d) {
        var c = this;
        c.self.prototype.setupRowData.apply(c, arguments);
        d.rowBody = c.getRowBodyContents(d);
        d.rowBodyCls = c.recordsExpanded[b.internalId] ? "" : c.rowBodyHiddenCls
    },
    setup: function (c, d) {
        var b = this, a = b.grid.ownerLockable;
        b.self.prototype.setup.apply(b, arguments);
        if (a && Ext.Array.indexOf(b.grid.columnManager.getColumns(), b.rowExpander.expanderColumn) !== -1) {
            d.rowBodyColspan -= 1
        }
    },
    bindView: function (a) {
        a.on("itemkeydown", this.onKeyDown, this);
        if (this.expandOnDblClick) {
            a.on("itemdblclick", this.onDblClick, this)
        }
    },
    onKeyDown: function (i, c, k, a, d) {
        var g = this, j = d.getKey(), h = i.getNavigationModel().getPosition(), b;
        if (h) {
            k = Ext.fly(k);
            b = k.hasCls(g.rowCollapsedCls);
            if (((j === 107 || (j === 187 && d.shiftKey)) && b) || ((j === 109 || j === 189) && !b)) {
                g.toggleRow(a, c)
            }
        }
    },
    onDblClick: function (b, a, g, c, d) {
        this.toggleRow(c, a)
    },
    toggleRow: function (b, g) {
        var l = this, m = l.view, o = m.bufferedRenderer, h = m.getScrollable(), p = m, c = m.getNode(b),
            e = Ext.fly(c), d, i = e.down(l.rowBodyTrSelector, true), q = e.hasCls(l.rowCollapsedCls),
            n = q ? "removeCls" : "addCls", k = q ? 2 : 1, a = l.grid.ownerLockable, j;
        e[n](l.rowCollapsedCls);
        Ext.fly(i)[n](l.rowBodyHiddenCls);
        l.recordsExpanded[g.internalId] = q;
        if (l.grid.ownerLockable) {
            p = a.getView();
            if (a.lockedGrid.isVisible()) {
                m = a.view.lockedGrid.view;
                d = Ext.fly(m.getNode(b));
                if (d) {
                    d[n](l.rowCollapsedCls);
                    i = d.down(l.rowBodyTrSelector, true);
                    Ext.fly(i)[n](l.rowBodyHiddenCls)
                }
            }
        }
        if (l.expanderColumn) {
            j = Ext.fly(m.getRow(b)).down(l.expanderColumn.getCellSelector(), true);
            if (j) {
                j.rowSpan = k
            }
        }
        p.fireEvent(q ? "expandbody" : "collapsebody", c, g, i);
        if (m.getSizeModel().height.shrinkWrap || a) {
            m.refreshSize(true)
        }
        if (h) {
            if (o) {
                o.refreshSize()
            } else {
                h.refresh(true)
            }
        }
    },
    syncRowHeights: function (a, h) {
        var d = this, c = Ext.fly(a).down(d.rowBodyTrSelector), b = Ext.fly(h).down(d.rowBodyTrSelector), g, e;
        if (b.isVisible()) {
            if ((g = c.getHeight()) !== (e = b.getHeight())) {
                if (g > e) {
                    b.setHeight(g)
                } else {
                    c.setHeight(e)
                }
            }
        } else {
            c.dom.style.height = b.dom.style.height = ""
        }
    },
    onColumnUnlock: function (c, a) {
        var b = this, d;
        c = b.grid.ownerLockable;
        d = c.lockedGrid.visibleColumnManager.getColumns();
        if (d.length === 1) {
            if (d[0] === b.expanderColumn) {
                c.unlock(b.expanderColumn);
                b.grid = c.normalGrid
            } else {
                c.lock(b.expanderColumn, 0)
            }
        }
    },
    onColumnLock: function (c, a) {
        var b = this, e, d;
        c = b.grid.ownerLockable;
        e = c.lockedGrid.visibleColumnManager.getColumns();
        if (e.length === 1) {
            b.grid = d = c.lockedGrid;
            d.headerCt.insert(0, b.expanderColumn)
        }
    },
    getHeaderConfig: function () {
        var b = this, a = b.grid.ownerLockable;
        return {
            width: b.headerWidth,
            ignoreExport: true,
            lockable: false,
            autoLock: true,
            sortable: false,
            resizable: false,
            draggable: false,
            hideable: false,
            menuDisabled: true,
            tdCls: "x-grid-cell-special",
            innerCls: "x-grid-cell-inner-row-expander",
            renderer: function () {
                return '<div class="x-grid-row-expander" role="presentation" tabIndex="0"></div>'
            },
            processEvent: function (i, g, c, k, h, j, d) {
                if ((i === "click" && j.getTarget(".x-grid-row-expander")) || (i === "keydown" && j.getKey() === j.SPACE)) {
                    b.toggleRow(k, d);
                    return b.selectRowOnExpand
                }
            },
            isLocked: function () {
                return a && (a.lockedGrid.isVisible() || this.locked)
            },
            editRenderer: function () {
                return "&#160;"
            }
        }
    }
}, 0, 0, 0, 0, ["plugin.rowexpander"], 0, [Ext.grid.plugin, "RowExpander"], 0));
(Ext.cmd.derive("Ext.grid.property.Grid", Ext.grid.Panel, {
    alternateClassName: "Ext.grid.PropertyGrid",
    valueField: "value",
    nameField: "name",
    inferTypes: true,
    enableColumnMove: false,
    columnLines: true,
    stripeRows: false,
    trackMouseOver: false,
    clicksToEdit: 1,
    enableHdMenu: false,
    gridCls: "x-property-grid",
    initComponent: function () {
        var a = this;
        a.source = a.source || {};
        a.addCls(a.gridCls);
        a.plugins = a.plugins || [];
        a.plugins.push(new Ext.grid.plugin.CellEditing({
            clicksToEdit: a.clicksToEdit, startEdit: function (b, c) {
                return this.self.prototype.startEdit.call(this, b, a.valueColumn)
            }
        }));
        a.selModel = {
            type: "cellmodel", onCellSelect: function (b) {
                b.column = a.valueColumn;
                b.colIdx = a.valueColumn.getVisibleIndex();
                return this.self.prototype.onCellSelect.call(this, b)
            }
        };
        a.sourceConfig = Ext.apply({}, a.sourceConfig);
        if (!a.store) {
            a.propStore = a.store = new Ext.grid.property.Store(a, a.source)
        }
        a.configure(a.sourceConfig);
        if (a.sortableColumns) {
            a.store.sort("name", "ASC")
        }
        a.columns = new Ext.grid.property.HeaderContainer(a, a.store);
        Ext.grid.Panel.prototype.initComponent.call(this);
        a.getView().walkCells = this.walkCells;
        a.editors = {
            date: new Ext.grid.CellEditor({field: new Ext.form.field.Date({selectOnFocus: true})}),
            string: new Ext.grid.CellEditor({field: new Ext.form.field.Text({selectOnFocus: true})}),
            number: new Ext.grid.CellEditor({field: new Ext.form.field.Number({selectOnFocus: true})}),
            "boolean": new Ext.grid.CellEditor({
                field: new Ext.form.field.ComboBox({
                    editable: false,
                    store: [[true, a.headerCt.trueText], [false, a.headerCt.falseText]]
                })
            })
        };
        a.store.on("update", a.onUpdate, a)
    },
    configure: function (b) {
        var h = this, k = h.store, d = 0, e = h.store.getCount(), l = h.nameField, m = h.valueField, a, j, c, g;
        h.configureLegacy(b);
        if (h.inferTypes) {
            for (; d < e; ++d) {
                c = k.getAt(d);
                a = c.get(l);
                if (!h.getConfigProp(a, "type")) {
                    j = c.get(m);
                    if (Ext.isDate(j)) {
                        g = "date"
                    } else {
                        if (Ext.isNumber(j)) {
                            g = "number"
                        } else {
                            if (Ext.isBoolean(j)) {
                                g = "boolean"
                            } else {
                                g = "string"
                            }
                        }
                    }
                    h.setConfigProp(a, "type", g)
                }
            }
        }
    },
    getConfigProp: function (e, d, a) {
        var c = this.sourceConfig[e], b;
        if (c) {
            b = c[d]
        }
        return b || a
    },
    setConfigProp: function (e, b, c) {
        var a = this.sourceConfig, d = a[e];
        if (!d) {
            d = a[e] = {__copied: true}
        } else {
            if (!d.__copied) {
                d = Ext.apply({__copied: true}, d);
                a[e] = d
            }
        }
        d[b] = c;
        return c
    },
    configureLegacy: function (a) {
        var b = this;
        b.copyLegacyObject(a, b.customRenderers, "renderer");
        b.copyLegacyObject(a, b.customEditors, "editor");
        b.copyLegacyObject(a, b.propertyNames, "displayName")
    },
    copyLegacyObject: function (a, d, c) {
        var b;
        for (b in d) {
            if (d.hasOwnProperty(b)) {
                if (!a[b]) {
                    a[b] = {}
                }
                a[b][c] = d[b]
            }
        }
    },
    onUpdate: function (d, a, c) {
        var g = this, b, e;
        if (g.rendered && c === Ext.data.Model.EDIT) {
            b = a.get(g.valueField);
            e = a.modified.value;
            if (g.fireEvent("beforepropertychange", g.source, a.getId(), b, e) !== false) {
                if (g.source) {
                    g.source[a.getId()] = b
                }
                a.commit();
                g.fireEvent("propertychange", g.source, a.getId(), b, e)
            } else {
                a.reject()
            }
        }
    },
    walkCells: function (j, i, h, g, a, c) {
        var d = this, b = d.ownerCt.valueColumn;
        if (i === "left") {
            i = "up"
        } else {
            if (i === "right") {
                i = "down"
            }
        }
        j = Ext.view.Table.prototype.walkCells.call(d, j, i, h, g, a, c);
        j.column = b;
        j.colIdx = b.getVisibleIndex();
        return j
    },
    getCellEditor: function (a, d) {
        var g = this, h = a.get(g.nameField), i = a.get(g.valueField), c = g.getConfigProp(h, "editor"),
            b = g.getConfigProp(h, "type"), e = g.editors;
        if (c) {
            if (!(c instanceof Ext.grid.CellEditor)) {
                if (!(c instanceof Ext.form.field.Base)) {
                    c = Ext.ComponentManager.create(c, "textfield")
                }
                c = g.setConfigProp(h, "editor", new Ext.grid.CellEditor({field: c}))
            }
        } else {
            if (b) {
                switch (b) {
                    case"date":
                        c = e.date;
                        break;
                    case"number":
                        c = e.number;
                        break;
                    case"boolean":
                        c = g.editors["boolean"];
                        break;
                    default:
                        c = e.string
                }
            } else {
                if (Ext.isDate(i)) {
                    c = e.date
                } else {
                    if (Ext.isNumber(i)) {
                        c = e.number
                    } else {
                        if (Ext.isBoolean(i)) {
                            c = e["boolean"]
                        } else {
                            c = e.string
                        }
                    }
                }
            }
        }
        c.editorId = h;
        c.field.column = g.valueColumn;
        return c
    },
    beforeDestroy: function () {
        var a = this;
        Ext.grid.Panel.prototype.beforeDestroy.call(this);
        a.destroyEditors(a.editors);
        a.destroyEditors(a.customEditors);
        delete a.source
    },
    destroyEditors: function (b) {
        for (var a in b) {
            if (b.hasOwnProperty(a)) {
                Ext.destroy(b[a])
            }
        }
    },
    setSource: function (b, c) {
        var a = this;
        a.source = b;
        if (c !== undefined) {
            a.sourceConfig = Ext.apply({}, c);
            a.configure(a.sourceConfig)
        }
        a.propStore.setSource(b)
    },
    getSource: function () {
        return this.propStore.getSource()
    },
    getProperty: function (a) {
        return this.propStore.getProperty(a)
    },
    setProperty: function (c, b, a) {
        this.propStore.setValue(c, b, a)
    },
    removeProperty: function (a) {
        this.propStore.remove(a)
    }
}, 0, ["propertygrid"], ["component", "box", "container", "panel", "tablepanel", "gridpanel", "grid", "propertygrid"], {
    component: true,
    box: true,
    container: true,
    panel: true,
    tablepanel: true,
    gridpanel: true,
    grid: true,
    propertygrid: true
}, ["widget.propertygrid"], 0, [Ext.grid.property, "Grid", Ext.grid, "PropertyGrid"], 0));
(Ext.cmd.derive("Ext.grid.property.HeaderContainer", Ext.grid.header.Container, {
    alternateClassName: "Ext.grid.PropertyColumnModel",
    nameWidth: 115,
    nameText: "Name",
    valueText: "Value",
    dateFormat: "m/j/Y",
    trueText: "true",
    falseText: "false",
    nameColumnCls: "x-grid-property-name",
    nameColumnInnerCls: "x-grid-cell-inner-property-name",
    constructor: function (b, a) {
        var c = this;
        c.grid = b;
        c.store = a;
        Ext.grid.header.Container.prototype.constructor.call(this, {
            isRootHeader: true,
            enableColumnResize: Ext.isDefined(b.enableColumnResize) ? b.enableColumnResize : c.enableColumnResize,
            enableColumnMove: Ext.isDefined(b.enableColumnMove) ? b.enableColumnMove : c.enableColumnMove,
            items: [{
                header: c.nameText,
                width: b.nameColumnWidth || c.nameWidth,
                sortable: b.sortableColumns,
                dataIndex: b.nameField,
                scope: c,
                renderer: c.renderProp,
                itemId: b.nameField,
                menuDisabled: true,
                tdCls: c.nameColumnCls,
                innerCls: c.nameColumnInnerCls
            }, {
                header: c.valueText,
                scope: c,
                renderer: c.renderCell,
                getEditor: c.getCellEditor.bind(c),
                sortable: b.sortableColumns,
                flex: 1,
                fixed: true,
                dataIndex: b.valueField,
                itemId: b.valueField,
                menuDisabled: true
            }]
        });
        c.grid.valueColumn = c.items.getAt(1)
    },
    getCellEditor: function (a) {
        return this.grid.getCellEditor(a, this)
    },
    renderProp: function (a) {
        return this.getPropertyName(a)
    },
    renderCell: function (h, e, g) {
        var c = this, b = c.grid, d = b.getConfigProp(g.get(b.nameField), "renderer"), a = h;
        if (d) {
            return d.apply(c, arguments)
        }
        if (Ext.isDate(h)) {
            a = c.renderDate(h)
        } else {
            if (Ext.isBoolean(h)) {
                a = c.renderBool(h)
            }
        }
        return Ext.util.Format.htmlEncode(a)
    },
    renderDate: Ext.util.Format.date,
    renderBool: function (a) {
        return this[a ? "trueText" : "falseText"]
    },
    getPropertyName: function (a) {
        return this.grid.getConfigProp(a, "displayName", a)
    }
}, 1, 0, ["component", "box", "container", "headercontainer"], {
    component: true,
    box: true,
    container: true,
    headercontainer: true
}, 0, 0, [Ext.grid.property, "HeaderContainer", Ext.grid, "PropertyColumnModel"], 0));
(Ext.cmd.derive("Ext.grid.property.Property", Ext.data.Model, {
    alternateClassName: "Ext.PropGridProperty",
    fields: [{name: "name", type: "string"}, {name: "value"}],
    idProperty: "name",
    constructor: function (b, a) {
        if (!Ext.isObject(b)) {
            b = {name: b, value: a}
        }
        Ext.data.Model.prototype.constructor.call(this, b)
    }
}, 1, 0, 0, 0, 0, 0, [Ext.grid.property, "Property", Ext, "PropGridProperty"], 0));
(Ext.cmd.derive("Ext.grid.property.Reader", Ext.data.reader.Reader, {
    successProperty: null,
    totalProperty: null,
    messageProperty: null,
    read: function (a) {
        return this.readRecords(a)
    },
    readRecords: function (b) {
        var e = this.getModel(), a = {records: [], success: true}, d, c;
        for (c in b) {
            if (b.hasOwnProperty(c)) {
                d = b[c];
                if (this.isEditableValue(d)) {
                    a.records.push(new e({name: c, value: d}))
                }
            }
        }
        a.total = a.count = a.records.length;
        return new Ext.data.ResultSet(a)
    },
    isEditableValue: function (a) {
        return Ext.isPrimitive(a) || Ext.isDate(a) || a === null
    }
}, 0, 0, 0, 0, 0, 0, [Ext.grid.property, "Reader"], 0));
(Ext.cmd.derive("Ext.grid.property.Store", Ext.data.Store, {
    alternateClassName: "Ext.grid.PropertyStore", remoteSort: true, constructor: function (a, c) {
        var b = this;
        b.grid = a;
        b.source = c;
        Ext.data.Store.prototype.constructor.call(this, {
            data: c,
            model: Ext.grid.property.Property,
            proxy: b.getProxy()
        })
    }, getProxy: function () {
        var a = this.proxy;
        if (!a) {
            a = this.proxy = new Ext.data.proxy.Memory({model: Ext.grid.property.Property, reader: this.getReader()})
        }
        return a
    }, getReader: function () {
        var a = this.reader;
        if (!a) {
            a = this.reader = new Ext.grid.property.Reader({model: Ext.grid.property.Property})
        }
        return a
    }, setSource: function (a) {
        var b = this;
        b.source = a;
        b.suspendEvents();
        b.removeAll();
        b.getProxy().setData(a);
        b.load();
        b.resumeEvents();
        b.fireEvent("datachanged", b);
        b.fireEvent("refresh", b)
    }, getProperty: function (c) {
        var b = Ext.isNumber(c) ? this.getAt(c) : this.getById(c), a = null;
        if (b) {
            a = b.get("value")
        }
        return a
    }, setValue: function (e, c, a) {
        var b = this, d = b.getRec(e);
        if (d) {
            d.set("value", c);
            b.source[e] = c
        } else {
            if (a) {
                b.source[e] = c;
                d = new Ext.grid.property.Property({name: e, value: c}, e);
                b.add(d)
            }
        }
    }, remove: function (b) {
        var a = this.getRec(b);
        if (a) {
            Ext.data.Store.prototype.remove.call(this, a);
            delete this.source[b]
        }
    }, getRec: function (a) {
        return this.getById(a)
    }, getSource: function () {
        return this.source
    }, onDestroy: function () {
        Ext.destroy(this.reader, this.proxy);
        Ext.data.Store.prototype.onDestroy.call(this)
    }
}, 1, 0, 0, 0, 0, 0, [Ext.grid.property, "Store", Ext.grid, "PropertyStore"], 0));
(Ext.cmd.derive("Ext.grid.selection.Selection", Ext.Base, {
    constructor: function (a) {
        this.view = a.ownerGrid.view
    }
}, 1, 0, 0, 0, 0, 0, [Ext.grid.selection, "Selection"], 0));
(Ext.cmd.derive("Ext.grid.selection.Cells", Ext.grid.selection.Selection, {
    type: "cells", isCells: true, clone: function () {
        var b = this, a = new b.self(b.view);
        if (b.startCell) {
            a.startCell = b.startCell.clone();
            a.endCell = b.endCell.clone()
        }
        return a
    }, contains: function (a) {
        var b;
        if (!a || !a.isCellContext) {
            return false
        }
        if (this.startCell) {
            b = this.getRowRange();
            if (a.rowIdx >= b[0] && a.rowIdx <= b[1]) {
                b = this.getColumnRange();
                return (a.colIdx >= b[0] && a.colIdx <= b[1])
            }
        }
        return false
    }, eachRow: function (c, b) {
        var e = this, g = e.getRowRange(), a = new Ext.grid.CellContext(e.view), d;
        for (d = g[0]; d <= g[1]; d++) {
            a.setRow(d);
            if (c.call(b || e, a.record) === false) {
                return
            }
        }
    }, eachColumn: function (d, c) {
        var e = this, a = e.getColumnRange(), b = new Ext.grid.CellContext(e.view), g;
        for (g = a[0]; g <= a[1]; g++) {
            b.setColumn(g);
            if (d.call(c || e, b.column, g) === false) {
                return
            }
        }
    }, eachCell: function (d, c) {
        var g = this, h = g.getRowRange(), a = g.getColumnRange(), b = new Ext.grid.CellContext(g.view), e, i;
        for (e = h[0]; e <= h[1]; e++) {
            b.setRow(e);
            for (i = a[0]; i <= a[1]; i++) {
                b.setColumn(i);
                if (d.call(c || g, b, i, e) === false) {
                    return
                }
            }
        }
    }, getFirstRowIndex: function () {
        return this.startCell ? Math.min(this.startCell.rowIdx, this.endCell.rowIdx) : 0
    }, getLastRowIndex: function () {
        return this.startCell ? Math.max(this.startCell.rowIdx, this.endCell.rowIdx) : -1
    }, getFirstColumnIndex: function () {
        return this.startCell ? Math.min(this.startCell.colIdx, this.endCell.colIdx) : 0
    }, getLastColumnIndex: function () {
        return this.startCell ? Math.max(this.startCell.colIdx, this.endCell.colIdx) : -1
    }, privates: {
        clear: function () {
            var b = this, a = b.view;
            b.eachCell(function (c) {
                a.onCellDeselect(c)
            });
            b.startCell = b.endCell = null
        }, setRangeStart: function (b, a) {
            this.startCell = (this.endCell = b.clone()).clone();
            this.view.onCellSelect(b)
        }, setRangeEnd: function (b) {
            var k = this, i, h, c, j, g, n, a, e, l = k.view, o = l.all, m = new Ext.grid.CellContext(l),
                d = l.getVisibleColumnManager().getColumns().length - 1;
            k.endCell = b.clone();
            i = k.getRange();
            h = k.lastRange || i;
            c = Math.max(Math.min(i[0][1], h[0][1]), o.startIndex);
            j = Math.min(Math.max(i[1][1], h[1][1]), o.endIndex);
            g = Math.min(i[0][0], h[0][0]);
            n = Math.min(Math.max(i[1][0], h[1][0]), d);
            for (a = c; a <= j; a++) {
                for (e = g; e <= n; e++) {
                    m.setPosition(a, e);
                    if (a < i[0][1] || a > i[1][1] || e < i[0][0] || e > i[1][0]) {
                        l.onCellDeselect(m)
                    } else {
                        l.onCellSelect(m)
                    }
                }
            }
            k.lastRange = i
        }, extendRange: function (b) {
            var c = this, a;
            if (b[b.type] < 0) {
                a = c.endCell.clone().setPosition(c.getLastRowIndex(), c.getLastColumnIndex());
                c.startCell = b.start.clone();
                c.setRangeEnd(a);
                c.view.getNavigationModel().setPosition(b.start)
            } else {
                c.startCell = c.startCell.setPosition(c.getFirstRowIndex(), c.getFirstColumnIndex());
                c.setRangeEnd(b.end);
                c.view.getNavigationModel().setPosition(b.end)
            }
        }, getRange: function () {
            return [[this.getFirstColumnIndex(), this.getFirstRowIndex()], [this.getLastColumnIndex(), this.getLastRowIndex()]]
        }, getRangeSize: function () {
            return this.getCount()
        }, getCount: function () {
            var a = this.getRange();
            return (a[1][0] - a[0][0] + 1) * (a[1][1] - a[0][1] + 1)
        }, selectAll: function () {
            var b = this, a = b.view;
            b.clear();
            b.setRangeStart(new Ext.grid.CellContext(a).setPosition(0, 0));
            b.setRangeEnd(new Ext.grid.CellContext(a).setPosition(a.dataSource.getCount() - 1, a.getVisibleColumnManager().getColumns().length - 1))
        }, isAllSelected: function () {
            var b = this.rangeStart, a = this.rangeEnd;
            if (b) {
                if (!b.colIdx && !b.rowIdx) {
                    return a.colIdx === a.view.getVisibleColumnManager().getColumns().length - 1 && a.rowIdx === a.view.dataSource.getCount - 1
                }
            }
            return false
        }, getColumnRange: function () {
            return [this.getFirstColumnIndex(), this.getLastColumnIndex()]
        }, getRowRange: function () {
            return [this.getFirstRowIndex(), this.getLastRowIndex()]
        }, onSelectionFinish: function () {
            var a = this;
            if (a.getCount()) {
                a.view.getSelectionModel().onSelectionFinish(a, new Ext.grid.CellContext(a.view).setPosition(a.getFirstRowIndex(), a.getFirstColumnIndex()), new Ext.grid.CellContext(a.view).setPosition(a.getLastRowIndex(), a.getLastColumnIndex()))
            } else {
                a.view.getSelectionModel().onSelectionFinish(a)
            }
        }
    }
}, 0, 0, 0, 0, 0, 0, [Ext.grid.selection, "Cells"], 0));
(Ext.cmd.derive("Ext.grid.selection.Columns", Ext.grid.selection.Selection, {
    type: "columns", isColumns: true, clone: function () {
        var c = this, a = new c.self(c.view), b = c.selectedColumns;
        if (b) {
            a.selectedColumns = Ext.Array.slice(b)
        }
        return a
    }, eachRow: function (c, b) {
        var a = this.selectedColumns;
        if (a && a.length) {
            this.view.dataSource.each(c, b || this)
        }
    }, eachColumn: function (h, g) {
        var j = this, b = j.view, e = j.selectedColumns, a, d, c = new Ext.grid.CellContext(b);
        if (e) {
            a = e.length;
            for (d = 0; d < a; d++) {
                c.setColumn(e[d]);
                if (h.call(g || j, c.column, c.colIdx) === false) {
                    return false
                }
            }
        }
    }, eachCell: function (h, g) {
        var j = this, b = j.view, e = j.selectedColumns, a, d, c = new Ext.grid.CellContext(b);
        if (e) {
            a = e.length;
            b.dataSource.each(function (i) {
                c.setRow(i);
                for (d = 0; d < a; d++) {
                    c.setColumn(e[d]);
                    if (h.call(g || j, c, c.colIdx, c.rowIdx) === false) {
                        return false
                    }
                }
            })
        }
    }, contains: function (b) {
        var a = this.selectedColumns;
        if (b && b.isColumn && a && a.length) {
            return Ext.Array.contains(a, b)
        }
        return false
    }, getCount: function () {
        var a = this.selectedColumns;
        return a ? a.length : 0
    }, getColumns: function () {
        return this.selectedColumns || []
    }, privates: {
        add: function (a) {
            Ext.Array.include((this.selectedColumns || (this.selectedColumns = [])), a);
            this.refreshColumns(a)
        }, clear: function () {
            var a = this, b = a.selectedColumns;
            if (b && b.length) {
                a.selectedColumns = [];
                a.refreshColumns.apply(a, b)
            }
        }, isAllSelected: function () {
            var a = this.selectedColumns;
            return a && a.length === this.view.ownerGrid.getVisibleColumnManager().getColumns().length
        }, refreshColumns: function (b) {
            var i = this, j = i.view, k = j.all, a, c = arguments, h = c.length, e, g = new Ext.grid.CellContext(j),
                d = [];
            if (j.rendered) {
                for (e = 0; e < h; e++) {
                    d[e] = i.contains(c[e])
                }
                for (a = k.startIndex; a <= k.endIndex; a++) {
                    g.setRow(a);
                    for (e = 0; e < h; e++) {
                        g.setColumn(c[e]);
                        if (d[e]) {
                            j.onCellSelect(g)
                        } else {
                            j.onCellDeselect(g)
                        }
                    }
                }
            }
        }, remove: function (a) {
            if (this.selectedColumns) {
                Ext.Array.remove(this.selectedColumns, a);
                if (a.getView() && a.isVisible()) {
                    this.refreshColumns(a)
                }
            }
        }, selectAll: function () {
            var a = this;
            a.clear();
            a.selectedColumns = a.view.getSelectionModel().lastContiguousColumnRange = a.view.getVisibleColumnManager().getColumns();
            a.refreshColumns.apply(a, a.selectedColumns)
        }, extendRange: function (a) {
            var d = this, c = d.view.getVisibleColumnManager().getColumns(), b;
            for (b = a.start.colIdx; b <= a.end.colIdx; b++) {
                d.add(c[b])
            }
        }, onSelectionFinish: function () {
            var b = this, a = b.getContiguousSelection();
            if (a) {
                b.view.getSelectionModel().onSelectionFinish(b, new Ext.grid.CellContext(b.view).setPosition(0, a[0]), new Ext.grid.CellContext(b.view).setPosition(b.view.dataSource.getCount() - 1, a[1]))
            } else {
                b.view.getSelectionModel().onSelectionFinish(b)
            }
        }, getContiguousSelection: function () {
            var c = Ext.Array.sort(this.selectedColumns, function (e, d) {
                return e.getVisibleIndex() - d.getVisibleIndex()
            }), a = c.length, b;
            if (a) {
                for (b = 1; b < a; b++) {
                    if (c[b].getVisibleIndex() !== c[b - 1].getVisibleIndex() + 1) {
                        return false
                    }
                }
                return [c[0], c[a - 1]]
            }
        }
    }
}, 0, 0, 0, 0, 0, 0, [Ext.grid.selection, "Columns"], 0));
(Ext.cmd.derive("Ext.grid.selection.Replicator", Ext.plugin.Abstract, {
    init: function (a) {
        this.gridListeners = a.on({beforeselectionextend: this.onBeforeSelectionExtend, scope: this, destroyable: true})
    }, onBeforeSelectionExtend: function (c, b, d) {
        var a = this.columns = [];
        b.eachColumn(function (e) {
            a.push(e)
        });
        return this.replicateSelection(c, b, d)
    }, replicateSelection: function (d, r, m) {
        if (m.columns || r.isColumns) {
            return
        }
        var A = this, b = A.columns, p, v, g, c, h, B, w, z, k, e, a, s, u = r.getFirstRowIndex(),
            t = r.getLastRowIndex(), l = t - u + 1, q = [], o, n;
        p = b.length, k = b[0].getView().dataSource;
        if (l === 1) {
            c = A.getColumnValues(r.view.dataSource.getAt(u))
        } else {
            c = new Array(p);
            if (m.rows < 0) {
                q = [k.getAt(u + 1), k.getAt(u)]
            } else {
                q = [k.getAt(t - 1), k.getAt(t)]
            }
            q[0] = A.getColumnValues(q[0]);
            q[1] = A.getColumnValues(q[1]);
            for (v = 0; v < p; v++) {
                o = q[1][v];
                n = q[0][v];
                if (!isNaN(o) && !isNaN(n)) {
                    c[v] = Number(o) - Number(n)
                }
            }
        }
        if (m.rows < 0) {
            h = m.end.rowIdx;
            B = m.start.rowIdx - 1;
            z = -1
        } else {
            h = m.start.rowIdx;
            B = m.end.rowIdx + 1;
            z = 1
        }
        if (l === 1) {
            for (w = h; w !== B; w += z) {
                e = k.getAt(w);
                for (v = 0; v < p; v++) {
                    g = b[v];
                    if (g.dataIndex) {
                        e.set(g.dataIndex, c[v])
                    }
                }
            }
        } else {
            for (w = h; w !== B; w += z) {
                e = k.getAt(w);
                a = A.getColumnValues(k.getAt(w - z));
                for (v = 0; v < p; v++) {
                    g = b[v];
                    if (g.dataIndex) {
                        s = a[v];
                        if (!isNaN(s)) {
                            e.set(g.dataIndex, Ext.coerce(Number(s) + c[v], s))
                        }
                    }
                }
            }
        }
    }, getColumnValues: function (c) {
        var e = this.columns, b = e.length, d, g, a = new Array(e.length);
        for (d = 0; d < b; d++) {
            g = e[d];
            if (g.dataIndex) {
                a[d] = c.get(g.dataIndex)
            }
        }
        return a
    }, destroy: function () {
        this.gridListeners = Ext.destroy(this.gridListeners);
        Ext.plugin.Abstract.prototype.destroy.call(this)
    }
}, 0, 0, 0, 0, ["plugin.selectionreplicator"], 0, [Ext.grid.selection, "Replicator"], 0));
(Ext.cmd.derive("Ext.grid.selection.Rows", Ext.grid.selection.Selection, {
    type: "rows", isRows: true, clone: function () {
        var b = this, a = new b.self(b.view);
        if (b.selectedRecords) {
            a.selectedRecords = b.selectedRecords.clone()
        }
        if (b.rangeStart) {
            a.setRangeStart(b.rangeStart);
            a.setRangeEnd(b.rangeEnd)
        }
        return a
    }, add: function (a) {
        var b = this.selectedRecords || (this.selectedRecords = this.createRecordCollection());
        if (!b.byInternalId.get(a.internalId)) {
            b.add(a);
            this.view.onRowSelect(a)
        }
    }, remove: function (a) {
        var b = this;
        if (b.selectedRecords && b.selectedRecords.byInternalId.get(a.internalId)) {
            b.selectedRecords.remove(a);
            b.view.onRowDeselect(a);
            b.allSelected = false;
            return true
        }
    }, contains: function (c) {
        if (!c || !c.isModel) {
            return false
        }
        var e = this, b = false, g = e.selectedRecords, a, d;
        if (e.allSelected) {
            e.add(c);
            return true
        }
        if (g) {
            b = !!g.byInternalId.get(c.internalId)
        }
        if (!b && e.rangeStart != null) {
            d = e.getRange();
            a = e.view.dataSource.indexOf(c);
            b = a >= d[0] && a <= d[1]
        }
        return b
    }, getCount: function () {
        var e = this, g = e.selectedRecords, a = g ? g.getCount() : 0, c = e.getRange(), d, b = e.view.dataSource;
        for (d = c[0]; d <= c[1]; d++) {
            if (!g || !g.byInternalId.get(b.getAt(d).internalId)) {
                a++
            }
        }
        return a
    }, getRecords: function () {
        var a = this.selectedRecords;
        return a ? a.getRange() : []
    }, selectAll: function () {
        var a = this;
        a.clear();
        a.setRangeStart(0);
        a.setRangeEnd(a.view.dataSource.getCount() - 1);
        a.addRange();
        a.allSelected = true
    }, getFirstRowIndex: function () {
        return this.getCount() ? this.view.dataSource.indexOf(this.selectedRecords.first()) : 0
    }, getLastRowIndex: function () {
        return this.getCount() ? this.view.dataSource.indexOf(this.selectedRecords.first()) : -1
    }, eachRow: function (b, a) {
        var c = this.selectedRecords;
        if (c) {
            c.each(b, a || this)
        }
    }, eachColumn: function (e, d) {
        var c = this.view.getVisibleColumnManager().getColumns(), a = c.length, b;
        if (this.selectedRecords) {
            for (b = 0; b < a; b++) {
                if (e.call(this || d, c[b], b) === false) {
                    return
                }
            }
        }
    }, eachCell: function (k, o) {
        var h = this, m = h.selectedRecords, l = h.view, b = l.ownerGrid.getVisibleColumnManager().getColumns(), n, e,
            c, a, g, p, d = false;
        if (b) {
            n = b.length;
            a = new Ext.grid.CellContext(l);
            if (m) {
                m.each(function (i) {
                    a.setRow(i);
                    for (e = 0; e < n; e++) {
                        a.setColumn(b[e]);
                        if (k.call(o || h, a, a.colIdx, a.rowIdx) === false) {
                            d = true;
                            return false
                        }
                    }
                })
            }
            if (!d && h.rangeStart != null) {
                g = h.getRange();
                h.view.dataSource.getRange(g[0], g[1], {
                    callback: function (i) {
                        p = i.length;
                        for (e = 0; !d && e < p; e++) {
                            a.setRow(i[e]);
                            for (c = 0; !d && c < n; c++) {
                                a.setColumn(b[c]);
                                if (k.call(o || h, a, a.colIdx, a.rowIdx) === false) {
                                    d = true
                                }
                            }
                        }
                    }
                })
            }
        }
    }, beginUpdate: function () {
        var a = this.selectedRecords;
        if (a) {
            a.beginUpdate()
        }
    }, endUpdate: function () {
        var a = this.selectedRecords;
        if (a) {
            a.endUpdate()
        }
    }, destroy: function () {
        this.selectedRecords = Ext.destroy(this.selectedRecords);
        this.callParent()
    }, privates: {
        clear: function () {
            var b = this, a = b.view;
            b.allSelected = false;
            if (b.selectedRecords) {
                b.eachRow(function (c) {
                    a.onRowDeselect(c)
                });
                b.selectedRecords.clear()
            }
        }, isAllSelected: function () {
            return !!this.allSelected
        }, setRangeStart: function (a) {
            this.allSelected = false;
            this.rangeStart = this.rangeEnd = a;
            this.view.onRowSelect(a)
        }, setRangeEnd: function (c) {
            var h = this, g, e, a, l, i = h.view, j = i.dataSource, k = i.all, d = h.selectedRecords, b;
            h.rangeEnd = c;
            g = h.getRange();
            e = h.lastRange || g;
            for (a = Math.max(Math.min(g[0], e[0]), k.startIndex), c = Math.min(Math.max(g[1], e[1]), k.endIndex); a <= c; a++) {
                l = k.item(a);
                if (a < g[0] || a > g[1]) {
                    if (d && (b = d.byInternalId.get(j.getAt(a).internalId))) {
                        d.remove(b)
                    }
                    i.onRowDeselect(a)
                } else {
                    i.onRowSelect(a)
                }
            }
            h.lastRange = g
        }, extendRange: function (b) {
            var d = this, a = d.view.dataSource, c;
            for (c = b.start.rowIdx; c <= b.end.rowIdx; c++) {
                d.add(a.getAt(c))
            }
        }, getRange: function () {
            var b = this.rangeStart, a = this.rangeEnd;
            if (b == null) {
                return [0, -1]
            } else {
                if (b <= a) {
                    return [b, a]
                }
            }
            return [a, b]
        }, getRangeSize: function () {
            var a = this.getRange();
            return a[1] - a[0] + 1
        }, createRecordCollection: function () {
            var b = this.view.dataSource, a = new Ext.util.Collection({
                rootProperty: "data",
                extraKeys: {byInternalId: {rootProperty: false, property: "internalId"}},
                sorters: [function (d, c) {
                    return b.indexOf(d) - b.indexOf(c)
                }]
            });
            return a
        }, addRange: function () {
            var c = this, a, b;
            if (c.rangeStart != null) {
                a = c.getRange();
                b = c.selectedRecords || (c.selectedRecords = c.createRecordCollection());
                c.view.dataSource.getRange(a[0], a[1], {
                    callback: function (d) {
                        b.add.apply(b, d)
                    }
                });
                c.setRangeStart(c.lastRange = null)
            }
        }, onSelectionFinish: function () {
            var b = this, a = b.getContiguousSelection();
            if (a) {
                b.view.getSelectionModel().onSelectionFinish(b, new Ext.grid.CellContext(b.view).setPosition(a[0], 0), new Ext.grid.CellContext(b.view).setPosition(a[1], b.view.getVisibleColumnManager().getColumns().length - 1))
            } else {
                b.view.getSelectionModel().onSelectionFinish(b)
            }
        }, getContiguousSelection: function () {
            var b = this.view.dataSource, d, a, c;
            if (this.selectedRecords) {
                d = Ext.Array.sort(this.selectedRecords.getRange(), function (g, e) {
                    return b.indexOf(g) - b.indexOf(e)
                });
                a = d.length;
                if (a) {
                    for (c = 1; c < a; c++) {
                        if (b.indexOf(d[c]) !== b.indexOf(d[c - 1]) + 1) {
                            return false
                        }
                    }
                    return [b.indexOf(d[0]), b.indexOf(d[a - 1])]
                }
            }
        }
    }
}, 0, 0, 0, 0, 0, 0, [Ext.grid.selection, "Rows"], 0));
(Ext.cmd.derive("Ext.grid.selection.SelectionExtender", Ext.dd.DragTracker, {
    maskBox: {}, constructor: function (a) {
        var b = this;
        if (a.view.rendered) {
            b.initSelectionExtender(a)
        } else {
            b.view = a.view;
            a.view.on({render: b.initSelectionExtender, args: [a], scope: b})
        }
    }, initSelectionExtender: function (a) {
        var b = this, c = Ext.dom.Element.DISPLAY;
        b.el = a.view.el;
        b.handle = a.view.ownerGrid.body.createChild({
            cls: "x-ssm-extender-drag-handle",
            style: "display:none"
        }).setVisibilityMode(c);
        b.handle.on({
            contextmenu: function (d) {
                d.stopEvent()
            }
        });
        b.mask = b.el.createChild({cls: "x-ssm-extender-mask", style: "display:none"}).setVisibilityMode(c);
        b.superclass.constructor.call(b, a);
        b.mask.skipGarbageCollection = b.handle.skipGarbageCollection = true;
        b.viewListeners = b.view.on({scroll: b.onViewScroll, scope: b, destroyable: true});
        b.gridListeners = b.view.ownerGrid.on({columnResize: b.alignHandle, scope: b, destroyable: true});
        b.extendX = !!(b.axes & 1);
        b.extendY = !!(b.axes & 2)
    }, setHandle: function (c, b) {
        var a = this;
        if (!a.view.rendered) {
            a.view.on({render: a.initSelectionExtender, args: [c, b], scope: a});
            return
        }
        a.firstPos = c;
        a.lastPos = b;
        if (c && b) {
            if (a.curPos) {
                a.curPos.setPosition(b)
            } else {
                a.curPos = b.clone()
            }
            if (c && b) {
                a.alignHandle()
            }
        } else {
            a.disable()
        }
    }, alignHandle: function () {
        var b = this, a = b.lastPos && b.lastPos.getCell();
        if (a) {
            b.enable();
            b.handle.alignTo(a, "c-br")
        } else {
            b.disable()
        }
    }, enable: function () {
        this.handle.show();
        Ext.dd.DragTracker.prototype.enable.call(this)
    }, disable: function () {
        this.handle.hide();
        this.mask.hide();
        Ext.dd.DragTracker.prototype.disable.call(this)
    }, onDrag: function (j) {
        if (j.target === this.mask.dom) {
            this.mask.hide();
            j.target = document.elementFromPoint.apply(document, j.getXY());
            this.mask.show()
        }
        var i = this, c = i.view, b = c.el.getY(), g = c.el.getX(), h = j.getTarget(i.view.getCellSelector()),
            d = i.scrollTask || (i.scrollTask = Ext.util.TaskManager.newTask({
                run: i.doAutoScroll,
                scope: i,
                interval: 10
            })), a = i.scrollBy || (i.scrollBy = []);
        if (!i.el.contains(j.target)) {
            a[0] = a[1] = 0;
            return d.stop()
        }
        if (i.lastXY[1] > b + c.el.getHeight(true) - 15) {
            if (i.extendY) {
                a[1] = 3;
                d.start()
            }
        } else {
            if (i.lastXY[1] < b + 10) {
                if (i.extendY) {
                    a[1] = -3;
                    d.start()
                }
            } else {
                if (i.lastXY[0] > g + c.el.getWidth(true) - 15) {
                    if (i.extendX) {
                        a[0] = 3;
                        d.start()
                    }
                } else {
                    if (i.lastXY[0] < g + 10) {
                        if (i.extendX) {
                            a[0] = -3;
                            d.start()
                        }
                    } else {
                        a[0] = a[1] = 0;
                        d.stop()
                    }
                }
            }
        }
        if (h && h !== i.lastOverCell) {
            i.lastOverCell = h;
            i.syncMaskOnCell(h)
        }
    }, doAutoScroll: function () {
        var b = this, a = b.view, c;
        a.scrollBy.apply(a, b.scrollBy);
        c = document.elementFromPoint.apply(document, b.lastXY);
        if (c) {
            c = Ext.fly(c).up(a.cellSelector);
            if (c && c !== b.lastOverCell) {
                b.lastOverCell = c;
                b.syncMaskOnCell(c)
            }
        }
    }, onEnd: function (b) {
        var a = this;
        if (a.scrollTask) {
            a.scrollTask.stop()
        }
        if (a.extensionDescriptor) {
            a.disable();
            a.view.getSelectionModel().extendSelection(a.extensionDescriptor)
        }
    }, onViewScroll: function () {
        var a = this;
        if (a.active && a.lastOverCell) {
            a.syncMaskOnCell(a.lastOverCell)
        }
        if (a.firstPos) {
            a.alignHandle()
        }
    }, syncMaskOnCell: function (e) {
        var h = this, j = h.view, k = j.all, b = h.curPos, g = h.maskBox, l, a = h.firstPos.clone(),
            i = h.lastPos.clone(), d = h.firstPos.clone(), c = h.lastPos.clone();
        a.setRow(Math.min(Math.max(a.rowIdx, k.startIndex), k.endIndex));
        i.setRow(Math.min(Math.max(i.rowIdx, k.startIndex), k.endIndex));
        h.selectionRegion = l = a.getCell().getRegion().union(i.getCell().getRegion());
        b.setPosition(j.getRecord(e), j.getHeaderByCell(e));
        e = Ext.fly(e);
        h.mask.dom.style.borderTopWidth = h.mask.dom.style.borderRightWidth = h.mask.dom.style.borderBottomWidth = h.mask.dom.style.borderLeftWidth = "";
        if (b.rowIdx < h.firstPos.rowIdx && h.extendY) {
            h.extensionDescriptor = {
                type: "rows",
                start: d.setRow(b.rowIdx),
                end: c.setRow(h.firstPos.rowIdx - 1),
                rows: b.rowIdx - h.firstPos.rowIdx,
                mousePosition: h.lastXY
            };
            h.mask.dom.style.borderBottomWidth = "0";
            g.x = l.x;
            g.y = e.getY();
            g.width = l.right - l.left;
            g.height = l.top - e.getY()
        } else {
            if (b.rowIdx > h.lastPos.rowIdx && h.extendY) {
                h.extensionDescriptor = {
                    type: "rows",
                    start: d.setRow(h.lastPos.rowIdx + 1),
                    end: c.setRow(b.rowIdx),
                    rows: b.rowIdx - h.lastPos.rowIdx,
                    mousePosition: h.lastXY
                };
                h.mask.dom.style.borderTopWidth = "0";
                g.x = l.x;
                g.y = l.bottom;
                g.width = l.right - l.left;
                g.height = e.getRegion().bottom - l.bottom
            } else {
                if (b.colIdx < h.firstPos.colIdx && h.extendX) {
                    h.extensionDescriptor = {
                        type: "columns",
                        start: d.setColumn(b.colIdx),
                        end: c.setColumn(h.firstPos.colIdx - 1),
                        columns: b.colIdx - h.firstPos.colIdx,
                        mousePosition: h.lastXY
                    };
                    h.mask.dom.style.borderRightWidth = "0";
                    g.x = e.getX();
                    g.y = l.top;
                    g.width = l.left - e.getX();
                    g.height = l.bottom - l.top
                } else {
                    if (b.colIdx > h.lastPos.colIdx && h.extendX) {
                        h.extensionDescriptor = {
                            type: "columns",
                            start: d.setColumn(h.lastPos.colIdx + 1),
                            end: c.setColumn(b.colIdx),
                            columns: b.colIdx - h.lastPos.colIdx,
                            mousePosition: h.lastXY
                        };
                        h.mask.dom.style.borderLeftWidth = "0";
                        g.x = l.right;
                        g.y = l.top;
                        g.width = e.getRegion().right - l.right;
                        g.height = l.bottom - l.top
                    } else {
                        h.extensionDescriptor = null
                    }
                }
            }
        }
        if (j.ownerGrid.hasListeners.selectionextenderdrag) {
            j.ownerGrid.fireEvent("selectionextenderdrag", j.ownerGrid, j.getSelectionModel().getSelected(), h.extensionDescriptor)
        }
        if (h.extensionDescriptor) {
            h.mask.show();
            h.mask.setBox(g)
        } else {
            h.mask.hide()
        }
    }, destroy: function () {
        var a = this;
        Ext.destroy(a.gridListeners, a.viewListeners, a.mask, a.handle);
        Ext.dd.DragTracker.prototype.destroy.call(this)
    }
}, 1, 0, 0, 0, 0, 0, [Ext.grid.selection, "SelectionExtender"], 0));
(Ext.cmd.derive("Ext.grid.selection.SpreadsheetModel", Ext.selection.Model, {
    isSpreadsheetModel: true,
    config: {
        columnSelect: {$value: false, lazy: true},
        cellSelect: {$value: true, lazy: true},
        rowSelect: {$value: true, lazy: true},
        dragSelect: {$value: true, lazy: true},
        selected: null,
        extensible: {$value: true, lazy: true}
    },
    checkboxSelect: false,
    checkboxColumnIndex: 0,
    showHeaderCheckbox: true,
    checkboxHeaderWidth: 24,
    rowNumbererHeaderWidth: 46,
    columnSelectCls: "x-ssm-column-select",
    rowNumbererHeaderCls: "x-ssm-row-numberer-hd",
    checkerOnCls: "x-grid-hd-checker-on",
    tdCls: "x-grid-cell-special x-grid-cell-row-checker",
    bindComponent: function (a) {
        var c = this, b, d;
        if (c.view !== a) {
            if (c.view) {
                c.navigationModel = null;
                Ext.destroy(c.viewListeners, c.navigationListeners)
            }
            c.view = a;
            if (a) {
                c.getCellSelect();
                d = a.ownerGrid.lockedGrid;
                if (d) {
                    c.hasLockedHeader = true;
                    c.onViewCreated(d, d.getView())
                } else {
                    a.grid.on({viewcreated: c.onViewCreated, scope: c, single: true})
                }
                c.gridListeners = a.ownerGrid.on({
                    columnschanged: c.onColumnsChanged,
                    columnmove: c.onColumnMove,
                    scope: c,
                    destroyable: true
                });
                b = c.getViewListeners();
                b.scope = c;
                b.destroyable = true;
                c.viewListeners = a.on(b);
                c.navigationModel = a.getNavigationModel();
                c.navigationListeners = c.navigationModel.on({navigate: c.onNavigate, scope: c, destroyable: true});
                if (c.getColumnSelect()) {
                    a.ownerGrid.addCls(c.columnSelectCls)
                }
            }
        }
    },
    getCheckboxHeaderConfig: function () {
        var a = this, b = a.showHeaderCheckbox !== false;
        return {
            ignoreExport: true,
            isCheckerHd: b,
            text: "&#160;",
            clickTargetName: "el",
            width: a.checkboxHeaderWidth,
            sortable: false,
            draggable: false,
            resizable: false,
            hideable: false,
            menuDisabled: true,
            dataIndex: "",
            tdCls: a.tdCls,
            cls: b ? "x-column-header-checkbox " : "",
            defaultRenderer: a.checkboxRenderer.bind(a),
            editRenderer: "&#160;",
            locked: a.hasLockedHeader
        }
    },
    checkboxRenderer: function () {
        return '<div class="x-grid-row-checker" role="presentation">&#160;</div>'
    },
    onHeaderClick: function (j, k, h) {
        var d = this, g = d.selected, a, b, c;
        if (k === d.numbererColumn || k === d.checkColumn) {
            h.stopEvent();
            if (!g || !g.isAllSelected()) {
                d.selectAll()
            } else {
                d.deselectAll()
            }
            d.updateHeaderState();
            d.lastColumnSelected = null
        } else {
            if (d.columnSelect) {
                if (h.shiftKey && g && g.lastColumnSelected) {
                    g.clear();
                    a = this.view.ownerGrid.getVisibleColumnManager();
                    b = Ext.Array.sort([a.indexOf(g.lastColumnSelected), a.indexOf(k)], Ext.Array.numericSortFn);
                    for (c = b[0]; c <= b[1]; c++) {
                        d.selectColumn(a.getHeaderAtIndex(c), true)
                    }
                } else {
                    if (d.isColumnSelected(k)) {
                        d.deselectColumn(k);
                        d.selected.lastColumnSelected = null
                    } else {
                        d.selectColumn(k, h.ctrlKey);
                        d.selected.lastColumnSelected = k
                    }
                }
            }
        }
    },
    updateHeaderState: function () {
        var e = this, c = e.view.dataSource, i = c.getCount(), b = e.views, g = e.selected,
            h = g && g.isRows && !c.isBufferedStore && i > 0 && (i === g.getCount()), d = e.checkColumn,
            a = e.checkerOnCls;
        if (b && b.length) {
            if (d) {
                if (h) {
                    d.addCls(a)
                } else {
                    d.removeCls(a)
                }
            }
        }
    },
    onReconfigure: function (c, a, b) {
        if (b) {
            this.addCheckbox(this.views[0])
        }
    },
    getCellContext: function (a, b) {
        return new Ext.grid.CellContext(this.view.ownerGrid.getView()).setPosition(a, b)
    },
    select: function (b, m, l) {
        var h = this, a = h.selected, j = h.view, k = j.dataSource, g, d, e, c = false;
        if (!a || !a.isRows || a.view !== j) {
            h.resetSelection(true);
            a = h.selected = new Ext.grid.selection.Rows(j)
        } else {
            if (!m) {
                a.clear()
            }
        }
        if (!Ext.isArray(b)) {
            b = [b]
        }
        g = b.length;
        for (d = 0; d < g; d++) {
            e = b[d];
            if (typeof e === "number") {
                e = k.getAt(e)
            }
            if (!a.contains(e)) {
                a.add(e);
                c = true
            }
        }
        if (c) {
            h.updateHeaderState();
            if (l) {
                h.fireSelectionChange()
            }
        }
    },
    deselect: function (b, k) {
        var h = this, a = h.selected, j = h.view.dataSource, g, d, e, c = false;
        if (a && a.isRows) {
            if (!Ext.isArray(b)) {
                b = [b]
            }
            g = b.length;
            for (d = 0; d < g; d++) {
                e = b[d];
                if (typeof e === "number") {
                    e = j.getAt(e)
                }
                c = c || a.remove(e)
            }
        }
        if (c) {
            h.updateHeaderState();
            if (!k) {
                h.fireSelectionChange()
            }
        }
    },
    selectCells: function (g, e, b) {
        var c = this, a = c.view.ownerGrid.view, d;
        g = g.isCellContext ? g.clone() : new Ext.grid.CellContext(a).setPosition(g);
        e = e.isCellContext ? e.clone() : new Ext.grid.CellContext(a).setPosition(e);
        c.resetSelection(true);
        c.selected = d = new Ext.grid.selection.Cells(g.view);
        d.setRangeStart(g);
        d.setRangeEnd(e);
        if (!b) {
            c.fireSelectionChange()
        }
    },
    selectAll: function (c) {
        var d = this, e = d.selected, a, b = d.view;
        if (d.rowSelect) {
            if (!e || !e.isRows) {
                d.resetSelection(true);
                d.selected = e = new Ext.grid.selection.Rows(b)
            }
            a = true
        } else {
            if (d.cellSelect) {
                if (!e || !e.isCells) {
                    d.resetSelection(true);
                    d.selected = e = new Ext.grid.selection.Cells(b)
                }
                a = true
            } else {
                if (d.columnSelect) {
                    if (!e || !e.isColumns) {
                        d.resetSelection(true);
                        d.selected = e = new Ext.grid.selection.Columns(b)
                    }
                    a = true
                }
            }
        }
        if (a) {
            e.selectAll();
            d.updateHeaderState();
            if (!c) {
                d.fireSelectionChange()
            }
        }
    },
    deselectAll: function (a) {
        var b = this.selected;
        if (b && b.getCount()) {
            b.clear();
            if (!a) {
                this.fireSelectionChange()
            }
        }
    },
    selectRows: function (j, e, c) {
        var g = this, h = g.selected, b = h && h.isRows, a = j.length, d;
        if (!e || !b) {
            g.resetSelection(true)
        }
        if (!b) {
            g.selected = h = new Ext.grid.selection.Rows(g.view)
        }
        if (j.isEntity) {
            h.add(j)
        } else {
            for (d = 0; d < a; d++) {
                h.add(j[d])
            }
        }
        if (!c) {
            g.fireSelectionChange()
        }
    },
    isSelected: function (a) {
        return this.isRowSelected(a)
    },
    selectColumn: function (d, c, b) {
        var e = this, g = e.selected, a = d.getView();
        if (!g || !g.isColumns || g.view !== a.ownerGrid.view) {
            e.resetSelection(true);
            e.selected = g = new Ext.grid.selection.Columns(a)
        }
        if (!g.contains(d)) {
            if (!c) {
                g.clear()
            }
            g.add(d);
            e.updateHeaderState();
            if (!b) {
                e.fireSelectionChange()
            }
        }
    },
    deselectColumn: function (b, a) {
        var c = this, d = c.getSelected();
        if (d && d.isColumns && d.contains(b)) {
            d.remove(b);
            c.updateHeaderState();
            if (!a) {
                c.fireSelectionChange()
            }
        }
    },
    getSelection: function () {
        var a = this.selected;
        if (a && a.isRows) {
            return a.getRecords()
        }
        return []
    },
    destroy: function () {
        var b = this, a = b.scrollEls;
        Ext.destroy(b.gridListeners, b.viewListeners, b.selected, b.navigationListeners, b.extensible);
        if (a) {
            Ext.dd.ScrollManager.unregister(a)
        }
        b.selected = b.gridListeners = b.viewListeners = b.selectionData = b.navigationListeners = b.scrollEls = null;
        Ext.selection.Model.prototype.destroy.call(this)
    },
    privates: {
        axesConfigs: {x: 1, y: 2, xy: 3, both: 3, "true": 3}, getViewListeners: function () {
            return {
                beforerefresh: this.onBeforeViewRefresh,
                refresh: this.onViewRefresh,
                keyup: {element: "el", fn: this.onViewKeyUp, scope: this}
            }
        }, onViewKeyUp: function (b) {
            var a = this.selected;
            if (b.keyCode === b.SHIFT && a && a.isRows && a.getRangeSize()) {
                a.addRange()
            }
        }, onColumnsChanged: function () {
            var g = this.selected, h, e, i, d, a, b, c;
            if (g) {
                a = g.view;
                if (g.isCells) {
                    b = new Ext.grid.CellContext(a);
                    h = g.getRowRange();
                    e = a.getVisibleColumnManager().getColumns().length;
                    for (d = h[0]; d <= h[1]; d++) {
                        b.setRow(d);
                        for (i = 0; i < e; i++) {
                            b.setColumn(i);
                            a.onCellDeselect(b)
                        }
                    }
                } else {
                    if (g.isColumns) {
                        c = false;
                        g.eachColumn(function (j, k) {
                            if (!j.isVisible() || !a.ownerGrid.isAncestor(j)) {
                                this.remove(j);
                                c = true
                            }
                        })
                    }
                }
            }
            Ext.on("idle", c ? this.fireSelectionChange : this.updateSelectionExtender, this, {single: true})
        }, onColumnMove: function () {
            this.updateSelectionExtender()
        }, onBeforeViewRefresh: function (a) {
            var b = this.selected;
            if (a.refreshCounter) {
                if (b && b.isCells) {
                    this.resetSelection()
                }
            }
        }, onViewRefresh: function (a) {
            var c = this, d = this.selected, b = c.view.store, e = false;
            if (d && d.isRows && b.isFiltered()) {
                d.eachRow(function (g) {
                    if (!b.contains(g)) {
                        this.remove(g);
                        e = true
                    }
                })
            }
            this[e ? "fireSelectionChange" : "updateSelectionExtender"]()
        }, resetSelection: function (a) {
            var b = this.selected;
            if (b) {
                b.clear();
                if (!a) {
                    this.fireSelectionChange()
                }
            }
        }, onViewCreated: function (b, a) {
            var c = this, d = a.ownerGrid, e = a.headerCt;
            if (!d.lockable || a.isLockedView) {
                if (c.getRowSelect()) {
                    c.getNumbererColumn()
                }
                if (c.checkboxSelect) {
                    c.addCheckbox(a, true);
                    c.mon(a.ownerGrid, "reconfigure", c.onReconfigure, c)
                }
            }
            e.sortOnClick = !c.getColumnSelect();
            if (c.getDragSelect()) {
                a.on("render", c.onViewRender, c, {single: true})
            }
        }, onViewRender: function (c) {
            var g = this, e = c.getEl(), b = g.views, a = b.length, d;
            for (d = 0; d < a; d++) {
                b[d].headerCt.sortOnClick = !g.columnSelect
            }
            e.ddScrollConfig = {vthresh: 50, hthresh: 50, frequency: 300, increment: 100};
            Ext.dd.ScrollManager.register(e);
            (g.scrollEls || (g.scrollEls = [])).push(e);
            c.on("cellmousedown", g.handleMouseDown, g);
            if (c.lockingPartner) {
                c.lockingPartner.on("cellmousedown", g.handleMouseDown, g)
            }
        }, handleMouseDown: function (m, c, l, h, j, a, i) {
            var k = this, b = k.selected, g = i.position.column, d, n;
            if (i.button || i.shiftKey || i.altKey || i.pointerType === "touch") {
                return
            }
            if (g) {
                d = g === k.checkColumn;
                if (g === k.numbererColumn || d || !k.cellSelect) {
                    if (k.rowSelect) {
                        if (b && b.isRows) {
                            if (!i.ctrlKey && !d) {
                                b.clear()
                            }
                        } else {
                            if (b) {
                                b.clear()
                            }
                            b = k.selected = new Ext.grid.selection.Rows(m)
                        }
                        n = true
                    }
                } else {
                    if (b) {
                        b.clear()
                    }
                    if (!b || !b.isCells) {
                        b = k.selected = new Ext.grid.selection.Cells(m)
                    }
                    n = true
                }
                k.lastOverRecord = k.lastOverColumn = null;
                Ext.getBody().on("mouseup", k.onMouseUp, k, {single: true, view: b.view});
                if (n) {
                    b.view.el.on("mousemove", k.onMouseMove, k, {view: b.view})
                }
            }
        }, onMouseMove: function (h, i, a) {
            var l = this, n = a.view, g, b, o = h.getTarget(n.cellSelector), d = a.view.getHeaderByCell(o),
                k = l.selected, m, j, c;
            if (l.extensible) {
                l.extensible.disable()
            }
            if (d) {
                g = n.getRecord(o.parentNode);
                b = l.store.indexOf(g);
                j = g !== l.lastOverRecord;
                c = d !== l.lastOverColumn;
                if (j || c) {
                    m = l.getCellContext(g, d)
                }
                if (k.isRows) {
                    if (j) {
                        if (l.lastOverRecord) {
                            k.setRangeEnd(b)
                        } else {
                            k.setRangeStart(b)
                        }
                    }
                } else {
                    if (j || c) {
                        if (l.lastOverRecord) {
                            k.setRangeEnd(m)
                        } else {
                            k.setRangeStart(m)
                        }
                    }
                }
                if (j || c) {
                    n.getNavigationModel().setPosition(new Ext.grid.CellContext(d.getView()).setPosition(g, d))
                }
                l.lastOverColumn = d;
                l.lastOverRecord = g
            }
        }, onMouseUp: function (g, d, c) {
            var b = this, a = c.view;
            if (a && !a.destroyed) {
                if (b.extensible) {
                    b.extensible.disable()
                }
                a.el.un("mousemove", b.onMouseMove, b);
                if (b.selected.isRows) {
                    b.selected.addRange()
                }
                b.fireSelectionChange()
            }
        }, addCheckbox: function (a, b) {
            var c = this, d = c.checkboxColumnIndex, e = a.headerCt;
            if (d !== false) {
                if (d === "first") {
                    d = 0
                } else {
                    if (d === "last") {
                        d = e.getColumnCount()
                    }
                }
                c.checkColumn = e.add(d, c.getCheckboxHeaderConfig())
            }
            if (b !== true) {
                a.refresh()
            }
        }, onNavigate: function (e) {
            var g = this, i = e.view.ownerGrid.view, c = e.record, a = g.selected,
                h = new Ext.grid.CellContext(i).setPosition(c, e.column), d = e.keyEvent, j = d.getKey(), b;
            if (d.stopSelection) {
                return
            }
            if (d.ctrlKey && (j === d.UP || j === d.LEFT || j === d.RIGHT || j === d.DOWN)) {
                return
            }
            if (a && a.isCells && a.getCount() > 1 && d.type === "click") {
                return
            }
            if (!(g.cellSelect || g.columnSelect || g.rowSelect) || !e.record || d.type === "mousedown") {
                return
            }
            if (d.ctrlKey && d.keyCode === d.A) {
                if (!a || a.getCount() < 2) {
                    g.selectAll()
                } else {
                    g.deselectAll()
                }
                g.updateHeaderState();
                return
            }
            if (d.shiftKey) {
                if (h.column === g.numbererColumn || h.column === g.checkColumn || !g.cellSelect || (a && a.isRows)) {
                    if (g.rowSelect) {
                        if (!a || !a.isRows || a.view !== i) {
                            g.resetSelection(true);
                            a = g.selected = new Ext.grid.selection.Rows(i)
                        }
                        if (!a.getRangeSize()) {
                            a.setRangeStart(e.previousRecordIndex || 0)
                        }
                        a.setRangeEnd(e.recordIndex);
                        a.addRange();
                        b = true
                    }
                } else {
                    if (g.cellSelect) {
                        if (!a || !a.isCells || a.view !== i) {
                            g.resetSelection(true);
                            a = g.selected = new Ext.grid.selection.Cells(i)
                        }
                        if (!a.getRangeSize()) {
                            a.setRangeStart(e.previousPosition || g.getCellContext(0, 0))
                        }
                        a.setRangeEnd(h);
                        b = true
                    }
                }
            } else {
                if (h.column === g.numbererColumn || h.column === g.checkColumn || !g.cellSelect) {
                    if (g.rowSelect) {
                        if (!a || !a.isRows || a.view !== i) {
                            g.resetSelection(true);
                            a = g.selected = new Ext.grid.selection.Rows(i)
                        }
                        if (d.ctrlKey || h.column === g.checkColumn) {
                            if (a.contains(c)) {
                                a.remove(c)
                            } else {
                                a.add(c)
                            }
                        } else {
                            a.clear();
                            a.add(c)
                        }
                        b = true
                    }
                } else {
                    if (g.cellSelect) {
                        if (!a || !a.isCells || a.view !== i) {
                            g.resetSelection(true);
                            g.selected = a = new Ext.grid.selection.Cells(i)
                        } else {
                            a.clear()
                        }
                        a.setRangeStart(h);
                        b = true
                    }
                }
            }
            if (b) {
                if (a.isRows) {
                    g.updateHeaderState()
                }
                g.fireSelectionChange()
            }
        }, isRowSelected: function (a) {
            var b = this, c = b.selected;
            if (c && c.isRows) {
                a = Ext.isNumber(a) ? b.store.getAt(a) : a;
                return c.contains(a)
            } else {
                return false
            }
        }, isColumnSelected: function (a) {
            var b = this, c = b.selected;
            if (c && c.isColumns) {
                return c.contains(a)
            } else {
                return false
            }
        }, isCellSelected: function (a, g, c) {
            var d = this, b, e = d.selected;
            a = a.ownerGrid.view;
            if (e) {
                if (e.isColumns) {
                    if (typeof c === "number") {
                        c = a.getVisibleColumnManager().getColumns()[c]
                    }
                    return e.contains(c)
                }
                if (e.isCells) {
                    b = new Ext.grid.CellContext(a).setPosition({row: g, column: c});
                    return e.contains(b)
                }
            }
            return false
        }, applySelected: function (a) {
            return a
        }, updateSelected: function (g, h) {
            var c, e, b, d, a;
            if (h) {
                h.clear()
            }
            if (g && g.getCount()) {
                c = g.view;
                if (g.isRows) {
                    g.eachRow(c.onRowSelect, c)
                } else {
                    if (g.isColumns) {
                        e = g.getColumns();
                        b = e.length;
                        if (b) {
                            a = new Ext.grid.CelContext(c);
                            c.store.each(function (i) {
                                a.setRow(i);
                                for (d = 0; d < b; d++) {
                                    a.setColumn(e[d]);
                                    c.onCellSelect(a)
                                }
                            })
                        }
                    } else {
                        if (g.isCells) {
                            g.eachCell(c.onCellSelect, c)
                        }
                    }
                }
            }
        }, getNumbererColumn: function (c) {
            var d = this, a = d.numbererColumn, b = d.view;
            if (!a) {
                if (b.isNormalView) {
                    b = b.ownerGrid.lockedGrid
                }
                a = d.numbererColumn = b.headerCt.down("rownumberer") || b.headerCt.add(0, d.getNumbererColumnConfig())
            }
            return a
        }, getNumbererColumnConfig: function () {
            var a = this;
            return {
                xtype: "rownumberer",
                width: a.rowNumbererHeaderWidth,
                editRenderer: "&#160;",
                tdCls: a.rowNumbererTdCls,
                cls: a.rowNumbererHeaderCls,
                locked: a.hasLockedHeader
            }
        }, updateRowSelect: function (c) {
            var b = this, d = b.selected, a = b.view;
            if (a && a.rendered) {
                if (a.isNormalView) {
                    a = a.lockingPartner
                }
                if (c) {
                    if (b.checkColumn) {
                        b.checkColumn.show()
                    }
                    b.getNumbererColumn().show()
                } else {
                    if (b.checkColumn) {
                        b.checkColumn.hide()
                    }
                    if (b.numbererColumn) {
                        b.numbererColumn.hide()
                    }
                }
                if (!c && d && d.isRows) {
                    d.clear();
                    b.fireSelectionChange()
                }
            }
        }, updateColumnSelect: function (g) {
            var d = this, e = d.selected, b = d.views, a = b ? b.length : 0, c;
            for (c = 0; c < a; c++) {
                b[c].headerCt.sortOnClick = !g
            }
            if (!g && e && e.isColumns) {
                e.clear();
                d.fireSelectionChange()
            }
            if (g) {
                d.view.ownerGrid.addCls(d.columnSelectCls)
            } else {
                d.view.ownerGrid.removeCls(d.columnSelectCls)
            }
        }, updateCellSelect: function (a) {
            var b = this, c = b.selected;
            if (!a && c && c.isCells) {
                c.clear();
                b.fireSelectionChange()
            }
        }, fireSelectionChange: function () {
            var a = this.view.ownerGrid, b = this.selected;
            this.updateSelectionExtender();
            a.fireEvent("selectionchange", a, b)
        }, updateSelectionExtender: function () {
            var a = this.selected;
            if (a) {
                a.onSelectionFinish()
            }
        }, onSelectionFinish: function (d, c, a) {
            var b = this.getExtensible();
            if (b) {
                b.setHandle(c, a)
            }
        }, applyExtensible: function (a) {
            var b = this;
            if (a === true || typeof a === "string") {
                a = {axes: b.axesConfigs[a]}
            } else {
                a = Ext.Object.chain(a)
            }
            a.view = b.selected.view;
            return new Ext.grid.selection.SelectionExtender(a)
        }, extendSelection: function (c) {
            var a = this, b = a.selected;
            if (a.view.ownerGrid.fireEvent("beforeselectionextend", a.view.ownerGrid, b, c) !== false) {
                b.extendRange(c);
                a.fireSelectionChange()
            }
        }, onIdChanged: function (a, e, d, b) {
            var c = this.selected;
            if (c && c.isRows && c.selectedRecords) {
                c.selectedRecords.updateKey(e, d)
            }
        }, onPageAdd: function (d, c, e) {
            var j = this.selected, a = e.length, g, b, h = j && j.selectedRecords;
            if (h && j.isRows) {
                for (g = 0; g < a; g++) {
                    b = e[g];
                    if (h.get(b.id)) {
                        h.replace(b)
                    }
                }
            }
        }, refresh: function () {
            var a = this.getSelected();
            if (a && a.isRows) {
                Ext.selection.Model.prototype.refresh.call(this)
            }
        }, onStoreAdd: function () {
            var a = this.getSelected();
            if (a && a.isRows) {
                Ext.selection.Model.prototype.onStoreAdd.apply(this, arguments);
                this.updateHeaderState()
            }
        }, onStoreClear: function () {
            this.resetSelection()
        }, onStoreLoad: function () {
            var a = this.getSelected();
            if (a && a.isRows) {
                Ext.selection.Model.prototype.onStoreLoad.apply(this, arguments);
                this.updateHeaderState()
            }
        }, onStoreRefresh: function () {
            var a = this.selected;
            if (a && a.isRows && a.selectedRecords) {
                this.updateSelectedInstances(a.selectedRecords)
            }
            this.updateHeaderState()
        }, onStoreRemove: function () {
            var a = this.getSelected();
            if (a && a.isRows) {
                Ext.selection.Model.prototype.onStoreRemove.apply(this, arguments)
            }
        }
    }
}, 0, 0, 0, 0, ["selection.spreadsheet"], 0, [Ext.grid.selection, "SpreadsheetModel"], function (b) {
    var a = Ext.ClassManager.get("Ext.grid.column.RowNumberer");
    if (a) {
        b.prototype.rowNumbererTdCls = Ext.grid.column.RowNumberer.prototype.tdCls + " x-ssm-row-numberer-cell"
    }
}));
(Ext.cmd.derive("Ext.util.Queue", Ext.Base, {
    constructor: function () {
        this.clear()
    }, add: function (c) {
        var b = this, a = b.getKey(c);
        if (!b.map[a]) {
            ++b.length;
            b.items.push(c);
            b.map[a] = c
        }
        return c
    }, clear: function () {
        var b = this, a = b.items;
        b.items = [];
        b.map = {};
        b.length = 0;
        return a
    }, contains: function (b) {
        var a = this.getKey(b);
        return this.map.hasOwnProperty(a)
    }, getCount: function () {
        return this.length
    }, getKey: function (a) {
        return a.id
    }, remove: function (e) {
        var d = this, c = d.getKey(e), a = d.items, b;
        if (d.map[c]) {
            b = Ext.Array.indexOf(a, e);
            Ext.Array.erase(a, b, 1);
            delete d.map[c];
            --d.length
        }
        return e
    }
}, 1, 0, 0, 0, 0, 0, [Ext.util, "Queue"], 0));
(Ext.cmd.derive("Ext.layout.ContextItem", Ext.Base, {
    heightModel: null,
    widthModel: null,
    sizeModel: null,
    optOut: false,
    ownerSizePolicy: null,
    boxChildren: null,
    boxParent: null,
    children: [],
    dirty: null,
    dirtyCount: 0,
    hasRawContent: true,
    isContextItem: true,
    isTopLevel: false,
    consumersContentHeight: 0,
    consumersContentWidth: 0,
    consumersContainerHeight: 0,
    consumersContainerWidth: 0,
    consumersHeight: 0,
    consumersWidth: 0,
    ownerCtContext: null,
    remainingChildDimensions: 0,
    props: null,
    state: null,
    wrapsComponent: false,
    constructor: function (r) {
        var s = this, p = Ext.layout.SizeModel.sizeModels, k = p.configured, j = p.shrinkWrap, b, q, n, m, g, d, t, e,
            o, l, c, i, h, a;
        Ext.apply(s, r);
        t = s.target;
        b = s.el;
        s.id = t.id;
        s.flushedProps = {};
        s.props = g = {};
        s.styles = {};
        if (!t.isComponent) {
            q = b.lastBox
        } else {
            s.wrapsComponent = true;
            s.framing = t.frameSize || null;
            s.isComponentChild = t.ownerLayout && t.ownerLayout.isComponentLayout;
            q = t.lastBox;
            n = t.ownerCt;
            if (n && (m = n.el && s.context.items[n.el.id])) {
                s.ownerCtContext = m
            }
            s.sizeModel = d = t.getSizeModel(m && m.widthModel.pairsByHeightOrdinal[m.heightModel.ordinal]);
            s.widthModel = i = d.width;
            s.heightModel = h = d.height;
            if (q && q.invalid === false) {
                l = (t.width === (e = q.width));
                c = (t.height === (o = q.height));
                if (i === j && h === j) {
                    a = true
                } else {
                    if (i === k && l) {
                        a = h === j || (h === k && c)
                    }
                }
                if (a) {
                    s.optOut = true;
                    g.width = e;
                    g.height = o
                }
            }
        }
        s.lastBox = q
    },
    init: function (j, c) {
        var t = this, a = t.props, d = t.dirty, l = t.ownerCtContext, p = t.target.ownerLayout, h = !t.state,
            u = j || h, e, o, m, q, b, v, w = t.heightModel, g = t.widthModel, k, r, s = 0;
        t.dirty = t.invalid = false;
        t.props = {};
        t.remainingChildDimensions = 0;
        if (t.boxChildren) {
            t.boxChildren.length = 0
        }
        if (!h) {
            t.clearAllBlocks("blocks");
            t.clearAllBlocks("domBlocks")
        }
        if (!t.wrapsComponent) {
            return u
        }
        v = t.target;
        t.state = {};
        if (h) {
            if (v.beforeLayout && v.beforeLayout !== Ext.emptyFn) {
                v.beforeLayout()
            }
            if (!l && (q = v.ownerCt)) {
                l = t.context.items[q.el.id]
            }
            if (l) {
                t.ownerCtContext = l;
                t.isBoxParent = p && p.isItemBoxParent(t)
            } else {
                t.isTopLevel = true
            }
            t.frameBodyContext = t.getEl("frameBody")
        } else {
            l = t.ownerCtContext;
            t.isTopLevel = !l;
            e = t.children;
            for (o = 0, m = e.length; o < m; ++o) {
                e[o].init(true)
            }
        }
        t.hasRawContent = !(v.isContainer && v.items.items.length > 0);
        if (j) {
            t.widthModel = t.heightModel = null;
            b = v.getSizeModel(l && l.widthModel.pairsByHeightOrdinal[l.heightModel.ordinal]);
            if (h) {
                t.sizeModel = b
            }
            t.widthModel = b.width;
            t.heightModel = b.height;
            if (l && !t.isComponentChild) {
                if (p.needsItemSize || !v.liquidLayout) {
                    l.remainingChildDimensions += 2
                } else {
                    if (t.widthModel.calculated) {
                        ++l.remainingChildDimensions
                    }
                    if (t.heightModel.calculated) {
                        ++l.remainingChildDimensions
                    }
                }
            }
        } else {
            if (a) {
                t.recoverProp("x", a, d);
                t.recoverProp("y", a, d);
                if (t.widthModel.calculated) {
                    t.recoverProp("width", a, d)
                } else {
                    if ("width" in a) {
                        ++s
                    }
                }
                if (t.heightModel.calculated) {
                    t.recoverProp("height", a, d)
                } else {
                    if ("height" in a) {
                        ++s
                    }
                }
                if (l && !t.isComponentChild) {
                    l.remainingChildDimensions += s
                }
            }
        }
        if (a && p && p.manageMargins) {
            t.recoverProp("margin-top", a, d);
            t.recoverProp("margin-right", a, d);
            t.recoverProp("margin-bottom", a, d);
            t.recoverProp("margin-left", a, d)
        }
        if (c) {
            k = c.heightModel;
            r = c.widthModel;
            if (r && k && g && w) {
                if (g.shrinkWrap && w.shrinkWrap) {
                    if (r.constrainedMax && k.constrainedMin) {
                        k = null
                    }
                }
            }
            if (r) {
                t.widthModel = r
            }
            if (k) {
                t.heightModel = k
            }
            if (c.state) {
                Ext.apply(t.state, c.state)
            }
        }
        return u
    },
    initContinue: function (e) {
        var h = this, d = h.ownerCtContext, a = h.target, c = h.widthModel, g = a.getInherited(), b;
        if (c.fixed) {
            g.inShrinkWrapTable = false
        } else {
            delete g.inShrinkWrapTable
        }
        if (e) {
            if (d && c.shrinkWrap) {
                b = d.isBoxParent ? d : d.boxParent;
                if (b) {
                    b.addBoxChild(h)
                }
            } else {
                if (c.natural) {
                    h.boxParent = d
                }
            }
        }
        return e
    },
    initDone: function (d) {
        var b = this, a = b.props, c = b.state;
        if (b.remainingChildDimensions === 0) {
            a.containerChildrenSizeDone = true
        }
        if (d) {
            a.containerLayoutDone = true
        }
        if (b.boxChildren && b.boxChildren.length && b.widthModel.shrinkWrap) {
            b.el.setWidth(10000);
            c.blocks = (c.blocks || 0) + 1
        }
    },
    initAnimation: function () {
        var b = this, c = b.target, a = b.ownerCtContext;
        if (a && a.isTopLevel) {
            b.animatePolicy = c.ownerLayout.getAnimatePolicy(b)
        } else {
            if (!a && c.isCollapsingOrExpanding && c.animCollapse) {
                b.animatePolicy = c.componentLayout.getAnimatePolicy(b)
            }
        }
        if (b.animatePolicy) {
            b.context.queueAnimation(b)
        }
    },
    addBlock: function (b, d, e) {
        var c = this, g = c[b] || (c[b] = {}), a = g[e] || (g[e] = {});
        if (!a[d.id]) {
            a[d.id] = d;
            ++d.blockCount;
            ++c.context.blockCount
        }
    },
    addBoxChild: function (d) {
        var c = this, b, a = d.widthModel;
        d.boxParent = this;
        d.measuresBox = a.shrinkWrap ? d.hasRawContent : a.natural;
        if (d.measuresBox) {
            b = c.boxChildren;
            if (b) {
                b.push(d)
            } else {
                c.boxChildren = [d]
            }
        }
    },
    addPositionStyles: function (d, b) {
        var a = b.x, e = b.y, c = 0;
        if (a !== undefined) {
            d.left = a + "px";
            ++c
        }
        if (e !== undefined) {
            d.top = e + "px";
            ++c
        }
        return c
    },
    addTrigger: function (g, h) {
        var e = this, a = h ? "domTriggers" : "triggers", i = e[a] || (e[a] = {}), b = e.context, d = b.currentLayout,
            c = i[g] || (i[g] = {});
        if (!c[d.id]) {
            c[d.id] = d;
            ++d.triggerCount;
            c = b.triggers[h ? "dom" : "data"];
            (c[d.id] || (c[d.id] = [])).push({item: this, prop: g});
            if (e.props[g] !== undefined) {
                if (!h || !(e.dirty && (g in e.dirty))) {
                    ++d.firedTriggers
                }
            }
        }
    },
    boxChildMeasured: function () {
        var b = this, c = b.state, a = (c.boxesMeasured = (c.boxesMeasured || 0) + 1);
        if (a === b.boxChildren.length) {
            c.clearBoxWidth = 1;
            ++b.context.progressCount;
            b.markDirty()
        }
    },
    borderNames: ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width"],
    marginNames: ["margin-top", "margin-right", "margin-bottom", "margin-left"],
    paddingNames: ["padding-top", "padding-right", "padding-bottom", "padding-left"],
    trblNames: ["top", "right", "bottom", "left"],
    cacheMissHandlers: {
        borderInfo: function (a) {
            var b = a.getStyles(a.borderNames, a.trblNames);
            b.width = b.left + b.right;
            b.height = b.top + b.bottom;
            return b
        }, marginInfo: function (a) {
            var b = a.getStyles(a.marginNames, a.trblNames);
            b.width = b.left + b.right;
            b.height = b.top + b.bottom;
            return b
        }, paddingInfo: function (b) {
            var a = b.frameBodyContext || b, c = a.getStyles(b.paddingNames, b.trblNames);
            c.width = c.left + c.right;
            c.height = c.top + c.bottom;
            return c
        }
    },
    checkCache: function (a) {
        return this.cacheMissHandlers[a](this)
    },
    clearAllBlocks: function (a) {
        var c = this[a], b;
        if (c) {
            for (b in c) {
                this.clearBlocks(a, b)
            }
        }
    },
    clearBlocks: function (c, g) {
        var h = this[c], b = h && h[g], d, e, a;
        if (b) {
            delete h[g];
            d = this.context;
            for (a in b) {
                e = b[a];
                --d.blockCount;
                if (!--e.blockCount && !e.pending && !e.done) {
                    d.queueLayout(e)
                }
            }
        }
    },
    block: function (a, b) {
        this.addBlock("blocks", a, b)
    },
    domBlock: function (a, b) {
        this.addBlock("domBlocks", a, b)
    },
    fireTriggers: function (b, g) {
        var h = this[b], d = h && h[g], c = this.context, e, a;
        if (d) {
            for (a in d) {
                e = d[a];
                ++e.firedTriggers;
                if (!e.done && !e.blockCount && !e.pending) {
                    c.queueLayout(e)
                }
            }
        }
    },
    flush: function () {
        var b = this, a = b.dirty, c = b.state, d = b.el;
        b.dirtyCount = 0;
        if ("attributes" in b) {
            d.set(b.attributes);
            delete b.attributes
        }
        if ("innerHTML" in b) {
            d.innerHTML = b.innerHTML;
            delete b.innerHTML
        }
        if (c && c.clearBoxWidth) {
            c.clearBoxWidth = 0;
            b.el.setStyle("width", null);
            if (!--c.blocks) {
                b.context.queueItemLayouts(b)
            }
        }
        if (a) {
            delete b.dirty;
            b.writeProps(a, true)
        }
    },
    flushAnimations: function () {
        var o = this, c = o.previousSize, l, n, e, h, g, d, i, m, k, a, b;
        if (c) {
            l = o.target;
            n = l.getAnimationProps();
            e = n.duration;
            h = Ext.Object.getKeys(o.animatePolicy);
            g = Ext.apply({}, {from: {}, to: {}, duration: e || Ext.fx.Anim.prototype.duration}, n);
            for (d = 0, i = 0, m = h.length; i < m; i++) {
                k = h[i];
                a = c[k];
                b = o.peek(k);
                if (a !== b) {
                    k = o.translateProps[k] || k;
                    g.from[k] = a;
                    g.to[k] = b;
                    ++d
                }
            }
            if (d) {
                if (o.isCollapsingOrExpanding === 1) {
                    l.componentLayout.undoLayout(o)
                } else {
                    o.writeProps(g.from)
                }
                o.el.animate(g);
                g = Ext.fx.Manager.getFxQueue(o.el.id)[0];
                l.$layoutAnim = g;
                g.on({
                    afteranimate: function () {
                        delete l.$layoutAnim;
                        if (l.destroying || l.destroyed) {
                            return
                        }
                        if (o.isCollapsingOrExpanding === 1) {
                            l.componentLayout.redoLayout(o);
                            l.afterCollapse(true)
                        } else {
                            if (o.isCollapsingOrExpanding === 2) {
                                l.afterExpand(true)
                            }
                        }
                        if (l.hasListeners.afterlayoutanimation) {
                            l.fireEvent("afterlayoutanimation", l)
                        }
                    }
                })
            }
        }
    },
    getBorderInfo: function () {
        var a = this, b = a.borderInfo;
        if (!b) {
            a.borderInfo = b = a.checkCache("borderInfo")
        }
        return b
    },
    getEl: function (c, a) {
        var e = this, g, d, b;
        if (c) {
            if (c.dom) {
                d = c
            } else {
                g = e.target;
                if (a) {
                    g = a
                }
                d = g[c];
                if (typeof d === "function") {
                    d = d.call(g);
                    if (d === e.el) {
                        return this
                    }
                }
            }
            if (d) {
                b = e.context.getEl(e, d)
            }
        }
        return b || null
    },
    getFrameInfo: function () {
        var c = this, d = c.frameInfo, b, a;
        if (!d) {
            b = c.framing;
            a = c.getBorderInfo();
            c.frameInfo = d = b ? {
                top: b.top + a.top,
                right: b.right + a.right,
                bottom: b.bottom + a.bottom,
                left: b.left + a.left,
                width: b.width + a.width,
                height: b.height + a.height
            } : a
        }
        return d
    },
    getMarginInfo: function () {
        var d = this, g = d.marginInfo, b, a, e, c;
        if (!g) {
            if (!d.wrapsComponent) {
                g = d.checkCache("marginInfo")
            } else {
                b = d.target;
                e = b.ownerLayout;
                c = e ? e.id : null;
                a = e && e.manageMargins;
                g = b.margin$;
                if (g && g.ownerId !== c) {
                    g = null
                }
                if (!g) {
                    g = d.parseMargins(b, b.margin) || d.checkCache("marginInfo");
                    if (a) {
                        d.setProp("margin-top", 0);
                        d.setProp("margin-right", 0);
                        d.setProp("margin-bottom", 0);
                        d.setProp("margin-left", 0)
                    }
                    g.ownerId = c;
                    b.margin$ = g
                }
                g.width = g.left + g.right;
                g.height = g.top + g.bottom
            }
            d.marginInfo = g
        }
        return g
    },
    clearMarginCache: function () {
        delete this.marginInfo;
        delete this.target.margin$
    },
    getPaddingInfo: function () {
        var a = this, b = a.paddingInfo;
        if (!b) {
            a.paddingInfo = b = a.checkCache("paddingInfo")
        }
        return b
    },
    getProp: function (c) {
        var b = this, a = b.props[c];
        b.addTrigger(c);
        return a
    },
    getDomProp: function (c) {
        var b = this, a = (b.dirty && (c in b.dirty)) ? undefined : b.props[c];
        b.addTrigger(c, true);
        return a
    },
    getStyle: function (a) {
        var c = this, b = c.styles, e, d;
        if (a in b) {
            d = b[a]
        } else {
            e = c.styleInfo[a];
            d = c.el.getStyle(a);
            if (e && e.parseInt) {
                d = parseInt(d, 10) || 0
            }
            b[a] = d
        }
        return d
    },
    getStyles: function (p, b) {
        var m = this, e = m.styles, q = {}, g = 0, d = p.length, k, j, l, a, c, h, r, o;
        b = b || p;
        for (k = 0; k < d; ++k) {
            a = p[k];
            if (a in e) {
                q[b[k]] = e[a];
                ++g;
                if (k && g === 1) {
                    j = p.slice(0, k);
                    l = b.slice(0, k)
                }
            } else {
                if (g) {
                    (j || (j = [])).push(a);
                    (l || (l = [])).push(b[k])
                }
            }
        }
        if (g < d) {
            j = j || p;
            l = l || b;
            h = m.styleInfo;
            r = m.el.getStyle(j);
            for (k = j.length; k--;) {
                a = j[k];
                c = h[a];
                o = r[a];
                if (c && c.parseInt) {
                    o = parseInt(o, 10) || 0
                }
                q[l[k]] = o;
                e[a] = o
            }
        }
        return q
    },
    hasProp: function (a) {
        return this.getProp(a) != null
    },
    hasDomProp: function (a) {
        return this.getDomProp(a) != null
    },
    invalidate: function (a) {
        this.context.queueInvalidate(this, a)
    },
    markDirty: function () {
        if (++this.dirtyCount === 1) {
            this.context.queueFlush(this)
        }
    },
    onBoxMeasured: function () {
        var a = this.boxParent, b = this.state;
        if (a && a.widthModel.shrinkWrap && !b.boxMeasured && this.measuresBox) {
            b.boxMeasured = 1;
            a.boxChildMeasured()
        }
    },
    parseMargins: function (a, d) {
        if (d === true) {
            d = 5
        }
        var c = typeof d, b;
        if (c === "string" || c === "number") {
            b = a.parseBox(d)
        } else {
            if (d) {
                b = {top: 0, right: 0, bottom: 0, left: 0};
                if (d) {
                    d = Ext.apply(b, a.parseBox(d))
                }
            }
        }
        return b
    },
    peek: function (a) {
        return this.props[a]
    },
    recalculateSizeModel: function () {
        var e = this, g = e.target, c = g.componentLayout, b = e.ownerCtContext, a = c.ownerContext, d;
        c.ownerContext = null;
        e.sizeModel = d = g.getSizeModel(b && b.widthModel.pairsByHeightOrdinal[b.heightModel.ordinal]);
        e.widthModel = d.width;
        e.heightModel = d.height;
        if (a) {
            c.ownerContext = e
        }
    },
    recoverProp: function (g, b, a) {
        var e = this, d = e.props, c;
        if (g in b) {
            d[g] = b[g];
            if (a && g in a) {
                c = e.dirty || (e.dirty = {});
                c[g] = a[g]
            }
        }
    },
    redo: function (b) {
        var e = this, c, a, d;
        e.revertProps(e.props);
        if (b && e.wrapsComponent) {
            if (e.childItems) {
                for (d = 0, c = e.childItems, a = c.length; d < a; d++) {
                    c[d].redo(b)
                }
            }
            for (d = 0, c = e.children, a = c.length; d < a; d++) {
                c[d].redo()
            }
        }
    },
    removeEl: function (b, a) {
        var d = this, e, c;
        if (b) {
            if (b.dom) {
                c = b
            } else {
                e = d.target;
                if (a) {
                    e = a
                }
                c = e[b];
                if (typeof c === "function") {
                    c = c.call(e);
                    if (c === d.el) {
                        return this
                    }
                }
            }
            if (c) {
                d.context.removeEl(c, d)
            }
        }
    },
    revertProps: function (d) {
        var a, b = this.flushedProps, c = {};
        for (a in d) {
            if (b.hasOwnProperty(a)) {
                c[a] = d[a]
            }
        }
        this.writeProps(c)
    },
    setAttribute: function (a, c) {
        var b = this;
        if (!b.attributes) {
            b.attributes = {}
        }
        b.attributes[a] = c;
        b.markDirty()
    },
    setBox: function (b) {
        var a = this;
        if ("left" in b) {
            a.setProp("x", b.left)
        }
        if ("top" in b) {
            a.setProp("y", b.top)
        }
        a.setSize(b.width, b.height)
    },
    setContentHeight: function (a, b) {
        if (!b && this.hasRawContent) {
            return 1
        }
        return this.setProp("contentHeight", a)
    },
    setContentWidth: function (b, a) {
        if (!a && this.hasRawContent) {
            return 1
        }
        return this.setProp("contentWidth", b)
    },
    setContentSize: function (c, a, b) {
        return this.setContentWidth(c, b) + this.setContentHeight(a, b) === 2
    },
    setProp: function (d, c, a) {
        var b = this, g = typeof c, e;
        if (g === "undefined" || (g === "number" && isNaN(c))) {
            return 0
        }
        if (b.props[d] === c) {
            return 1
        }
        b.props[d] = c;
        ++b.context.progressCount;
        if (a === false) {
            b.fireTriggers("domTriggers", d);
            b.clearBlocks("domBlocks", d)
        } else {
            e = b.styleInfo[d];
            if (e) {
                if (!b.dirty) {
                    b.dirty = {}
                }
                b.dirty[d] = c;
                b.markDirty()
            }
        }
        b.fireTriggers("triggers", d);
        b.clearBlocks("blocks", d);
        return 1
    },
    setHeight: function (k, a) {
        var g = this, d = g.target, c = g.ownerCtContext, h, e, b, j, i;
        if (k < 0) {
            k = 0
        }
        if (!g.wrapsComponent) {
            if (!g.setProp("height", k, a)) {
                return NaN
            }
        } else {
            b = g.collapsedVert ? 0 : (d.minHeight || 0);
            k = Ext.Number.constrain(k, b, d.maxHeight);
            j = g.props.height;
            if (!g.setProp("height", k, a)) {
                return NaN
            }
            if (c && !g.isComponentChild && isNaN(j)) {
                i = --c.remainingChildDimensions;
                if (!i) {
                    c.setProp("containerChildrenSizeDone", true)
                }
            }
            h = g.frameBodyContext;
            if (h) {
                e = g.getFrameInfo();
                h[g.el.vertical ? "setWidth" : "setHeight"](k - e.height, a)
            }
        }
        return k
    },
    setWidth: function (b, a) {
        var i = this, g = i.target, e = i.ownerCtContext, j, h, d, c, k;
        if (b < 0) {
            b = 0
        }
        if (!i.wrapsComponent) {
            if (!i.setProp("width", b, a)) {
                return NaN
            }
        } else {
            d = i.collapsedHorz ? 0 : (g.minWidth || 0);
            b = Ext.Number.constrain(b, d, g.maxWidth);
            c = i.props.width;
            if (!i.setProp("width", b, a)) {
                return NaN
            }
            if (e && !i.isComponentChild && isNaN(c)) {
                k = --e.remainingChildDimensions;
                if (!k) {
                    e.setProp("containerChildrenSizeDone", true)
                }
            }
            j = i.frameBodyContext;
            if (j) {
                h = i.getFrameInfo();
                j.setWidth(b - h.width, a)
            }
        }
        return b
    },
    setSize: function (c, a, b) {
        this.setWidth(c, b);
        this.setHeight(a, b)
    },
    translateProps: {x: "left", y: "top"},
    undo: function (b) {
        var e = this, c, a, d;
        e.revertProps(e.lastBox);
        if (b && e.wrapsComponent) {
            if (e.childItems) {
                for (d = 0, c = e.childItems, a = c.length; d < a; d++) {
                    c[d].undo(b)
                }
            }
            for (d = 0, c = e.children, a = c.length; d < a; d++) {
                c[d].undo()
            }
        }
    },
    unsetProp: function (b) {
        var a = this.dirty;
        delete this.props[b];
        if (a) {
            delete a[b]
        }
    },
    writeProps: function (e, d) {
        if (!(e && typeof e === "object")) {
            return
        }
        var s = this, c = s.el, i = {}, g = 0, b = s.styleInfo, r, j, m, o = e.width, k = e.height, t = s.target, h, a,
            n, p, q, l;
        if ("displayed" in e) {
            c.setDisplayed(e.displayed)
        }
        for (j in e) {
            if (d) {
                s.fireTriggers("domTriggers", j);
                s.clearBlocks("domBlocks", j);
                s.flushedProps[j] = 1
            }
            r = b[j];
            if (r && r.dom) {
                if (r.suffix && (m = parseInt(e[j], 10))) {
                    i[j] = m + r.suffix
                } else {
                    i[j] = e[j]
                }
                ++g
            }
        }
        if ("x" in e || "y" in e) {
            if (t.isComponent) {
                t.setPosition(e.x, e.y)
            } else {
                g += s.addPositionStyles(i, e)
            }
        }
        if (s.wrapsComponent && Ext.isIE9) {
            if ((h = o !== undefined && s.hasOverflowY) || (a = k !== undefined && s.hasOverflowX)) {
                n = s.isAbsolute;
                if (n === undefined) {
                    n = false;
                    l = s.target.getTargetEl();
                    q = l.getStyle("position");
                    s.isAbsolute = n = (q === "absolute")
                }
                if (n) {
                    p = Ext.getScrollbarSize();
                    if (h) {
                        o = parseInt(o, 10) + p.width;
                        i.width = o + "px";
                        ++g
                    }
                    if (a) {
                        k = parseInt(k, 10) + p.height;
                        i.height = k + "px";
                        ++g
                    }
                }
            }
        }
        if (g) {
            c.setStyle(i)
        }
    }
}, 1, 0, 0, 0, 0, 0, [Ext.layout, "ContextItem"], function () {
    var c = {dom: true, parseInt: true, suffix: "px"}, b = {dom: true}, a = {dom: false};
    this.prototype.styleInfo = {
        containerChildrenSizeDone: a,
        containerLayoutDone: a,
        displayed: a,
        done: a,
        x: a,
        y: a,
        columnsChanged: a,
        rowHeights: a,
        viewOverflowY: a,
        left: c,
        top: c,
        right: c,
        bottom: c,
        width: c,
        height: c,
        "border-top-width": c,
        "border-right-width": c,
        "border-bottom-width": c,
        "border-left-width": c,
        "margin-top": c,
        "margin-right": c,
        "margin-bottom": c,
        "margin-left": c,
        "padding-top": c,
        "padding-right": c,
        "padding-bottom": c,
        "padding-left": c,
        "line-height": b,
        display: b,
        clear: b
    }
}));
(Ext.cmd.derive("Ext.layout.Context", Ext.Base, {
    remainingLayouts: 0, state: 0, cycleWatchDog: 200, constructor: function (a) {
        var b = this;
        Ext.apply(b, a);
        b.items = {};
        b.layouts = {};
        b.blockCount = 0;
        b.cycleCount = 0;
        b.flushCount = 0;
        b.calcCount = 0;
        b.animateQueue = b.newQueue();
        b.completionQueue = b.newQueue();
        b.finalizeQueue = b.newQueue();
        b.finishQueue = b.newQueue();
        b.flushQueue = b.newQueue();
        b.invalidateData = {};
        b.layoutQueue = b.newQueue();
        b.invalidQueue = [];
        b.triggers = {data: {}, dom: {}}
    }, callLayout: function (b, a) {
        this.currentLayout = b;
        b[a](this.getCmp(b.owner))
    }, cancelComponent: function (j, a, m) {
        var p = this, h = j, l = !j.isComponent, b = l ? h.length : 1, d, c, o, n, g, s, q, r, t, e;
        for (d = 0; d < b; ++d) {
            if (l) {
                j = h[d]
            }
            if (m) {
                if (j.ownerCt) {
                    e = this.items[j.ownerCt.el.id];
                    if (e) {
                        Ext.Array.remove(e.childItems, p.getCmp(j))
                    }
                } else {
                    if (j.rendered) {
                        p.removeEl(j.el)
                    }
                }
            }
            if (!a) {
                q = p.invalidQueue;
                o = q.length;
                if (o) {
                    p.invalidQueue = s = [];
                    for (c = 0; c < o; ++c) {
                        r = q[c];
                        t = r.item.target;
                        if (t !== j && !t.up(j)) {
                            s.push(r)
                        }
                    }
                }
            }
            g = j.componentLayout;
            p.cancelLayout(g);
            if (g.getLayoutItems) {
                n = g.getLayoutItems();
                if (n.length) {
                    p.cancelComponent(n, true)
                }
            }
            if (j.isContainer && !j.collapsed) {
                g = j.layout;
                p.cancelLayout(g);
                n = g.getVisibleItems();
                if (n.length) {
                    p.cancelComponent(n, true)
                }
            }
        }
    }, cancelLayout: function (b) {
        var a = this;
        a.completionQueue.remove(b);
        a.finalizeQueue.remove(b);
        a.finishQueue.remove(b);
        a.layoutQueue.remove(b);
        if (b.running) {
            a.layoutDone(b)
        }
        b.ownerContext = null
    }, clearTriggers: function (g, h) {
        var a = g.id, e = this.triggers[h ? "dom" : "data"], j = e && e[a], b = (j && j.length) || 0, d, k, c;
        for (d = 0; d < b; ++d) {
            c = j[d];
            k = c.item;
            e = h ? k.domTriggers : k.triggers;
            delete e[c.prop][a]
        }
    }, flush: function () {
        var d = this, a = d.flushQueue.clear(), c = a.length, b;
        if (c) {
            ++d.flushCount;
            for (b = 0; b < c; ++b) {
                a[b].flush()
            }
        }
    }, flushAnimations: function () {
        var d = this, b = d.animateQueue.clear(), a = b.length, c;
        if (a) {
            for (c = 0; c < a; c++) {
                if (b[c].target.animate !== false) {
                    b[c].flushAnimations()
                }
            }
            Ext.fx.Manager.runner()
        }
    }, flushInvalidates: function () {
        var h = this, a = h.invalidQueue, g = a && a.length, b, e, d, c;
        h.invalidQueue = [];
        if (g) {
            e = [];
            for (c = 0; c < g; ++c) {
                b = (d = a[c]).item.target;
                if (!b.container.isDetachedBody) {
                    e.push(b);
                    if (d.options) {
                        h.invalidateData[b.id] = d.options
                    }
                }
            }
            h.invalidate(e, null)
        }
    }, flushLayouts: function (h, a, c) {
        var g = this, j = c ? g[h].items : g[h].clear(), e = j.length, b, d;
        if (e) {
            for (b = 0; b < e; ++b) {
                d = j[b];
                if (!d.running) {
                    g.callLayout(d, a)
                }
            }
            g.currentLayout = null
        }
    }, getCmp: function (a) {
        return this.getItem(a, a.el)
    }, getEl: function (b, a) {
        var c = this.getItem(a, a);
        if (!c.parent) {
            c.parent = b;
            if (b.children.length) {
                b.children.push(c)
            } else {
                b.children = [c]
            }
        }
        return c
    }, getItem: function (d, b) {
        var e = b.id, a = this.items,
            c = a[e] || (a[e] = new Ext.layout.ContextItem({context: this, target: d, el: b}));
        return c
    }, handleFailure: function () {
        var c = this.layouts, b, a;
        Ext.failedLayouts = (Ext.failedLayouts || 0) + 1;
        for (a in c) {
            b = c[a];
            if (c.hasOwnProperty(a)) {
                b.running = false;
                b.ownerContext = null
            }
        }
    }, invalidate: function (l, n) {
        var p = this, m = !l.isComponent, c, q, a, g, k, r, o, b, h, j, e, d, s;
        for (g = 0, b = m ? l.length : 1; g < b; ++g) {
            k = m ? l[g] : l;
            if (k.rendered && !k.hidden) {
                q = k.ownerLayout;
                h = k.componentLayout;
                s = false;
                if ((!q || !q.needsItemSize) && k.liquidLayout) {
                    s = true
                }
                if (!s || (q && q.setsItemSize)) {
                    r = p.getCmp(k);
                    a = !r.state;
                    j = (k.isContainer && !k.collapsed) ? k.layout : null;
                    e = p.invalidateData[r.id];
                    delete p.invalidateData[r.id];
                    d = r.init(n, e)
                }
                if (s) {
                    continue
                }
                if (e) {
                    p.processInvalidate(e, r, "before")
                }
                if (h.beforeLayoutCycle) {
                    h.beforeLayoutCycle(r)
                }
                if (j && j.beforeLayoutCycle) {
                    j.beforeLayoutCycle(r)
                }
                d = r.initContinue(d);
                c = true;
                if (h.getLayoutItems) {
                    h.renderChildren();
                    o = h.getLayoutItems();
                    if (o.length) {
                        p.invalidate(o, true)
                    }
                }
                if (j) {
                    c = false;
                    j.renderChildren();
                    if (j.needsItemSize || j.activeItemCount) {
                        o = j.getVisibleItems();
                        if (o.length) {
                            p.invalidate(o, true)
                        }
                    }
                }
                r.initDone(c);
                p.resetLayout(h, r, a);
                if (j) {
                    p.resetLayout(j, r, a)
                }
                r.initAnimation();
                if (e) {
                    p.processInvalidate(e, r, "after")
                }
            }
        }
        p.currentLayout = null
    }, isDescendant: function (a, b) {
        if (a.isContainer) {
            for (var d = b.ownerCt; d; d = d.ownerCt) {
                if (d === a) {
                    return true
                }
            }
        }
        return false
    }, layoutDone: function (a) {
        var b = a.ownerContext;
        a.running = false;
        if (a.isComponentLayout) {
            if (b.measuresBox) {
                b.onBoxMeasured()
            }
            b.setProp("done", true)
        } else {
            b.setProp("containerLayoutDone", true)
        }
        --this.remainingLayouts;
        ++this.progressCount
    }, newQueue: function () {
        return new Ext.util.Queue()
    }, processInvalidate: function (b, e, a) {
        if (b[a]) {
            var d = this, c = d.currentLayout;
            d.currentLayout = b.layout || null;
            b[a](e, b);
            d.currentLayout = c
        }
    }, queueAnimation: function (a) {
        this.animateQueue.add(a)
    }, queueCompletion: function (a) {
        this.completionQueue.add(a)
    }, queueFinalize: function (a) {
        this.finalizeQueue.add(a)
    }, queueFlush: function (a) {
        this.flushQueue.add(a)
    }, chainFns: function (a, i, g) {
        var d = this, c = a.layout, e = i.layout, b = a[g], h = i[g];
        return function (j) {
            var k = d.currentLayout;
            if (b) {
                d.currentLayout = c;
                b.call(a.scope || a, j, a)
            }
            d.currentLayout = e;
            h.call(i.scope || i, j, i);
            d.currentLayout = k
        }
    }, purgeInvalidates: function () {
        var h = this, k = [], i = h.invalidQueue, e = i.length, j, l, d, c, b, g, a;
        for (j = 0; j < e; ++j) {
            b = i[j];
            g = b.item.target;
            a = true;
            for (l = k.length; l--;) {
                d = k[l];
                c = d.item.target;
                if (g.isLayoutChild(c)) {
                    a = false;
                    break
                }
                if (c.isLayoutChild(g)) {
                    Ext.Array.erase(k, l, 1)
                }
            }
            if (a) {
                k.push(b)
            }
        }
        h.invalidQueue = k
    }, queueInvalidate: function (k, l) {
        var h = this, j = [], i = h.invalidQueue, g = i.length, d, b, e, a, c;
        if (k.isComponent) {
            d = k;
            k = h.items[d.el.id];
            if (k) {
                k.recalculateSizeModel()
            } else {
                k = h.getCmp(d)
            }
        } else {
            d = k.target
        }
        k.invalid = true;
        while (g--) {
            b = i[g];
            e = b.item.target;
            if (!d.isFloating && d.up(e)) {
                return
            }
            if (e === d) {
                if (!(a = b.options)) {
                    b.options = l
                } else {
                    if (l) {
                        if (l.widthModel) {
                            a.widthModel = l.widthModel
                        }
                        if (l.heightModel) {
                            a.heightModel = l.heightModel
                        }
                        if (!(c = a.state)) {
                            a.state = l.state
                        } else {
                            if (l.state) {
                                Ext.apply(c, l.state)
                            }
                        }
                        if (l.before) {
                            a.before = h.chainFns(a, l, "before")
                        }
                        if (l.after) {
                            a.after = h.chainFns(a, l, "after")
                        }
                    }
                }
                return
            }
            if (!e.isLayoutChild(d)) {
                j.push(b)
            }
        }
        j.push({item: k, options: l});
        h.invalidQueue = j
    }, queueItemLayouts: function (c) {
        var a = c.isComponent ? c : c.target, b = a.componentLayout;
        if (!b.pending && !b.invalid && !b.done) {
            this.queueLayout(b)
        }
        b = a.layout;
        if (b && !b.pending && !b.invalid && !b.done && !a.collapsed) {
            this.queueLayout(b)
        }
    }, queueLayout: function (a) {
        this.layoutQueue.add(a);
        a.pending = true
    }, removeEl: function (d, c) {
        var e = d.id, b = c ? c.children : null, a = this.items;
        if (b) {
            Ext.Array.remove(b, a[e])
        }
        delete a[e]
    }, resetLayout: function (b, c, d) {
        var a = this;
        a.currentLayout = b;
        b.done = false;
        b.pending = true;
        b.firedTriggers = 0;
        a.layoutQueue.add(b);
        if (d) {
            a.layouts[b.id] = b;
            b.running = true;
            if (b.finishedLayout) {
                a.finishQueue.add(b)
            }
            ++a.remainingLayouts;
            ++b.layoutCount;
            b.ownerContext = c;
            b.beginCount = 0;
            b.blockCount = 0;
            b.calcCount = 0;
            b.triggerCount = 0;
            if (!b.initialized) {
                b.initLayout()
            }
            b.beginLayout(c)
        } else {
            ++b.beginCount;
            if (!b.running) {
                ++a.remainingLayouts;
                b.running = true;
                b.ownerContext = c;
                if (b.isComponentLayout) {
                    c.unsetProp("done")
                }
                a.completionQueue.remove(b);
                a.finalizeQueue.remove(b)
            }
        }
        b.beginLayoutCycle(c, d)
    }, run: function () {
        var c = this, b = false, a = c.cycleWatchDog;
        c.purgeInvalidates();
        c.flushInvalidates();
        c.state = 1;
        c.totalCount = c.layoutQueue.getCount();
        c.flush();
        while ((c.remainingLayouts || c.invalidQueue.length) && a--) {
            if (c.invalidQueue.length) {
                c.flushInvalidates()
            }
            if (c.runCycle()) {
                b = false
            } else {
                if (!b) {
                    c.flush();
                    b = true;
                    c.flushLayouts("completionQueue", "completeLayout")
                } else {
                    if (!c.invalidQueue.length) {
                        c.state = 2;
                        break
                    }
                }
            }
            if (!(c.remainingLayouts || c.invalidQueue.length)) {
                c.flush();
                c.flushLayouts("completionQueue", "completeLayout");
                c.flushLayouts("finalizeQueue", "finalizeLayout")
            }
        }
        return c.runComplete()
    }, runComplete: function () {
        var a = this;
        a.state = 2;
        if (a.remainingLayouts) {
            a.handleFailure();
            return false
        }
        a.flush();
        a.flushLayouts("finishQueue", "finishedLayout", true);
        a.flushLayouts("finishQueue", "notifyOwner");
        a.flush();
        a.flushAnimations();
        return true
    }, runCycle: function () {
        var c = this, d = c.layoutQueue.clear(), b = d.length, a;
        ++c.cycleCount;
        c.progressCount = 0;
        for (a = 0; a < b; ++a) {
            c.runLayout(c.currentLayout = d[a])
        }
        c.currentLayout = null;
        return c.progressCount > 0
    }, runLayout: function (b) {
        var a = this, c = a.getCmp(b.owner);
        b.pending = false;
        if (c.state.blocks) {
            return
        }
        b.done = true;
        ++b.calcCount;
        ++a.calcCount;
        b.calculate(c);
        if (b.done) {
            a.layoutDone(b);
            if (b.completeLayout) {
                a.queueCompletion(b)
            }
            if (b.finalizeLayout) {
                a.queueFinalize(b)
            }
        } else {
            if (!b.pending && !b.invalid && !(b.blockCount + b.triggerCount - b.firedTriggers)) {
                a.queueLayout(b)
            }
        }
    }, setItemSize: function (h, g, b) {
        var d = h, a = 1, c, e;
        if (h.isComposite) {
            d = h.elements;
            a = d.length;
            h = d[0]
        } else {
            if (!h.dom && !h.el) {
                a = d.length;
                h = d[0]
            }
        }
        for (e = 0; e < a;) {
            c = this.get(h);
            c.setSize(g, b);
            h = d[++e]
        }
    }
}, 1, 0, 0, 0, 0, 0, [Ext.layout, "Context"], 0));
(Ext.cmd.derive("Ext.layout.component.Body", Ext.layout.component.Auto, {
    type: "body", beginLayout: function (a) {
        Ext.layout.component.Auto.prototype.beginLayout.apply(this, arguments);
        a.bodyContext = a.getEl("body")
    }, beginLayoutCycle: function (d, b) {
        var c = this, g = c.lastWidthModel, e = c.lastHeightModel, a = c.owner.body;
        Ext.layout.component.Auto.prototype.beginLayoutCycle.apply(this, arguments);
        if (g && g.fixed && d.widthModel.shrinkWrap) {
            a.setWidth(null)
        }
        if (e && e.fixed && d.heightModel.shrinkWrap) {
            a.setHeight(null)
        }
    }, calculateOwnerHeightFromContentHeight: function (c, b) {
        var a = Ext.layout.component.Auto.prototype.calculateOwnerHeightFromContentHeight.apply(this, arguments);
        if (c.targetContext !== c) {
            a += c.getPaddingInfo().height
        }
        return a
    }, calculateOwnerWidthFromContentWidth: function (c, a) {
        var b = Ext.layout.component.Auto.prototype.calculateOwnerWidthFromContentWidth.apply(this, arguments);
        if (c.targetContext !== c) {
            b += c.getPaddingInfo().width
        }
        return b
    }, measureContentWidth: function (a) {
        return a.bodyContext.setWidth(a.bodyContext.el.dom.offsetWidth, false)
    }, measureContentHeight: function (a) {
        return a.bodyContext.setHeight(a.bodyContext.el.dom.offsetHeight, false)
    }, publishInnerHeight: function (c, a) {
        var d = a - c.getFrameInfo().height, b = c.targetContext;
        if (b !== c) {
            d -= c.getPaddingInfo().height
        }
        return c.bodyContext.setHeight(d, !c.heightModel.natural)
    }, publishInnerWidth: function (d, c) {
        var a = c - d.getFrameInfo().width, b = d.targetContext;
        if (b !== d) {
            a -= d.getPaddingInfo().width
        }
        d.bodyContext.setWidth(a, !d.widthModel.natural)
    }
}, 0, 0, 0, 0, ["layout.body"], 0, [Ext.layout.component, "Body"], 0));
(Ext.cmd.derive("Ext.layout.component.FieldSet", Ext.layout.component.Body, {
    type: "fieldset", defaultCollapsedWidth: 100, beforeLayoutCycle: function (a) {
        if (a.target.collapsed) {
            a.heightModel = this.sizeModels.shrinkWrap
        }
    }, beginLayout: function (b) {
        var a = this.owner.legend;
        Ext.layout.component.Body.prototype.beginLayout.call(this, b);
        if (a) {
            b.legendContext = b.context.getCmp(a)
        }
    }, beginLayoutCycle: function (b) {
        var c = b.target, a;
        Ext.layout.component.Body.prototype.beginLayoutCycle.apply(this, arguments);
        if (c.collapsed) {
            b.setContentHeight(0);
            b.restoreMinHeight = c.minHeight;
            delete c.minHeight;
            if (b.widthModel.shrinkWrap) {
                a = this.lastComponentSize;
                b.setContentWidth((a && a.contentWidth) || this.defaultCollapsedWidth)
            }
        }
    }, finishedLayout: function (c) {
        var a = this.owner, b = c.restoreMinHeight;
        Ext.layout.component.Body.prototype.finishedLayout.apply(this, arguments);
        if (b) {
            a.minHeight = b
        }
    }, calculateOwnerWidthFromContentWidth: function (c, a) {
        var b = c.legendContext;
        if (b) {
            a = Math.max(a, b.getProp("width"))
        }
        return Ext.layout.component.Body.prototype.calculateOwnerWidthFromContentWidth.call(this, c, a)
    }, calculateOwnerHeightFromContentHeight: function (d, c) {
        var a = d.getBorderInfo(), b = d.legendContext;
        return d.getProp("contentHeight") + d.getPaddingInfo().height + (Ext.isIE8 ? d.bodyContext.getPaddingInfo().top : 0) + (b ? b.getProp("height") : a.top) + a.bottom
    }, publishInnerHeight: function (d, a) {
        var c = d.legendContext, b = 0;
        if (c) {
            b = c.getProp("height")
        }
        if (b === undefined) {
            this.done = false
        } else {
            Ext.layout.component.Body.prototype.publishInnerHeight.call(this, d, a - b)
        }
    }, getLayoutItems: function () {
        var a = this.owner.legend;
        return a ? [a] : []
    }
}, 0, 0, 0, 0, ["layout.fieldset"], 0, [Ext.layout.component, "FieldSet"], 0));
(Ext.cmd.derive("Ext.layout.container.Absolute", Ext.layout.container.Anchor, {
    alternateClassName: "Ext.layout.AbsoluteLayout",
    targetCls: "x-abs-layout-ct",
    itemCls: "x-abs-layout-item",
    ignoreOnContentChange: true,
    type: "absolute",
    adjustWidthAnchor: function (c, b) {
        var d = this.targetPadding, a = b.getStyle("left");
        return c - a + d.left
    },
    adjustHeightAnchor: function (b, a) {
        var c = this.targetPadding, d = a.getStyle("top");
        return b - d + c.top
    },
    isItemLayoutRoot: function (a) {
        return this.ignoreOnContentChange || Ext.layout.container.Anchor.prototype.isItemLayoutRoot.apply(this, arguments)
    },
    isItemShrinkWrap: function (a) {
        return true
    },
    beginLayout: function (b) {
        var a = this, c = a.getTarget();
        Ext.layout.container.Anchor.prototype.beginLayout.apply(this, arguments);
        if (c.dom !== document.body) {
            c.position()
        }
        a.targetPadding = b.targetContext.getPaddingInfo()
    },
    isItemBoxParent: function (a) {
        return true
    },
    onContentChange: function () {
        if (this.ignoreOnContentChange) {
            return false
        }
        return Ext.layout.container.Anchor.prototype.onContentChange.apply(this, arguments)
    },
    calculateContentSize: function (m, k) {
        var u = this, d = (k || 0) | ((m.widthModel.shrinkWrap ? 1 : 0) | (m.heightModel.shrinkWrap ? 2 : 0)),
            c = (d & 1) || undefined, h = (d & 2) || undefined, b = m.childItems, g = b.length, r = 0, p = 0, l = 0,
            e = m.props, t, j, n, o, s, a, q;
        if (c) {
            if (isNaN(e.contentWidth)) {
                ++l
            } else {
                c = undefined
            }
        }
        if (h) {
            if (isNaN(e.contentHeight)) {
                ++l
            } else {
                h = undefined
            }
        }
        if (l) {
            for (s = 0; s < g; ++s) {
                n = b[s];
                j = n.target;
                o = h && n.getProp("height");
                q = c && n.getProp("width");
                a = n.getMarginInfo();
                o += a.bottom;
                q += a.right;
                r = Math.max(r, (j.y || 0) + o);
                p = Math.max(p, (j.x || 0) + q);
                if (isNaN(r) && isNaN(p)) {
                    u.done = false;
                    return
                }
            }
            if (c || h) {
                t = m.targetContext.getPaddingInfo()
            }
            if (c && !m.setContentWidth(p + t.width)) {
                u.done = false
            }
            if (h && !m.setContentHeight(r + t.height)) {
                u.done = false
            }
        }
    }
}, 0, 0, 0, 0, ["layout.absolute"], 0, [Ext.layout.container, "Absolute", Ext.layout, "AbsoluteLayout"], 0));
(Ext.cmd.derive("Ext.layout.container.Accordion", Ext.layout.container.VBox, {
    type: "accordion",
    alternateClassName: "Ext.layout.AccordionLayout",
    targetCls: "x-accordion-layout-ct",
    itemCls: ["x-box-item", "x-accordion-item"],
    align: "stretch",
    enableSplitters: false,
    fill: true,
    titleCollapse: true,
    hideCollapseTool: false,
    collapseFirst: undefined,
    animate: true,
    activeOnTop: false,
    multi: false,
    wrapOver: true,
    panelCollapseMode: "header",
    defaultAnimatePolicy: {y: true, height: true},
    constructor: function () {
        var a = this;
        Ext.layout.container.VBox.prototype.constructor.apply(this, arguments);
        if (a.animate) {
            a.animatePolicy = {};
            a.animatePolicy[a.names.x] = true;
            a.animatePolicy[a.names.width] = true
        } else {
            a.animatePolicy = null
        }
    },
    beforeRenderItems: function (h) {
        var j = this, g = h.length, b = j.owner, k = j.collapseFirst, a = Ext.isDefined(k), l = j.getExpanded(true)[0],
            e = j.multi, d, c;
        for (c = 0; c < g; c++) {
            d = h[c];
            if (!d.rendered) {
                d.isAccordionPanel = true;
                d.bodyAriaRole = "tabpanel";
                d.accordionWrapOver = j.wrapOver;
                if (!e || d.collapsible !== false) {
                    d.collapsible = true
                }
                if (d.collapsible) {
                    if (a) {
                        d.collapseFirst = k
                    }
                    if (j.hideCollapseTool) {
                        d.hideCollapseTool = j.hideCollapseTool;
                        d.titleCollapse = true
                    } else {
                        if (j.titleCollapse && d.titleCollapse === undefined) {
                            d.titleCollapse = j.titleCollapse
                        }
                    }
                }
                d.hideHeader = d.width = null;
                d.title = d.title || "&#160;";
                d.addBodyCls("x-accordion-body");
                if (!e) {
                    if (l) {
                        d.collapsed = l !== d
                    } else {
                        if (d.hasOwnProperty("collapsed") && d.collapsed === false) {
                            l = d
                        } else {
                            d.collapsed = true
                        }
                    }
                    b.mon(d, "show", j.onComponentShow, j)
                }
                d.headerOverCls = "x-accordion-hd-over"
            }
        }
        if (!j.processing && !e) {
            if (!l) {
                if (g) {
                    h[0].collapsed = false
                }
            } else {
                if (j.activeOnTop) {
                    l.collapsed = false;
                    j.configureItem(l);
                    if (b.items.indexOf(l) > 0) {
                        b.insert(0, l)
                    }
                }
            }
        }
    },
    getItemsRenderTree: function (a) {
        this.beforeRenderItems(a);
        return Ext.layout.container.VBox.prototype.getItemsRenderTree.apply(this, arguments)
    },
    renderItems: function (a, b) {
        this.beforeRenderItems(a);
        Ext.layout.container.VBox.prototype.renderItems.apply(this, arguments)
    },
    configureItem: function (a) {
        Ext.layout.container.VBox.prototype.configureItem.apply(this, arguments);
        a.ignoreHeaderBorderManagement = true;
        a.animCollapse = false;
        if (this.fill) {
            a.flex = 1
        }
    },
    beginLayout: function (a) {
        Ext.layout.container.VBox.prototype.beginLayout.apply(this, arguments);
        this.innerCt.dom.setAttribute("role", "tablist");
        this.innerCt.dom.setAttribute("aria-multiselectable", true);
        this.updatePanelClasses(a)
    },
    updatePanelClasses: function (e) {
        var c = e.visibleItems, d = c.length, a = true, b, h, g;
        for (b = 0; b < d; b++) {
            h = c[b];
            g = h.header;
            g.addCls("x-accordion-hd");
            if (a) {
                g.removeCls("x-accordion-hd-sibling-expanded")
            } else {
                g.addCls("x-accordion-hd-sibling-expanded")
            }
            if (b + 1 === d && h.collapsed) {
                g.addCls("x-accordion-hd-last-collapsed")
            } else {
                g.removeCls("x-accordion-hd-last-collapsed")
            }
            a = h.collapsed
        }
    },
    onBeforeComponentExpand: function (i) {
        var d = this, a = d.owner, h = d.multi, g = !h && !d.animate && d.activeOnTop, c, b, e;
        if (!d.processing) {
            d.processing = true;
            b = a.deferLayouts;
            a.deferLayouts = true;
            if (!h) {
                c = d.getExpanded()[0];
                if (c && c !== i) {
                    e = c.$layoutAnim;
                    if (e) {
                        e.jumpToEnd()
                    }
                    c.collapse()
                }
            }
            if (g) {
                Ext.suspendLayouts();
                a.insert(0, i);
                Ext.resumeLayouts()
            }
            a.deferLayouts = b;
            d.processing = false
        }
    },
    onBeforeComponentCollapse: function (d) {
        var e = this, a = e.owner, g, c, b;
        if (e.owner.items.getCount() === 1) {
            return false
        }
        if (!e.processing) {
            e.processing = true;
            b = a.deferLayouts;
            a.deferLayouts = true;
            g = d.next() || d.prev();
            if (e.multi) {
                c = e.getExpanded();
                if (c.length === 1) {
                    g.expand()
                }
            } else {
                if (g) {
                    g.expand()
                }
            }
            a.deferLayouts = b;
            e.processing = false
        }
    },
    onComponentShow: function (a) {
        this.onBeforeComponentExpand(a)
    },
    onAdd: function (b) {
        var a = this;
        Ext.layout.container.VBox.prototype.onAdd.apply(this, arguments);
        if (b.collapseMode === "placeholder") {
            b.collapseMode = a.panelCollapseMode
        }
        b.collapseDirection = b.headerPosition;
        if (a.layoutCount && !a.multi && a.owner.items.getCount() > 1) {
            a.processing = true;
            b.collapse();
            a.processing = false
        }
    },
    onRemove: function (a, d) {
        var c = this, b;
        Ext.layout.container.VBox.prototype.onRemove.apply(this, arguments);
        if (!c.owner.destroying && !c.multi && !a.collapsed) {
            b = c.owner.items.first();
            if (b) {
                b.expand()
            }
        }
    },
    getExpanded: function (h) {
        var b = this.owner.items.items, a = b.length, d = 0, c = [], g, e;
        for (; d < a; ++d) {
            e = b[d];
            if (!e.hidden) {
                if (h) {
                    g = e.hasOwnProperty("collapsed") && e.collapsed === false
                } else {
                    g = !e.collapsed
                }
                if (g) {
                    c.push(e)
                }
            }
        }
        return c
    },
    afterCollapse: Ext.emptyFn,
    afterExpand: Ext.emptyFn
}, 1, 0, 0, 0, ["layout.accordion"], 0, [Ext.layout.container, "Accordion", Ext.layout, "AccordionLayout"], 0));
(Ext.cmd.derive("Ext.resizer.BorderSplitter", Ext.resizer.Splitter, {
    collapseTarget: null,
    getTrackerConfig: function () {
        var a = Ext.resizer.Splitter.prototype.getTrackerConfig.call(this);
        a.xclass = "Ext.resizer.BorderSplitterTracker";
        return a
    },
    onTargetCollapse: function (a) {
        Ext.resizer.Splitter.prototype.onTargetCollapse.call(this, a);
        if (this.performCollapse !== false && a.collapseMode == "mini") {
            a.addCls(a.baseCls + "-" + a.collapsedCls + "-mini")
        }
    },
    onTargetExpand: function (a) {
        Ext.resizer.Splitter.prototype.onTargetExpand.call(this, a);
        if (this.performCollapse !== false && a.collapseMode == "mini") {
            a.removeCls(a.baseCls + "-" + a.collapsedCls + "-mini")
        }
    }
}, 0, ["bordersplitter"], ["component", "box", "splitter", "bordersplitter"], {
    component: true,
    box: true,
    splitter: true,
    bordersplitter: true
}, ["widget.bordersplitter"], 0, [Ext.resizer, "BorderSplitter"], 0));
(Ext.cmd.derive("Ext.layout.container.Border", Ext.layout.container.Container, {
    alternateClassName: "Ext.layout.BorderLayout",
    targetCls: "x-border-layout-ct",
    itemCls: ["x-border-item", "x-box-item"],
    type: "border",
    isBorderLayout: true,
    padding: undefined,
    percentageRe: /(\\d+)%/,
    horzPositionProp: "left",
    padOnContainerProp: "left",
    padNotOnContainerProp: "right",
    axisProps: {
        horz: {
            borderBegin: "west",
            borderEnd: "east",
            horizontal: true,
            posProp: "x",
            sizeProp: "width",
            sizePropCap: "Width"
        },
        vert: {
            borderBegin: "north",
            borderEnd: "south",
            horizontal: false,
            posProp: "y",
            sizeProp: "height",
            sizePropCap: "Height"
        }
    },
    centerRegion: null,
    manageMargins: true,
    panelCollapseAnimate: true,
    panelCollapseMode: "placeholder",
    regionWeights: {north: 20, south: 10, center: 0, west: -10, east: -20},
    beginAxis: function (m, b, w) {
        var u = this, c = u.axisProps[w], r = !c.horizontal, l = c.sizeProp, p = 0, a = m.childItems, g = a.length, t,
            q, o, h, s, e, k, n, d, v, j;
        for (q = 0; q < g; ++q) {
            o = a[q];
            s = o.target;
            o.layoutPos = {};
            if (s.region) {
                o.region = e = s.region;
                o.isCenter = s.isCenter;
                o.isHorz = s.isHorz;
                o.isVert = s.isVert;
                o.weight = s.weight || u.regionWeights[e] || 0;
                s.weight = o.weight;
                b[s.id] = o;
                if (s.isCenter) {
                    t = o;
                    h = s.flex;
                    m.centerRegion = t;
                    continue
                }
                if (r !== o.isVert) {
                    continue
                }
                o.reverseWeighting = (e === c.borderEnd);
                n = s[l];
                d = typeof n;
                if (!s.collapsed) {
                    if (d === "string" && (k = u.percentageRe.exec(n))) {
                        o.percentage = parseInt(k[1], 10)
                    } else {
                        if (s.flex) {
                            p += o.flex = s.flex
                        }
                    }
                }
            }
        }
        if (t) {
            v = t.target;
            if ((j = v.placeholderFor)) {
                if (!h && r === j.collapsedVertical()) {
                    h = 0;
                    t.collapseAxis = w
                }
            } else {
                if (v.collapsed && (r === v.collapsedVertical())) {
                    h = 0;
                    t.collapseAxis = w
                }
            }
        }
        if (h == null) {
            h = 1
        }
        p += h;
        return Ext.apply({before: r ? "top" : "left", totalFlex: p}, c)
    },
    beginLayout: function (d) {
        var l = this, k = l.getLayoutItems(), e = l.padding, m = typeof e, p = false, q, o, b, h, g, a, c, j, n;
        if (e) {
            if (m === "string" || m === "number") {
                e = Ext.util.Format.parseBox(e)
            }
        } else {
            e = d.getEl("getTargetEl").getPaddingInfo();
            p = true
        }
        d.outerPad = e;
        d.padOnContainer = p;
        for (h = 0, b = k.length; h < b; ++h) {
            o = k[h];
            a = l.getSplitterTarget(o);
            if (a) {
                c = undefined;
                j = !!o.hidden;
                if (!a.split) {
                    if (a.isCollapsingOrExpanding) {
                        c = !!a.collapsed
                    }
                } else {
                    if (j !== a.hidden) {
                        c = !a.hidden
                    }
                }
                if (c) {
                    o.show()
                } else {
                    if (c === false) {
                        o.hide()
                    }
                }
            }
        }
        Ext.layout.container.Container.prototype.beginLayout.apply(this, arguments);
        k = d.childItems;
        b = k.length;
        g = {};
        d.borderAxisHorz = l.beginAxis(d, g, "horz");
        d.borderAxisVert = l.beginAxis(d, g, "vert");
        for (h = 0; h < b; ++h) {
            q = k[h];
            a = l.getSplitterTarget(q.target);
            if (a) {
                n = g[a.id];
                if (!n) {
                    n = d.getEl(a.el, l);
                    n.region = a.region
                }
                q.collapseTarget = a = n;
                q.weight = a.weight;
                q.reverseWeighting = a.reverseWeighting;
                a.splitter = q;
                q.isHorz = a.isHorz;
                q.isVert = a.isVert
            }
        }
        l.sortWeightedItems(k, "reverseWeighting");
        l.setupSplitterNeighbors(k)
    },
    calculate: function (d) {
        var m = this, a = m.getContainerSize(d), j = d.childItems, c = j.length, b = d.borderAxisHorz,
            k = d.borderAxisVert, e = d.outerPad, o = d.padOnContainer, h, q, l, p, n, g;
        b.begin = e[m.padOnContainerProp];
        k.begin = e.top;
        n = b.end = b.flexSpace = a.width + (o ? e[m.padOnContainerProp] : -e[m.padNotOnContainerProp]);
        g = k.end = k.flexSpace = a.height + (o ? e.top : -e.bottom);
        for (h = 0; h < c; ++h) {
            q = j[h];
            l = q.getMarginInfo();
            if (q.isHorz || q.isCenter) {
                b.addUnflexed(l.width);
                n -= l.width
            }
            if (q.isVert || q.isCenter) {
                k.addUnflexed(l.height);
                g -= l.height
            }
            if (!q.flex && !q.percentage) {
                if (q.isHorz || (q.isCenter && q.collapseAxis === "horz")) {
                    p = q.getProp("width");
                    b.addUnflexed(p);
                    if (q.collapseTarget) {
                        n -= p
                    }
                } else {
                    if (q.isVert || (q.isCenter && q.collapseAxis === "vert")) {
                        p = q.getProp("height");
                        k.addUnflexed(p);
                        if (q.collapseTarget) {
                            g -= p
                        }
                    }
                }
            }
        }
        for (h = 0; h < c; ++h) {
            q = j[h];
            l = q.getMarginInfo();
            if (q.percentage) {
                if (q.isHorz) {
                    p = Math.ceil(n * q.percentage / 100);
                    p = q.setWidth(p);
                    b.addUnflexed(p)
                } else {
                    if (q.isVert) {
                        p = Math.ceil(g * q.percentage / 100);
                        p = q.setHeight(p);
                        k.addUnflexed(p)
                    }
                }
            }
        }
        for (h = 0; h < c; ++h) {
            q = j[h];
            if (!q.isCenter) {
                m.calculateChildAxis(q, b);
                m.calculateChildAxis(q, k)
            }
        }
        if (m.finishAxis(d, k) + m.finishAxis(d, b) < 2) {
            m.done = false
        } else {
            m.finishPositions(j)
        }
    },
    calculateChildAxis: function (l, c) {
        var a = l.collapseTarget, h = "set" + c.sizePropCap, e = c.sizeProp, d = l.getMarginInfo()[e], j, b, g, i, k;
        if (a) {
            j = a.region
        } else {
            j = l.region;
            g = l.flex
        }
        b = j === c.borderBegin;
        if (!b && j !== c.borderEnd) {
            l[h](c.end - c.begin - d);
            i = c.begin
        } else {
            if (g) {
                k = Math.ceil(c.flexSpace * (g / c.totalFlex));
                k = l[h](k)
            } else {
                if (l.percentage) {
                    k = l.peek(e)
                } else {
                    k = l.getProp(e)
                }
            }
            k += d;
            if (b) {
                i = c.begin;
                c.begin += k
            } else {
                c.end = i = c.end - k
            }
        }
        l.layoutPos[c.posProp] = i
    },
    eachItem: function (h, d, c) {
        var g = this, a = g.getLayoutItems(), b = 0, e;
        if (Ext.isFunction(h)) {
            d = h;
            c = d
        }
        for (b; b < a.length; b++) {
            e = a[b];
            if (!h || e.region === h) {
                if (d.call(c, e) === false) {
                    break
                }
            }
        }
    },
    finishAxis: function (d, c) {
        var b = c.end - c.begin, a = d.centerRegion;
        if (a) {
            a["set" + c.sizePropCap](b - a.getMarginInfo()[c.sizeProp]);
            a.layoutPos[c.posProp] = c.begin
        }
        return Ext.isNumber(b) ? 1 : 0
    },
    finishPositions: function (e) {
        var c = e.length, b, a, d = this.horzPositionProp;
        for (b = 0; b < c; ++b) {
            a = e[b];
            a.setProp("x", a.layoutPos.x + a.marginInfo[d]);
            a.setProp("y", a.layoutPos.y + a.marginInfo.top)
        }
    },
    getLayoutItems: function () {
        var a = this.owner, e = (a && a.items && a.items.items) || [], d = e.length, b = [], c = 0, g, h;
        for (; c < d; c++) {
            g = e[c];
            h = g.placeholderFor;
            if (g.hidden || ((!g.floated || g.isCollapsingOrExpanding === 2) && !(h && h.isCollapsingOrExpanding === 2))) {
                b.push(g)
            }
        }
        return b
    },
    getPlaceholder: function (a) {
        return a.getPlaceholder && a.getPlaceholder()
    },
    getMaxWeight: function (a) {
        return this.getMinMaxWeight(a)
    },
    getMinWeight: function (a) {
        return this.getMinMaxWeight(a, true)
    },
    getMinMaxWeight: function (d, a) {
        var b = this, c = null;
        b.eachItem(d, function (e) {
            if (e.hasOwnProperty("weight")) {
                if (c === null) {
                    c = e.weight;
                    return
                }
                if ((a && e.weight < c) || e.weight > c) {
                    c = e.weight
                }
            }
        }, this);
        return c
    },
    getSplitterTarget: function (b) {
        var a = b.collapseTarget;
        if (a && a.collapsed) {
            return a.placeholder || a
        }
        return a
    },
    isItemBoxParent: function (a) {
        return true
    },
    isItemShrinkWrap: function (a) {
        return true
    },
    insertSplitter: function (d, c, g, b) {
        var h = d.region, e = Ext.apply({
            xtype: "bordersplitter",
            collapseTarget: d,
            id: d.id + "-splitter",
            hidden: g,
            canResize: d.splitterResize !== false,
            splitterFor: d,
            synthetic: true
        }, b), a = c + ((h === "south" || h === "east") ? 0 : 1);
        if (d.collapseMode === "mini") {
            e.collapsedCls = d.collapsedCls
        }
        d.splitter = this.owner.add(a, e)
    },
    getMoveAfterIndex: function (b) {
        var a = Ext.layout.container.Container.prototype.getMoveAfterIndex.apply(this, arguments);
        if (b.splitter) {
            a++
        }
        return a
    },
    moveItemBefore: function (a, c) {
        var b;
        if (c && c.splitter) {
            b = c.region;
            if (b === "south" || b === "east") {
                c = c.splitter
            }
        }
        return Ext.layout.container.Container.prototype.moveItemBefore.call(this, a, c)
    },
    onAdd: function (j, d) {
        var g = this, c = j.placeholderFor, i = j.region, e, h, a, b;
        Ext.layout.container.Container.prototype.onAdd.apply(this, arguments);
        if (i) {
            Ext.apply(j, g.regionFlags[i]);
            if (g.owner.isViewport) {
                j.isViewportBorderChild = true
            }
            if (j.initBorderRegion) {
                j.initBorderRegion()
            }
            e = i === "center";
            if (e) {
                g.centerRegion = j
            } else {
                h = j.split;
                a = !!j.hidden;
                if (typeof h === "object") {
                    b = h;
                    h = true
                }
                if ((j.isHorz || j.isVert) && (h || j.collapseMode === "mini")) {
                    g.insertSplitter(j, d, a || !h, b)
                }
            }
            if (!e && !j.hasOwnProperty("collapseMode")) {
                j.collapseMode = g.panelCollapseMode
            }
            if (!j.hasOwnProperty("animCollapse")) {
                if (j.collapseMode !== "placeholder") {
                    j.animCollapse = false
                } else {
                    j.animCollapse = g.panelCollapseAnimate
                }
            }
        } else {
            if (c) {
                Ext.apply(j, g.regionFlags[c.region]);
                j.region = c.region;
                j.weight = c.weight
            }
        }
    },
    onDestroy: function () {
        this.centerRegion = null;
        Ext.layout.container.Container.prototype.onDestroy.call(this)
    },
    onRemove: function (b, d) {
        var e = this, i = b.region, g = b.splitter, a = e.owner, h = a.destroying, c;
        if (i) {
            if (b.isCenter) {
                e.centerRegion = null
            }
            delete b.isCenter;
            delete b.isHorz;
            delete b.isVert;
            if (g && !a.destroying) {
                a.doRemove(g, true)
            }
            delete b.splitter
        }
        Ext.layout.container.Container.prototype.onRemove.apply(this, arguments);
        if (!h && !d && b.rendered) {
            c = b.getEl();
            if (c) {
                c.setStyle("top", "");
                c.setStyle(e.horzPositionProp, "")
            }
        }
    },
    regionMeta: {
        center: {splitterDelta: 0},
        north: {splitterDelta: 1},
        south: {splitterDelta: -1},
        west: {splitterDelta: 1},
        east: {splitterDelta: -1}
    },
    regionFlags: {
        center: {isCenter: true, isHorz: false, isVert: false},
        north: {isCenter: false, isHorz: false, isVert: true, collapseDirection: "top"},
        south: {isCenter: false, isHorz: false, isVert: true, collapseDirection: "bottom"},
        west: {isCenter: false, isHorz: true, isVert: false, collapseDirection: "left"},
        east: {isCenter: false, isHorz: true, isVert: false, collapseDirection: "right"}
    },
    setupSplitterNeighbors: function (m) {
        var p = {}, e = m.length, o = this.touchedRegions, h, g, a, l, d, k, n, b, c;
        for (h = 0; h < e; ++h) {
            k = m[h].target;
            n = k.region;
            if (k.isCenter) {
                a = k
            } else {
                if (n) {
                    c = o[n];
                    for (g = 0, l = c.length; g < l; ++g) {
                        d = p[c[g]];
                        if (d) {
                            d.neighbors.push(k)
                        }
                    }
                    if (k.placeholderFor) {
                        b = k.placeholderFor.splitter
                    } else {
                        b = k.splitter
                    }
                    if (b) {
                        b.neighbors = []
                    }
                    p[n] = b
                }
            }
        }
        if (a) {
            c = o.center;
            for (g = 0, l = c.length; g < l; ++g) {
                d = p[c[g]];
                if (d) {
                    d.neighbors.push(a)
                }
            }
        }
    },
    touchedRegions: {
        center: ["north", "south", "east", "west"],
        north: ["north", "east", "west"],
        south: ["south", "east", "west"],
        east: ["east", "north", "south"],
        west: ["west", "north", "south"]
    },
    sizePolicies: {
        vert: {readsWidth: 0, readsHeight: 1, setsWidth: 1, setsHeight: 0},
        horz: {readsWidth: 1, readsHeight: 0, setsWidth: 0, setsHeight: 1},
        flexAll: {readsWidth: 0, readsHeight: 0, setsWidth: 1, setsHeight: 1}
    },
    getItemSizePolicy: function (e) {
        var d = this, a = this.sizePolicies, c, b, g, h;
        if (e.isCenter) {
            h = e.placeholderFor;
            if (h) {
                if (h.collapsedVertical()) {
                    return a.vert
                }
                return a.horz
            }
            if (e.collapsed) {
                if (e.collapsedVertical()) {
                    return a.vert
                }
                return a.horz
            }
            return a.flexAll
        }
        c = e.collapseTarget;
        if (c) {
            return c.isVert ? a.vert : a.horz
        }
        if (e.region) {
            if (e.isVert) {
                b = e.height;
                g = a.vert
            } else {
                b = e.width;
                g = a.horz
            }
            if (e.flex || (typeof b === "string" && d.percentageRe.test(b))) {
                return a.flexAll
            }
            return g
        }
        return d.autoSizePolicy
    }
}, 0, 0, 0, 0, ["layout.border"], 0, [Ext.layout.container, "Border", Ext.layout, "BorderLayout"], function () {
    var a = {
        addUnflexed: function (c) {
            this.flexSpace = Math.max(this.flexSpace - c, 0)
        }
    }, b = this.prototype.axisProps;
    Ext.apply(b.horz, a);
    Ext.apply(b.vert, a)
}));
(Ext.cmd.derive("Ext.layout.container.Card", Ext.layout.container.Fit, {
    alternateClassName: "Ext.layout.CardLayout",
    type: "card",
    hideInactive: true,
    deferredRender: false,
    getRenderTree: function () {
        var a = this, b = a.getActiveItem();
        if (b) {
            if (b.hasListeners.beforeactivate && b.fireEvent("beforeactivate", b) === false) {
                b = a.activeItem = a.owner.activeItem = null
            } else {
                if (b.hasListeners.activate) {
                    b.on({
                        boxready: function () {
                            b.fireEvent("activate", b)
                        }, single: true
                    })
                }
            }
            if (a.deferredRender) {
                if (b) {
                    return a.getItemsRenderTree([b])
                }
            } else {
                return Ext.layout.container.Fit.prototype.getRenderTree.apply(this, arguments)
            }
        }
    },
    renderChildren: function () {
        var a = this, b = a.getActiveItem();
        if (!a.deferredRender) {
            Ext.layout.container.Fit.prototype.renderChildren.call(this)
        } else {
            if (b) {
                a.renderItems([b], a.getRenderTarget())
            }
        }
    },
    isValidParent: function (c, d, a) {
        var b = c.el ? c.el.dom : Ext.getDom(c);
        return (b && b.parentNode === (d.dom || d)) || false
    },
    getActiveItem: function () {
        var c = this, b = c.activeItem === undefined ? (c.owner && c.owner.activeItem) : c.activeItem,
            a = c.parseActiveItem(b);
        if (a && c.owner.items.indexOf(a) !== -1) {
            c.activeItem = a
        }
        return a == null ? null : (c.activeItem || c.owner.activeItem)
    },
    parseActiveItem: function (a) {
        var b;
        if (a && a.isComponent) {
            b = a
        } else {
            if (typeof a === "number" || a === undefined) {
                b = this.getLayoutItems()[a || 0]
            } else {
                if (a === null) {
                    b = null
                } else {
                    b = this.owner.getComponent(a)
                }
            }
        }
        return b
    },
    configureItem: function (a) {
        a.setHiddenState(a !== this.getActiveItem());
        Ext.layout.container.Fit.prototype.configureItem.apply(this, arguments)
    },
    onAdd: function (a, b) {
        Ext.layout.container.Fit.prototype.onAdd.call(this, a, b);
        this.setItemHideMode(a)
    },
    onRemove: function (a) {
        var b = this;
        Ext.layout.container.Fit.prototype.onRemove.call(this, a);
        b.resetItemHideMode(a);
        if (a === b.activeItem) {
            b.activeItem = undefined
        }
    },
    getAnimation: function (b, a) {
        var c = (b || {}).cardSwitchAnimation;
        if (c === false) {
            return false
        }
        return c || a.cardSwitchAnimation
    },
    getNext: function () {
        var c = arguments[0], a = this.getLayoutItems(), b = Ext.Array.indexOf(a, this.activeItem);
        return a[b + 1] || (c ? a[0] : false)
    },
    next: function () {
        var b = arguments[0], a = arguments[1];
        return this.setActiveItem(this.getNext(a), b)
    },
    getPrev: function () {
        var c = arguments[0], a = this.getLayoutItems(), b = Ext.Array.indexOf(a, this.activeItem);
        return a[b - 1] || (c ? a[a.length - 1] : false)
    },
    prev: function () {
        var b = arguments[0], a = arguments[1];
        return this.setActiveItem(this.getPrev(a), b)
    },
    setActiveItem: function (b) {
        var e = this, a = e.owner, d = e.activeItem, h = a.rendered, c, g;
        b = e.parseActiveItem(b);
        c = a.items.indexOf(b);
        if (c === -1) {
            c = a.items.items.length;
            Ext.suspendLayouts();
            b = a.add(b);
            Ext.resumeLayouts()
        }
        if (b && d !== b) {
            if (b.fireEvent("beforeactivate", b, d) === false) {
                return false
            }
            if (d && d.fireEvent("beforedeactivate", d, b) === false) {
                return false
            }
            if (h) {
                Ext.suspendLayouts();
                if (!b.rendered) {
                    e.renderItem(b, e.getRenderTarget(), a.items.length)
                }
                if (d) {
                    if (e.hideInactive) {
                        g = d.el.contains(Ext.Element.getActiveElement());
                        d.hide();
                        if (d.hidden) {
                            d.hiddenByLayout = true;
                            d.fireEvent("deactivate", d, b)
                        } else {
                            return false
                        }
                    }
                }
                if (b.hidden) {
                    b.show()
                }
                if (b.hidden) {
                    e.activeItem = b = null
                } else {
                    e.activeItem = b;
                    if (g) {
                        if (!b.defaultFocus) {
                            b.defaultFocus = ":focusable"
                        }
                        b.focus()
                    }
                }
                Ext.resumeLayouts(true)
            } else {
                e.activeItem = b
            }
            b.fireEvent("activate", b, d);
            return e.activeItem
        }
        return false
    },
    resetItemHideMode: function (a) {
        a.hideMode = a.originalHideMode;
        delete a.originalHideMode
    },
    setItemHideMode: function (a) {
        a.originalHideMode = a.hideMode;
        a.hideMode = "offsets"
    }
}, 0, 0, 0, 0, ["layout.card"], 0, [Ext.layout.container, "Card", Ext.layout, "CardLayout"], 0));
(Ext.cmd.derive("Ext.layout.container.Center", Ext.layout.container.Fit, {
    alternateClassName: "Ext.ux.layout.Center",
    type: "center",
    percentRe: /^\\d+(?:\\.\\d+)?\\%$/,
    itemCls: "x-center-layout-item",
    childEls: ["targetEl"],
    renderTpl: ['<div id="{ownerId}-targetEl" data-ref="targetEl" class="{targetElCls}" role="presentation">{%this.renderBody(out, values)%}</div>'],
    targetElCls: "x-center-target",
    beginLayout: function (b) {
        var k = this, c = k.percentRe, g, j, d, a, l, h, e;
        Ext.layout.container.Fit.prototype.beginLayout.call(this, b);
        g = b.childItems;
        for (d = 0, j = g.length; d < j; ++d) {
            a = g[d];
            l = a.target;
            h = a.widthModel;
            e = a.heightModel;
            if (c.test(l.width)) {
                l.getEl().setStyle("width", "")
            }
            if (c.test(l.height)) {
                l.getEl().setStyle("height", "")
            }
        }
        b.targetElContext = b.getEl("targetEl", k)
    },
    beginLayoutCycle: function (b, a) {
        var c = this.targetEl;
        Ext.layout.container.Fit.prototype.beginLayoutCycle.call(this, b, a);
        c.setStyle("width", "");
        c.setStyle("height", "")
    },
    getRenderData: function () {
        var a = Ext.layout.container.Fit.prototype.getRenderData.call(this);
        a.targetElCls = this.targetElCls;
        return a
    },
    getRenderTarget: function () {
        return this.targetEl
    },
    getItemSizePolicy: function (c, e) {
        var b = this, a = e || b.owner.getSizeModel(), d = b.percentRe,
            g = ((a.width.shrinkWrap || !d.test(c.width)) ? 0 : 1) | ((a.height.shrinkWrap || !d.test(c.height)) ? 0 : 2);
        return b.sizePolicies[g]
    },
    isItemBoxParent: function (a) {
        return true
    },
    isItemShrinkWrap: function (a) {
        return true
    },
    calculate: function (b) {
        var a = b.targetElContext, c;
        Ext.layout.container.Fit.prototype.calculate.call(this, b);
        c = b.state.info;
        if (b.widthModel.shrinkWrap) {
            a.setWidth(c.contentWidth)
        }
        if (b.heightModel.shrinkWrap) {
            a.setHeight(c.contentHeight)
        }
    },
    getPos: function (c, e, d) {
        var a = d + "Model", b = c.props[d], g = 0;
        if (!c[a].calculated) {
            b += e.margins[d]
        }
        if (!e.ownerContext[a].shrinkWrap) {
            g = Math.round((e.targetSize[d] - b) / 2);
            if (isNaN(g)) {
                this.done = false
            }
        }
        return Math.max(g, 0)
    },
    positionItemX: function (a, c) {
        var b = this.getPos(a, c, "width");
        a.setProp("x", b)
    },
    positionItemY: function (a, c) {
        var b = this.getPos(a, c, "height");
        a.setProp("y", b)
    },
    setItemHeight: function (b, c) {
        var a = parseFloat(b.target.height) / 100;
        b.setHeight(Math.round((c.targetSize.height - c.margins.height) * a))
    },
    setItemWidth: function (b, c) {
        var a = parseFloat(b.target.width) / 100;
        b.setWidth(Math.round((c.targetSize.width - c.margins.width) * a))
    }
}, 0, 0, 0, 0, ["layout.center", "layout.ux.center"], 0, [Ext.layout.container, "Center", Ext.ux.layout, "Center"], 0));
(Ext.cmd.derive("Ext.layout.container.Form", Ext.layout.container.Auto, {
    alternateClassName: "Ext.layout.FormLayout",
    type: "form",
    formWrapCls: "x-form-layout-wrap",
    formWrapAutoLabelCls: "x-form-layout-auto-label",
    formWrapSizedLabelCls: "x-form-layout-sized-label",
    formColGroupCls: "x-form-layout-colgroup",
    formColumnCls: "x-form-layout-column",
    formLabelColumnCls: "x-form-layout-label-column",
    childEls: ["formWrap", "labelColumn"],
    beforeBodyTpl: '<div id="{ownerId}-formWrap" data-ref="formWrap" class="{formWrapCls}"<tpl if="itemSpacing"> style="border-spacing:{itemSpacing}px"</tpl>><div class="{formColGroupCls}"><div id="{ownerId}-labelColumn" data-ref="labelColumn" class="{formColumnCls} {formLabelColumnCls}"<tpl if="labelWidth"> style="width:{labelWidth}"</tpl>></div><div class="{formColumnCls}"></div></div>',
    afterBodyTpl: "</div>",
    getRenderData: function () {
        var c = this, a = c.labelWidth, b = c.formWrapCls,
            d = Ext.layout.container.Auto.prototype.getRenderData.call(this);
        if (a) {
            if (typeof a === "number") {
                a += "px"
            }
            d.labelWidth = a;
            b += " " + c.formWrapSizedLabelCls
        } else {
            b += " " + c.formWrapAutoLabelCls
        }
        d.formWrapCls = b;
        d.formColGroupCls = c.formColGroupCls;
        d.formColumnCls = c.formColumnCls;
        d.formLabelColumnCls = c.formLabelColumnCls;
        return d
    },
    getRenderTarget: function () {
        return this.formWrap
    }
}, 0, 0, 0, 0, ["layout.form"], 0, [Ext.layout.container, "Form", Ext.layout, "FormLayout"], 0));
(Ext.cmd.derive("Ext.menu.ColorPicker", Ext.menu.Menu, {
    hideOnClick: true, pickerId: null, initComponent: function () {
        var b = this, a = Ext.apply({}, b.initialConfig);
        delete a.listeners;
        Ext.apply(b, {
            plain: true,
            showSeparator: false,
            bodyPadding: 0,
            items: Ext.applyIf({cls: "x-menu-color-item", margin: 0, id: b.pickerId, xtype: "colorpicker"}, a)
        });
        Ext.menu.Menu.prototype.initComponent.apply(this, arguments);
        b.picker = b.down("colorpicker");
        b.relayEvents(b.picker, ["select"]);
        if (b.hideOnClick) {
            b.on("select", b.hidePickerOnSelect, b)
        }
    }, hidePickerOnSelect: function () {
        Ext.menu.Manager.hideAll()
    }
}, 0, ["colormenu"], ["component", "box", "container", "panel", "menu", "colormenu"], {
    component: true,
    box: true,
    container: true,
    panel: true,
    menu: true,
    colormenu: true
}, ["widget.colormenu"], 0, [Ext.menu, "ColorPicker"], 0));
(Ext.cmd.derive("Ext.menu.DatePicker", Ext.menu.Menu, {
    ariaRole: "dialog",
    ariaLabel: "Date picker",
    hideOnClick: true,
    pickerId: null,
    initComponent: function () {
        var b = this, a = Ext.apply({}, b.initialConfig);
        delete a.listeners;
        Ext.apply(b, {
            showSeparator: false,
            plain: true,
            bodyPadding: 0,
            items: Ext.applyIf({
                cls: "x-menu-date-item",
                margin: 0,
                border: false,
                id: b.pickerId,
                xtype: "datepicker"
            }, a)
        });
        Ext.menu.Menu.prototype.initComponent.apply(this, arguments);
        b.picker = b.down("datepicker");
        b.relayEvents(b.picker, ["select"]);
        if (b.hideOnClick) {
            b.on("select", b.hidePickerOnSelect, b)
        }
    },
    hidePickerOnSelect: function () {
        Ext.menu.Manager.hideAll()
    }
}, 0, ["datemenu"], ["component", "box", "container", "panel", "menu", "datemenu"], {
    component: true,
    box: true,
    container: true,
    panel: true,
    menu: true,
    datemenu: true
}, ["widget.datemenu"], 0, [Ext.menu, "DatePicker"], 0));
(Ext.cmd.derive("Ext.panel.Pinnable", Ext.Mixin, {
    mixinId: "pinnable",
    pinnable: true,
    pinnedTip: "Unpin this item",
    unpinnedTip: "Pin this item",
    initPinnable: function () {
        var b = this, a = b.isPinned();
        b.addTool(b.pinTool = Ext.widget({
            xtype: "tool",
            type: a ? "unpin" : "pin",
            callback: "togglePin",
            scope: b,
            tooltip: a ? b.pinnedTip : b.unpinnedTip
        }))
    },
    isPinned: function () {
        return !this.floating
    },
    setPinned: function (b) {
        var c = this, a;
        if (b !== c.isPinned()) {
            a = [c, b];
            if (c.fireEventArgs("beforepinchange", a) !== false) {
                c.updatePinned(b);
                c.fireEventArgs("pinchange", a)
            }
        }
    },
    togglePin: function () {
        this.setPinned(!this.isPinned())
    },
    updatePinned: function (b) {
        var c = this, a = c.pinTool;
        a.setTooltip(b ? c.pinnedTip : c.unpinnedTip);
        a.setType(b ? "unpin" : "pin")
    }
}, 0, 0, 0, 0, 0, 0, [Ext.panel, "Pinnable"], 0));
(Ext.cmd.derive("Ext.plugin.Manager", Ext.Base, {
    alternateClassName: ["Ext.PluginManager", "Ext.PluginMgr"],
    singleton: true,
    typeName: "ptype",
    create: function (b, e, d) {
        var a, c;
        if (b.init) {
            a = b
        } else {
            if (d) {
                b = Ext.apply({}, b);
                b.cmp = d
            } else {
                d = b.cmp
            }
            if (b.xclass) {
                a = Ext.create(b)
            } else {
                c = "plugin." + (b.ptype || e);
                a = Ext.ClassManager.instantiateByAlias(c, b)
            }
        }
        if (a && d && a.setCmp && !a.setCmpCalled) {
            a.setCmp(d);
            a.setCmpCalled = true
        }
        return a
    }
}, 0, 0, 0, 0, 0, 0, [Ext.plugin, "Manager", Ext, "PluginManager", Ext, "PluginMgr"], 0));
(Ext.cmd.derive("Ext.resizer.BorderSplitterTracker", Ext.resizer.SplitterTracker, {
    getPrevCmp: null, getNextCmp: null, calculateConstrainRegion: function () {
        var z = this, a = z.splitter, o = a.collapseTarget, d = a.defaultSplitMin, h = a.vertical ? "Width" : "Height",
            c = "min" + h, v = "max" + h, j = "get" + h, u = a.neighbors, e = u.length, n = o.el.getBox(), g = n.x,
            p = n.y, y = n.right, k = n.bottom, r = a.vertical ? (y - g) : (k - p), x, l, s, m, w, t, q, b;
        m = (o[c] || Math.min(r, d)) - r;
        w = o[v];
        if (!w) {
            w = 1000000000
        } else {
            w -= r
        }
        b = r;
        for (x = 0; x < e; ++x) {
            l = u[x];
            r = l[j]();
            s = l[v];
            if (s === null) {
                s = undefined
            }
            t = r - s;
            q = r - (l[c] || Math.min(r, d));
            if (!isNaN(t)) {
                if (m < t) {
                    m = t
                }
            }
            if (w > q) {
                w = q
            }
        }
        if (w - m < 2) {
            return null
        }
        n = new Ext.util.Region(p, y, k, g);
        z.constraintAdjusters[z.getCollapseDirection()](n, m, w, a);
        z.dragInfo = {minRange: m, maxRange: w, targetSize: b};
        return n
    }, constraintAdjusters: {
        left: function (c, a, b, d) {
            c[0] = c.x = c.left = c.right + a;
            c.right += b + d.getWidth()
        }, top: function (c, a, b, d) {
            c[1] = c.y = c.top = c.bottom + a;
            c.bottom += b + d.getHeight()
        }, bottom: function (c, a, b, d) {
            c.bottom = c.top - a;
            c.top -= b + d.getHeight()
        }, right: function (c, a, b, d) {
            c.right = c.left - a;
            c[0] = c.x = c.left = c.x - b + d.getWidth()
        }
    }, onBeforeStart: function (k) {
        var g = this, h = g.splitter, d = h.collapseTarget, b = h.neighbors, c = b.length, a, j;
        if (d.collapsed) {
            return false
        }
        for (a = 0; a < c; ++a) {
            j = b[a];
            if (j.collapsed && j.isHorz === d.isHorz) {
                return false
            }
        }
        if (!(g.constrainTo = g.calculateConstrainRegion())) {
            return false
        }
        return true
    }, performResize: function (j, i) {
        var k = this, b = k.splitter, h = b.getCollapseDirection(), a = b.collapseTarget,
            g = k.splitAdjusters[b.vertical ? "horz" : "vert"], l = i[g.index], d = k.dragInfo, c;
        if (h === "right" || h === "bottom") {
            l = -l
        }
        l = Math.min(Math.max(d.minRange, l), d.maxRange);
        if (l) {
            (c = b.ownerCt).suspendLayouts();
            g.adjustTarget(a, d.targetSize, l);
            c.resumeLayouts(true)
        }
    }, splitAdjusters: {
        horz: {
            index: 0, adjustTarget: function (b, a, c) {
                b.flex = null;
                b.setSize(a + c)
            }
        }, vert: {
            index: 1, adjustTarget: function (b, a, c) {
                b.flex = null;
                b.setSize(undefined, a + c)
            }
        }
    }, getCollapseDirection: function () {
        return this.splitter.getCollapseDirection()
    }
}, 0, 0, 0, 0, 0, 0, [Ext.resizer, "BorderSplitterTracker"], 0));
(Ext.cmd.derive("Ext.resizer.Handle", Ext.Component, {
    handleCls: "",
    baseHandleCls: "x-resizable-handle",
    region: "",
    ariaRole: "presentation",
    beforeRender: function () {
        var a = this;
        Ext.Component.prototype.beforeRender.call(this);
        a.protoEl.unselectable();
        a.addCls(a.baseHandleCls, a.baseHandleCls + "-" + a.region, a.handleCls)
    }
}, 0, 0, ["component", "box"], {component: true, box: true}, 0, 0, [Ext.resizer, "Handle"], 0));
(Ext.cmd.derive("Ext.resizer.ResizeTracker", Ext.dd.DragTracker, {
    dynamic: true, preserveRatio: false, constrainTo: null, proxyCls: "x-resizable-proxy", constructor: function (b) {
        var d = this, c, a, e;
        if (!b.el) {
            if (b.target.isComponent) {
                d.el = b.target.getEl()
            } else {
                d.el = b.target
            }
        }
        Ext.dd.DragTracker.prototype.constructor.apply(this, arguments);
        if (d.preserveRatio && d.minWidth && d.minHeight) {
            c = d.minWidth / d.el.getWidth();
            a = d.minHeight / d.el.getHeight();
            if (a > c) {
                d.minWidth = d.el.getWidth() * a
            } else {
                d.minHeight = d.el.getHeight() * c
            }
        }
        if (d.throttle) {
            e = Ext.Function.createThrottled(function () {
                Ext.resizer.ResizeTracker.prototype.resize.apply(d, arguments)
            }, d.throttle);
            d.resize = function (h, i, g) {
                if (g) {
                    Ext.resizer.ResizeTracker.prototype.resize.apply(d, arguments)
                } else {
                    e.apply(null, arguments)
                }
            }
        }
    }, onBeforeStart: function (a) {
        this.startBox = this.target.getBox()
    }, getProxy: function () {
        var a = this;
        if (!a.dynamic && !a.proxy) {
            a.proxy = a.createProxy(a.target || a.el);
            a.hideProxy = true
        }
        if (a.proxy) {
            a.proxy.show();
            return a.proxy
        }
    }, createProxy: function (c) {
        var b, a = this.proxyCls;
        if (c.isComponent) {
            b = c.getProxy().addCls(a)
        } else {
            b = c.createProxy({tag: "div", role: "presentation", cls: a, id: c.id + "-rzproxy"}, Ext.getBody())
        }
        b.removeCls("x-proxy-el");
        return b
    }, onStart: function (a) {
        this.activeResizeHandle = Ext.get(this.getDragTarget().id);
        if (!this.dynamic) {
            this.resize(this.startBox)
        }
    }, onDrag: function (a) {
        if (this.dynamic || this.proxy) {
            this.updateDimensions(a)
        }
    }, updateDimensions: function (q, m) {
        var r = this, c = r.activeResizeHandle.region, g = r.getOffset(r.constrainTo ? "dragTarget" : null),
            k = r.startBox, h, o = 0, s = 0, j, p, a = 0, u = 0, t, i, b, d, n, l;
        c = r.convertRegionName(c);
        switch (c) {
            case"south":
                s = g[1];
                b = 2;
                break;
            case"north":
                s = -g[1];
                u = -s;
                b = 2;
                break;
            case"east":
                o = g[0];
                b = 1;
                break;
            case"west":
                o = -g[0];
                a = -o;
                b = 1;
                break;
            case"northeast":
                s = -g[1];
                u = -s;
                o = g[0];
                i = [k.x, k.y + k.height];
                b = 3;
                break;
            case"southeast":
                s = g[1];
                o = g[0];
                i = [k.x, k.y];
                b = 3;
                break;
            case"southwest":
                o = -g[0];
                a = -o;
                s = g[1];
                i = [k.x + k.width, k.y];
                b = 3;
                break;
            case"northwest":
                s = -g[1];
                u = -s;
                o = -g[0];
                a = -o;
                i = [k.x + k.width, k.y + k.height];
                b = 3;
                break
        }
        d = {width: k.width + o, height: k.height + s, x: k.x + a, y: k.y + u};
        j = Ext.Number.snap(d.width, r.widthIncrement);
        p = Ext.Number.snap(d.height, r.heightIncrement);
        if (j !== d.width || p !== d.height) {
            switch (c) {
                case"northeast":
                    d.y -= p - d.height;
                    break;
                case"north":
                    d.y -= p - d.height;
                    break;
                case"southwest":
                    d.x -= j - d.width;
                    break;
                case"west":
                    d.x -= j - d.width;
                    break;
                case"northwest":
                    d.x -= j - d.width;
                    d.y -= p - d.height
            }
            d.width = j;
            d.height = p
        }
        if (d.width < r.minWidth || d.width > r.maxWidth) {
            d.width = Ext.Number.constrain(d.width, r.minWidth, r.maxWidth);
            if (a) {
                d.x = k.x + (k.width - d.width)
            }
        } else {
            r.lastX = d.x
        }
        if (d.height < r.minHeight || d.height > r.maxHeight) {
            d.height = Ext.Number.constrain(d.height, r.minHeight, r.maxHeight);
            if (u) {
                d.y = k.y + (k.height - d.height)
            }
        } else {
            r.lastY = d.y
        }
        if (r.preserveRatio || q.shiftKey) {
            h = r.startBox.width / r.startBox.height;
            n = Math.min(Math.max(r.minHeight, d.width / h), r.maxHeight);
            l = Math.min(Math.max(r.minWidth, d.height * h), r.maxWidth);
            if (b === 1) {
                d.height = n
            } else {
                if (b === 2) {
                    d.width = l
                } else {
                    t = Math.abs(i[0] - this.lastXY[0]) / Math.abs(i[1] - this.lastXY[1]);
                    if (t > h) {
                        d.height = n
                    } else {
                        d.width = l
                    }
                    if (c === "northeast") {
                        d.y = k.y - (d.height - k.height)
                    } else {
                        if (c === "northwest") {
                            d.y = k.y - (d.height - k.height);
                            d.x = k.x - (d.width - k.width)
                        } else {
                            if (c === "southwest") {
                                d.x = k.x - (d.width - k.width)
                            }
                        }
                    }
                }
            }
        }
        r.setPosition = d.x !== r.startBox.x || d.y !== r.startBox.y;
        r.resize(d, m)
    }, resize: function (d, a) {
        var c = this, e, b = c.setPosition;
        if (c.dynamic || (!c.dynamic && a)) {
            if (b) {
                c.target.setBox(d)
            } else {
                c.target.setSize(d.width, d.height)
            }
        }
        if (!a) {
            e = c.getProxy();
            if (e && e !== c.target) {
                if (b || c.hideProxy) {
                    e.setBox(d)
                } else {
                    e.setSize(d.width, d.height)
                }
            }
        }
    }, onEnd: function (a) {
        this.updateDimensions(a, true);
        if (this.proxy && this.hideProxy) {
            this.proxy.hide()
        }
    }, convertRegionName: function (a) {
        return a
    }
}, 1, 0, 0, 0, 0, 0, [Ext.resizer, "ResizeTracker"], 0));
(Ext.cmd.derive("Ext.resizer.Resizer", Ext.Base, {
    alternateClassName: "Ext.Resizable",
    handleCls: "x-resizable-handle",
    overCls: "x-resizable-handle-over",
    pinnedCls: "x-resizable-pinned",
    wrapCls: "x-resizable-wrap",
    wrappedCls: "x-resizable-wrapped",
    delimiterRe: /(?:\\s*[,;]\\s*)|\\s+/,
    dynamic: true,
    handles: "s e se",
    height: null,
    width: null,
    heightIncrement: 0,
    widthIncrement: 0,
    minHeight: 20,
    minWidth: 20,
    maxHeight: 10000,
    maxWidth: 10000,
    pinned: false,
    preserveRatio: false,
    transparent: false,
    possiblePositions: {
        n: "north",
        s: "south",
        e: "east",
        w: "west",
        se: "southeast",
        sw: "southwest",
        nw: "northwest",
        ne: "northeast"
    },
    ariaRole: "presentation",
    constructor: function (b) {
        var l = this, q = l.handles, k = Ext.dom.Element.unselectableCls, o = [], p, c, n, s, h, e, m, a, g, d, r, j;
        if (Ext.isString(b) || Ext.isElement(b) || b.dom) {
            p = b;
            b = arguments[1] || {};
            b.target = p
        }
        l.mixins.observable.constructor.call(l, b);
        p = l.target;
        if (p) {
            if (p.isComponent) {
                p.addClsWithUI("resizable");
                if (p.minWidth) {
                    l.minWidth = p.minWidth
                }
                if (p.minHeight) {
                    l.minHeight = p.minHeight
                }
                if (p.maxWidth) {
                    l.maxWidth = p.maxWidth
                }
                if (p.maxHeight) {
                    l.maxHeight = p.maxHeight
                }
                if (p.floating) {
                    if (!l.hasOwnProperty("handles")) {
                        l.handles = "n ne e se s sw w nw"
                    }
                }
                l.el = p.getEl()
            } else {
                p = l.el = l.target = Ext.get(p)
            }
        } else {
            p = l.target = l.el = Ext.get(l.el)
        }
        l.el.addCls(Ext.Component.prototype.borderBoxCls);
        if (Ext.isNumber(l.width)) {
            l.width = Ext.Number.constrain(l.width, l.minWidth, l.maxWidth)
        }
        if (Ext.isNumber(l.height)) {
            l.height = Ext.Number.constrain(l.height, l.minHeight, l.maxHeight)
        }
        if (l.width !== null || l.height !== null) {
            l.target.setSize(l.width, l.height)
        }
        s = l.el.dom.tagName.toUpperCase();
        if (s === "TEXTAREA" || s === "IMG" || s === "TABLE") {
            l.originalTarget = l.target;
            d = p.isComponent ? p.getEl() : p;
            l.el.addCls(l.wrappedCls);
            l.target = l.el = l.el.wrap({
                role: "presentation",
                cls: l.wrapCls,
                id: l.el.id + "-rzwrap",
                style: d.getStyle(["margin-top", "margin-bottom"])
            });
            r = d.getPositioning();
            l.el.setPositioning(r);
            d.clearPositioning();
            g = d.getBox();
            if (r.position !== "absolute") {
                g.x = 0;
                g.y = 0
            }
            l.el.setBox(g);
            d.setStyle("position", "absolute");
            l.isTargetWrapped = true
        }
        l.el.position();
        if (l.pinned) {
            l.el.addCls(l.pinnedCls)
        }
        l.resizeTracker = new Ext.resizer.ResizeTracker({
            disabled: l.disabled,
            target: p,
            el: l.el,
            constrainTo: l.constrainTo,
            handleCls: l.handleCls,
            overCls: l.overCls,
            throttle: l.throttle,
            proxy: l.originalTarget ? l.el : null,
            dynamic: l.originalTarget ? true : l.dynamic,
            originalTarget: l.originalTarget,
            delegate: "." + l.handleCls,
            preserveRatio: l.preserveRatio,
            heightIncrement: l.heightIncrement,
            widthIncrement: l.widthIncrement,
            minHeight: l.minHeight,
            maxHeight: l.maxHeight,
            minWidth: l.minWidth,
            maxWidth: l.maxWidth
        });
        l.resizeTracker.on({mousedown: l.onBeforeResize, drag: l.onResize, dragend: l.onResizeEnd, scope: l});
        if (l.handles === "all") {
            l.handles = "n s e w ne nw se sw"
        }
        q = l.handles = l.handles.split(l.delimiterRe);
        n = l.possiblePositions;
        h = q.length;
        c = l.handleCls + " " + l.handleCls + "-{0}";
        if (l.target.isComponent) {
            j = l.target.baseCls;
            c += " " + j + "-handle " + j + "-handle-{0}";
            if (Ext.supports.CSS3BorderRadius) {
                c += " " + j + "-handle-{0}-br"
            }
        }
        for (e = 0; e < h; e++) {
            if (q[e] && n[q[e]]) {
                m = n[q[e]];
                o.push('<div id="', l.el.id, "-", m, '-handle" class="', Ext.String.format(c, m), " ", k, '" unselectable="on" role="presentation"', "></div>")
            }
        }
        Ext.DomHelper.append(l.el, o.join(""));
        o.length = 0;
        for (e = 0; e < h; e++) {
            if (q[e] && n[q[e]]) {
                m = n[q[e]];
                a = l[m] = l.el.getById(l.el.id + "-" + m + "-handle");
                o.push(a);
                a.region = m;
                if (l.transparent) {
                    a.setOpacity(0)
                }
            }
        }
        l.resizeTracker.handleEls = o
    },
    disable: function () {
        this.resizeTracker.disable()
    },
    enable: function () {
        this.resizeTracker.enable()
    },
    onBeforeResize: function (a, b) {
        return this.fireResizeEvent("beforeresize", a, b)
    },
    onResize: function (a, b) {
        return this.fireResizeEvent("resizedrag", a, b)
    },
    onResizeEnd: function (a, b) {
        return this.fireResizeEvent("resize", a, b)
    },
    fireResizeEvent: function (a, d, g) {
        var c = this, b;
        if (c.hasListeners[a]) {
            b = c.el.getBox();
            return c.fireEvent(a, c, b.width, b.height, g)
        }
    },
    resizeTo: function (b, a) {
        var c = this;
        c.target.setSize(b, a);
        c.fireEvent("resize", c, b, a, null)
    },
    getEl: function () {
        return this.el
    },
    getTarget: function () {
        return this.target
    },
    destroy: function () {
        var e = this, d, c = e.handles, a = c.length, b = e.possiblePositions, g;
        e.resizeTracker.destroy();
        if (e.isTargetWrapped) {
            e.target.destroy()
        }
        for (d = 0; d < a; d++) {
            if ((g = e[b[c[d]]])) {
                g.destroy()
            }
        }
        e.callParent()
    }
}, 1, 0, 0, 0, 0, [["observable", Ext.util.Observable]], [Ext.resizer, "Resizer", Ext, "Resizable"], 0));
(Ext.cmd.derive("Ext.selection.CellModel", Ext.selection.DataViewModel, {
    isCellModel: true,
    deselectOnContainerClick: false,
    enableKeyNav: true,
    preventWrap: false,
    bindComponent: function (a) {
        var c = this, b;
        if (c.view && c.gridListeners) {
            c.gridListeners.destroy()
        }
        Ext.selection.DataViewModel.prototype.bindComponent.call(this, a);
        if (a) {
            b = a.grid || a.ownerCt;
            if (b.optimizedColumnMove !== false) {
                c.gridListeners = b.on({columnmove: c.onColumnMove, scope: c, destroyable: true})
            }
        }
    },
    getViewListeners: function () {
        var a = Ext.selection.DataViewModel.prototype.getViewListeners.call(this);
        a.refresh = this.onViewRefresh;
        return a
    },
    getHeaderCt: function () {
        var b = this.navigationModel.getPosition(), a = b ? b.view : this.primaryView;
        return a.headerCt
    },
    onNavigate: function (a) {
        if (!a.record || a.keyEvent.stopSelection) {
            return
        }
        this.setPosition(a.position)
    },
    selectWithEvent: function (a, b) {
        this.select(a)
    },
    select: function (h, e, b) {
        var d = this, g, c = d.getPosition(), a = d.view.store;
        if (h || h === 0) {
            if (h.isModel) {
                g = a.indexOf(h);
                if (g !== -1) {
                    h = {row: g, column: c ? c.column : 0}
                } else {
                    h = null
                }
            } else {
                if (typeof h === "number") {
                    h = {row: h, column: 0}
                }
            }
        }
        if (h) {
            d.selectByPosition(h, b)
        } else {
            d.deselect()
        }
    },
    getCurrentPosition: function () {
        var a = this.selecting ? this.nextSelection : this.selection;
        return a ? {
            view: a.view,
            record: a.record,
            row: a.rowIdx,
            columnHeader: a.column,
            column: a.view.getColumnManager().indexOf(a.column)
        } : a
    },
    getPosition: function () {
        return (this.selecting ? this.nextSelection : this.selection) || null
    },
    setCurrentPosition: function (c, a, b) {
        if (c && !c.isCellContext) {
            c = new Ext.grid.CellContext(this.view).setPosition({
                row: c.row,
                column: typeof c.column === "number" ? this.view.getColumnManager().getColumns()[c.column] : c.column
            })
        }
        return this.setPosition(c, a, b)
    },
    setPosition: function (e, a, d) {
        var c = this, b = c.selection;
        if (e) {
            e = e.isCellContext ? e.clone() : new Ext.grid.CellContext(c.view).setPosition(e)
        }
        if (!d && b) {
            if (e && (e.record === b.record && e.column === b.column && e.view === b.view)) {
                e = null
            } else {
                c.onCellDeselect(c.selection, a)
            }
        }
        if (e) {
            c.nextSelection = e;
            c.selecting = true;
            c.onCellSelect(c.nextSelection, a);
            c.selecting = false;
            return (c.selection = e)
        }
    },
    isCellSelected: function (a, e, c) {
        var d = this, b, g = d.getPosition();
        if (g && g.view === a) {
            b = new Ext.grid.CellContext(a).setPosition({
                row: e,
                column: typeof c === "number" ? a.getColumnManager().getColumns()[c] : c
            });
            return (b.record === g.record) && (b.column === g.column)
        }
    },
    onStoreRemove: function (b, a, d) {
        var c = this, e = c.getPosition();
        Ext.selection.DataViewModel.prototype.onStoreRemove.apply(this, arguments);
        if (e && b.isMoving(e.record)) {
            return
        }
        if (e && b.getCount() && b.indexOf(e.record) !== -1) {
            e.setRow(e.record)
        } else {
            c.selection = null
        }
    },
    onStoreClear: function () {
        Ext.selection.DataViewModel.prototype.onStoreClear.apply(this, arguments);
        this.selection = null
    },
    onStoreAdd: function () {
        var a = this, b = a.getPosition();
        Ext.selection.DataViewModel.prototype.onStoreAdd.apply(this, arguments);
        if (b) {
            b.setRow(b.record)
        } else {
            a.selection = null
        }
    },
    onCellClick: function (c, a, g, b, i, d, h) {
        if (d !== -1) {
            this.setPosition(h.position)
        }
    },
    onCellSelect: function (a, b) {
        if (a && a.rowIdx !== undefined && a.rowIdx > -1) {
            this.doSelect(a.record, false, b)
        }
    },
    onCellDeselect: function (a, b) {
        if (a && a.rowIdx !== undefined) {
            this.doDeselect(a.record, b)
        }
    },
    onSelectChange: function (b, e, d, h) {
        var g = this, i, c, a;
        if (e) {
            i = g.nextSelection;
            c = "select"
        } else {
            i = g.selection;
            c = "deselect"
        }
        a = i.view || g.primaryView;
        if ((d || g.fireEvent("before" + c, g, b, i.rowIdx, i.colIdx)) !== false && h() !== false) {
            if (e) {
                a.onCellSelect(i)
            } else {
                a.onCellDeselect(i);
                delete g.selection
            }
            if (!d) {
                g.fireEvent(c, g, b, i.rowIdx, i.colIdx)
            }
        }
    },
    refresh: function () {
        var b = this.getPosition(), a;
        if (b && (a = this.store.indexOf(this.selected.last())) !== -1) {
            b.rowIdx = a
        }
    },
    onColumnMove: function (d, e, b, c) {
        var a = d.up("tablepanel");
        if (a) {
            this.onViewRefresh(a.view)
        }
    },
    onUpdate: function (a) {
        var b = this, c;
        if (b.isSelected(a)) {
            c = b.selecting ? b.nextSelection : b.selection;
            b.view.onCellSelect(c)
        }
    },
    onViewRefresh: function (b) {
        var e = this, h = e.getPosition(), c, g = b.headerCt, a, d;
        if (h && h.view === b) {
            a = h.record;
            d = h.column;
            if (!d.isDescendantOf(g)) {
                d = g.queryById(d.id) || g.down('[text="' + d.text + '"]') || g.down('[dataIndex="' + d.dataIndex + '"]')
            }
            if (h.record) {
                if (d && (b.store.indexOfId(a.getId()) !== -1)) {
                    c = new Ext.grid.CellContext(b).setPosition({row: a, column: d});
                    e.setPosition(c)
                }
            } else {
                e.selection = null
            }
        }
    },
    selectByPosition: function (a, b) {
        this.setPosition(a, b)
    }
}, 0, 0, 0, 0, ["selection.cellmodel"], 0, [Ext.selection, "CellModel"], 0));
(Ext.cmd.derive("Ext.selection.RowModel", Ext.selection.DataViewModel, {
    enableKeyNav: true, isRowModel: true, deselectOnContainerClick: false, onUpdate: function (b) {
        var d = this, a = d.view, c;
        if (a && d.isSelected(b)) {
            c = a.indexOf(b);
            a.onRowSelect(c);
            if (b === d.lastFocused) {
                a.onRowFocus(c, true)
            }
        }
    }, onSelectChange: function (g, b, l, a) {
        var j = this, m = j.views || [j.view], c = m.length, d = j.store.indexOf(g), h = b ? "select" : "deselect", e,
            k;
        if ((l || j.fireEvent("before" + h, j, g, d)) !== false && a() !== false) {
            for (e = 0; e < c; e++) {
                k = m[e];
                d = k.indexOf(g);
                if (k.indexOf(g) !== -1) {
                    if (b) {
                        k.onRowSelect(d, l)
                    } else {
                        k.onRowDeselect(d, l)
                    }
                }
            }
            if (!l) {
                j.fireEvent(h, j, g, d)
            }
        }
    }, getCurrentPosition: function () {
        var a = this.selected.getAt(0);
        if (a) {
            return new Ext.grid.CellContext(this.view).setPosition(this.store.indexOf(a), 0)
        }
    }, selectByPosition: function (a, b) {
        if (!a.isCellContext) {
            a = new Ext.grid.CellContext(this.view).setPosition(a.row, a.column)
        }
        this.select(a.record, b)
    }, selectNext: function (h, c) {
        var g = this, b = g.store, e = g.getSelection(), a = e[e.length - 1], d = g.view.indexOf(a) + 1, i;
        if (d === b.getCount() || d === 0) {
            i = false
        } else {
            g.doSelect(d, h, c);
            i = true
        }
        return i
    }, selectPrevious: function (g, b) {
        var e = this, d = e.getSelection(), a = d[0], c = e.view.indexOf(a) - 1, h;
        if (c < 0) {
            h = false
        } else {
            e.doSelect(c, g, b);
            h = true
        }
        return h
    }, isRowSelected: function (a) {
        return this.isSelected(a)
    }, isCellSelected: function (b, a, c) {
        return this.isSelected(a)
    }, vetoSelection: function (c) {
        var b = this.view.getNavigationModel(), a = c.getKey(), d = a === c.RIGHT || a === c.LEFT;
        return (d && b.previousRecord === b.record) || Ext.selection.DataViewModel.prototype.vetoSelection.call(this, c)
    }
}, 0, 0, 0, 0, ["selection.rowmodel"], 0, [Ext.selection, "RowModel"], 0));
(Ext.cmd.derive("Ext.selection.CheckboxModel", Ext.selection.RowModel, {
    mode: "MULTI",
    injectCheckbox: 0,
    checkOnly: false,
    showHeaderCheckbox: undefined,
    checkSelector: ".x-grid-row-checker",
    allowDeselect: true,
    headerWidth: 24,
    checkerOnCls: "x-grid-hd-checker-on",
    tdCls: "x-grid-cell-special x-grid-cell-row-checker",
    constructor: function () {
        var a = this;
        Ext.selection.RowModel.prototype.constructor.apply(this, arguments);
        if (a.mode === "SINGLE") {
            a.showHeaderCheckbox = false
        }
    },
    beforeViewRender: function (b) {
        var c = this, a;
        Ext.selection.RowModel.prototype.beforeViewRender.apply(this, arguments);
        if (!c.hasLockedHeader() || b.headerCt.lockedCt) {
            c.addCheckbox(b, true);
            a = b.ownerCt;
            if (b.headerCt.lockedCt) {
                a = a.ownerCt
            }
            c.mon(a, "reconfigure", c.onReconfigure, c)
        }
    },
    bindComponent: function (a) {
        this.sortable = false;
        Ext.selection.RowModel.prototype.bindComponent.apply(this, arguments)
    },
    hasLockedHeader: function () {
        var a = this.views, c = a.length, b;
        for (b = 0; b < c; b++) {
            if (a[b].headerCt.lockedCt) {
                return true
            }
        }
        return false
    },
    addCheckbox: function (a, b) {
        var c = this, d = c.injectCheckbox, e = a.headerCt;
        if (d !== false) {
            if (d === "first") {
                d = 0
            } else {
                if (d === "last") {
                    d = e.getColumnCount()
                }
            }
            Ext.suspendLayouts();
            if (a.getStore().isBufferedStore) {
                c.showHeaderCheckbox = false
            }
            c.column = e.add(d, c.getHeaderConfig());
            Ext.resumeLayouts()
        }
        if (b !== true) {
            a.refresh()
        }
    },
    onReconfigure: function (c, a, b) {
        if (b) {
            this.addCheckbox(this.views[0])
        }
    },
    toggleUiHeader: function (e) {
        var b = this.views[0], d = b.headerCt, c = d.child("gridcolumn[isCheckerHd]"), a = this.checkerOnCls;
        if (c) {
            if (e) {
                c.addCls(a)
            } else {
                c.removeCls(a)
            }
        }
    },
    onHeaderClick: function (c, g, b) {
        var a = this, d;
        if (g === a.column && a.mode !== "SINGLE") {
            b.stopEvent();
            d = g.el.hasCls("x-grid-hd-checker-on");
            if (d) {
                a.deselectAll()
            } else {
                a.selectAll()
            }
        }
    },
    getHeaderConfig: function () {
        var a = this, b = a.showHeaderCheckbox !== false;
        return {
            xtype: "gridcolumn",
            ignoreExport: true,
            isCheckerHd: b,
            text: "&#160;",
            clickTargetName: "el",
            width: a.headerWidth,
            sortable: false,
            draggable: false,
            resizable: false,
            hideable: false,
            menuDisabled: true,
            dataIndex: "",
            tdCls: a.tdCls,
            cls: b ? "x-column-header-checkbox " : "",
            defaultRenderer: a.renderer.bind(a),
            editRenderer: a.editRenderer || a.renderEmpty,
            locked: a.hasLockedHeader(),
            processEvent: a.processColumnEvent
        }
    },
    processColumnEvent: function (g, i, j, b, h, d, c, k) {
        var a = i.getNavigationModel();
        if (d.type === "keydown" && i.actionableMode && d.getKey() === d.SPACE) {
            a.fireEvent("navigate", {
                view: i,
                navigationModel: a,
                keyEvent: d,
                position: d.position,
                recordIndex: b,
                record: c,
                item: d.item,
                cell: d.position.cellElement,
                columnIndex: d.position.colIdx,
                column: d.position.column
            })
        }
    },
    renderEmpty: function () {
        return "&#160;"
    },
    refresh: function () {
        Ext.selection.RowModel.prototype.refresh.apply(this, arguments);
        this.updateHeaderState()
    },
    renderer: function (g, c, b, h, e, d, a) {
        return '<div class="x-grid-row-checker" role="button" tabIndex="0">&#160;</div>'
    },
    selectByPosition: function (a, b) {
        if (!a.isCellContext) {
            a = new Ext.grid.CellContext(this.view).setPosition(a.row, a.column)
        }
        if (!this.checkOnly || a.column !== this.column) {
            Ext.selection.RowModel.prototype.selectByPosition.call(this, a, b)
        }
    },
    onSelectChange: function () {
        Ext.selection.RowModel.prototype.onSelectChange.apply(this, arguments);
        if (!this.suspendChange) {
            this.updateHeaderState()
        }
    },
    onStoreLoad: function () {
        Ext.selection.RowModel.prototype.onStoreLoad.apply(this, arguments);
        this.updateHeaderState()
    },
    onStoreAdd: function () {
        Ext.selection.RowModel.prototype.onStoreAdd.apply(this, arguments);
        this.updateHeaderState()
    },
    onStoreRemove: function () {
        Ext.selection.RowModel.prototype.onStoreRemove.apply(this, arguments);
        this.updateHeaderState()
    },
    onStoreRefresh: function () {
        Ext.selection.RowModel.prototype.onStoreRefresh.apply(this, arguments);
        this.updateHeaderState()
    },
    maybeFireSelectionChange: function (a) {
        if (a && !this.suspendChange) {
            this.updateHeaderState()
        }
        Ext.selection.RowModel.prototype.maybeFireSelectionChange.apply(this, arguments)
    },
    resumeChanges: function () {
        Ext.selection.RowModel.prototype.resumeChanges.call(this);
        if (!this.suspendChange) {
            this.updateHeaderState()
        }
    },
    updateHeaderState: function () {
        var g = this, h = g.store, e = h.getCount(), j = g.views, k = false, a = 0, b, d, c;
        if (!h.isBufferedStore && e > 0) {
            b = g.selected;
            k = true;
            for (c = 0, d = b.getCount(); c < d; ++c) {
                if (h.indexOfId(b.getAt(c).id) === -1) {
                    break
                }
                ++a
            }
            k = e === a
        }
        if (j && j.length) {
            g.toggleUiHeader(k)
        }
    },
    vetoSelection: function (g) {
        var c = this, b = c.column, a, d, h;
        if (c.checkOnly) {
            d = g.type === "click" && g.getTarget(c.checkSelector);
            h = g.getKey() === g.SPACE && g.position.column === b;
            a = !(d || h)
        }
        return a || Ext.selection.RowModel.prototype.vetoSelection.call(this, g)
    },
    destroy: function () {
        this.column = null;
        Ext.selection.RowModel.prototype.destroy.call(this)
    },
    privates: {
        onBeforeNavigate: function (a) {
            var b = a.keyEvent;
            if (this.selectionMode !== "SINGLE") {
                a.ctrlKey = a.ctrlKey || b.ctrlKey || (b.type === "click" && !b.shiftKey) || b.getKey() === b.SPACE
            }
        }, selectWithEventMulti: function (a, d, b) {
            var c = this;
            if (!d.shiftKey && !d.ctrlKey && d.getTarget(c.checkSelector)) {
                if (b) {
                    c.doDeselect(a)
                } else {
                    c.doSelect(a, true)
                }
            } else {
                Ext.selection.RowModel.prototype.selectWithEventMulti.call(this, a, d, b)
            }
        }
    }
}, 1, 0, 0, 0, ["selection.checkboxmodel"], 0, [Ext.selection, "CheckboxModel"], 0));
(Ext.cmd.derive("Ext.selection.TreeModel", Ext.selection.RowModel, {
    selectOnExpanderClick: false,
    constructor: function (a) {
        var b = this;
        Ext.selection.RowModel.prototype.constructor.call(this, a);
        if (b.pruneRemoved) {
            b.pruneRemoved = false;
            b.pruneRemovedNodes = true
        }
    },
    getStoreListeners: function () {
        var b = this, a = Ext.selection.RowModel.prototype.getStoreListeners.call(this);
        a.noderemove = b.onNodeRemove;
        return a
    },
    onNodeRemove: function (c, d, a) {
        if (!a) {
            var b = [];
            this.gatherSelected(d, b);
            if (b.length) {
                this.deselect(b)
            }
        }
    },
    pruneRemovedOnRefresh: function () {
        return this.pruneRemovedNodes
    },
    vetoSelection: function (d) {
        var c = this.view, b = this.selectOnExpanderClick,
            a = !b && d.type === "click" && d.getTarget(c.expanderSelector || (c.lockingPartner && c.lockingPartner.expanderSelector));
        return a || Ext.selection.RowModel.prototype.vetoSelection.call(this, d)
    },
    privates: {
        gatherSelected: function (d, c) {
            var e = d.childNodes, b, a, g;
            if (this.selected.containsKey(d.id)) {
                c.push(d)
            }
            if (e) {
                for (b = 0, a = e.length; b < a; ++b) {
                    g = e[b];
                    this.gatherSelected(g, c)
                }
            }
        }
    }
}, 1, 0, 0, 0, ["selection.treemodel"], 0, [Ext.selection, "TreeModel"], 0));
(Ext.cmd.derive("Ext.slider.Thumb", Ext.Base, {
    overCls: "x-slider-thumb-over", constructor: function (a) {
        var b = this;
        Ext.apply(b, a || {}, {cls: "x-slider-thumb", constrain: false});
        b.callParent([a])
    }, render: function () {
        var a = this;
        a.el = a.slider.innerEl.insertFirst(a.getElConfig());
        a.onRender()
    }, onRender: function () {
        if (this.disabled) {
            this.disable()
        }
        this.initEvents()
    }, getElConfig: function () {
        var c = this, b = c.slider, a = {};
        a[b.vertical ? "bottom" : b.horizontalProp] = b.calculateThumbPosition(b.normalizeValue(c.value)) + "%";
        return {style: a, id: this.id, cls: this.cls, role: "presentation"}
    }, move: function (j, b) {
        var g = this, c = g.el, a = g.slider, d = a.vertical ? "bottom" : a.horizontalProp, h, i, e;
        j += "%";
        if (!b) {
            c.dom.style[d] = j
        } else {
            h = {};
            h[d] = j;
            if (!Ext.supports.GetPositionPercentage) {
                i = {};
                i[d] = c.dom.style[d]
            }
            e = {target: c, duration: 350, from: i, to: h, scope: g, callback: g.onAnimComplete};
            if (b !== true) {
                Ext.apply(e, b)
            }
            g.anim = new Ext.fx.Anim(e)
        }
    }, onAnimComplete: function () {
        this.anim = null
    }, enable: function () {
        var a = this.el;
        this.disabled = false;
        if (a) {
            a.removeCls(this.slider.disabledCls)
        }
    }, disable: function () {
        var a = this.el;
        this.disabled = true;
        if (a) {
            a.addCls(this.slider.disabledCls)
        }
    }, initEvents: function () {
        var a = this;
        a.tracker = new Ext.dd.DragTracker({
            el: a.el,
            onBeforeStart: a.onBeforeDragStart.bind(a),
            onStart: a.onDragStart.bind(a),
            onDrag: a.onDrag.bind(a),
            onEnd: a.onDragEnd.bind(a),
            tolerance: 3,
            autoStart: 300
        });
        a.el.hover(a.addOverCls, a.removeOverCls, a)
    }, addOverCls: function () {
        var a = this;
        if (!a.disabled) {
            a.el.addCls(a.overCls)
        }
    }, removeOverCls: function () {
        this.el.removeCls(this.overCls)
    }, onBeforeDragStart: function (d) {
        var c = this, b = c.el, a = c.tracker.getXY(), g = c.pointerOffset = b.getXY();
        if (c.disabled) {
            return false
        } else {
            g[0] += Math.floor(b.getWidth() / 2) - a[0];
            g[1] += Math.floor(b.getHeight() / 2) - a[1];
            c.slider.promoteThumb(c);
            return true
        }
    }, onDragStart: function (c) {
        var b = this, a = b.slider;
        a.onDragStart(b, c);
        b.el.addCls("x-slider-thumb-drag");
        b.dragging = b.slider.dragging = true;
        b.dragStartValue = b.value;
        a.fireEvent("dragstart", a, c, b)
    }, onDrag: function (h) {
        var d = this, c = d.slider, b = d.index, g = d.getValueFromTracker(), a, i;
        if (g !== undefined) {
            if (d.constrain) {
                a = c.thumbs[b + 1];
                i = c.thumbs[b - 1];
                if (i !== undefined && g <= i.value) {
                    g = i.value
                }
                if (a !== undefined && g >= a.value) {
                    g = a.value
                }
            }
            c.setValue(b, g, false);
            c.fireEvent("drag", c, h, d)
        }
    }, getValueFromTracker: function () {
        var b = this.slider, a = this.tracker.getXY(), c;
        a[0] += this.pointerOffset[0];
        a[1] += this.pointerOffset[1];
        c = b.getTrackpoint(a);
        if (c !== undefined) {
            return b.reversePixelValue(c)
        }
    }, onDragEnd: function (d) {
        var b = this, a = b.slider, c = b.value;
        a.onDragEnd(b, d);
        b.el.removeCls("x-slider-thumb-drag");
        b.dragging = a.dragging = false;
        a.fireEvent("dragend", a, d);
        if (b.dragStartValue !== c) {
            a.fireEvent("changecomplete", a, c, b)
        }
    }, destroy: function () {
        var a = this, b = this.anim;
        if (b) {
            b.end()
        }
        a.el = a.tracker = a.anim = Ext.destroy(a.el, a.tracker);
        a.callParent()
    }
}, 1, 0, 0, 0, 0, 0, [Ext.slider, "Thumb"], 0));
(Ext.cmd.derive("Ext.slider.Tip", Ext.tip.Tip, {
    minWidth: 10,
    offsets: null,
    align: null,
    position: "",
    defaultVerticalPosition: "left",
    defaultHorizontalPosition: "top",
    isSliderTip: true,
    init: function (c) {
        var b = this, d, a;
        if (!b.position) {
            b.position = c.vertical ? b.defaultVerticalPosition : b.defaultHorizontalPosition
        }
        switch (b.position) {
            case"top":
                a = [0, -10];
                d = "b-t?";
                break;
            case"bottom":
                a = [0, 10];
                d = "t-b?";
                break;
            case"left":
                a = [-10, 0];
                d = "r-l?";
                break;
            case"right":
                a = [10, 0];
                d = "l-r?"
        }
        if (!b.align) {
            b.align = d
        }
        if (!b.offsets) {
            b.offsets = a
        }
        c.on({scope: b, dragstart: b.onSlide, drag: b.onSlide, dragend: b.hide, destroy: b.destroy})
    },
    onSlide: function (c, d, a) {
        var b = this;
        b.show();
        b.update(b.getText(a));
        b.el.alignTo(a.el, b.align, b.offsets)
    },
    getText: function (a) {
        return String(a.value)
    }
}, 0, ["slidertip"], ["component", "box", "container", "panel", "tip", "slidertip"], {
    component: true,
    box: true,
    container: true,
    panel: true,
    tip: true,
    slidertip: true
}, ["widget.slidertip"], 0, [Ext.slider, "Tip"], 0));
(Ext.cmd.derive("Ext.slider.Multi", Ext.form.field.Base, {
    alternateClassName: "Ext.slider.MultiSlider",
    vertical: false,
    minValue: 0,
    maxValue: 100,
    decimalPrecision: 0,
    keyIncrement: 1,
    pageSize: 10,
    increment: 0,
    clickRange: [5, 15],
    clickToChange: true,
    animate: true,
    dragging: false,
    constrainThumbs: true,
    useTips: true,
    tipText: null,
    defaultBindProperty: "values",
    ariaRole: "slider",
    focusable: true,
    needArrowKeys: true,
    tabIndex: 0,
    focusCls: "slider-focus",
    childEls: ["endEl", "innerEl"],
    fieldSubTpl: ['<div id="{id}" data-ref="inputEl" {inputAttrTpl}', ' class="', "x-", "slider {fieldCls} {vertical}", '{childElCls}"', '<tpl if="tabIdx != null"> tabindex="{tabIdx}"</tpl>', '<tpl foreach="inputElAriaAttributes"> {$}="{.}"</tpl>', ">", '<div id="{cmpId}-endEl" data-ref="endEl" class="x-slider-end" role="presentation">', '<div id="{cmpId}-innerEl" data-ref="innerEl" class="x-slider-inner" role="presentation">', "{%this.renderThumbs(out, values)%}", "</div>", "</div>", "</div>", {
        renderThumbs: function (g, e) {
            var j = e.$comp, h = 0, c = j.thumbs, b = c.length, d, a;
            for (; h < b; h++) {
                d = c[h];
                a = d.getElConfig();
                a.id = j.id + "-thumb-" + h;
                Ext.DomHelper.generateMarkup(a, g)
            }
        }, disableFormats: true
    }],
    horizontalProp: "left",
    initValue: function () {
        var e = this, b = Ext.valueFrom, c = b(e.values, [b(e.value, b(e.minValue, 0))]), d = 0, a = c.length;
        e.originalValue = c;
        for (; d < a; d++) {
            e.addThumb(e.normalizeValue(c[d]))
        }
    },
    initComponent: function () {
        var e = this, c, d, g, b, a;
        e.thumbs = [];
        e.keyIncrement = Math.max(e.increment, e.keyIncrement);
        e.extraFieldBodyCls = "x-slider-ct-" + (e.vertical ? "vert" : "horz");
        Ext.form.field.Base.prototype.initComponent.call(this);
        if (e.useTips) {
            if (Ext.isObject(e.useTips)) {
                c = Ext.apply({}, e.useTips)
            } else {
                c = e.tipText ? {getText: e.tipText} : {}
            }
            a = e.plugins = e.plugins || [];
            b = a.length;
            for (g = 0; g < b; g++) {
                if (a[g].isSliderTip) {
                    d = true;
                    break
                }
            }
            if (!d) {
                e.plugins.push(new Ext.slider.Tip(c))
            }
        }
    },
    addThumb: function (c) {
        var b = this, a = new Ext.slider.Thumb({
            ownerCt: b,
            value: c,
            slider: b,
            index: b.thumbs.length,
            constrain: b.constrainThumbs,
            disabled: !!b.readOnly
        });
        b.thumbs.push(a);
        if (b.rendered) {
            a.render()
        }
        return a
    },
    promoteThumb: function (b) {
        var a = this.thumbStack || (this.thumbStack = Ext.Array.slice(this.thumbs)), d = a.length, e = 10000, c;
        if (a[0] !== b) {
            Ext.Array.remove(a, b);
            a.unshift(b)
        }
        for (c = 0; c < d; c++) {
            a[c].el.setStyle("zIndex", e);
            e -= 1000
        }
    },
    getSubTplData: function (b) {
        var c = this, d, a;
        d = Ext.apply(Ext.form.field.Base.prototype.getSubTplData.call(this, b), {
            $comp: c,
            vertical: c.vertical ? "x-slider-vert" : "x-slider-horz",
            minValue: c.minValue,
            maxValue: c.maxValue,
            value: c.value,
            tabIdx: c.tabIndex,
            childElCls: ""
        });
        a = d.inputElAriaAttributes;
        if (a) {
            a["aria-orientation"] = c.vertical ? "vertical" : "horizontal";
            a["aria-minvalue"] = c.minValue;
            a["aria-maxvalue"] = c.maxValue;
            a["aria-valuenow"] = c.value
        }
        return d
    },
    onRender: function () {
        var e = this, b = e.thumbs, a = b.length, d = 0, c;
        (arguments.callee.$previous || Ext.form.field.Base.prototype.onRender).apply(this, arguments);
        for (d = 0; d < a; d++) {
            c = b[d];
            c.el = e.el.getById(e.id + "-thumb-" + d);
            c.onRender()
        }
    },
    initEvents: function () {
        var a = this;
        Ext.form.field.Base.prototype.initEvents.call(this);
        a.mon(a.el, {scope: a, mousedown: a.onMouseDown, keydown: a.onKeyDown})
    },
    onDragStart: Ext.emptyFn,
    onDragEnd: Ext.emptyFn,
    getTrackpoint: function (h) {
        var g = this, d = g.vertical, c = g.innerEl, b, a, e;
        if (d) {
            e = "top";
            b = c.getHeight()
        } else {
            e = g.horizontalProp;
            b = c.getWidth()
        }
        h = g.transformTrackPoints(c.translatePoints(h));
        a = Ext.Number.constrain(h[e], 0, b);
        return d ? b - a : a
    },
    transformTrackPoints: Ext.identityFn,
    checkChange: Ext.emptyFn,
    onMouseDown: function (j) {
        var d = this, h = false, c = 0, b = d.thumbs, a = b.length, g;
        if (d.disabled) {
            return
        }
        for (; !h && c < a; c++) {
            h = h || j.target === b[c].el.dom
        }
        d.focus();
        if (d.clickToChange && !h) {
            g = d.getTrackpoint(j.getXY());
            if (g !== undefined) {
                d.onClickChange(g)
            }
        }
    },
    onClickChange: function (d) {
        var c = this, a, b;
        a = c.getNearest(d);
        if (!a.disabled) {
            b = a.index;
            c.setValue(b, Ext.util.Format.round(c.reversePixelValue(d), c.decimalPrecision), undefined, true)
        }
    },
    getNearest: function (j) {
        var k = this, g = k.reversePixelValue(j), l = k.getRange() + 5, b = null, e = k.thumbs, c = 0, d = e.length, a,
            m, h;
        for (; c < d; c++) {
            a = k.thumbs[c];
            m = a.value;
            h = Math.abs(m - g);
            if (Math.abs(h) <= l) {
                b = a;
                l = h
            }
        }
        return b
    },
    onKeyDown: function (d) {
        var c = this, a = c.ariaEl.dom, b, g;
        if (c.disabled || c.thumbs.length !== 1) {
            d.preventDefault();
            return
        }
        b = d.getKey();
        switch (b) {
            case d.UP:
            case d.RIGHT:
                g = d.ctrlKey ? c.maxValue : c.getValue(0) + c.keyIncrement;
                break;
            case d.DOWN:
            case d.LEFT:
                g = d.ctrlKey ? c.minValue : c.getValue(0) - c.keyIncrement;
                break;
            case d.HOME:
                g = c.minValue;
                break;
            case d.END:
                g = c.maxValue;
                break;
            case d.PAGE_UP:
                g = c.getValue(0) + c.pageSize;
                break;
            case d.PAGE_DOWN:
                g = c.getValue(0) - c.pageSize;
                break
        }
        if (g !== undefined) {
            d.stopEvent();
            g = c.normalizeValue(g);
            c.setValue(0, g, undefined, true);
            if (a) {
                a.setAttribute("aria-valuenow", g)
            }
        }
    },
    normalizeValue: function (b) {
        var c = this, a = c.zeroBasedSnapping ? "snap" : "snapInRange";
        b = Ext.Number[a](b, c.increment, c.minValue, c.maxValue);
        b = Ext.util.Format.round(b, c.decimalPrecision);
        b = Ext.Number.constrain(b, c.minValue, c.maxValue);
        return b
    },
    setMinValue: function (h) {
        var g = this, c = g.thumbs, b = c.length, a = g.ariaEl.dom, d, e;
        g.minValue = h;
        for (e = 0; e < b; ++e) {
            d = c[e];
            if (d.value < h) {
                g.setValue(e, h, false)
            }
        }
        if (a) {
            a.setAttribute("aria-minvalue", h)
        }
        g.syncThumbs()
    },
    setMaxValue: function (h) {
        var g = this, c = g.thumbs, b = c.length, a = g.ariaEl.dom, d, e;
        g.maxValue = h;
        for (e = 0; e < b; ++e) {
            d = c[e];
            if (d.value > h) {
                g.setValue(e, h, false)
            }
        }
        if (a) {
            a.setAttribute("aria-maxvalue", h)
        }
        g.syncThumbs()
    },
    setValue: function (g, l, b, d) {
        var k = this, j = k.thumbs, h = k.ariaEl.dom, a, e, c, m;
        if (Ext.isArray(g)) {
            m = g;
            b = l;
            for (c = 0, e = m.length; c < e; ++c) {
                a = j[c];
                if (a) {
                    k.setValue(c, m[c], b)
                }
            }
            return k
        }
        a = k.thumbs[g];
        l = k.normalizeValue(l);
        if (l !== a.value && k.fireEvent("beforechange", k, l, a.value, a) !== false) {
            a.value = l;
            if (k.rendered) {
                if (Ext.isDefined(b)) {
                    b = b === false ? false : b
                } else {
                    b = k.animate
                }
                a.move(k.calculateThumbPosition(l), b);
                if (g === 0 && h) {
                    h.setAttribute("aria-valuenow", l)
                }
                k.fireEvent("change", k, l, a);
                k.checkDirty();
                if (d) {
                    k.fireEvent("changecomplete", k, l, a)
                }
            }
        }
        return k
    },
    calculateThumbPosition: function (a) {
        var b = this, c = b.minValue, d = (a - c) / b.getRange() * 100;
        if (isNaN(d)) {
            d = 0
        }
        return d
    },
    getRatio: function () {
        var b = this, d = b.innerEl, a = b.vertical ? d.getHeight() : d.getWidth(), c = b.getRange();
        return c === 0 ? a : (a / c)
    },
    getRange: function () {
        return this.maxValue - this.minValue
    },
    reversePixelValue: function (a) {
        return this.minValue + (a / this.getRatio())
    },
    reversePercentageValue: function (a) {
        return this.minValue + this.getRange() * (a / 100)
    },
    onDisable: function () {
        var g = this, d = 0, b = g.thumbs, a = b.length, c, e, h;
        Ext.form.field.Base.prototype.onDisable.call(this);
        for (; d < a; d++) {
            c = b[d];
            e = c.el;
            c.disable();
            if (Ext.isIE) {
                h = e.getXY();
                e.hide();
                g.innerEl.addCls(g.disabledCls).dom.disabled = true;
                if (!g.thumbHolder) {
                    g.thumbHolder = g.endEl.createChild({role: "presentation", cls: "x-slider-thumb " + g.disabledCls})
                }
                g.thumbHolder.show().setXY(h)
            }
        }
    },
    onEnable: function () {
        var g = this, d = 0, b = g.thumbs, a = b.length, c, e;
        Ext.form.field.Base.prototype.onEnable.call(this);
        for (; d < a; d++) {
            c = b[d];
            e = c.el;
            c.enable();
            if (Ext.isIE) {
                g.innerEl.removeCls(g.disabledCls).dom.disabled = false;
                if (g.thumbHolder) {
                    g.thumbHolder.hide()
                }
                e.show();
                g.syncThumbs()
            }
        }
    },
    syncThumbs: function () {
        if (this.rendered) {
            var a = this.thumbs, c = a.length, b = 0;
            for (; b < c; b++) {
                a[b].move(this.calculateThumbPosition(a[b].value))
            }
        }
    },
    getValue: function (a) {
        return Ext.isNumber(a) ? this.thumbs[a].value : this.getValues()
    },
    getValues: function () {
        var c = [], d = 0, b = this.thumbs, a = b.length;
        for (; d < a; d++) {
            c.push(b[d].value)
        }
        return c
    },
    getSubmitValue: function () {
        var a = this;
        return (a.disabled || !a.submitValue) ? null : a.getValue()
    },
    reset: function () {
        var e = this, b = [].concat(e.originalValue), c = 0, d = b.length, g;
        for (; c < d; c++) {
            g = b[c];
            e.setValue(c, g)
        }
        e.clearInvalid();
        delete e.wasValid
    },
    setReadOnly: function (e) {
        var d = this, b = d.thumbs, a = b.length, c = 0;
        Ext.form.field.Base.prototype.setReadOnly.apply(this, arguments);
        e = d.readOnly;
        for (; c < a; ++c) {
            if (e) {
                b[c].disable()
            } else {
                b[c].enable()
            }
        }
    },
    beforeDestroy: function () {
        var e = this, b = e.thumbs, d = 0, a = b.length, c;
        if (e.rendered) {
            for (; d < a; d++) {
                c = b[d];
                Ext.destroy(c)
            }
        }
        Ext.form.field.Base.prototype.beforeDestroy.call(this)
    }
}, 0, ["multislider"], ["component", "box", "field", "multislider"], {
    component: true,
    box: true,
    field: true,
    multislider: true
}, ["widget.multislider"], 0, [Ext.slider, "Multi", Ext.slider, "MultiSlider"], 0));
(Ext.cmd.derive("Ext.slider.Single", Ext.slider.Multi, {
    alternateClassName: ["Ext.Slider", "Ext.form.SliderField", "Ext.slider.SingleSlider", "Ext.slider.Slider"],
    defaultBindProperty: "value",
    initComponent: function () {
        if (this.publishOnComplete) {
            this.valuePublishEvent = "changecomplete"
        }
        Ext.slider.Multi.prototype.initComponent.call(this)
    },
    publishOnComplete: true,
    getValue: function () {
        return Ext.slider.Multi.prototype.getValue.call(this, 0)
    },
    setValue: function (d, b) {
        var c = arguments, a = c.length;
        if (a === 1 || (a <= 3 && typeof c[1] !== "number")) {
            c = Ext.toArray(c);
            c.unshift(0)
        }
        return Ext.slider.Multi.prototype.setValue.apply(this, c)
    },
    getNearest: function () {
        return this.thumbs[0]
    }
}, 0, ["slider", "sliderfield"], ["component", "box", "field", "multislider", "slider", "sliderfield"], {
    component: true,
    box: true,
    field: true,
    multislider: true,
    slider: true,
    sliderfield: true
}, ["widget.slider", "widget.sliderfield"], 0, [Ext.slider, "Single", Ext, "Slider", Ext.form, "SliderField", Ext.slider, "SingleSlider", Ext.slider, "Slider"], 0));
(Ext.cmd.derive("Ext.slider.Widget", Ext.Widget, {
    cachedConfig: {vertical: false},
    config: {
        clickToChange: true,
        ui: "widget",
        value: 0,
        minValue: 0,
        maxValue: 100,
        publishOnComplete: true,
        twoWayBindable: {value: 1}
    },
    decimalPrecision: 0,
    defaultBindProperty: "value",
    element: {
        reference: "element",
        cls: "x-slider",
        listeners: {mousedown: "onMouseDown", dragstart: "cancelDrag", drag: "cancelDrag", dragend: "cancelDrag"},
        children: [{reference: "endEl", cls: "x-slider-end", children: [{reference: "innerEl", cls: "x-slider-inner"}]}]
    },
    thumbCls: "x-slider-thumb",
    horizontalProp: "left",
    animateOnSetValue: undefined,
    applyValue: function (e) {
        var d = this, b = d.animateOnSetValue, c, a;
        if (Ext.isArray(e)) {
            e = Ext.Array.from(e);
            for (c = 0, a = e.length; c < a; ++c) {
                d.setThumbValue(c, e[c] = d.normalizeValue(e[c]), b, true)
            }
        } else {
            e = d.normalizeValue(e);
            d.setThumbValue(0, e, b, true)
        }
        return e
    },
    updateVertical: function (a, b) {
        this.element.removeCls("x-slider-" + (b ? "vert" : "horz"));
        this.element.addCls("x-slider-" + (a ? "vert" : "horz"))
    },
    updateHeight: function (a, b) {
        Ext.Widget.prototype.updateHeight.call(this, a, b);
        this.endEl.dom.style.height = this.innerEl.dom.style.height = "100%"
    },
    cancelDrag: function (a) {
        a.stopPropagation()
    },
    getThumb: function (c) {
        var d = this, b, a = (d.thumbs || (d.thumbs = []))[c];
        if (!a) {
            b = {cls: d.thumbCls, style: {}};
            b["data-thumbIndex"] = c;
            a = d.thumbs[c] = d.innerEl.createChild(b)
        }
        return a
    },
    getThumbPositionStyle: function () {
        return this.getVertical() ? "bottom" : (this.rtl && Ext.rtl ? "right" : "left")
    },
    update: function () {
        var d = this, b = d.getValue(), a = b.length, c;
        for (c = 0; c < a; c++) {
            this.thumbs[c].dom.style[d.getThumbPositionStyle()] = d.calculateThumbPosition(b[c]) + "%"
        }
    },
    onMouseDown: function (d) {
        var b = this, a, c = d.getXY(), g;
        if (!b.disabled && d.button === 0) {
            Ext.getDoc().on({scope: b, capture: true, selectstart: b.stopSelect});
            a = d.getTarget("." + b.thumbCls, null, true);
            if (a) {
                b.animateOnSetValue = false;
                b.promoteThumb(a);
                b.captureMouse(b.onMouseMove, b.onMouseUp, [a], 1);
                g = b.pointerOffset = a.getXY();
                g[0] += Math.floor(a.getWidth() / 2) - c[0];
                g[1] += Math.floor(a.getHeight() / 2) - c[1]
            } else {
                if (b.getClickToChange()) {
                    c = b.getTrackpoint(c);
                    if (c != null) {
                        b.onClickChange(c)
                    }
                }
            }
        }
    },
    onClickChange: function (e) {
        var c = this, a, b, d;
        a = c.getNearest(e);
        b = parseInt(a.getAttribute("data-thumbIndex"), 10);
        d = Ext.util.Format.round(c.reversePixelValue(e), c.decimalPrecision);
        if (b) {
            c.setThumbValue(b, d, undefined, true)
        } else {
            c.setValue(d)
        }
    },
    getNearest: function (j) {
        var k = this, g = k.reversePixelValue(j), l = k.getRange() + 5, b = null, e = k.thumbs, c = 0, d = e.length, a,
            m, h;
        for (; c < d; c++) {
            a = e[c];
            m = k.reversePercentageValue(parseInt(a.dom.style[k.getThumbPositionStyle()], 10));
            h = Math.abs(m - g);
            if (Math.abs(h) <= l) {
                b = a;
                l = h
            }
        }
        return b
    },
    promoteThumb: function (b) {
        var a = this.thumbStack || (this.thumbStack = Ext.Array.slice(this.thumbs)), d = a.length, e = 10000, c;
        if (a[0] !== b) {
            Ext.Array.remove(a, b);
            a.unshift(b)
        }
        for (c = 0; c < d; c++) {
            a[c].el.setStyle("zIndex", e);
            e -= 1000
        }
    },
    doMouseMove: function (j, b, g) {
        var d = this, a = j.getXY(), i, c, h;
        a[0] += d.pointerOffset[0];
        a[1] += d.pointerOffset[1];
        h = d.getTrackpoint(a);
        if (h) {
            i = d.reversePixelValue(h);
            c = parseInt(b.getAttribute("data-thumbIndex"), 10);
            if (c || (!g && d.getPublishOnComplete())) {
                d.setThumbValue(c, i, false, g)
            } else {
                d.setValue(i)
            }
        }
    },
    onMouseMove: function (b, a) {
        this.doMouseMove(b, a, false)
    },
    onMouseUp: function (c, a) {
        var b = this;
        b.doMouseMove(c, a, true);
        Ext.getDoc().un({scope: b, capture: true, selectstart: b.stopSelect});
        delete b.animateOnSetValue
    },
    stopSelect: function (a) {
        a.stopEvent();
        return false
    },
    setThumbValue: function (g, k, b, d) {
        var j = this, a, e, h, c, l;
        if (Ext.isArray(g)) {
            l = g;
            b = k;
            for (c = 0, h = l.length; c < h; ++c) {
                j.setThumbValue(c, l[c], b, d)
            }
            return j
        }
        a = j.getThumb(g);
        e = j.reversePercentageValue(parseInt(a.dom.style[j.getThumbPositionStyle()], 10));
        k = j.normalizeValue(k);
        if (k !== e && j.fireEvent("beforechange", j, k, e, a) !== false) {
            if (j.element.dom) {
                j.element.set({"aria-valuenow": k, "aria-valuetext": k});
                j.moveThumb(a, j.calculateThumbPosition(k), Ext.isDefined(b) ? b !== false : j.animate);
                j.fireEvent("change", j, k, a)
            }
        }
        return j
    },
    getValue: function (a) {
        var b = this, c;
        if (Ext.isNumber(a)) {
            c = b.thumbs[a].dom.style[b.getThumbPositionStyle()];
            c = b.reversePercentageValue(parseInt(c, 10))
        } else {
            c = b.getValues();
            if (c.length === 1) {
                c = c[0]
            }
        }
        return c
    },
    getValues: function () {
        var e = this, c = [], d = 0, b = e.thumbs, a = b.length;
        for (; d < a; d++) {
            c.push(e.reversePercentageValue(parseInt(e.thumbs[d].dom.style[e.getThumbPositionStyle()], 10)))
        }
        return c
    },
    moveThumb: function (d, c, b) {
        var e = this, a = e.getThumbPositionStyle(), h, g;
        c += "%";
        if (!b) {
            d.dom.style[a] = c
        } else {
            h = {};
            h[a] = c;
            if (!Ext.supports.GetPositionPercentage) {
                g = {};
                g[a] = d.dom.style[a]
            }
            new Ext.fx.Anim({target: d, duration: 350, from: g, to: h})
        }
    },
    normalizeValue: function (b) {
        var c = this, a = c.zeroBasedSnapping ? "snap" : "snapInRange";
        b = Ext.Number[a](b, c.increment, c.minValue, c.maxValue);
        b = Ext.util.Format.round(b, c.decimalPrecision);
        b = Ext.Number.constrain(b, c.minValue, c.maxValue);
        return b
    },
    getTrackpoint: function (h) {
        var g = this, d = g.getVertical(), c = g.innerEl, b, a, e;
        if (d) {
            e = "top";
            b = c.getHeight()
        } else {
            e = "left";
            b = c.getWidth()
        }
        h = g.transformTrackPoints(c.translatePoints(h));
        a = Ext.Number.constrain(h[e], 0, b);
        return d ? b - a : a
    },
    transformTrackPoints: Ext.identityFn,
    calculateThumbPosition: function (a) {
        var b = this, c = (a - b.getMinValue()) / b.getRange() * 100;
        if (isNaN(c)) {
            c = 0
        }
        return c
    },
    getRatio: function () {
        var b = this, d = b.innerEl, a = b.getVertical() ? d.getHeight() : d.getWidth(), c = b.getRange();
        return c === 0 ? a : (a / c)
    },
    getRange: function () {
        return this.getMaxValue() - this.getMinValue()
    },
    reversePixelValue: function (a) {
        return this.getMinValue() + (a / this.getRatio())
    },
    reversePercentageValue: function (a) {
        return this.getMinValue() + this.getRange() * (a / 100)
    },
    captureMouse: function (h, b, d, a) {
        var g = this, c, e;
        h = h && Ext.Function.bind(h, g, d, a);
        b = b && Ext.Function.bind(b, g, d, a);
        c = function () {
            Ext.getDoc().un(e);
            if (b) {
                b.apply(g, arguments)
            }
        };
        e = {mousemove: h, mouseup: c};
        Ext.getDoc().on(e)
    }
}, 0, ["sliderwidget"], ["widget", "sliderwidget"], {
    widget: true,
    sliderwidget: true
}, ["widget.sliderwidget"], 0, [Ext.slider, "Widget"], 0));
(Ext.cmd.derive("Ext.sparkline.Shape", Ext.Base, {
    constructor: function (c, d, b, a) {
        this.target = c;
        this.id = d;
        this.type = b;
        this.args = a
    }, append: function () {
        this.target.appendShape(this);
        return this
    }
}, 1, 0, 0, 0, 0, 0, [Ext.sparkline, "Shape"], 0));
(Ext.cmd.derive("Ext.sparkline.CanvasBase", Ext.Base, {
    shapeCount: 0,
    _pxregex: /(\\d+)(px)?\\s*$/i,
    constructor: function (a) {
        this.owner = a
    },
    setWidth: function (a) {
        this.pixelWidth = a
    },
    setHeight: function (a) {
        this.pixelHeight = a
    },
    drawLine: function (c, e, b, d, g, a) {
        return this.drawShape([[c, e], [b, d]], g, a)
    },
    drawShape: function (c, b, d, a) {
        return this._genShape("Shape", [c, b, d, a])
    },
    drawCircle: function (c, g, b, d, e, a) {
        return this._genShape("Circle", [c, g, b, d, e, a])
    },
    drawPieSlice: function (b, h, a, d, c, e, g) {
        return this._genShape("PieSlice", [b, h, a, d, c, e, g])
    },
    drawRect: function (b, g, c, a, d, e) {
        return this._genShape("Rect", [b, g, c, a, d, e])
    },
    getElement: function () {
        return this.el
    },
    getLastShapeId: function () {
        return this.lastShapeId
    },
    reset: function () {
    },
    _genShape: function (b, a) {
        var c = this.shapeCount++;
        a.unshift(c);
        return new Ext.sparkline.Shape(this, c, b, a)
    },
    appendShape: function (a) {
    },
    replaceWithShape: function (b, a) {
    },
    insertAfterShape: function (b, a) {
    },
    removeShapeId: function (a) {
    },
    getShapeAt: function (a, b) {
    },
    render: function () {
    }
}, 1, 0, 0, 0, 0, 0, [Ext.sparkline, "CanvasBase"], 0));
(Ext.cmd.derive("Ext.sparkline.CanvasCanvas", Ext.sparkline.CanvasBase, {
    statics: {
        contextOverrides: (function () {
            var a = window.devicePixelRatio || 1;
            return {
                moveTo: function (b, c) {
                    this.$moveTo(b * a, c * a)
                }, lineTo: function (b, c) {
                    this.$lineTo(b * a, c * a)
                }, arc: function (c, h, b, g, d, e) {
                    this.$arc(c * a, h * a, b * a, g, d, e)
                }, clearRect: function (c, e, d, b) {
                    this.$clearRect(c * a, e * a, d * a, b * a)
                }
            }
        })()
    }, setWidth: function (a) {
        Ext.sparkline.CanvasBase.prototype.setWidth.apply(this, arguments);
        this.owner.element.dom.width = a * (window.devicePixelRatio || 1)
    }, setHeight: function (a) {
        Ext.sparkline.CanvasBase.prototype.setHeight.apply(this, arguments);
        this.owner.element.dom.height = a * (window.devicePixelRatio || 1)
    }, onOwnerUpdate: function () {
        var a = this;
        a.el = a.owner.element;
        a.interact = !a.owner.initialConfig.disableInteraction;
        a.shapes = {};
        a.shapeseq = [];
        a.currentTargetShapeId = a.lastShapeId = null
    }, _getContext: function (d, g, a) {
        var c = this.el.dom.getContext("2d"), e = Ext.sparkline.CanvasCanvas.contextOverrides, b;
        if (!this.context) {
            for (b in e) {
                c["$" + b] = c[b]
            }
            Ext.apply(c, e);
            this.context = c
        }
        if (d != null) {
            c.strokeStyle = d
        }
        c.lineWidth = a || 1;
        if (g != null) {
            c.fillStyle = g
        }
        return c
    }, reset: function () {
        var a = this._getContext();
        a.clearRect(0, 0, this.pixelWidth, this.pixelHeight);
        this.shapes = {};
        this.shapeseq = [];
        this.currentTargetShapeId = this.lastShapeId = null
    }, _drawShape: function (h, g, e, j, a) {
        var c = this._getContext(e, j, a), b, d;
        c.beginPath();
        c.moveTo(g[0][0] + 0.5, g[0][1] + 0.5);
        for (b = 1, d = g.length; b < d; b++) {
            c.lineTo(g[b][0] + 0.5, g[b][1] + 0.5)
        }
        if (e != null) {
            c.stroke()
        }
        if (j != null) {
            c.fill()
        }
        if (this.targetX != null && this.targetY != null && c.isPointInPath(this.targetX, this.targetY)) {
            this.currentTargetShapeId = h
        }
    }, _drawCircle: function (g, c, i, b, e, h, a) {
        var d = this._getContext(e, h, a);
        d.beginPath();
        d.arc(c, i, b, 0, 2 * Math.PI, false);
        if (this.targetX != null && this.targetY != null && d.isPointInPath(this.targetX, this.targetY)) {
            this.currentTargetShapeId = g
        }
        if (e !== undefined) {
            d.stroke()
        }
        if (h !== undefined) {
            d.fill()
        }
    }, _drawPieSlice: function (e, j, h, d, g, c, i, b) {
        var a = this._getContext(i, b);
        a.beginPath();
        a.moveTo(j, h);
        a.arc(j, h, d, g, c, false);
        a.lineTo(j, h);
        a.closePath();
        if (i != null) {
            a.stroke()
        }
        if (b) {
            a.fill()
        }
        if (this.targetX !== undefined && this.targetY !== undefined && a.isPointInPath(this.targetX, this.targetY)) {
            this.currentTargetShapeId = e
        }
    }, _drawRect: function (e, b, h, c, a, d, g) {
        return this._drawShape(e, [[b, h], [b + c, h], [b + c, h + a], [b, h + a], [b, h]], d, g)
    }, appendShape: function (a) {
        this.shapes[a.id] = a;
        this.shapeseq.push(a.id);
        this.lastShapeId = a.id;
        return a.id
    }, replaceWithShape: function (c, a) {
        var d = this.shapeseq, b;
        this.shapes[a.id] = a;
        for (b = d.length; b--;) {
            if (d[b] == c) {
                d[b] = a.id
            }
        }
        delete this.shapes[c]
    }, replaceWithShapes: function (c, b) {
        var h = this.shapeseq, e = {}, a, d, g;
        for (d = c.length; d--;) {
            e[c[d]] = true
        }
        for (d = h.length; d--;) {
            a = h[d];
            if (e[a]) {
                h.splice(d, 1);
                delete this.shapes[a];
                g = d
            }
        }
        for (d = b.length; d--;) {
            h.splice(g, 0, b[d].id);
            this.shapes[b[d].id] = b[d]
        }
    }, insertAfterShape: function (c, a) {
        var d = this.shapeseq, b;
        for (b = d.length; b--;) {
            if (d[b] === c) {
                d.splice(b + 1, 0, a.id);
                this.shapes[a.id] = a;
                return
            }
        }
    }, removeShapeId: function (b) {
        var c = this.shapeseq, a;
        for (a = c.length; a--;) {
            if (c[a] === b) {
                c.splice(a, 1);
                break
            }
        }
        delete this.shapes[b]
    }, getShapeAt: function (a, b) {
        this.targetX = a;
        this.targetY = b;
        this.render();
        return this.currentTargetShapeId
    }, render: function () {
        var h = this.shapeseq, a = this.shapes, e = h.length, d = this._getContext(), g, b, c;
        d.clearRect(0, 0, this.pixelWidth, this.pixelHeight);
        for (c = 0; c < e; c++) {
            g = h[c];
            b = a[g];
            this["_draw" + b.type].apply(this, b.args)
        }
        if (!this.interact) {
            this.shapes = {};
            this.shapeseq = []
        }
    }
}, 0, 0, 0, 0, 0, 0, [Ext.sparkline, "CanvasCanvas"], 0));
(Ext.cmd.derive("Ext.sparkline.VmlCanvas", Ext.sparkline.CanvasBase, {
    setWidth: function (a) {
        var b = this;
        Ext.sparkline.CanvasBase.prototype.setWidth.apply(this, arguments);
        b.owner.groupEl.dom.coordsize = b.width + " " + (b.height || 0);
        b.owner.groupEl.dom.style.width = a + "px"
    }, setHeight: function (a) {
        var b = this;
        Ext.sparkline.CanvasBase.prototype.setHeight.apply(this, arguments);
        b.owner.groupEl.dom.coordsize = (b.width || 0) + " " + b.height;
        b.owner.groupEl.dom.style.height = a + "px"
    }, onOwnerUpdate: function () {
        var a = this;
        a.group = a.owner.groupEl;
        a.el = a.owner.element;
        a.prerender = []
    }, _drawShape: function (g, n, j, a, d) {
        var k = [], h, m, l, e, b, c;
        for (c = 0, b = n.length; c < b; c++) {
            k[c] = (n[c][0]) + "," + (n[c][1])
        }
        h = k.splice(0, 1);
        d = d == null ? 1 : d;
        m = j == null ? ' stroked="false" ' : ' strokeWeight="' + d + 'px" strokeColor="' + j + '" ';
        l = a == null ? ' filled="false"' : ' fillColor="' + a + '" filled="true" ';
        e = k[0] === k[k.length - 1] ? "x " : "";
        return ['<svml:shape coordorigin="0 0" coordsize="', this.pixelWidth, " ", this.pixelHeight, '" id="jqsshape', g, '" ', m, l, ' style="position:absolute;height:', this.pixelHeight, "px;width:", this.pixelWidth, 'px" ', ' path="m ', h, " l ", k.join(", "), " ", e, 'e"></svml:shape>'].join("")
    }, _drawCircle: function (d, i, g, c, h, a, b) {
        var e = c * 2, k, j;
        i -= c;
        g -= c;
        k = h == null ? ' stroked="false" ' : ' strokeWeight="' + b + 'px" strokeColor="' + h + '" ';
        j = a == null ? ' filled="false"' : ' fillColor="' + a + '" filled="true" ';
        return ['<svml:oval id="jqsshape', d, '" ', k, j, ' style="position:absolute;top:', g, "px; left:", i, "px;width:", e, "px;height:", e, 'px"></svml:oval>'].join("")
    }, _drawPieSlice: function (j, o, m, i, k, e, n, d) {
        var l, c = this.pixelWidth, p = this.pixelHeight, b, a, h, g,
            r = n == null ? ' stroked="false" ' : ' strokeWeight="1px" strokeColor="' + n + '" ',
            q = d == null ? ' filled="false"' : ' fillColor="' + d + '" filled="true" ';
        if (k === e) {
            return ""
        }
        if ((e - k) === (2 * Math.PI)) {
            k = 0;
            e = (2 * Math.PI)
        }
        b = o + Math.round(Math.cos(k) * i);
        a = m + Math.round(Math.sin(k) * i);
        h = o + Math.round(Math.cos(e) * i);
        g = m + Math.round(Math.sin(e) * i);
        if (b === h && a === g) {
            if ((e - k) < Math.PI) {
                return ""
            }
            b = h = o + i;
            a = g = m
        }
        if (b === h && a === g && (e - k) < Math.PI) {
            return ""
        }
        l = [o - i, m - i, o + i, m + i, b, a, h, g];
        return ['<svml:shape coordorigin="0 0" coordsize="', c, " ", p, '" id="jqsshape', j, '" ', r, q, ' style="position:absolute;height:', p, "px;width:", c, 'px" path="m ', o, ",", m, " wa ", l.join(", "), ' x e"></svml:shape>'].join("")
    }, _drawRect: function (e, b, h, c, a, d, g) {
        return this._drawShape(e, [[b, h], [b, h + a], [b + c, h + a], [b + c, h], [b, h]], d, g)
    }, reset: function () {
        Ext.fly(this.group).empty()
    }, appendShape: function (a) {
        this.prerender.push(this["_draw" + a.type].apply(this, a.args));
        this.lastShapeId = a.id;
        return a.id
    }, replaceWithShape: function (d, a) {
        var c = this.el.getById("jqsshape" + d, true), b = this["_draw" + a.type].apply(this, a.args);
        c.outerHTML = b
    }, replaceWithShapes: function (b, a) {
        var e = this.el.getById("jqsshape" + b[0], true), d = "", g = a.length, c;
        for (c = 0; c < g; c++) {
            d += this["_draw" + a[c].type].apply(this, a[c].args)
        }
        e.outerHTML = d;
        for (c = 1; c < b.length; c++) {
            this.el.getById("jqsshape" + b[c]).destroy()
        }
    }, insertAfterShape: function (d, a) {
        var c = this.el.getById("jqsshape" + d, true), b = this["_draw" + a.type].apply(this, a.args);
        c.insertAdjacentHTML("afterEnd", b)
    }, removeShapeId: function (b) {
        var a = this.el.getById("jqsshape" + b, true);
        this.group.removeChild(a)
    }, getShapeAt: function (a, c) {
        var b = this.el.id.substr(8);
        return b
    }, render: function () {
        this.group.dom.innerHTML = this.prerender.join("")
    }
}, 0, 0, 0, 0, 0, 0, [Ext.sparkline, "VmlCanvas"], function () {
    Ext.onInternalReady(function () {
        var a = document;
        if (a.namespaces && !a.namespaces.svml) {
            a.namespaces.add("svml", "urn:schemas-microsoft-com:vml", "#default#VML")
        }
    })
}));
(Ext.cmd.derive("Ext.sparkline.Base", Ext.Widget, {
    cachedConfig: {
        baseCls: "x-sparkline",
        lineColor: "#157fcc",
        fillColor: "#def",
        defaultPixelsPerValue: 3,
        tagValuesAttribute: "values",
        enableTagOptions: false,
        enableHighlight: true,
        highlightColor: null,
        highlightLighten: 1.4,
        tooltipSkipNull: true,
        tooltipPrefix: "",
        tooltipSuffix: "",
        disableTooltips: false,
        disableInteraction: false,
        tipTpl: null
    },
    config: {values: null},
    element: {
        tag: "canvas",
        reference: "element",
        style: {display: "inline-block", verticalAlign: "top"},
        listeners: {mouseenter: "onMouseEnter", mouseleave: "onMouseLeave", mousemove: "onMouseMove"},
        width: 0,
        height: 0
    },
    defaultBindProperty: "values",
    redrawQueue: {},
    inheritableStatics: {
        sparkLineTipClass: "x-sparkline-tip-target", onClassCreated: function (a) {
            var c = a.prototype, d = a.getConfigurator().configs, b;
            for (b in d) {
                if (b !== "tipTpl") {
                    c[Ext.Config.get(b).names.apply] = c.applyConfigChange
                }
            }
        }
    },
    constructor: function (a) {
        var b = this;
        b.canvas = Ext.supports.Canvas ? new Ext.sparkline.CanvasCanvas(b) : new Ext.sparkline.VmlCanvas(b);
        if (!b.getDisableTooltips()) {
            b.element.cls = Ext.sparkline.Base.sparkLineTipClass
        }
        Ext.apply(b, a);
        Ext.Widget.prototype.constructor.call(this, a);
        b.el = b.element
    },
    all: function (d, b, a) {
        var c;
        for (c = b.length; c--;) {
            if (a && b[c] === null) {
                continue
            }
            if (b[c] !== d) {
                return false
            }
        }
        return true
    },
    applyConfigChange: function (b) {
        var a = this;
        a.redrawQueue[a.getId()] = a;
        if (!a.redrawTimer) {
            Ext.sparkline.Base.prototype.redrawTimer = Ext.Function.requestAnimationFrame(a.processRedrawQueue)
        }
        return b
    },
    applyTipTpl: function (a) {
        if (!a.isTemplate) {
            a = new Ext.XTemplate(a)
        }
        return a
    },
    normalizeValue: function (b) {
        var a;
        switch (b) {
            case"undefined":
                b = undefined;
                break;
            case"null":
                b = null;
                break;
            case"true":
                b = true;
                break;
            case"false":
                b = false;
                break;
            default:
                a = parseFloat(b);
                if (b == a) {
                    b = a
                }
        }
        return b
    },
    normalizeValues: function (c) {
        var b, a = [];
        for (b = c.length; b--;) {
            a[b] = this.normalizeValue(c[b])
        }
        return a
    },
    updateWidth: function (b, a) {
        var c = this, d = c.element.dom;
        Ext.Widget.prototype.updateWidth.call(this, b, a);
        c.canvas.setWidth(b);
        c.width = b;
        if (c.height == null) {
            c.setHeight(parseInt(c.measurer.getCachedStyle(d.parentNode, "line-height"), 10))
        } else {
            c.redrawQueue[c.getId()] = c
        }
    },
    updateHeight: function (a, c) {
        var b = this;
        Ext.Widget.prototype.updateHeight.call(this, a, c);
        b.canvas.setHeight(a);
        b.height = a;
        b.redrawQueue[b.getId()] = b
    },
    updateValues: function (a) {
        this.values = a
    },
    redraw: function () {
        var a = this;
        if (a.getValues()) {
            a.onUpdate();
            a.canvas.onOwnerUpdate();
            a.renderGraph()
        }
    },
    onUpdate: Ext.emptyFn,
    renderGraph: function () {
        var a = true;
        if (this.disabled) {
            this.canvas.reset();
            a = false
        }
        return a
    },
    onMouseEnter: function (a) {
        this.onMouseMove(a)
    },
    onMouseMove: function (a) {
        this.tooltip.triggerEvent = a;
        this.currentPageXY = a.getPoint();
        this.redraw()
    },
    onMouseLeave: function () {
        var a = this;
        a.currentPageXY = a.targetX = a.targetY = null;
        a.redraw();
        a.tooltip.target = null;
        a.tooltip.hide()
    },
    updateDisplay: function () {
        var c = this, b = c.getValues(), g, d = c.tooltip, a, e;
        if (b && b.length && c.currentPageXY && c.el.getRegion().contains(c.currentPageXY)) {
            g = c.canvas.el.getXY();
            e = c.getRegion(c.currentPageXY[0] - g[0], c.currentPageXY[1] - g[1]);
            if (e != null && !c.disableHighlight) {
                c.renderHighlight(e);
                a = c.getRegionTooltip(e)
            }
            c.fireEvent("sparklineregionchange", c);
            if (a) {
                if (!c.lastTooltipHTML || a[0] !== c.lastTooltipHTML[0] || a[1] !== c.lastTooltipHTML[1]) {
                    d.setTitle(a[0]);
                    d.update(a[1]);
                    c.lastTooltipHTML = a
                }
                d.target = c.el;
                d.onTargetOver(d.triggerEvent)
            }
        }
        if (!a) {
            d.target = null;
            d.hide()
        }
    },
    getRegion: Ext.emptyFn,
    getRegionTooltip: function (o) {
        var n = this, e = n.tooltipChartTitle, g = [], q = n.getTipTpl(), h, k, d, l, b, p, m, c, a;
        h = n.getRegionFields(o);
        p = n.tooltipFormatter;
        if (p) {
            return p(n, n, h)
        }
        if (!q) {
            return ""
        }
        if (!Ext.isArray(h)) {
            h = [h]
        }
        k = n.tooltipFormatFieldlist;
        d = n.tooltipFormatFieldlistKey;
        if (k && d) {
            l = [];
            for (c = h.length; c--;) {
                b = h[c][d];
                if ((a = Ext.Array.indexOf(b, k)) !== -1) {
                    l[a] = h[c]
                }
            }
            h = l
        }
        m = h.length;
        for (a = 0; a < m; a++) {
            if (!h[a].isNull || !n.getTooltipSkipNull()) {
                Ext.apply(h[a], {prefix: n.getTooltipPrefix(), suffix: n.getTooltipSuffix()});
                g.push(q.apply(h[a]))
            }
        }
        if (e || g.length) {
            return [e, g.join("<br>")]
        }
        return ""
    },
    getRegionFields: Ext.emptyFn,
    calcHighlightColor: function (a) {
        var d = this, j = d.getHighlightColor(), c = d.getHighlightLighten(), h, g, e, b;
        if (j) {
            return j
        }
        if (c) {
            h = /^#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(a) || /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(a);
            if (h) {
                e = [];
                g = a.length === 4 ? 16 : 1;
                for (b = 0; b < 3; b++) {
                    e[b] = Ext.Number.constrain(Math.round(parseInt(h[b + 1], 16) * g * c), 0, 255)
                }
                return "rgb(" + e.join(",") + ")"
            }
        }
        return a
    },
    destroy: function () {
        delete this.redrawQueue[this.getId()];
        Ext.Widget.prototype.destroy.call(this)
    }
}, 1, 0, ["widget"], {widget: true}, 0, 0, [Ext.sparkline, "Base"], function (b) {
    var a = b.prototype;
    Ext.onInternalReady(function () {
        a.tooltip = new Ext.tip.ToolTip({id: "sparklines-tooltip", showDelay: 0, dismissDelay: 0, hideDelay: 400})
    });
    b.onClassCreated(b);
    a.processRedrawQueue = function () {
        var c = a.redrawQueue, d;
        for (d in c) {
            c[d].redraw()
        }
        a.redrawQueue = {};
        a.redrawTimer = 0
    };
    if (!Ext.supports.Canvas) {
        b.prototype.element = {
            tag: "span",
            reference: "element",
            listeners: {mouseenter: "onMouseEnter", mouseleave: "onMouseLeave", mousemove: "onMouseMove"},
            style: {
                display: "inline-block",
                position: "relative",
                overflow: "hidden",
                margin: "0px",
                padding: "0px",
                verticalAlign: "top",
                cursor: "default"
            },
            children: [{
                tag: "svml:group",
                reference: "groupEl",
                coordorigin: "0 0",
                coordsize: "0 0",
                style: "position:absolute;width:0;height:0;pointer-events:none"
            }]
        }
    }
}));
(Ext.cmd.derive("Ext.sparkline.BarBase", Ext.sparkline.Base, {
    renderHighlight: function (a) {
        this.renderRegion(a, true)
    }, renderGraph: function () {
        var h = this, b = h.values, d = h.canvas, k = h.regionShapes || (h.regionShapes = {}), a, g, e, c;
        if (!Ext.sparkline.Base.prototype.renderGraph.call(this)) {
            return
        }
        for (e = b.length; e--;) {
            a = h.renderRegion(e);
            if (a) {
                if (Ext.isArray(a)) {
                    g = [];
                    for (c = a.length; c--;) {
                        a[c].append();
                        g.push(a[c].id)
                    }
                    k[e] = g
                } else {
                    a.append();
                    k[e] = a.id
                }
            } else {
                k[e] = null
            }
        }
        if (h.currentPageXY) {
            h.currentRegion = null;
            h.updateDisplay()
        }
        d.render()
    }
}, 0, 0, ["widget"], {widget: true}, 0, 0, [Ext.sparkline, "BarBase"], 0));
(Ext.cmd.derive("Ext.sparkline.RangeMap", Ext.Base, {
    constructor: function (d) {
        var c, a, b = [];
        for (c in d) {
            if (d.hasOwnProperty(c) && typeof c === "string" && c.indexOf(":") > -1) {
                a = c.split(":");
                a[0] = a[0].length === 0 ? -Infinity : parseFloat(a[0]);
                a[1] = a[1].length === 0 ? Infinity : parseFloat(a[1]);
                a[2] = d[c];
                b.push(a)
            }
        }
        this.map = d;
        this.rangelist = b || false
    }, get: function (e) {
        var d = this.rangelist, c, b, a;
        if ((a = this.map[e]) !== undefined) {
            return a
        }
        if (d) {
            for (c = d.length; c--;) {
                b = d[c];
                if (b[0] <= e && b[1] >= e) {
                    return b[2]
                }
            }
        }
    }
}, 1, 0, 0, 0, 0, 0, [Ext.sparkline, "RangeMap"], 0));
(Ext.cmd.derive("Ext.sparkline.Bar", Ext.sparkline.BarBase, {
    config: {
        barColor: "#3366cc",
        negBarColor: "#f44",
        stackedBarColor: ["#3366cc", "#dc3912", "#ff9900", "#109618", "#66aa00", "#dd4477", "#0099c6", "#990099"],
        zeroColor: null,
        nullColor: null,
        zeroAxis: true,
        barWidth: 4,
        barSpacing: 1,
        chartRangeMin: null,
        chartRangeMax: null,
        chartRangeClip: false,
        colorMap: null,
        tipTpl: new Ext.XTemplate("&#9679; {prefix}{value}{suffix}")
    }, remove: function (e, c) {
        var b, d, a = [];
        for (b = 0, d = e.length; b < d; b++) {
            if (e[b] !== c) {
                a.push(e[b])
            }
        }
        return a
    }, all: function (b, d, a) {
        var c;
        for (c = b.length; c--;) {
            if (a && b[c] === null) {
                continue
            }
            if (b[c] !== d) {
                return false
            }
        }
        return true
    }, applyColorMap: function (a) {
        var b = this;
        if (Ext.isArray(a)) {
            b.colorMapByIndex = a;
            b.colorMapByValue = null
        } else {
            b.colorMapByIndex = null;
            b.colorMapByValue = a;
            if (b.colorMapByValue && b.colorMapByValue.get == null) {
                b.colorMapByValue = new Ext.sparkline.RangeMap(a)
            }
        }
        return a
    }, onUpdate: function () {
        var I = this, c = I.values, t = I.getBarWidth(), q = I.getBarSpacing(), k = I.getChartRangeMin(),
            l = I.getChartRangeMax(), m = I.getChartRangeClip(), D = Infinity, G = -Infinity, v, r, u, e, g, B, h, s,
            z = I.getZeroAxis(), o, x, A, C, F, E, w, y, H, p, J, n, d, b = [], a = [];
        for (B = 0, h = c.length; B < h; B++) {
            J = c[B];
            v = typeof (J) === "string" && J.indexOf(":") > -1;
            if (v || Ext.isArray(J)) {
                E = true;
                if (v) {
                    J = c[B] = I.normalizeValues(J.split(":"))
                }
                J = I.remove(J, null);
                r = Math.min.apply(Math, J);
                u = Math.max.apply(Math, J);
                if (r < D) {
                    D = r
                }
                if (u > G) {
                    G = u
                }
            }
        }
        I.stacked = E;
        I.regionShapes = {};
        I.totalBarWidth = t + q;
        I.width = (c.length * t) + ((c.length - 1) * q);
        if (m) {
            C = k == null ? -Infinity : k;
            F = l == null ? Infinity : l
        }
        g = [];
        e = E ? [] : g;
        for (B = 0, h = c.length; B < h; B++) {
            if (E) {
                w = c[B];
                c[B] = p = [];
                b[B] = 0;
                e[B] = a[B] = 0;
                for (y = 0, H = w.length; y < H; y++) {
                    J = p[y] = m ? Ext.Number.constrain(w[y], C, F) : w[y];
                    if (J !== null) {
                        if (J > 0) {
                            b[B] += J
                        }
                        if (D < 0 && G > 0) {
                            if (J < 0) {
                                a[B] += Math.abs(J)
                            } else {
                                e[B] += J
                            }
                        } else {
                            e[B] += Math.abs(J - (J < 0 ? G : D))
                        }
                        g.push(J)
                    }
                }
            } else {
                J = m ? Ext.Number.constrain(c[B], C, F) : c[B];
                J = c[B] = I.normalizeValue(J);
                if (J !== null) {
                    g.push(J)
                }
            }
        }
        I.max = A = Math.max.apply(Math, g);
        I.min = x = Math.min.apply(Math, g);
        I.stackMax = G = E ? Math.max.apply(Math, b) : A;
        I.stackMin = D = E ? Math.min.apply(Math, g) : x;
        if (k != null && (m || k < x)) {
            x = k
        }
        if (l != null && (m || l > A)) {
            A = l
        }
        if (x <= 0 && A >= 0 && z) {
            o = 0
        } else {
            if (!z) {
                o = x
            } else {
                if (x > 0) {
                    o = x
                } else {
                    o = A
                }
            }
        }
        I.xAxisOffset = o;
        s = E ? (Math.max.apply(Math, e) + Math.max.apply(Math, a)) : A - x;
        I.canvasHeightEf = (z && x < 0) ? I.getHeight() - 2 : I.getHeight() - 1;
        if (x < o) {
            d = (E && A >= 0) ? G : A;
            n = (d - o) / s * I.getHeight();
            if (n !== Math.ceil(n)) {
                I.canvasHeightEf -= 2;
                n = Math.ceil(n)
            }
        } else {
            n = I.getHeight()
        }
        I.yoffset = n;
        I.range = s
    }, getRegion: function (b, c) {
        var a = Math.floor(b / this.totalBarWidth);
        return (a < 0 || a >= this.values.length) ? undefined : a
    }, getRegionFields: function (e) {
        var b = Ext.Array.from(this.values[e]), a = [], d, c;
        for (c = b.length; c--;) {
            d = b[c];
            a.push({isNull: d === null, value: d, color: this.calcColor(c, d, e), offset: e})
        }
        return a
    }, calcColor: function (j, i, d) {
        var g = this, b = g.colorMapByIndex, h = g.colorMapByValue, a, e, c = g.getZeroColor();
        if (this.stacked) {
            a = g.getStackedBarColor()
        } else {
            a = (i < 0) ? g.getNegBarColor() : g.getBarColor()
        }
        if (i === 0 && c !== undefined) {
            a = c
        }
        if (h && (e = h.get(i))) {
            a = e
        } else {
            if (b && b.length > d) {
                a = b[d]
            }
        }
        return Ext.isArray(a) ? a[j % a.length] : a
    }, renderRegion: function (l, e) {
        var z = this, n = z.values[l], a = z.xAxisOffset, o = z.range, w = z.stacked, c = z.canvas, q = z.getBarWidth(),
            j = l * z.totalBarWidth, b = z.canvasHeightEf, k = z.yoffset, h, r, t, s, g, u, d, A, v, m,
            p = z.getNullColor();
        n = Ext.isArray(n) ? n : [n];
        d = n.length;
        A = n[0];
        s = z.all(n, null);
        m = z.all(n, a, true);
        if (s) {
            if (p) {
                t = e ? p : z.calcHighlightColor(p, z);
                h = (k > 0) ? k - 1 : k;
                c.drawRect(j, h, q - 1, 0, t, t).append()
            }
            return
        }
        g = k;
        for (u = 0; u < d; u++) {
            A = n[u];
            if (w && A === a) {
                if (!m || v) {
                    continue
                }
                v = true
            }
            if (o > 0) {
                r = Math.floor(b * ((Math.abs(A - a) / o))) + 1
            } else {
                r = 1
            }
            if (A < a || (A === a && k === 0)) {
                h = g;
                g += r
            } else {
                h = k - r;
                k -= r
            }
            t = z.calcColor(u, A, l);
            if (e) {
                t = z.calcHighlightColor(t, z)
            }
            c.drawRect(j, h, q - 1, r - 1, t, t).append()
        }
    }
}, 0, ["sparklinebar"], ["widget", "sparklinebar"], {
    widget: true,
    sparklinebar: true
}, ["widget.sparklinebar"], 0, [Ext.sparkline, "Bar"], function (a) {
    a.onClassCreated(a)
}));
(Ext.cmd.derive("Ext.sparkline.Box", Ext.sparkline.Base, {
    config: {
        raw: false,
        boxLineColor: "#000",
        boxFillColor: "#cdf",
        whiskerColor: "#000",
        outlierLineColor: "#333",
        outlierFillColor: "#fff",
        medianColor: "#f00",
        showOutliers: true,
        outlierIQR: 1.5,
        spotRadius: 1.5,
        target: null,
        targetColor: "#4a2",
        chartRangeMin: null,
        chartRangeMax: null,
        tipTpl: new Ext.XTemplate("{field:this.fields}: {value}", {
            fields: function (b) {
                var a = {
                    lq: "Lower Quartile",
                    med: "Median",
                    uq: "Upper Quartile",
                    lo: "Left Outlier",
                    ro: "Right Outlier",
                    lw: "Left Whisker",
                    rw: "Right Whisker"
                };
                return a[b]
            }
        }),
        tooltipFormatFieldlistKey: "field"
    }, quartile: function (a, c) {
        var b;
        if (c === 2) {
            b = Math.floor(a.length / 2);
            return a.length % 2 ? a[b] : (a[b - 1] + a[b]) / 2
        } else {
            if (a.length % 2) {
                b = (a.length * c + c) / 4;
                return b % 1 ? (a[Math.floor(b)] + a[Math.floor(b) - 1]) / 2 : a[b - 1]
            } else {
                b = (a.length * c + 2) / 4;
                return b % 1 ? (a[Math.floor(b)] + a[Math.floor(b) - 1]) / 2 : a[b - 1]
            }
        }
    }, applyValues: function (a) {
        a = Ext.Array.map(Ext.Array.from(a), Number);
        this.disabled = !(a && a.length);
        return a
    }, getRegion: function () {
        return 1
    }, getRegionFields: function () {
        var a = [{field: "lq", value: this.quartiles[0]}, {field: "med", value: this.quartiles[1]}, {
            field: "uq",
            value: this.quartiles[2]
        }];
        if (this.loutlier !== undefined) {
            a.push({field: "lo", value: this.loutlier})
        }
        if (this.routlier !== undefined) {
            a.push({field: "ro", value: this.routlier})
        }
        if (this.lwhisker !== undefined) {
            a.push({field: "lw", value: this.lwhisker})
        }
        if (this.rwhisker !== undefined) {
            a.push({field: "rw", value: this.rwhisker})
        }
        return a
    }, renderHighlight: Ext.emptyFn, renderGraph: function () {
        var E = this, l = E.canvas, h = E.values, o = h.length, D = E.getWidth(), e = E.getHeight(),
            q = E.getChartRangeMin(), t = E.getChartRangeMax(), x = q == null ? Math.min.apply(Math, h) : q,
            C = t == null ? Math.max.apply(Math, h) : t, z = 0, w, B, j, s, r, p, b, m, A, y, g, F = E.getSpotRadius(),
            a = E.getOutlierLineColor(), k = E.getOutlierFillColor(), v = E.getShowOutliers(), u = E.getOutlierIQR(),
            d = E.getLineColor(), c = E.getWhiskerColor(), n = E.getTargetColor();
        if (!Ext.sparkline.Base.prototype.renderGraph.call(this)) {
            return
        }
        if (E.raw) {
            if (v && h.length > 5) {
                B = h[0];
                w = h[1];
                s = h[2];
                r = h[3];
                p = h[4];
                b = h[5];
                m = h[6]
            } else {
                w = h[0];
                s = h[1];
                r = h[2];
                p = h[3];
                b = h[4]
            }
        } else {
            h.sort(function (G, i) {
                return G - i
            });
            s = E.quartile(h, 1);
            r = E.quartile(h, 2);
            p = E.quartile(h, 3);
            j = p - s;
            if (v) {
                w = b = null;
                for (A = 0; A < o; A++) {
                    if (w == null && h[A] > s - (j * u)) {
                        w = h[A]
                    }
                    if (h[A] < p + (j * u)) {
                        b = h[A]
                    }
                }
                B = h[0];
                m = h[o - 1]
            } else {
                w = h[0];
                b = h[o - 1]
            }
        }
        E.quartiles = [s, r, p];
        E.lwhisker = w;
        E.rwhisker = b;
        E.loutlier = B;
        E.routlier = m;
        g = D / (C - x + 1);
        if (v) {
            z = Math.ceil(F);
            D -= 2 * Math.ceil(F);
            g = D / (C - x + 1);
            if (B < w) {
                l.drawCircle((B - x) * g + z, e / 2, F, a, k).append()
            }
            if (m > b) {
                l.drawCircle((m - x) * g + z, e / 2, F, a, k).append()
            }
        }
        l.drawRect(Math.round((s - x) * g + z), Math.round(e * 0.1), Math.round((p - s) * g), Math.round(e * 0.8), E.getBoxLineColor(), E.getBoxFillColor()).append();
        l.drawLine(Math.round((w - x) * g + z), Math.round(e / 2), Math.round((s - x) * g + z), Math.round(e / 2), d).append();
        l.drawLine(Math.round((w - x) * g + z), Math.round(e / 4), Math.round((w - x) * g + z), Math.round(e - e / 4), c).append();
        l.drawLine(Math.round((b - x) * g + z), Math.round(e / 2), Math.round((p - x) * g + z), Math.round(e / 2), d).append();
        l.drawLine(Math.round((b - x) * g + z), Math.round(e / 4), Math.round((b - x) * g + z), Math.round(e - e / 4), c).append();
        l.drawLine(Math.round((r - x) * g + z), Math.round(e * 0.1), Math.round((r - x) * g + z), Math.round(e * 0.9), E.getMedianColor()).append();
        if (E.target) {
            y = Math.ceil(E.spotRadius);
            l.drawLine(Math.round((E.target - x) * g + z), Math.round((e / 2) - y), Math.round((E.target - x) * g + z), Math.round((e / 2) + y), n).append();
            l.drawLine(Math.round((E.target - x) * g + z - y), Math.round(e / 2), Math.round((E.target - x) * g + z + y), Math.round(e / 2), n).append()
        }
        if (E.currentPageXY && E.el.getRegion().contains(E.currentPageXY)) {
            E.currentRegion = null;
            E.updateDisplay()
        }
        l.render()
    }
}, 0, ["sparklinebox"], ["widget", "sparklinebox"], {
    widget: true,
    sparklinebox: true
}, ["widget.sparklinebox"], 0, [Ext.sparkline, "Box"], 0));
(Ext.cmd.derive("Ext.sparkline.Bullet", Ext.sparkline.Base, {
    config: {
        targetColor: "#f33",
        targetWidth: 3,
        performanceColor: "#33f",
        rangeColors: ["#d3dafe", "#a8b6ff", "#7f94ff"],
        base: null,
        tipTpl: new Ext.XTemplate("{fieldkey:this.fields} - {value}", {
            fields: function (a) {
                if (a === "r") {
                    return "Range"
                }
                if (a === "p") {
                    return "Performance"
                }
                if (a === "t") {
                    return "Target"
                }
            }
        })
    }, applyValues: function (a) {
        a = Ext.Array.map(Ext.Array.from(a), this.normalizeValue);
        this.disabled = !(a && a.length);
        return a
    }, onUpdate: function () {
        var d = this, b = d.values, c, a, g, e = d.getBase();
        Ext.sparkline.Base.prototype.onUpdate.apply(this, arguments);
        g = b.slice();
        g[0] = g[0] === null ? g[2] : g[0];
        g[1] = b[1] === null ? g[2] : g[1];
        c = Math.min.apply(Math, b);
        a = Math.max.apply(Math, b);
        if (e == null) {
            c = c < 0 ? c : 0
        } else {
            c = e
        }
        d.min = c;
        d.max = a;
        d.range = a - c;
        d.shapes = {};
        d.valueShapes = {};
        d.regiondata = {};
        if (!b.length) {
            d.disabled = true
        }
    }, getRegion: function (a, c) {
        var b = this.canvas.getShapeAt(a, c);
        return (b !== undefined && this.shapes[b] !== undefined) ? this.shapes[b] : undefined
    }, getRegionFields: function (a) {
        return {fieldkey: a.substr(0, 1), value: this.values[a.substr(1)], region: a}
    }, renderHighlight: function (a) {
        switch (a.substr(0, 1)) {
            case"r":
                this.renderRange(a.substr(1), true).append();
                break;
            case"p":
                this.renderPerformance(true).append();
                break;
            case"t":
                this.renderTarget(true).append();
                break
        }
    }, renderRange: function (e, b) {
        var d = this.values[e], c = Math.round(this.getWidth() * ((d - this.min) / this.range)),
            a = this.getRangeColors()[e - 2];
        if (b) {
            a = this.calcHighlightColor(a)
        }
        return this.canvas.drawRect(0, 0, c - 1, this.getHeight() - 1, a, a)
    }, renderPerformance: function (b) {
        var d = this.values[1], c = Math.round(this.getWidth() * ((d - this.min) / this.range)),
            a = this.getPerformanceColor();
        if (b) {
            a = this.calcHighlightColor(a)
        }
        return this.canvas.drawRect(0, Math.round(this.getHeight() * 0.3), c - 1, Math.round(this.getHeight() * 0.4) - 1, a, a)
    }, renderTarget: function (c) {
        var h = this.values[0], e = this.getTargetWidth(),
            a = Math.round(this.getWidth() * ((h - this.min) / this.range) - (e / 2)),
            g = Math.round(this.getHeight() * 0.1), d = this.getHeight() - (g * 2), b = this.getTargetColor();
        if (c) {
            b = this.calcHighlightColor(b)
        }
        return this.canvas.drawRect(a, g, e - 1, d - 1, b, b)
    }, renderGraph: function () {
        var g = this, h = g.values.length, d = g.canvas, e, c, b = g.shapes || (g.shapes = {}),
            a = g.valueShapes || (g.valueShapes = {});
        if (!Ext.sparkline.Base.prototype.renderGraph.call(this)) {
            return
        }
        for (e = 2; e < h; e++) {
            c = g.renderRange(e).append();
            b[c.id] = "r" + e;
            a["r" + e] = c.id
        }
        if (g.values[1] !== null) {
            c = g.renderPerformance().append();
            b[c.id] = "p1";
            a.p1 = c.id
        }
        if (g.values[0] !== null) {
            c = this.renderTarget().append();
            b[c.id] = "t0";
            a.t0 = c.id
        }
        if (g.currentPageXY && g.el.getRegion().contains(g.currentPageXY)) {
            g.updateDisplay()
        }
        d.render()
    }
}, 0, ["sparklinebullet"], ["widget", "sparklinebullet"], {
    widget: true,
    sparklinebullet: true
}, ["widget.sparklinebullet"], 0, [Ext.sparkline, "Bullet"], 0));
(Ext.cmd.derive("Ext.sparkline.Discrete", Ext.sparkline.BarBase, {
    config: {
        lineHeight: "auto",
        thresholdColor: null,
        thresholdValue: 0,
        chartRangeMax: null,
        chartRangeMin: null,
        chartRangeClip: false,
        tipTpl: new Ext.XTemplate("{prefix}{value}{suffix}")
    }, applyValues: function (a) {
        a = Ext.Array.map(Ext.Array.from(a), Number);
        this.disabled = !(a && a.length);
        return a
    }, onUpdate: function () {
        var c = this, b = c.values, a = c.getChartRangeMin(), d = c.getChartRangeMax(), e = c.getChartRangeClip();
        Ext.sparkline.BarBase.prototype.onUpdate.apply(this, arguments);
        c.regionShapes = {};
        c.min = Math.min.apply(Math, b);
        c.max = Math.max.apply(Math, b);
        c.range = c.max - c.min;
        c.width = c.getWidth();
        c.interval = Math.floor(c.width / b.length);
        c.itemWidth = c.width / b.length;
        if (a != null && (e || a < c.min)) {
            c.min = a
        }
        if (d != null && (e || d > c.max)) {
            c.max = d
        }
        if (c.canvas) {
            if (c.getLineHeight() === "auto") {
                c.setLineHeight(Math.round(c.getHeight() * 0.3))
            }
        }
    }, getRegion: function (a, b) {
        return Math.floor(a / this.itemWidth)
    }, getRegionFields: function (a) {
        return {isNull: this.values[a] === undefined, value: this.values[a], offset: a}
    }, renderRegion: function (k, e) {
        var m = this, r = m.values, h = m.min, n = m.max, j = m.range, c = m.interval, b = m.canvas, i = m.getHeight(),
            q = m.getLineHeight(), l = i - q, a, d, g, p, o = m.getThresholdColor();
        d = Ext.Number.constrain(r[k], h, n);
        p = k * c;
        a = Math.round(l - l * ((d - h) / j));
        g = (o && d < m.getThresholdValue()) ? o : m.getLineColor();
        if (e) {
            g = m.calcHighlightColor(g)
        }
        b.drawLine(p, a, p, a + q, g).append()
    }
}, 0, ["sparklinediscrete"], ["widget", "sparklinediscrete"], {
    widget: true,
    sparklinediscrete: true
}, ["widget.sparklinediscrete"], 0, [Ext.sparkline, "Discrete"], 0));
(Ext.cmd.derive("Ext.sparkline.Line", Ext.sparkline.Base, {
    config: {
        spotColor: "#f80",
        highlightSpotColor: "#5f5",
        highlightLineColor: "#f22",
        spotRadius: 1.5,
        minSpotColor: "#f80",
        maxSpotColor: "#f80",
        lineWidth: 1,
        normalRangeMin: null,
        normalRangeMax: null,
        normalRangeColor: "#ccc",
        drawNormalOnTop: false,
        chartRangeMin: null,
        chartRangeMax: null,
        chartRangeMinX: null,
        chartRangeMaxX: null,
        tipTpl: new Ext.XTemplate("&#9679; {prefix}{y}{suffix}"),
        valueSpots: null
    }, applyValueSpots: function (a) {
        if (a && !a.get) {
            a = new Ext.sparkline.RangeMap(a)
        }
        return a
    }, onUpdate: function () {
        this.vertices = [];
        this.regionMap = [];
        this.xvalues = [];
        this.yvalues = [];
        this.yminmax = []
    }, getRegion: function (a, d) {
        var b, c = this.regionMap;
        for (b = c.length; b--;) {
            if (c[b] !== null && a >= c[b][0] && a <= c[b][1]) {
                return c[b][2]
            }
        }
        return undefined
    }, getRegionFields: function (a) {
        return {
            isNull: this.yvalues[a] === null,
            x: this.xvalues[a],
            y: this.yvalues[a],
            color: this.getLineColor(),
            fillColor: this.getFillColor(),
            offset: a
        }
    }, renderHighlight: function (g) {
        var c = this, a = c.canvas, e = c.vertices[g], b = c.getSpotRadius(), h = c.getHighlightSpotColor(),
            d = c.getHighlightLineColor();
        if (!e) {
            return
        }
        if (b && h) {
            a.drawCircle(e[0], e[1], b, null, h).append()
        }
        if (d) {
            a.drawLine(e[0], c.canvasTop, e[0], c.canvasTop + c.getHeight(), d).append()
        }
    }, scanValues: function () {
        var k = this, l = k.values, c = l.length, a = k.xvalues, h = k.yvalues, m = k.yminmax, e, d, j, g, b;
        for (e = 0; e < c; e++) {
            d = l[e];
            j = typeof (l[e]) === "string";
            g = typeof (l[e]) === "object" && l[e] instanceof Array;
            b = j && l[e].split(":");
            if (j && b.length === 2) {
                a.push(Number(b[0]));
                h.push(Number(b[1]));
                m.push(Number(b[1]))
            } else {
                if (g) {
                    a.push(d[0]);
                    h.push(d[1]);
                    m.push(d[1])
                } else {
                    a.push(e);
                    if (l[e] === null || l[e] === "null") {
                        h.push(null)
                    } else {
                        h.push(Number(d));
                        m.push(Number(d))
                    }
                }
            }
        }
        if (k.xvalues) {
            a = k.xvalues
        }
        k.maxy = k.maxyorg = Math.max.apply(Math, m);
        k.miny = k.minyorg = Math.min.apply(Math, m);
        k.maxx = Math.max.apply(Math, a);
        k.minx = Math.min.apply(Math, a);
        k.xvalues = a;
        k.yvalues = h;
        k.yminmax = m
    }, processRangeOptions: function () {
        var d = this, c = d.getNormalRangeMin(), g = d.getNormalRangeMax(), a = d.getChartRangeMin(),
            b = d.getChartRangeMinX(), e = d.getChartRangeMax(), h = d.getChartRangeMaxX();
        if (c != null) {
            if (c < d.miny) {
                d.miny = c
            }
            if (g > d.maxy) {
                d.maxy = g
            }
        }
        if (a != null && (d.chartRangeClip || a < d.miny)) {
            d.miny = a
        }
        if (e != null && (d.chartRangeClip || e > d.maxy)) {
            this.maxy = e
        }
        if (b != null && (d.chartRangeClipX || b < d.minx)) {
            d.minx = b
        }
        if (h != null && (d.chartRangeClipX || h > d.maxx)) {
            d.maxx = h
        }
    }, drawNormalRange: function (c, h, g, d, i) {
        var a = this.getNormalRangeMin(), e = this.getNormalRangeMax(),
            b = h + Math.round(g - (g * ((e - this.miny) / i))), j = Math.round((g * (e - a)) / i);
        this.canvas.drawRect(c, b, d, j, undefined, this.normalRangeColor).append()
    }, renderGraph: function () {
        var q = this, k = q.canvas, M = q.getWidth(), m = q.getHeight(), d = q.vertices, L = q.getSpotRadius(),
            O = q.regionMap, B, g, C, t, r, s, J, A, F, E, j, w, n, p, h, K, e, D, o, c = q.getValueSpots(), H, u, G, I,
            N, l = q.getSpotColor(), b = q.getMinSpotColor(), z = q.getMaxSpotColor(), v = q.getNormalRangeMin(),
            a = q.getDrawNormalOnTop();
        if (!Ext.sparkline.Base.prototype.renderGraph.call(this)) {
            return
        }
        q.scanValues();
        q.processRangeOptions();
        G = q.xvalues;
        I = q.yvalues;
        if (!q.yminmax.length || q.yvalues.length < 2) {
            return
        }
        t = r = 0;
        B = q.maxx - q.minx === 0 ? 1 : q.maxx - q.minx;
        g = q.maxy - q.miny === 0 ? 1 : q.maxy - q.miny;
        C = q.yvalues.length - 1;
        if (L && (M < (L * 4) || m < (L * 4))) {
            L = 0
        }
        if (L) {
            H = q.getHighlightSpotColor() && !q.disableInteraction;
            if (H || b || (l && I[C] === q.miny)) {
                m -= Math.ceil(L)
            }
            if (H || z || (l && I[C] === q.maxy)) {
                m -= Math.ceil(L);
                t += Math.ceil(L)
            }
            if (H || ((b || z) && (I[0] === q.miny || I[0] === q.maxy))) {
                r += Math.ceil(L);
                M -= Math.ceil(L)
            }
            if (H || l || (b || z && (I[C] === q.miny || I[C] === q.maxy))) {
                M -= Math.ceil(L)
            }
        }
        m--;
        if (v != null && !a) {
            q.drawNormalRange(r, t, m, M, g)
        }
        J = [];
        A = [J];
        p = h = null;
        K = I.length;
        for (N = 0; N < K; N++) {
            F = G[N];
            j = G[N + 1];
            E = I[N];
            w = r + Math.round((F - q.minx) * (M / B));
            n = N < K - 1 ? r + Math.round((j - q.minx) * (M / B)) : M;
            h = w + ((n - w) / 2);
            O[N] = [p || 0, h, N];
            p = h;
            if (E === null) {
                if (N) {
                    if (I[N - 1] !== null) {
                        J = [];
                        A.push(J)
                    }
                    d.push(null)
                }
            } else {
                if (E < q.miny) {
                    E = q.miny
                }
                if (E > q.maxy) {
                    E = q.maxy
                }
                if (!J.length) {
                    J.push([w, t + m])
                }
                s = [w, t + Math.round(m - (m * ((E - this.miny) / g)))];
                J.push(s);
                d.push(s)
            }
        }
        e = [];
        D = [];
        o = A.length;
        for (N = 0; N < o; N++) {
            J = A[N];
            if (J.length) {
                if (q.fillColor) {
                    J.push([J[J.length - 1][0], (t + m)]);
                    D.push(J.slice(0));
                    J.pop()
                }
                if (J.length > 2) {
                    J[0] = [J[0][0], J[1][1]]
                }
                e.push(J)
            }
        }
        o = D.length;
        for (N = 0; N < o; N++) {
            k.drawShape(D[N], q.fillColor, q.fillColor).append()
        }
        if (v != null && a) {
            q.drawNormalRange(r, t, m, M, g)
        }
        o = e.length;
        for (N = 0; N < o; N++) {
            k.drawShape(e[N], q.getLineColor(), null, q.getLineWidth()).append()
        }
        if (L && c) {
            if (c.get == null) {
                c = new Ext.sparkline.RangeMap(c)
            }
            for (N = 0; N < K; N++) {
                u = c.get(I[N]);
                if (u) {
                    k.drawCircle(r + Math.round((G[N] - q.minx) * (M / B)), t + Math.round(m - (m * ((I[N] - q.miny) / g))), L, null, u).append()
                }
            }
        }
        if (L && l && I[C] != null) {
            k.drawCircle(r + Math.round((G[G.length - 1] - q.minx) * (M / B)), t + Math.round(m - (m * ((I[C] - q.miny) / g))), L, null, l).append()
        }
        if (q.maxy !== q.minyorg) {
            if (L && b) {
                F = G[Ext.Array.indexOf(I, q.minyorg)];
                k.drawCircle(r + Math.round((F - q.minx) * (M / B)), t + Math.round(m - (m * ((q.minyorg - q.miny) / g))), L, null, b).append()
            }
            if (L && z) {
                F = G[Ext.Array.indexOf(I, q.maxyorg)];
                k.drawCircle(r + Math.round((F - q.minx) * (M / B)), t + Math.round(m - (m * ((q.maxyorg - q.miny) / g))), L, null, z).append()
            }
        }
        q.canvasTop = t;
        if (q.currentPageXY && q.el.getRegion().contains(q.currentPageXY)) {
            q.updateDisplay()
        }
        k.render()
    }
}, 0, ["sparklineline"], ["widget", "sparklineline"], {
    widget: true,
    sparklineline: true
}, ["widget.sparklineline"], 0, [Ext.sparkline, "Line"], 0));
(Ext.cmd.derive("Ext.sparkline.Pie", Ext.sparkline.Base, {
    config: {
        offset: 0,
        sliceColors: ["#3366cc", "#dc3912", "#ff9900", "#109618", "#66aa00", "#dd4477", "#0099c6", "#990099"],
        borderWidth: 0,
        borderColor: "#000",
        tipTpl: new Ext.XTemplate('&#9679; {value} ({percent:number("0.0")}%)')
    }, applyValues: function (a) {
        a = Ext.Array.map(Ext.Array.from(a), Number);
        this.disabled = !(a && a.length);
        return a
    }, onUpdate: function () {
        var d = this, a = d.values, c = 0, b;
        Ext.sparkline.Base.prototype.onUpdate.apply(this, arguments);
        d.shapes = {};
        d.valueShapes = {};
        if (a.length > 0) {
            for (b = a.length; b--;) {
                c += a[b]
            }
        }
        d.total = c;
        d.radius = Math.floor(Math.min(d.getWidth(), d.getHeight()) / 2)
    }, getRegion: function (a, d) {
        var b = window.devicePixelRatio || 1, c = this.canvas.getShapeAt(a * b, d * b);
        return (c != null && this.shapes[c] != null) ? this.shapes[c] : null
    }, getRegionFields: function (b) {
        var a = this.getSliceColors();
        return {
            isNull: this.values[b] == null,
            value: this.values[b],
            percent: this.values[b] / this.total * 100,
            color: a[b % a.length],
            offset: b
        }
    }, renderHighlight: function (a) {
        this.renderSlice(a, true).append()
    }, renderSlice: function (m, e) {
        var o = this, d = o.canvas, n = o.radius, a = o.getBorderWidth(), j = o.getOffset(), b = 2 * Math.PI,
            s = o.values, p = o.total, l = j ? (2 * Math.PI) * (j / 360) : 0, c, h, k, q, g, r = this.getSliceColors();
        q = s.length;
        for (k = 0; k < q; k++) {
            c = l;
            h = l;
            if (p > 0) {
                h = l + (b * (s[k] / p))
            }
            if (m === k) {
                g = r[k % r.length];
                if (e) {
                    g = o.calcHighlightColor(g)
                }
                return d.drawPieSlice(n, n, n - a, c, h, null, g)
            }
            l = h
        }
    }, renderGraph: function () {
        var h = this, c = h.canvas, k = h.values, e = h.radius, a = h.getBorderWidth(), g, d,
            b = h.shapes || (h.shapes = {}), j = h.valueShapes || (h.valueShapes = {});
        if (!Ext.sparkline.Base.prototype.renderGraph.call(this)) {
            return
        }
        if (a) {
            c.drawCircle(e, e, Math.floor(e - (a / 2)), h.getBorderColor(), null, a).append()
        }
        for (d = k.length; d--;) {
            if (k[d]) {
                g = h.renderSlice(d).append();
                j[d] = g.id;
                b[g.id] = d
            }
        }
        if (h.currentPageXY && h.el.getRegion().contains(h.currentPageXY)) {
            h.currentRegion = null;
            h.updateDisplay()
        }
        c.render()
    }
}, 0, ["sparklinepie"], ["widget", "sparklinepie"], {
    widget: true,
    sparklinepie: true
}, ["widget.sparklinepie"], 0, [Ext.sparkline, "Pie"], 0));
(Ext.cmd.derive("Ext.sparkline.TriState", Ext.sparkline.BarBase, {
    config: {
        barWidth: 4,
        barSpacing: 1,
        posBarColor: "#6f6",
        negBarColor: "#f44",
        zeroBarColor: "#999",
        colorMap: {},
        tipTpl: new Ext.XTemplate("&#9679; {value:this.states}", {
            states: function (a) {
                var b = Number(a);
                if (b === -1) {
                    return "Loss"
                }
                if (b === 0) {
                    return "Draw"
                }
                if (b === 1) {
                    return "Win"
                }
                return a
            }
        })
    }, applyColorMap: function (a) {
        var b = this;
        if (Ext.isArray(a)) {
            b.colorMapByIndex = a;
            b.colorMapByValue = null
        } else {
            b.colorMapByIndex = null;
            b.colorMapByValue = a;
            if (b.colorMapByValue && b.colorMapByValue.get == null) {
                b.colorMapByValue = new Ext.sparkline.RangeMap(a)
            }
        }
        return a
    }, applyValues: function (a) {
        a = Ext.Array.map(Ext.Array.from(a), Number);
        this.disabled = !(a && a.length);
        return a
    }, onUpdate: function () {
        this.totalBarWidth = this.getBarWidth() + this.getBarSpacing()
    }, getBarWidth: function () {
        var a = this.values;
        return this._barWidth || (this.getWidth() - (a.length - 1) * this.getBarSpacing()) / a.length
    }, getRegion: function (a, b) {
        return Math.floor(a / this.totalBarWidth)
    }, getRegionFields: function (a) {
        return {
            isNull: this.values[a] == null,
            value: this.values[a],
            color: this.calcColor(this.values[a], a),
            offset: a
        }
    }, calcColor: function (g, h) {
        var e = this, b = e.values, i = e.colorMapByIndex, d = e.colorMapByValue, a, c;
        if (d && (c = d.get(g))) {
            a = c
        } else {
            if (i && i.length > h) {
                a = i[h]
            } else {
                if (b[h] < 0) {
                    a = e.getNegBarColor()
                } else {
                    if (b[h] > 0) {
                        a = e.getPosBarColor()
                    } else {
                        a = e.getZeroBarColor()
                    }
                }
            }
        }
        return a
    }, renderRegion: function (e, b) {
        var h = this, k = h.values, a = h.canvas, d, l, g, j, i, c;
        d = a.pixelHeight;
        g = Math.round(d / 2);
        j = e * h.totalBarWidth;
        if (k[e] < 0) {
            i = g;
            l = g - 1
        } else {
            if (k[e] > 0) {
                i = 0;
                l = g - 1
            } else {
                i = g - 1;
                l = 2
            }
        }
        c = h.calcColor(k[e], e);
        if (c == null) {
            return
        }
        if (b) {
            c = h.calcHighlightColor(c)
        }
        a.drawRect(j, i, h.getBarWidth() - 1, l - 1, c, c).append()
    }
}, 0, ["sparklinetristate"], ["widget", "sparklinetristate"], {
    widget: true,
    sparklinetristate: true
}, ["widget.sparklinetristate"], 0, [Ext.sparkline, "TriState"], 0));
(Ext.cmd.derive("Ext.state.CookieProvider", Ext.state.Provider, {
    constructor: function (a) {
        var b = this;
        b.path = "/";
        b.expires = new Date(Ext.Date.now() + (1000 * 60 * 60 * 24 * 7));
        b.domain = null;
        b.secure = false;
        Ext.state.Provider.prototype.constructor.apply(this, arguments);
        b.state = b.readCookies()
    }, set: function (a, c) {
        var b = this;
        if (typeof c === "undefined" || c === null) {
            b.clear(a);
            return
        }
        b.setCookie(a, c);
        Ext.state.Provider.prototype.set.apply(this, arguments)
    }, clear: function (a) {
        this.clearCookie(a);
        Ext.state.Provider.prototype.clear.apply(this, arguments)
    }, readCookies: function () {
        var e = {}, j = document.cookie + ";", d = /\\s?(.*?)=(.*?);/g, i = this.prefix, a = i.length, h, b, g;
        while ((h = d.exec(j)) != null) {
            b = h[1];
            g = h[2];
            if (b && b.substring(0, a) === i) {
                e[b.substr(a)] = this.decodeValue(g)
            }
        }
        return e
    }, setCookie: function (a, c) {
        var b = this;
        document.cookie = b.prefix + a + "=" + b.encodeValue(c) + ((b.expires == null) ? "" : ("; expires=" + b.expires.toUTCString())) + ((b.path == null) ? "" : ("; path=" + b.path)) + ((b.domain == null) ? "" : ("; domain=" + b.domain)) + (b.secure ? "; secure" : "")
    }, clearCookie: function (a) {
        var b = this;
        document.cookie = b.prefix + a + "=null; expires=Thu, 01-Jan-1970 00:00:01 GMT" + ((b.path == null) ? "" : ("; path=" + b.path)) + ((b.domain == null) ? "" : ("; domain=" + b.domain)) + (b.secure ? "; secure" : "")
    }
}, 1, 0, 0, 0, 0, 0, [Ext.state, "CookieProvider"], 0));
(Ext.cmd.derive("Ext.state.LocalStorageProvider", Ext.state.Provider, {
    constructor: function () {
        var a = this;
        Ext.state.Provider.prototype.constructor.apply(this, arguments);
        a.store = a.getStorageObject();
        if (a.store) {
            a.state = a.readLocalStorage()
        } else {
            a.state = {}
        }
    }, readLocalStorage: function () {
        var a = this.store, e = {}, d = a.getKeys(), c = d.length, b;
        while (c--) {
            b = d[c];
            e[b] = this.decodeValue(a.getItem(b))
        }
        return e
    }, set: function (a, c) {
        var b = this;
        b.clear(a);
        if (c != null) {
            b.store.setItem(a, b.encodeValue(c));
            Ext.state.Provider.prototype.set.apply(this, arguments)
        }
    }, clear: function (a) {
        this.store.removeItem(a);
        Ext.state.Provider.prototype.clear.apply(this, arguments)
    }, getStorageObject: function () {
        var a = this.prefix, c = a, b = c.length - 1;
        if (c.charAt(b) === "-") {
            c = c.substring(0, b)
        }
        return new Ext.util.LocalStorage({id: c, prefix: a})
    }
}, 1, 0, 0, 0, ["state.localstorage"], 0, [Ext.state, "LocalStorageProvider"], 0));
(Ext.cmd.derive("Ext.tab.Tab", Ext.button.Button, {
    isTab: true,
    baseCls: "x-tab",
    closeElOverCls: "x-tab-close-btn-over",
    closeElPressedCls: "x-tab-close-btn-pressed",
    config: {rotation: "default", tabPosition: "top"},
    closable: true,
    closeText: "Close Tab",
    active: false,
    childEls: ["closeEl"],
    scale: false,
    ariaRole: "tab",
    tabIndex: -1,
    keyHandlers: {DELETE: "onDeleteKey"},
    _btnWrapCls: "x-tab-wrap",
    _btnCls: "x-tab-button",
    _baseIconCls: "x-tab-icon-el",
    _glyphCls: "x-tab-glyph",
    _innerCls: "x-tab-inner",
    _textCls: "x-tab-text",
    _noTextCls: "x-tab-no-text",
    _hasIconCls: "x-tab-icon",
    _activeCls: "x-tab-active",
    _closableCls: "x-tab-closable",
    overCls: "x-tab-over",
    _pressedCls: "x-tab-pressed",
    _disabledCls: "x-tab-disabled",
    _rotateClasses: {1: "x-tab-rotate-right", 2: "x-tab-rotate-left"},
    _positions: {
        top: {"default": "top", 0: "top", 1: "left", 2: "right"},
        right: {"default": "top", 0: "right", 1: "top", 2: "bottom"},
        bottom: {"default": "bottom", 0: "bottom", 1: "right", 2: "left"},
        left: {"default": "top", 0: "left", 1: "bottom", 2: "top"}
    },
    _defaultRotations: {top: 0, right: 1, bottom: 0, left: 2},
    initComponent: function () {
        var a = this;
        if (a.card) {
            a.setCard(a.card)
        }
        Ext.button.Button.prototype.initComponent.apply(this, arguments)
    },
    getActualRotation: function () {
        var a = this.getRotation();
        return (a !== "default") ? a : this._defaultRotations[this.getTabPosition()]
    },
    updateRotation: function () {
        this.syncRotationAndPosition()
    },
    updateTabPosition: function () {
        this.syncRotationAndPosition()
    },
    syncRotationAndPosition: function () {
        var h = this, c = h._rotateClasses, b = h.getTabPosition(), g = h.getActualRotation(), e = h._rotateCls,
            i = h._rotateCls = c[g], d = h._positionCls, a = h._positionCls = h._positions[b][g];
        if (e !== i) {
            if (e) {
                h.removeCls(e)
            }
            if (i) {
                h.addCls(i)
            }
        }
        if (d !== a) {
            if (d) {
                h.removeClsWithUI(d)
            }
            if (a) {
                h.addClsWithUI(a)
            }
            if (h.rendered) {
                h.updateFrame()
            }
        }
        if (h.rendered) {
            h.setElOrientation()
        }
    },
    onAdded: function (b, c, a) {
        Ext.button.Button.prototype.onAdded.call(this, b, c, a);
        this.syncRotationAndPosition()
    },
    getTemplateArgs: function () {
        var b = this, a = Ext.button.Button.prototype.getTemplateArgs.call(this);
        a.closable = b.closable;
        a.closeText = b.closeText;
        return a
    },
    beforeRender: function () {
        var b = this, a = b.up("tabbar"), c = b.up("tabpanel");
        Ext.button.Button.prototype.beforeRender.call(this);
        b.ariaRenderAttributes = b.ariaRenderAttributes || {};
        if (b.active) {
            b.ariaRenderAttributes["aria-selected"] = true;
            b.addCls(b._activeCls)
        } else {
            b.ariaRenderAttributes["aria-selected"] = false
        }
        b.syncClosableCls();
        if (!b.minWidth) {
            b.minWidth = (a) ? a.minTabWidth : b.minWidth;
            if (!b.minWidth && c) {
                b.minWidth = c.minTabWidth
            }
            if (b.minWidth && b.iconCls) {
                b.minWidth += 25
            }
        }
        if (!b.maxWidth) {
            b.maxWidth = (a) ? a.maxTabWidth : b.maxWidth;
            if (!b.maxWidth && c) {
                b.maxWidth = c.maxTabWidth
            }
        }
    },
    onRender: function () {
        var a = this;
        a.setElOrientation();
        Ext.button.Button.prototype.onRender.apply(this, arguments);
        if (a.closable) {
            a.closeEl.addClsOnOver(a.closeElOverCls);
            a.closeEl.addClsOnClick(a.closeElPressedCls)
        }
    },
    setElOrientation: function () {
        var c = this, a = c.getActualRotation(), b = c.el;
        if (a) {
            b.setVertical(a === 1 ? 90 : 270)
        } else {
            b.setHorizontal()
        }
    },
    enable: function (a) {
        var b = this;
        Ext.button.Button.prototype.enable.apply(this, arguments);
        b.removeCls(b._disabledCls);
        return b
    },
    disable: function (a) {
        var b = this;
        Ext.button.Button.prototype.disable.apply(this, arguments);
        b.addCls(b._disabledCls);
        return b
    },
    setClosable: function (a) {
        var b = this;
        a = (!arguments.length || !!a);
        if (b.closable !== a) {
            b.closable = a;
            if (b.card) {
                b.card.closable = a
            }
            b.syncClosableCls();
            if (b.rendered) {
                b.syncClosableElements();
                b.updateLayout()
            }
        }
    },
    syncClosableElements: function () {
        var a = this, b = a.closeEl;
        if (a.closable) {
            if (!b) {
                b = a.closeEl = a.btnWrap.insertSibling({
                    tag: "span",
                    id: a.id + "-closeEl",
                    cls: a.baseCls + "-close-btn",
                    html: a.closeText
                }, "after")
            }
            b.addClsOnOver(a.closeElOverCls);
            b.addClsOnClick(a.closeElPressedCls)
        } else {
            if (b) {
                b.destroy();
                delete a.closeEl
            }
        }
    },
    syncClosableCls: function () {
        var b = this, a = b._closableCls;
        if (b.closable) {
            b.addCls(a)
        } else {
            b.removeCls(a)
        }
    },
    setCard: function (a) {
        var b = this;
        b.card = a;
        if (a.iconAlign) {
            b.setIconAlign(a.iconAlign)
        }
        if (a.textAlign) {
            b.setTextAlign(a.textAlign)
        }
        b.setText(b.title || a.title);
        b.setIconCls(b.iconCls || a.iconCls);
        b.setIcon(b.icon || a.icon);
        b.setGlyph(b.glyph || a.glyph)
    },
    onCloseClick: function () {
        var a = this;
        if (a.fireEvent("beforeclose", a) !== false) {
            if (a.tabBar) {
                if (a.tabBar.closeTab(a) === false) {
                    return
                }
            } else {
                a.fireClose()
            }
        }
    },
    fireClose: function () {
        this.fireEvent("close", this)
    },
    onEnterKey: function (b) {
        var a = this;
        if (a.tabBar) {
            a.tabBar.onClick(b, a.el);
            b.stopEvent();
            return false
        }
    },
    onDeleteKey: function (a) {
        if (this.closable) {
            this.onCloseClick();
            a.stopEvent();
            return false
        }
    },
    beforeClick: function (a) {
        if (!a) {
            this.focus()
        }
    },
    activate: function (d) {
        var c = this, b = c.card, a = c.ariaEl.dom;
        c.active = true;
        c.addCls(c._activeCls);
        if (a) {
            a.setAttribute("aria-selected", true)
        } else {
            c.ariaRenderAttributes = c.ariaRenderAttributes || {};
            c.ariaRenderAttributes["aria-selected"] = true
        }
        if (b) {
            if (b.ariaEl.dom) {
                b.ariaEl.dom.setAttribute("aria-expanded", true)
            } else {
                b.ariaRenderAttributes = b.ariaRenderAttributes || {};
                b.ariaRenderAttributes["aria-expanded"] = true
            }
        }
        if (d !== true) {
            c.fireEvent("activate", c)
        }
    },
    deactivate: function (d) {
        var c = this, b = c.card, a = c.ariaEl.dom;
        c.active = false;
        c.removeCls(c._activeCls);
        if (a) {
            a.setAttribute("aria-selected", false)
        } else {
            c.ariaRenderAttributes = c.ariaRenderAttributes || {};
            c.ariaRenderAttributes["aria-selected"] = false
        }
        if (b) {
            if (b.ariaEl.dom) {
                b.ariaEl.dom.setAttribute("aria-expanded", false)
            } else {
                b.ariaRenderAttributes = b.ariaRenderAttributes || {};
                b.ariaRenderAttributes["aria-expanded"] = false
            }
        }
        if (d !== true) {
            c.fireEvent("deactivate", c)
        }
    },
    privates: {
        getFramingInfoCls: function () {
            return this.baseCls + "-" + this.ui + "-" + this._positionCls
        }, wrapPrimaryEl: function (a) {
            Ext.Button.superclass.wrapPrimaryEl.call(this, a)
        }
    }
}, 0, ["tab"], ["component", "box", "button", "tab"], {
    component: true,
    box: true,
    button: true,
    tab: true
}, ["widget.tab"], 0, [Ext.tab, "Tab"], 0));
(Ext.cmd.derive("Ext.tab.Bar", Ext.panel.Bar, {
    baseCls: "x-tab-bar",
    componentLayout: "body",
    isTabBar: true,
    config: {tabRotation: "default", tabStretchMax: true, activateOnFocus: true},
    defaultType: "tab",
    plain: false,
    ensureActiveVisibleOnChange: true,
    ariaRole: "tablist",
    childEls: ["body", "strip"],
    _stripCls: "x-tab-bar-strip",
    _baseBodyCls: "x-tab-bar-body",
    renderTpl: '<div id="{id}-body" data-ref="body" role="presentation" class="{baseBodyCls} {baseBodyCls}-{ui} {bodyCls} {bodyTargetCls}{childElCls}"<tpl if="bodyStyle"> style="{bodyStyle}"</tpl>>{%this.renderContainer(out,values)%}</div><div id="{id}-strip" data-ref="strip" role="presentation" class="{stripCls} {stripCls}-{ui}{childElCls}"></div>',
    _reverseDockNames: {left: "right", right: "left"},
    _layoutAlign: {top: "end", right: "begin", bottom: "begin", left: "end"},
    initComponent: function () {
        var d = this, a = d.initialConfig.layout, c = a && a.align, b = a && a.overflowHandler;
        if (d.plain) {
            d.addCls(d.baseCls + "-plain")
        }
        Ext.panel.Bar.prototype.initComponent.call(this);
        d.setLayout({
            align: c || (d.getTabStretchMax() ? "stretchmax" : d._layoutAlign[d.dock]),
            overflowHandler: b || "scroller"
        });
        d.on({click: d.onClick, element: "el", scope: d})
    },
    ensureTabVisible: function (b) {
        var c = this, d = c.tabPanel, a = c.layout.overflowHandler;
        if (c.rendered && a && c.tooNarrow && a.scrollToItem) {
            if (b || b === 0) {
                if (!b.isTab) {
                    if (Ext.isNumber(b)) {
                        b = this.items.getAt(b)
                    } else {
                        if (b.isComponent && d && d.items.contains(b)) {
                            b = b.tab
                        }
                    }
                }
            }
            if (!b) {
                b = c.activeTab
            }
            if (b) {
                a.scrollToItem(b)
            }
        }
    },
    initRenderData: function () {
        var a = this;
        return Ext.apply(Ext.panel.Bar.prototype.initRenderData.call(this), {
            bodyCls: a.bodyCls,
            baseBodyCls: a._baseBodyCls,
            bodyTargetCls: a.bodyTargetCls,
            stripCls: a._stripCls,
            dock: a.dock
        })
    },
    setDock: function (h) {
        var g = this, a = g.items, c = g.ownerCt, e, b, d;
        a = a && a.items;
        if (a) {
            for (b = 0, d = a.length; b < d; b++) {
                e = a[b];
                if (e.isTab) {
                    e.setTabPosition(h)
                }
            }
        }
        if (g.rendered) {
            g.resetItemMargins();
            if (c && c.isHeader) {
                c.resetItemMargins()
            }
            g.needsScroll = true
        }
        Ext.panel.Bar.prototype.setDock.call(this, h)
    },
    updateTabRotation: function (g) {
        var e = this, a = e.items, b, d, c;
        a = a && a.items;
        if (a) {
            for (b = 0, d = a.length; b < d; b++) {
                c = a[b];
                if (c.isTab) {
                    c.setRotation(g)
                }
            }
        }
        if (e.rendered) {
            e.resetItemMargins();
            e.needsScroll = true;
            e.updateLayout()
        }
    },
    onRender: function () {
        var a = this;
        Ext.panel.Bar.prototype.onRender.call(this);
        if (Ext.isIE8 && a.vertical) {
            a.el.on({mousemove: a.onMouseMove, scope: a})
        }
    },
    afterLayout: function () {
        this.adjustTabPositions();
        Ext.panel.Bar.prototype.afterLayout.apply(this, arguments)
    },
    onAdd: function (b, c) {
        var a = this.onTabContentChange;
        if (this.ensureActiveVisibleOnChange) {
            b.barListeners = b.on({scope: this, destroyable: true, glyphchange: a, iconchange: a, textchange: a})
        }
        Ext.panel.Bar.prototype.onAdd.call(this, b, c)
    },
    onAdded: function (b, c, a) {
        if (b.isHeader) {
            this.addCls(b.baseCls + "-" + b.ui + "-tab-bar")
        }
        Ext.panel.Bar.prototype.onAdded.call(this, b, c, a)
    },
    onRemove: function (a, c) {
        var b = this;
        if (b.ensureActiveVisibleOnChange) {
            if (!c) {
                a.barListeners.destroy()
            }
            a.barListeners = null
        }
        if (a === b.previousTab) {
            b.previousTab = null
        }
        Ext.panel.Bar.prototype.onRemove.call(this, a, c)
    },
    onRemoved: function (b) {
        var a = this.ownerCt;
        if (a.isHeader) {
            this.removeCls(a.baseCls + "-" + a.ui + "-tab-bar")
        }
        Ext.panel.Bar.prototype.onRemoved.call(this, b)
    },
    onTabContentChange: function (a) {
        if (a === this.activeTab) {
            this.ensureTabVisible(a)
        }
    },
    afterComponentLayout: function (c) {
        var d = this, b = d.needsScroll, a = d.layout.overflowHandler;
        Ext.panel.Bar.prototype.afterComponentLayout.apply(this, arguments);
        if (a && b && d.tooNarrow && a.scrollToItem) {
            a.scrollToItem(d.activeTab)
        }
        delete d.needsScroll
    },
    onMouseMove: function (g) {
        var d = this, b = d._overTab, a, c;
        if (g.getTarget(".x-box-scroller")) {
            return
        }
        a = d.getTabInfoFromPoint(g.getXY());
        c = a.tab;
        if (c !== b) {
            if (b && b.rendered) {
                b.onMouseLeave(g);
                d._overTab = null
            }
            if (c) {
                c.onMouseEnter(g);
                d._overTab = c;
                if (!c.disabled) {
                    d.el.setStyle("cursor", "pointer")
                }
            } else {
                d.el.setStyle("cursor", "default")
            }
        }
    },
    onMouseLeave: function (b) {
        var a = this._overTab;
        if (a && a.rendered) {
            a.onMouseLeave(b)
        }
    },
    getTabInfoFromPoint: function (g) {
        var A = this, w = A.items.items, e = w.length, o = A.layout.innerCt, u = o.getXY(),
            t = new Ext.util.Point(g[0], g[1]), v = 0, x, b, a, p, y, j, h, d, r, l, k, n, m, s, q, z, c;
        for (; v < e; v++) {
            c = w[v];
            x = c.lastBox;
            if (!x || !c.isTab) {
                continue
            }
            l = u[0] + x.x;
            k = u[1] - o.dom.scrollTop + x.y;
            n = x.width;
            m = x.height;
            b = new Ext.util.Region(k, l + n, k + m, l);
            if (b.contains(t)) {
                a = c.closeEl;
                if (a) {
                    if (A._isTabReversed === undefined) {
                        A._isTabReversed = q = (c.btnWrap.dom.currentStyle.filter.indexOf("rotation=2") !== -1)
                    }
                    z = q ? this._reverseDockNames[A.dock] : A.dock;
                    d = a.getWidth();
                    r = a.getHeight();
                    y = A.getCloseXY(a, l, k, n, m, d, r, z);
                    j = y[0];
                    h = y[1];
                    s = new Ext.util.Region(h, j + d, h + r, j);
                    p = s.contains(t)
                }
                break
            }
        }
        return {tab: c, close: p}
    },
    getCloseXY: function (c, k, i, g, l, j, d, h) {
        var e = c.getXY(), b, a;
        if (h === "right") {
            b = k + g - ((e[1] - i) + d);
            a = i + (e[0] - k)
        } else {
            b = k + (e[1] - i);
            a = i + k + l - e[0] - j
        }
        return [b, a]
    },
    closeTab: function (c) {
        var d = this, b = c.card, e = d.tabPanel, a;
        if (b && b.fireEvent("beforeclose", b) === false) {
            return false
        }
        a = d.findNextActivatable(c);
        Ext.suspendLayouts();
        if (e && b) {
            delete c.ownerCt;
            b.fireEvent("close", b);
            e.remove(b);
            if (!e.getComponent(b)) {
                c.fireClose();
                d.remove(c)
            } else {
                c.ownerCt = d;
                Ext.resumeLayouts(true);
                return false
            }
        }
        if (a) {
            if (e) {
                e.setActiveTab(a.card)
            } else {
                d.setActiveTab(a)
            }
            a.focus()
        }
        Ext.resumeLayouts(true)
    },
    findNextActivatable: function (b) {
        var c = this, d = c.previousTab, a;
        if (b.active && c.items.getCount() > 1) {
            if (d && d !== b && !d.disabled) {
                a = d
            } else {
                a = b.next("tab[disabled=false]") || b.prev("tab[disabled=false]")
            }
        }
        return a || c.activeTab
    },
    setActiveTab: function (b, a) {
        var c = this;
        if (!b.disabled && b !== c.activeTab) {
            if (c.activeTab) {
                if (c.activeTab.destroyed) {
                    c.previousTab = null
                } else {
                    c.previousTab = c.activeTab;
                    c.activeTab.deactivate();
                    c.deactivateFocusable(c.activeTab)
                }
            }
            b.activate();
            c.activateFocusable(b);
            c.activeTab = b;
            c.needsScroll = true;
            if (!a) {
                c.fireEvent("change", c, b, b.card);
                c.updateLayout()
            }
        }
    },
    privates: {
        adjustTabPositions: function () {
            var h = this, a = h.items.items, d = a.length, g, b, e, c, j;
            if (!Ext.isIE8) {
                j = h._getTabAdjustProp();
                while (d--) {
                    g = a[d];
                    e = g.el;
                    b = g.lastBox;
                    c = g.isTab ? g.getActualRotation() : 0;
                    if (c === 1 && g.isVisible()) {
                        e.setStyle(j, (b.x + b.width) + "px")
                    } else {
                        if (c === 2 && g.isVisible()) {
                            e.setStyle(j, (b.x - b.height) + "px")
                        }
                    }
                }
            }
        }, applyTargetCls: function (a) {
            this.bodyTargetCls = a
        }, _getTabAdjustProp: function () {
            return "left"
        }, getTargetEl: function () {
            return this.body || this.frameBody || this.el
        }, onClick: function (h, g) {
            var d = this, i, c, b, a;
            if (h.getTarget(".x-box-scroller")) {
                return
            }
            if (Ext.isIE8 && d.vertical) {
                a = d.getTabInfoFromPoint(h.getXY());
                c = a.tab;
                b = a.close
            } else {
                i = h.getTarget("." + Ext.tab.Tab.prototype.baseCls);
                c = i && Ext.getCmp(i.id);
                b = c && c.closeEl && (g === c.closeEl.dom)
            }
            if (b) {
                h.preventDefault()
            }
            if (c && c.isDisabled && !c.isDisabled()) {
                c.beforeClick(b);
                if (c.closable && b) {
                    c.onCloseClick()
                } else {
                    d.doActivateTab(c)
                }
            }
        }, doActivateTab: function (a) {
            var b = this.tabPanel;
            if (b) {
                if (!a.disabled) {
                    b.setActiveTab(a.card)
                }
            } else {
                this.setActiveTab(a)
            }
        }, onFocusableContainerFocus: function (c) {
            var b = this, a = b.mixins.focusablecontainer, d;
            d = a.onFocusableContainerFocus.call(b, c);
            if (d && d.isTab) {
                b.doActivateTab(d)
            }
        }, onFocusableContainerFocusEnter: function (c) {
            var b = this, a = b.mixins.focusablecontainer, d;
            d = a.onFocusableContainerFocusEnter.call(b, c);
            if (d && d.isTab) {
                b.doActivateTab(d)
            }
        }, focusChild: function (e, b) {
            var c = this, a = c.mixins.focusablecontainer, d;
            d = a.focusChild.call(c, e, b);
            if (c.activateOnFocus && d && d.isTab) {
                c.doActivateTab(d)
            }
        }
    }
}, 0, ["tabbar"], ["component", "box", "container", "tabbar"], {
    component: true,
    box: true,
    container: true,
    tabbar: true
}, ["widget.tabbar"], [[Ext.util.FocusableContainer.prototype.mixinId || Ext.util.FocusableContainer.$className, Ext.util.FocusableContainer]], [Ext.tab, "Bar"], 0));
(Ext.cmd.derive("Ext.tab.Panel", Ext.panel.Panel, {
    alternateClassName: ["Ext.TabPanel"],
    config: {tabBar: undefined, tabPosition: "top", tabRotation: "default", tabStretchMax: true},
    removePanelHeader: true,
    plain: false,
    itemCls: "x-tabpanel-child",
    minTabWidth: undefined,
    maxTabWidth: undefined,
    deferredRender: true,
    _defaultTabRotation: {top: 0, right: 1, bottom: 0, left: 2},
    initComponent: function () {
        var g = this, c = g.activeTab !== null ? (g.activeTab || 0) : null, e = g.dockedItems, h = g.header,
            d = g.tabBarHeaderPosition, b = g.getTabBar(), a;
        g.layout = new Ext.layout.container.Card(Ext.apply({
            owner: g,
            deferredRender: g.deferredRender,
            itemCls: g.itemCls,
            activeItem: c
        }, g.layout));
        if (d != null) {
            h = g.header = Ext.apply({}, h);
            a = h.items = (h.items ? h.items.slice() : []);
            h.itemPosition = d;
            a.push(b);
            h.hasTabBar = true
        } else {
            e = [].concat(g.dockedItems || []);
            e.push(b);
            g.dockedItems = e
        }
        Ext.panel.Panel.prototype.initComponent.apply(this, arguments);
        c = g.activeTab = g.getComponent(c);
        if (c) {
            b.setActiveTab(c.tab, true)
        }
    },
    onRender: function () {
        var b = this.items.items, a = b.length, c;
        Ext.panel.Panel.prototype.onRender.apply(this, arguments);
        for (c = 0; c < a; ++c) {
            b[c].getBind()
        }
    },
    setActiveTab: function (a) {
        var c = this, b;
        if (!Ext.isObject(a) || a.isComponent) {
            a = c.getComponent(a)
        }
        b = c.getActiveTab();
        if (a) {
            Ext.suspendLayouts();
            if (!a.isComponent) {
                a = c.add(a)
            }
            if (b === a || c.fireEvent("beforetabchange", c, a, b) === false) {
                Ext.resumeLayouts(true);
                return b
            }
            c.activeTab = a;
            c.layout.setActiveItem(a);
            a = c.activeTab = c.layout.getActiveItem();
            if (a && a !== b) {
                c.tabBar.setActiveTab(a.tab);
                Ext.resumeLayouts(true);
                if (b !== a) {
                    c.fireEvent("tabchange", c, a, b)
                }
            } else {
                Ext.resumeLayouts(true)
            }
            return a
        }
        return b
    },
    setActiveItem: function (a) {
        return this.setActiveTab(a)
    },
    getActiveTab: function () {
        var b = this, a = b.getComponent(b.activeTab);
        if (a && b.items.indexOf(a) !== -1) {
            b.activeTab = a
        } else {
            b.activeTab = undefined
        }
        return b.activeTab
    },
    applyTabBar: function (a) {
        var c = this, b = (c.tabBarHeaderPosition != null) ? c.getHeaderPosition() : c.getTabPosition();
        return new Ext.tab.Bar(Ext.apply({
            ui: c.ui,
            dock: b,
            tabRotation: c.getTabRotation(),
            vertical: (b === "left" || b === "right"),
            plain: c.plain,
            tabStretchMax: c.getTabStretchMax(),
            tabPanel: c
        }, a))
    },
    updateHeaderPosition: function (c, b) {
        var a = this.getTabBar();
        if (a && (this.tabBarHeaderPosition != null)) {
            a.setDock(c)
        }
        Ext.panel.Panel.prototype.updateHeaderPosition.call(this, c, b)
    },
    updateTabPosition: function (b) {
        var a = this.getTabBar();
        if (a && (this.tabBarHeaderPosition == null)) {
            a.setDock(b)
        }
    },
    updateTabRotation: function (b) {
        var a = this.getTabBar();
        if (a) {
            a.setTabRotation(b)
        }
    },
    onAdd: function (g, d) {
        var e = this, c = Ext.apply({}, g.tabConfig), b = e.getTabBar(), a = {
            xtype: "tab",
            title: g.title,
            icon: g.icon,
            iconCls: g.iconCls,
            glyph: g.glyph,
            ui: b.ui,
            card: g,
            disabled: g.disabled,
            closable: g.closable,
            hidden: g.hidden && !g.hiddenByLayout,
            tooltip: g.tooltip,
            tabBar: b,
            tabPosition: b.dock,
            rotation: b.getTabRotation()
        };
        if (g.closeText !== undefined) {
            a.closeText = g.closeText
        }
        c = Ext.applyIf(c, a);
        g.tab = e.tabBar.insert(d, c);
        g.ariaRole = "tabpanel";
        g.ariaRenderAttributes = g.ariaRenderAttributes || {};
        g.ariaRenderAttributes["aria-labelledby"] = g.tab.id;
        g.on({
            scope: e,
            enable: e.onItemEnable,
            disable: e.onItemDisable,
            beforeshow: e.onItemBeforeShow,
            iconchange: e.onItemIconChange,
            iconclschange: e.onItemIconClsChange,
            glyphchange: e.onItemGlyphChange,
            titlechange: e.onItemTitleChange
        });
        if (g.isPanel) {
            if (e.removePanelHeader) {
                if (g.rendered) {
                    if (g.header) {
                        g.header.hide()
                    }
                } else {
                    g.header = false
                }
            }
            if (g.isPanel && e.border) {
                g.setBorder(false)
            }
        }
        if (e.rendered) {
            g.getBind()
        }
        if (e.rendered && e.loader && e.activeTab === undefined && e.layout.activeItem !== null) {
            e.setActiveTab(0)
        }
    },
    onMove: function (c, b, d) {
        var a = this.getTabBar();
        Ext.panel.Panel.prototype.onMove.call(this, c, b, d);
        if (a.items.indexOf(c.tab) !== d) {
            a.move(c.tab, d)
        }
    },
    onItemEnable: function (a) {
        a.tab.enable()
    },
    onItemDisable: function (a) {
        a.tab.disable()
    },
    onItemBeforeShow: function (a) {
        if (a !== this.activeTab) {
            this.setActiveTab(a);
            return false
        }
    },
    onItemGlyphChange: function (a, b) {
        a.tab.setGlyph(b)
    },
    onItemIconChange: function (b, a) {
        b.tab.setIcon(a)
    },
    onItemIconClsChange: function (b, a) {
        b.tab.setIconCls(a)
    },
    onItemTitleChange: function (a, b) {
        a.tab.setText(b)
    },
    onRemove: function (b, c) {
        var a = this;
        b.un({
            scope: a,
            enable: a.onItemEnable,
            disable: a.onItemDisable,
            beforeshow: a.onItemBeforeShow,
            iconchange: a.onItemIconChange,
            iconclschange: a.onItemIconClsChange,
            glyphchange: a.onItemGlyphChange,
            titlechange: a.onItemTitleChange
        });
        if (b.tab && !a.destroying && b.tab.ownerCt === a.tabBar) {
            a.tabBar.remove(b.tab)
        }
    },
    privates: {
        doRemove: function (d, b) {
            var c = this, a;
            if (c.removingAll || c.destroying || c.items.getCount() === 1) {
                c.activeTab = null
            } else {
                if (d.tab && (a = c.tabBar.items.indexOf(c.tabBar.findNextActivatable(d.tab))) !== -1) {
                    c.setActiveTab(a)
                }
            }
            Ext.panel.Panel.prototype.doRemove.apply(this, arguments);
            if (d.tab) {
                delete d.tab.card;
                delete d.tab
            }
        }
    }
}, 0, ["tabpanel"], ["component", "box", "container", "panel", "tabpanel"], {
    component: true,
    box: true,
    container: true,
    panel: true,
    tabpanel: true
}, ["widget.tabpanel"], 0, [Ext.tab, "Panel", Ext, "TabPanel"], 0));
(Ext.cmd.derive("Ext.toolbar.Breadcrumb", Ext.Container, {
    isBreadcrumb: true,
    baseCls: "x-breadcrumb",
    layout: "hbox",
    config: {
        buttonUI: "plain-toolbar",
        displayField: "text",
        overflowHandler: null,
        showIcons: null,
        showMenuIcons: null,
        store: null,
        useSplitButtons: true
    },
    renderConfig: {selection: "root"},
    publishes: ["selection"],
    twoWayBindable: ["selection"],
    _breadcrumbCls: "x-breadcrumb",
    _btnCls: "x-breadcrumb-btn",
    _folderIconCls: "x-breadcrumb-icon-folder",
    _leafIconCls: "x-breadcrumb-icon-leaf",
    initComponent: function () {
        var c = this, b = c.layout, a = c.getOverflowHandler();
        if (typeof b === "string") {
            b = {type: b}
        }
        if (a) {
            b.overflowHandler = a
        }
        c.layout = b;
        c.defaultButtonUI = c.getButtonUI();
        c._buttons = [];
        c.addCls([c._breadcrumbCls, c._breadcrumbCls + "-" + c.ui]);
        Ext.container.Container.prototype.initComponent.call(this)
    },
    onDestroy: function () {
        var a = this;
        a._buttons = Ext.destroy(a._buttons);
        a.setStore(null);
        Ext.container.Container.prototype.onDestroy.call(this)
    },
    onRemove: function (a, b) {
        Ext.container.Container.prototype.onRemove.call(this, a, b);
        delete a._breadcrumbNodeId
    },
    afterComponentLayout: function () {
        var b = this, a = b.layout.overflowHandler;
        Ext.container.Container.prototype.afterComponentLayout.apply(this, arguments);
        if (a && b.tooNarrow && a.scrollToItem) {
            a.scrollToItem(b.getSelection().get("depth"))
        }
    },
    applySelection: function (b) {
        var a = this.getStore();
        if (a) {
            b = (b === "root") ? this.getStore().getRoot() : b
        } else {
            b = null
        }
        return b
    },
    updateSelection: function (m, l) {
        var s = this, p = s._buttons, h = [], r = s.items.getCount(), k = s._needsSync, n = s.getDisplayField(), d, e,
            b, q, t, c, g, a, j, u, o;
        Ext.suspendLayouts();
        if (m) {
            c = m;
            u = m.get("depth");
            t = u + 1;
            o = u;
            while (c) {
                j = c.getId();
                a = p[o];
                if (!k && a && a._breadcrumbNodeId === j) {
                    break
                }
                g = c.get(n);
                if (a) {
                    a.setText(g)
                } else {
                    a = p[o] = Ext.create({
                        xtype: s.getUseSplitButtons() ? "splitbutton" : "button",
                        ui: s.getButtonUI(),
                        cls: s._btnCls + " " + s._btnCls + "-" + s.ui,
                        text: g,
                        showEmptyMenu: true,
                        menu: {listeners: {click: "_onMenuClick", beforeshow: "_onMenuBeforeShow", scope: this}},
                        handler: "_onButtonClick",
                        scope: s
                    })
                }
                d = this.getShowIcons();
                if (d !== false) {
                    e = c.get("glyph");
                    q = c.get("icon");
                    b = c.get("iconCls");
                    if (e) {
                        a.setGlyph(e);
                        a.setIcon(null);
                        a.setIconCls(b)
                    } else {
                        if (q) {
                            a.setGlyph(null);
                            a.setIconCls(null);
                            a.setIcon(q)
                        } else {
                            if (b) {
                                a.setGlyph(null);
                                a.setIcon(null);
                                a.setIconCls(b)
                            } else {
                                if (d) {
                                    a.setGlyph(null);
                                    a.setIcon(null);
                                    a.setIconCls((c.isLeaf() ? s._leafIconCls : s._folderIconCls) + "-" + s.ui)
                                } else {
                                    a.setGlyph(null);
                                    a.setIcon(null);
                                    a.setIconCls(null)
                                }
                            }
                        }
                    }
                }
                a.setArrowVisible(c.hasChildNodes());
                a._breadcrumbNodeId = c.getId();
                c = c.parentNode;
                o--
            }
            if (t > r) {
                h = p.slice(r, u + 1);
                s.add(h)
            } else {
                for (o = r - 1; o >= t; o--) {
                    s.remove(s.items.items[o], false)
                }
            }
        } else {
            s.removeAll(false)
        }
        Ext.resumeLayouts(true);
        s.fireEvent("selectionchange", s, m, l);
        if (s._shouldFireChangeEvent) {
            s.fireEvent("change", s, m, l)
        }
        s._shouldFireChangeEvent = true;
        s._needsSync = false
    },
    applyUseSplitButtons: function (b, a) {
        if (this.rendered && b !== a) {
            Ext.raise("Cannot reconfigure 'useSplitButtons' config of Ext.toolbar.Breadcrumb after initial render")
        }
        return b
    },
    applyStore: function (a) {
        if (a) {
            a = Ext.data.StoreManager.lookup(a)
        }
        return a
    },
    updateStore: function (a, b) {
        this._needsSync = true;
        if (a && !this.isConfiguring) {
            this.setSelection(a.getRoot())
        }
    },
    privates: {
        _onButtonClick: function (a, b) {
            if (this.getUseSplitButtons()) {
                this.setSelection(this.getStore().getNodeById(a._breadcrumbNodeId))
            }
        }, _onMenuClick: function (c, a, b) {
            if (a) {
                this.setSelection(this.getStore().getNodeById(a._breadcrumbNodeId))
            }
        }, _onMenuBeforeShow: function (c) {
            var k = this, d = k.getStore().getNodeById(c.ownerCmp._breadcrumbNodeId), g = k.getDisplayField(),
                a = k.getShowMenuIcons(), o, b, l, j, e, m, n, h, p;
            if (d.hasChildNodes()) {
                o = d.childNodes;
                j = [];
                for (e = 0, h = o.length; e < h; e++) {
                    b = o[e];
                    p = {text: b.get(g), _breadcrumbNodeId: b.getId()};
                    if (a !== false) {
                        l = b.get("glyph");
                        m = b.get("icon");
                        n = b.get("iconCls");
                        if (l) {
                            p.glyph = l;
                            p.iconCls = n
                        } else {
                            if (m) {
                                p.icon = m
                            } else {
                                if (n) {
                                    p.iconCls = n
                                } else {
                                    if (a) {
                                        p.iconCls = (b.isLeaf() ? k._leafIconCls : k._folderIconCls) + "-" + k.ui
                                    }
                                }
                            }
                        }
                    }
                    j.push(p)
                }
                c.removeAll();
                c.add(j)
            } else {
                return false
            }
        }
    }
}, 0, ["breadcrumb"], ["component", "box", "container", "breadcrumb"], {
    component: true,
    box: true,
    container: true,
    breadcrumb: true
}, ["widget.breadcrumb"], [[Ext.util.FocusableContainer.prototype.mixinId || Ext.util.FocusableContainer.$className, Ext.util.FocusableContainer]], [Ext.toolbar, "Breadcrumb"], 0));
(Ext.cmd.derive("Ext.toolbar.Fill", Ext.Component, {
    alternateClassName: "Ext.Toolbar.Fill",
    ariaRole: "presentation",
    isFill: true,
    flex: 1
}, 0, ["tbfill"], ["component", "box", "tbfill"], {
    component: true,
    box: true,
    tbfill: true
}, ["widget.tbfill"], 0, [Ext.toolbar, "Fill", Ext.Toolbar, "Fill"], 0));
(Ext.cmd.derive("Ext.toolbar.Spacer", Ext.Component, {
    alternateClassName: "Ext.Toolbar.Spacer",
    baseCls: "x-toolbar-spacer",
    ariaRole: "presentation"
}, 0, ["tbspacer"], ["component", "box", "tbspacer"], {
    component: true,
    box: true,
    tbspacer: true
}, ["widget.tbspacer"], 0, [Ext.toolbar, "Spacer", Ext.Toolbar, "Spacer"], 0));
(Ext.cmd.derive("Ext.tree.Column", Ext.grid.column.Column, {
    tdCls: "x-grid-cell-treecolumn",
    autoLock: true,
    lockable: false,
    draggable: false,
    hideable: false,
    iconCls: "x-tree-icon",
    checkboxCls: "x-tree-checkbox",
    elbowCls: "x-tree-elbow",
    expanderCls: "x-tree-expander",
    textCls: "x-tree-node-text",
    innerCls: "x-grid-cell-inner-treecolumn",
    customIconCls: "x-tree-icon-custom",
    isTreeColumn: true,
    cellTpl: ['<tpl for="lines">', '<div class="{parent.childCls} {parent.elbowCls}-img ', '{parent.elbowCls}-<tpl if=".">line<tpl else>empty</tpl>" role="presentation"></div>', "</tpl>", '<div class="{childCls} {elbowCls}-img {elbowCls}', '<tpl if="isLast">-end</tpl><tpl if="expandable">-plus {expanderCls}</tpl>" role="presentation"></div>', '<tpl if="checked !== null">', '<div role="button" {ariaCellCheckboxAttr}', ' class="{childCls} {checkboxCls}<tpl if="checked"> {checkboxCls}-checked</tpl>"></div>', "</tpl>", '<tpl if="icon"><img src="{blankUrl}"<tpl else><div</tpl>', ' role="presentation" class="{childCls} {baseIconCls} {customIconCls} ', '{baseIconCls}-<tpl if="leaf">leaf<tpl else><tpl if="expanded">parent-expanded<tpl else>parent</tpl></tpl> {iconCls}" ', '<tpl if="icon">style="background-image:url({icon})"/><tpl else>></div></tpl>', '<tpl if="href">', '<a href="{href}" role="link" target="{hrefTarget}" class="{textCls} {childCls}">{value}</a>', "<tpl else>", '<span class="{textCls} {childCls}">{value}</span>', "</tpl>"],
    initComponent: function () {
        var a = this;
        a.rendererScope = a.scope;
        a.setupRenderer();
        a.innerRenderer = a.renderer;
        a.renderer = a.treeRenderer;
        Ext.grid.column.Column.prototype.initComponent.call(this);
        a.scope = a;
        a.hasCustomRenderer = a.innerRenderer && a.innerRenderer.length > 1
    },
    treeRenderer: function (i, a, e, b, c, j, h) {
        var g = this, k = e.get("cls"), d;
        if (a && k) {
            a.tdCls += " " + k
        }
        d = g.initTemplateRendererData(i, a, e, b, c, j, h);
        return g.getTpl("cellTpl").apply(d)
    },
    initTemplateRendererData: function (l, a, g, b, e, m, j) {
        var i = this, c = i.innerRenderer, d = g.data, k = g.parentNode, n = j.rootVisible, o = [], h;
        while (k && (n || k.data.depth > 0)) {
            h = k.data;
            o[n ? h.depth : h.depth - 1] = h.isLast ? 0 : 1;
            k = k.parentNode
        }
        return {
            record: g,
            baseIconCls: i.iconCls,
            customIconCls: (d.icon || d.iconCls) ? i.customIconCls : "",
            iconCls: d.iconCls,
            icon: d.icon,
            checkboxCls: i.checkboxCls,
            checked: d.checked,
            elbowCls: i.elbowCls,
            expanderCls: i.expanderCls,
            textCls: i.textCls,
            leaf: d.leaf,
            expandable: g.isExpandable(),
            expanded: d.expanded,
            isLast: g.isLastVisible(),
            blankUrl: Ext.BLANK_IMAGE_URL,
            href: d.href,
            hrefTarget: d.hrefTarget,
            lines: o,
            metaData: a,
            childCls: i.getChildCls ? i.getChildCls() + " " : "",
            value: c ? c.apply(i.rendererScope, arguments) : l
        }
    }
}, 0, ["treecolumn"], ["component", "box", "container", "headercontainer", "gridcolumn", "treecolumn"], {
    component: true,
    box: true,
    container: true,
    headercontainer: true,
    gridcolumn: true,
    treecolumn: true
}, ["widget.treecolumn"], 0, [Ext.tree, "Column"], 0));
(Ext.cmd.derive("Ext.tree.NavigationModel", Ext.grid.NavigationModel, {
    initKeyNav: function (b) {
        var e = this, d = e.view.ownerGrid.columns, a, c;
        e.isTreeGrid = d && d.length > 1;
        Ext.grid.NavigationModel.prototype.initKeyNav.call(this, b);
        for (c = 0, a = e.keyNav.length; c < a; c++) {
            e.keyNav[c].map.addBinding([{
                key: "8",
                shift: true,
                handler: e.onAsterisk,
                scope: e
            }, {key: Ext.event.Event.NUM_MULTIPLY, handler: e.onAsterisk, scope: e}])
        }
        e.view.grid.on({columnschanged: e.onColumnsChanged, scope: e})
    }, onColumnsChanged: function () {
        this.isTreeGrid = this.view.ownerGrid.getVisibleColumnManager().getColumns().length > 1
    }, onKeyLeft: function (d) {
        var c = this, b = d.view, a = c.record;
        if (c.isTreeGrid && !d.ctrlKey) {
            return Ext.grid.NavigationModel.prototype.onKeyLeft.call(this, d)
        }
        if (d.position.column.isTreeColumn && a.isExpanded()) {
            b.collapse(a)
        } else {
            a = a.parentNode;
            if (a && !(a.isRoot() && !b.rootVisible)) {
                c.setPosition(a, null, d)
            }
        }
    }, onKeyRight: function (c) {
        var b = this, a = b.record;
        if (b.isTreeGrid && !c.ctrlKey) {
            return Ext.grid.NavigationModel.prototype.onKeyRight.call(this, c)
        }
        if (!a.isLeaf()) {
            if (c.position.column.isTreeColumn && !a.isExpanded()) {
                c.view.expand(a)
            } else {
                if (a.isExpanded()) {
                    a = a.childNodes[0];
                    if (a) {
                        b.setPosition(a)
                    }
                }
            }
        }
    }, onKeyEnter: function (a) {
        if (this.record.data.checked != null) {
            this.toggleCheck(a)
        } else {
            Ext.grid.NavigationModel.prototype.onKeyEnter.call(this, a)
        }
    }, onKeySpace: function (a) {
        if (this.record.data.checked != null) {
            this.toggleCheck(a)
        } else {
            Ext.grid.NavigationModel.prototype.onKeySpace.call(this, a)
        }
    }, toggleCheck: function (a) {
        this.view.onCheckChange(this.record)
    }, onAsterisk: function (a) {
        this.view.ownerCt.expandAll()
    }
}, 0, 0, 0, 0, ["view.navigation.tree"], 0, [Ext.tree, "NavigationModel"], 0));
(Ext.cmd.derive("Ext.tree.View", Ext.view.Table, {
    config: {selectionModel: {type: "treemodel"}},
    isTreeView: true,
    loadingCls: "x-grid-tree-loading",
    expandedCls: "x-grid-tree-node-expanded",
    leafCls: "x-grid-tree-node-leaf",
    expanderSelector: ".x-tree-expander",
    checkboxSelector: ".x-tree-checkbox",
    expanderIconOverCls: "x-tree-expander-over",
    nodeAnimWrapCls: "x-tree-animator-wrap",
    ariaRole: "tree",
    loadMask: false,
    rootVisible: true,
    expandDuration: 250,
    collapseDuration: 250,
    toggleOnDblClick: true,
    stripeRows: false,
    uiFields: {checked: 1, icon: 1, iconCls: 1},
    rowFields: {expanded: 1, loaded: 1, expandable: 1, leaf: 1, loading: 1, qtip: 1, qtitle: 1, cls: 1},
    treeRowTpl: ["{%", "this.processRowValues(values);", "this.nextTpl.applyOut(values, out, parent);", "%}", {
        priority: 10,
        processRowValues: function (c) {
            var b = c.record, a = c.view;
            c.rowAttr["data-qtip"] = b.get("qtip") || "";
            c.rowAttr["data-qtitle"] = b.get("qtitle") || "";
            if (b.isExpanded()) {
                c.rowClasses.push(a.expandedCls)
            }
            if (b.isLeaf()) {
                c.rowClasses.push(a.leafCls)
            }
            if (b.isLoading()) {
                c.rowClasses.push(a.loadingCls)
            }
        }
    }],
    initComponent: function () {
        var a = this;
        if (a.bufferedRenderer) {
            a.animate = false
        } else {
            if (a.initialConfig.animate === undefined) {
                a.animate = Ext.enableFx
            }
        }
        a.store = a.panel.getStore();
        a.onRootChange(a.store.getRoot());
        a.animQueue = {};
        a.animWraps = {};
        Ext.view.Table.prototype.initComponent.call(this);
        a.store.setRootVisible(a.rootVisible);
        a.addRowTpl(Ext.XTemplate.getTpl(a, "treeRowTpl"))
    },
    onFillComplete: function (e, d, b) {
        var c = this, a = c.store, g = a.indexOf(b[0]);
        d.triggerUIUpdate();
        if (!b.length || g === -1) {
            return
        }
        c.onAdd(c.store, b, g);
        c.refreshPartner()
    },
    refreshPartner: function () {
        var a = this.lockingPartner;
        if (a) {
            a.refresh()
        }
    },
    afterRender: function () {
        var a = this;
        Ext.view.Table.prototype.afterRender.call(this);
        a.el.on({
            scope: a,
            delegate: a.expanderSelector,
            mouseover: a.onExpanderMouseOver,
            mouseout: a.onExpanderMouseOut,
            click: {delegate: a.checkboxSelector, fn: a.onCheckboxChange, scope: a}
        })
    },
    afterComponentLayout: function (c, b, d, e) {
        var a = this.getScrollable();
        Ext.view.Table.prototype.afterComponentLayout.call(this, c, b, d, e);
        if (a && !this.bufferedRenderer) {
            a.refresh()
        }
    },
    processUIEvent: function (a) {
        if (a.getTarget("." + this.nodeAnimWrapCls, this.el)) {
            return false
        }
        return Ext.view.Table.prototype.processUIEvent.call(this, a)
    },
    setRootNode: function (a) {
        this.node = a
    },
    onCheckboxChange: function (d, a) {
        var c = this, b = d.getTarget(c.getItemSelector(), c.getTargetEl());
        if (b) {
            c.onCheckChange(c.getRecord(b))
        }
    },
    onCheckChange: function (a) {
        var b = a.get("checked");
        if (Ext.isBoolean(b)) {
            b = !b;
            a.set("checked", b);
            this.fireEvent("checkchange", a, b)
        }
    },
    getChecked: function () {
        var a = [];
        this.node.cascadeBy(function (b) {
            if (b.get("checked")) {
                a.push(b)
            }
        });
        return a
    },
    isItemChecked: function (a) {
        return a.get("checked")
    },
    createAnimWrap: function (a, b) {
        var e = this, d = e.getNode(a), c;
        c = Ext.fly(d).insertSibling({role: "presentation", tag: "div", cls: e.nodeAnimWrapCls}, "after");
        return {record: a, node: d, el: c, expanding: false, collapsing: false, animateEl: c, targetEl: c}
    },
    getAnimWrap: function (d, a) {
        if (!this.animate) {
            return null
        }
        var b = this.animWraps, c = b[d.internalId];
        if (a !== false) {
            while (!c && d) {
                d = d.parentNode;
                if (d) {
                    c = b[d.internalId]
                }
            }
        }
        return c
    },
    doAdd: function (b, g) {
        var h = this, d = b[0], i = d.parentNode, j = h.all, n, c = h.getAnimWrap(i), l, k, e, m, a;
        if (!c || !c.expanding) {
            return Ext.view.Table.prototype.doAdd.call(this, b, g)
        }
        m = h.bufferRender(b, g, true);
        a = m.children;
        i = c.record;
        l = c.targetEl;
        k = l.dom.childNodes;
        e = k.length;
        n = g - h.indexInStore(i) - 1;
        if (!e || n >= e) {
            l.appendChild(m.fragment, true)
        } else {
            Ext.fly(k[n]).insertSibling(a, "before", true)
        }
        j.insert(g, a);
        return a
    },
    onRemove: function (g, a, b) {
        var d = this, e, c, j = d.hasListeners.remove, h;
        if (d.viewReady) {
            e = d.store.getCount() === 0;
            if (d.bufferedRenderer) {
                return Ext.view.Table.prototype.onRemove.call(this, g, a, b)
            }
            if (j) {
                h = this.all.slice(b, b + a.length)
            }
            if (e) {
                d.refresh()
            } else {
                for (c = a.length - 1, b += c; c >= 0; --c, --b) {
                    d.doRemove(a[c], b)
                }
                d.refreshSizePending = true
            }
            if (j) {
                d.fireEvent("itemremove", a, b, h, d)
            }
        }
    },
    doRemove: function (a, c) {
        var h = this, d = h.all, b = h.getAnimWrap(a), g = d.item(c), e = g ? g.dom : null;
        if (!e || !b || !b.collapsing) {
            return Ext.view.Table.prototype.doRemove.call(this, a, c)
        }
        b.targetEl.dom.insertBefore(e, b.targetEl.dom.firstChild);
        d.removeElement(c)
    },
    onBeforeExpand: function (d, b, c) {
        var e = this, a;
        if (e.rendered && e.all.getCount() && e.animate) {
            if (e.getNode(d)) {
                a = e.getAnimWrap(d, false);
                if (!a) {
                    a = e.animWraps[d.internalId] = e.createAnimWrap(d);
                    a.animateEl.setHeight(0)
                } else {
                    if (a.collapsing) {
                        a.targetEl.select(e.itemSelector).destroy()
                    }
                }
                a.expanding = true;
                a.collapsing = false
            }
        }
    },
    onExpand: function (i) {
        var h = this, e = h.animQueue, a = i.getId(), c = h.getNode(i), g = c ? h.indexOf(c) : -1, d, b, j;
        if (h.singleExpand) {
            h.ensureSingleExpand(i)
        }
        if (g === -1) {
            return
        }
        d = h.getAnimWrap(i, false);
        if (!d) {
            i.isExpandingOrCollapsing = false;
            h.fireEvent("afteritemexpand", i, g, c);
            return
        }
        b = d.animateEl;
        j = d.targetEl;
        b.stopAnimation();
        e[a] = true;
        Ext.on("idle", function () {
            b.dom.style.height = "0px"
        }, null, {single: true});
        b.animate({
            from: {height: 0},
            to: {height: j.dom.scrollHeight},
            duration: h.expandDuration,
            listeners: {
                afteranimate: function () {
                    var k = j.dom.childNodes, l = Ext.Element.getActiveElement();
                    if (k.length) {
                        if (!j.contains(l)) {
                            l = null
                        }
                        d.el.insertSibling(k, "before", true);
                        if (l) {
                            l.focus()
                        }
                    }
                    d.el.destroy();
                    h.animWraps[d.record.internalId] = e[a] = null
                }
            },
            callback: function () {
                i.isExpandingOrCollapsing = false;
                if (!h.destroyed) {
                    h.refreshSize(true)
                }
                h.fireEvent("afteritemexpand", i, g, c)
            }
        })
    },
    onBeforeCollapse: function (e, b, c, h, d) {
        var g = this, a;
        if (g.rendered && g.all.getCount()) {
            if (g.animate) {
                if (e.isVisible()) {
                    a = g.getAnimWrap(e);
                    if (!a) {
                        a = g.animWraps[e.internalId] = g.createAnimWrap(e, c)
                    } else {
                        if (a.expanding) {
                            a.targetEl.select(this.itemSelector).destroy()
                        }
                    }
                    a.expanding = false;
                    a.collapsing = true;
                    a.callback = h;
                    a.scope = d
                }
            } else {
                g.onCollapseCallback = h;
                g.onCollapseScope = d
            }
        }
    },
    onCollapse: function (d) {
        var g = this, a = g.animQueue, i = d.getId(), e = g.getNode(d), c = e ? g.indexOf(e) : -1, b = g.getAnimWrap(d),
            h;
        if (!g.all.getCount() || !d.isVisible()) {
            return
        }
        if (!b) {
            d.isExpandingOrCollapsing = false;
            g.fireEvent("afteritemcollapse", d, c, e);
            Ext.callback(g.onCollapseCallback, g.onCollapseScope);
            g.onCollapseCallback = g.onCollapseScope = null;
            return
        }
        h = b.animateEl;
        a[i] = true;
        h.stopAnimation();
        h.animate({
            to: {height: 0}, duration: g.collapseDuration, listeners: {
                afteranimate: function () {
                    b.el.destroy();
                    g.animWraps[b.record.internalId] = a[i] = null
                }
            }, callback: function () {
                d.isExpandingOrCollapsing = false;
                if (!g.destroyed) {
                    g.refreshSize(true)
                }
                g.fireEvent("afteritemcollapse", d, c, e);
                Ext.callback(b.callback, b.scope);
                b.callback = b.scope = null
            }
        })
    },
    isAnimating: function (a) {
        return !!this.animQueue[a.getId()]
    },
    expand: function (d, c, h, e) {
        var g = this, b = !!g.animate, a;
        if (!b || !d.isExpandingOrCollapsing) {
            if (!d.isLeaf()) {
                d.isExpandingOrCollapsing = b
            }
            Ext.suspendLayouts();
            a = d.expand(c, h, e);
            Ext.resumeLayouts(true);
            return a
        }
    },
    collapse: function (c, b, g, d) {
        var e = this, a = !!e.animate;
        if (!a || !c.isExpandingOrCollapsing) {
            if (!c.isLeaf()) {
                c.isExpandingOrCollapsing = a
            }
            return c.collapse(b, g, d)
        }
    },
    toggle: function (b, a, d, c) {
        if (b.isExpanded()) {
            this.collapse(b, a, d, c)
        } else {
            this.expand(b, a, d, c)
        }
    },
    onItemDblClick: function (a, g, c, h) {
        var d = this, b = d.editingPlugin;
        Ext.view.Table.prototype.onItemDblClick.call(this, a, g, c, h);
        if (d.toggleOnDblClick && a.isExpandable() && !(b && b.clicksToEdit === 2)) {
            d.toggle(a)
        }
    },
    onBeforeItemMouseDown: function (a, c, b, d) {
        if (d.getTarget(this.expanderSelector, c)) {
            return false
        }
        return Ext.view.Table.prototype.onBeforeItemMouseDown.call(this, a, c, b, d)
    },
    onItemClick: function (a, c, b, d) {
        if (d.getTarget(this.expanderSelector, c) && a.isExpandable()) {
            this.toggle(a, d.ctrlKey);
            return false
        }
        return Ext.view.Table.prototype.onItemClick.call(this, a, c, b, d)
    },
    onExpanderMouseOver: function (b, a) {
        b.getTarget(this.cellSelector, 10, true).addCls(this.expanderIconOverCls)
    },
    onExpanderMouseOut: function (b, a) {
        b.getTarget(this.cellSelector, 10, true).removeCls(this.expanderIconOverCls)
    },
    getStoreListeners: function () {
        return Ext.apply(Ext.view.Table.prototype.getStoreListeners.call(this), {
            rootchange: this.onRootChange,
            fillcomplete: this.onFillComplete
        })
    },
    onBindStore: function (a, c, d, e) {
        var b = e && e.getRootNode(), g = a && a.getRootNode();
        Ext.view.Table.prototype.onBindStore.call(this, a, c, d, e);
        if (g !== b) {
            this.onRootChange(g, b)
        }
    },
    onRootChange: function (c, a) {
        var b = this;
        if (a) {
            b.rootListeners.destroy();
            b.rootListeners = null
        }
        if (c) {
            b.rootListeners = c.on({
                beforeexpand: b.onBeforeExpand,
                expand: b.onExpand,
                beforecollapse: b.onBeforeCollapse,
                collapse: b.onCollapse,
                destroyable: true,
                scope: b
            })
        }
    },
    ensureSingleExpand: function (b) {
        var a = b.parentNode;
        if (a) {
            a.eachChild(function (c) {
                if (c !== b && c.isExpanded()) {
                    c.collapse()
                }
            })
        }
    },
    shouldUpdateCell: function (b, e, d) {
        if (e.isTreeColumn && d) {
            var c = 0, a = d.length;
            for (; c < a; ++c) {
                if (this.rowFields[d[c]]) {
                    return 1
                }
                if (this.uiFields[d[c]]) {
                    return 2
                }
            }
        }
        return Ext.view.Table.prototype.shouldUpdateCell.call(this, b, e, d)
    }
}, 0, ["treeview"], ["component", "box", "dataview", "tableview", "gridview", "treeview"], {
    component: true,
    box: true,
    dataview: true,
    tableview: true,
    gridview: true,
    treeview: true
}, ["widget.treeview"], 0, [Ext.tree, "View"], 0));
(Ext.cmd.derive("Ext.tree.Panel", Ext.panel.Table, {
    alternateClassName: ["Ext.tree.TreePanel", "Ext.TreePanel"],
    viewType: "treeview",
    treeCls: "x-tree-panel",
    rowLines: false,
    lines: true,
    useArrows: false,
    singleExpand: false,
    ddConfig: {enableDrag: true, enableDrop: true},
    rootVisible: true,
    displayField: "text",
    root: null,
    normalCfgCopy: ["displayField", "root", "singleExpand", "useArrows", "lines", "rootVisible", "scroll"],
    lockedCfgCopy: ["displayField", "root", "singleExpand", "useArrows", "lines", "rootVisible"],
    isTree: true,
    arrowCls: "x-tree-arrows",
    linesCls: "x-tree-lines",
    noLinesCls: "x-tree-no-lines",
    autoWidthCls: "x-autowidth-table",
    constructor: function (a) {
        a = a || {};
        if (a.animate === undefined) {
            a.animate = Ext.isBoolean(this.animate) ? this.animate : Ext.enableFx
        }
        this.enableAnimations = a.animate;
        delete a.animate;
        Ext.panel.Table.prototype.constructor.call(this, a)
    },
    initComponent: function () {
        var d = this, b = [d.treeCls], c, a;
        if (d.useArrows) {
            b.push(d.arrowCls);
            d.lines = false
        }
        if (d.lines) {
            b.push(d.linesCls)
        } else {
            if (!d.useArrows) {
                b.push(d.noLinesCls)
            }
        }
        c = d.applyStore(d.store);
        if (!c.getRoot()) {
            c.setRoot({})
        }
        c.setRootVisible(d.rootVisible);
        d.viewConfig = Ext.apply({
            rootVisible: d.rootVisible,
            animate: d.enableAnimations,
            singleExpand: d.singleExpand,
            node: c.getRoot(),
            hideHeaders: d.hideHeaders,
            navigationModel: "tree"
        }, d.viewConfig);
        if (!d.columns) {
            if (d.initialConfig.hideHeaders === undefined) {
                d.hideHeaders = true
            }
            d.addCls(d.autoWidthCls);
            d.columns = [{xtype: "treecolumn", text: "Name", flex: 1, dataIndex: d.displayField}]
        }
        if (d.cls) {
            b.push(d.cls)
        }
        d.cls = b.join(" ");
        Ext.panel.Table.prototype.initComponent.call(this);
        a = d.getView();
        d.relayEvents(a, ["checkchange", "afteritemexpand", "afteritemcollapse"])
    },
    applyStore: function (a) {
        var b = this;
        if (Ext.isString(a)) {
            a = b.store = Ext.StoreMgr.lookup(a)
        } else {
            if (!a || !a.isStore) {
                a = Ext.apply({type: "tree", proxy: "memory"}, a);
                if (b.root) {
                    a.root = b.root
                }
                if (b.fields) {
                    a.fields = b.fields
                } else {
                    if (b.model) {
                        a.model = b.model
                    }
                }
                if (b.folderSort) {
                    a.folderSort = b.folderSort
                }
                a = b.store = Ext.StoreMgr.lookup(a)
            } else {
                if (b.root) {
                    a = b.store = Ext.data.StoreManager.lookup(a);
                    a.setRoot(b.root);
                    if (b.folderSort !== undefined) {
                        a.folderSort = b.folderSort;
                        a.sort()
                    }
                }
            }
        }
        return a
    },
    setStore: function (a) {
        var b = this;
        a = b.applyStore(a);
        if (!a.getRoot()) {
            a.setRoot({})
        }
        a.setRootVisible(b.rootVisible);
        if (b.view) {
            b.view.setRootNode(a.getRootNode())
        }
        b.bindStore(a)
    },
    bindStore: function (b, c) {
        var d = this, a = b.getRoot(), e = d.bufferedRenderer;
        Ext.panel.Table.prototype.bindStore.apply(this, arguments);
        if (e) {
            if (e.store) {
                e.bindStore(b)
            }
        }
        b.singleExpand = d.singleExpand;
        d.storeListeners = d.mon(b, {destroyable: true, rootchange: d.onRootChange, scope: d});
        d.storeRelayers = d.relayEvents(b, ["beforeload", "load"]);
        d.rootRelayers = d.mon(a, {
            destroyable: true,
            append: d.createRelayer("itemappend"),
            remove: d.createRelayer("itemremove"),
            move: d.createRelayer("itemmove", [0, 4]),
            insert: d.createRelayer("iteminsert"),
            beforeappend: d.createRelayer("beforeitemappend"),
            beforeremove: d.createRelayer("beforeitemremove"),
            beforemove: d.createRelayer("beforeitemmove"),
            beforeinsert: d.createRelayer("beforeiteminsert"),
            expand: d.createRelayer("itemexpand", [0, 1]),
            collapse: d.createRelayer("itemcollapse", [0, 1]),
            beforeexpand: d.createRelayer("beforeitemexpand", [0, 1]),
            beforecollapse: d.createRelayer("beforeitemcollapse", [0, 1])
        });
        if (!d.rootVisible && !b.autoLoad && !(a.isExpanded() || a.isLoading())) {
            if (a.isLoaded()) {
                a.data.expanded = true;
                b.onNodeExpand(a, a.childNodes)
            } else {
                if (b.autoLoad !== false) {
                    a.data.expanded = false;
                    a.expand()
                }
            }
        }
        b.ownerTree = d;
        if (!c) {
            d.view.setRootNode(a)
        }
    },
    unbindStore: function () {
        var b = this, a = b.store;
        if (a) {
            Ext.panel.Table.prototype.unbindStore.call(this);
            Ext.destroy(b.storeListeners, b.storeRelayers, b.rootRelayers);
            delete a.ownerTree;
            a.singleExpand = null
        }
    },
    setRootNode: function () {
        return this.store.setRoot.apply(this.store, arguments)
    },
    getRootNode: function () {
        return this.store.getRoot()
    },
    onRootChange: function (a) {
        this.view.setRootNode(a)
    },
    getChecked: function () {
        return this.getView().getChecked()
    },
    isItemChecked: function (a) {
        return a.get("checked")
    },
    expandNode: function (b, a, d, c) {
        return this.getView().expand(b, a, d, c || this)
    },
    collapseNode: function (b, a, d, c) {
        return this.getView().collapse(b, a, d, c || this)
    },
    expandAll: function (d, b) {
        var c = this, a = c.getRootNode();
        if (a) {
            Ext.suspendLayouts();
            a.expand(true, d, b || c);
            Ext.resumeLayouts(true)
        }
    },
    collapseAll: function (e, c) {
        var d = this, b = d.getRootNode(), a = d.getView();
        if (b) {
            Ext.suspendLayouts();
            c = c || d;
            if (a.rootVisible) {
                b.collapse(true, e, c)
            } else {
                b.collapseChildren(true, e, c)
            }
            Ext.resumeLayouts(true)
        }
    },
    expandPath: function (o, q) {
        var e = arguments, g = this, h = g.view, i = (q && q.field) || g.store.model.idProperty, j, p,
            b = (q && q.separator) || "/", k, n, d, c, m, a, l;
        if (q && typeof q === "object") {
            i = q.field || g.store.model.idProperty;
            b = q.separator || "/";
            k = q.callback;
            n = q.scope;
            j = q.select;
            p = q.focus
        } else {
            i = e[1] || g.store.model.idProperty;
            b = e[2] || "/";
            k = e[3];
            n = e[4]
        }
        if (Ext.isEmpty(o)) {
            return Ext.callback(k, n || g, [false, null])
        }
        m = o.split(b);
        a = !m[0];
        if (a) {
            d = g.getRootNode();
            c = 1
        } else {
            d = g.store.findNode(i, m[0]);
            c = 0
        }
        if (!d || (a && d.get(i) !== m[1])) {
            return Ext.callback(k, n || g, [false, d])
        }
        l = function (v) {
            var t = this, r, s, u;
            if (++c === m.length) {
                if (j) {
                    h.getSelectionModel().select(t)
                }
                if (p) {
                    h.getNavigationModel().setPosition(t, 0)
                }
                return Ext.callback(k, n || g, [true, t, h.getNode(t)])
            }
            for (s = 0, r = v ? v.length : 0; s < r; s++) {
                t = v[s];
                u = t.get(i);
                if (u || u === 0) {
                    u = u.toString()
                }
                if (u === m[c]) {
                    return t.expand(false, l)
                }
            }
            t = this;
            Ext.callback(k, n || g, [false, t, h.getNode(t)])
        };
        d.expand(false, l)
    },
    ensureVisible: function (m, n) {
        if (m.isEntity || typeof m === "number") {
            return Ext.panel.Table.prototype.ensureVisible.call(this, m, n)
        }
        var g = this, h = (n && n.field) || g.store.model.idProperty, e = (n && n.separator) || "/", j, l, k, a, i, b,
            d, c = function (r, p, o, q) {
                if (!q && r && p) {
                    q = p.findChild(h, i)
                }
                if (q) {
                    g.doEnsureVisible(q, n)
                } else {
                    Ext.callback(j, l || g, [false, p])
                }
            };
        if (n) {
            j = n.callback;
            l = n.scope
        }
        k = m.split(e);
        a = !k[0];
        i = k.pop();
        if (k.length && !(a && k.length === 1)) {
            g.expandPath(k.join(e), h, e, c)
        } else {
            b = g.store.findNode(h, i);
            if (b) {
                d = b.parentNode;
                if (d && !d.isExpanded()) {
                    d.expand()
                }
                c(true, null, null, b)
            } else {
                Ext.callback(j, l || g, [false, null])
            }
        }
    },
    selectPath: function (d, c, b, e, a) {
        this.ensureVisible(d, {field: c, separator: b, select: true, callback: e, scope: a})
    }
}, 1, ["treepanel"], ["component", "box", "container", "panel", "tablepanel", "treepanel"], {
    component: true,
    box: true,
    container: true,
    panel: true,
    tablepanel: true,
    treepanel: true
}, ["widget.treepanel"], 0, [Ext.tree, "Panel", Ext.tree, "TreePanel", Ext, "TreePanel"], 0));
(Ext.cmd.derive("Ext.view.DragZone", Ext.dd.DragZone, {
    containerScroll: false, constructor: function (b) {
        var e = this, a, d, c;
        Ext.apply(e, b);
        if (!e.ddGroup) {
            e.ddGroup = "view-dd-zone-" + e.view.id
        }
        a = e.view;
        d = a.ownerCt;
        if (d) {
            c = d.getTargetEl().dom
        } else {
            c = a.el.dom.parentNode
        }
        Ext.dd.DragZone.prototype.constructor.call(this, c);
        e.ddel = document.createElement("div");
        e.ddel.className = "x-grid-dd-wrap"
    }, init: function (e, a, c) {
        var d = this, b = {itemmousedown: d.onItemMouseDown, scope: d};
        if (Ext.supports.touchScroll) {
            b.itemlongpress = d.onItemMouseDown
        }
        d.initTarget(e, a, c);
        d.view.mon(d.view, b)
    }, onValidDrop: function (b, a, c) {
        Ext.dd.DragZone.prototype.onValidDrop.call(this, b, a, c);
        b.el.focus()
    }, onItemMouseDown: function (b, a, g, c, h) {
        var d;
        if (h.pointerType === "touch" && h.type !== "longpress") {
            return
        }
        if (!this.isPreventDrag(h, a, g, c)) {
            d = b.getNavigationModel();
            if (h.position) {
                d.setPosition(h.position)
            } else {
                d.setPosition(c)
            }
            this.handleMouseDown(h)
        }
    }, isPreventDrag: function (d, a, c, b) {
        return false
    }, getDragData: function (c) {
        var a = this.view, b = c.getTarget(a.getItemSelector());
        if (b) {
            return {
                copy: a.copy || (a.allowCopy && c.ctrlKey),
                event: c,
                view: a,
                ddel: this.ddel,
                item: b,
                records: a.getSelectionModel().getSelection(),
                fromPosition: Ext.fly(b).getXY()
            }
        }
    }, onInitDrag: function (b, h) {
        var e = this, g = e.dragData, d = g.view, a = d.getSelectionModel(), c = d.getRecord(g.item);
        if (!a.isSelected(c)) {
            a.selectWithEvent(c, e.DDMInstance.mousedownEvent)
        }
        g.records = a.getSelection();
        Ext.fly(e.ddel).setHtml(e.getDragText());
        e.proxy.update(e.ddel);
        e.onStartDrag(b, h);
        return true
    }, getDragText: function () {
        var a = this.dragData.records.length;
        return Ext.String.format(this.dragText, a, a === 1 ? "" : "s")
    }, getRepairXY: function (b, a) {
        return a ? a.fromPosition : false
    }
}, 1, 0, 0, 0, 0, 0, [Ext.view, "DragZone"], 0));
(Ext.cmd.derive("Ext.tree.ViewDragZone", Ext.view.DragZone, {
    isPreventDrag: function (b, a) {
        return (a.get("allowDrag") === false) || !!b.getTarget(this.view.expanderSelector)
    }, getDragText: function () {
        var a = this.dragData.records, b = a.length, d = a[0].get(this.displayField), c = "s";
        if (b === 1 && d) {
            return d
        } else {
            if (!d) {
                c = ""
            }
        }
        return Ext.String.format(this.dragText, b, c)
    }, afterRepair: function () {
        var h = this, a = h.view, i = a.selectedItemCls, b = h.dragData.records, g, e = b.length, c = Ext.fly, d;
        if (Ext.enableFx && h.repairHighlight) {
            for (g = 0; g < e; g++) {
                d = a.getNode(b[g]);
                c(d.firstChild).highlight(h.repairHighlightColor, {
                    listeners: {
                        beforeanimate: function () {
                            if (a.isSelected(d)) {
                                c(d).removeCls(i)
                            }
                        }, afteranimate: function () {
                            if (a.isSelected(d)) {
                                c(d).addCls(i)
                            }
                        }
                    }
                })
            }
        }
        h.dragging = false
    }
}, 0, 0, 0, 0, 0, 0, [Ext.tree, "ViewDragZone"], 0));
(Ext.cmd.derive("Ext.tree.ViewDropZone", Ext.view.DropZone, {
    allowParentInserts: false,
    allowContainerDrops: false,
    appendOnly: false,
    expandDelay: 500,
    indicatorCls: "x-tree-ddindicator",
    expandNode: function (b) {
        var a = this.view;
        this.expandProcId = false;
        if (!b.isLeaf() && !b.isExpanded()) {
            a.expand(b);
            this.expandProcId = false
        }
    },
    queueExpand: function (a) {
        this.expandProcId = Ext.Function.defer(this.expandNode, this.expandDelay, this, [a])
    },
    cancelExpand: function () {
        if (this.expandProcId) {
            clearTimeout(this.expandProcId);
            this.expandProcId = false
        }
    },
    getPosition: function (g, b) {
        var j = this.view, c = j.getRecord(b), h = g.getY(), k = c.isLeaf(), a = false, i = Ext.fly(b).getRegion(), d;
        if (c.isRoot()) {
            return "append"
        }
        if (this.appendOnly) {
            return k ? false : "append"
        }
        if (!this.allowParentInserts) {
            a = c.hasChildNodes() && c.isExpanded()
        }
        d = (i.bottom - i.top) / (k ? 2 : 3);
        if (h >= i.top && h < (i.top + d)) {
            return "before"
        } else {
            if (!a && (k || (h >= (i.bottom - d) && h <= i.bottom))) {
                return "after"
            } else {
                return "append"
            }
        }
    },
    isValidDropPoint: function (b, j, n, k, g) {
        if (!b || !g.item) {
            return false
        }
        var o = this.view, l = o.getRecord(b), d = g.records, a = d.length, m = d.length, c, h;
        if (!(l && j && a)) {
            return false
        }
        for (c = 0; c < m; c++) {
            h = d[c];
            if (h.isNode && h.contains(l)) {
                return false
            }
        }
        if (j === "append" && l.get("allowDrop") === false) {
            return false
        } else {
            if (j !== "append" && l.parentNode.get("allowDrop") === false) {
                return false
            }
        }
        if (Ext.Array.contains(d, l)) {
            return false
        }
        return o.fireEvent("nodedragover", l, j, g, k) !== false
    },
    onNodeOver: function (a, i, g, c) {
        var d = this.getPosition(g, a), b = this.dropNotAllowed, j = this.view, h = j.getRecord(a),
            k = this.getIndicator(), l = 0;
        this.cancelExpand();
        if (d === "append" && !this.expandProcId && !Ext.Array.contains(c.records, h) && !h.isLeaf() && !h.isExpanded()) {
            this.queueExpand(h)
        }
        if (this.isValidDropPoint(a, d, i, g, c)) {
            this.valid = true;
            this.currentPosition = d;
            this.overRecord = h;
            k.setWidth(Ext.fly(a).getWidth());
            l = Ext.fly(a).getY() - Ext.fly(j.el).getY() - 1;
            if (j.touchScroll === 2) {
                l += j.getScrollY()
            }
            if (d === "before") {
                b = h.isFirst() ? "x-tree-drop-ok-above" : "x-tree-drop-ok-between";
                k.showAt(0, l);
                i.proxy.show()
            } else {
                if (d === "after") {
                    b = h.isLast() ? "x-tree-drop-ok-below" : "x-tree-drop-ok-between";
                    l += Ext.fly(a).getHeight();
                    k.showAt(0, l);
                    i.proxy.show()
                } else {
                    b = "x-tree-drop-ok-append";
                    k.hide()
                }
            }
        } else {
            this.valid = false
        }
        this.currentCls = b;
        return b
    },
    onNodeOut: function (d, a, c, b) {
        this.valid = false;
        this.getIndicator().hide()
    },
    onContainerOver: function (a, c, b) {
        return this.allowContainerDrops ? this.dropAllowed : c.getTarget("." + this.indicatorCls) ? this.currentCls : this.dropNotAllowed
    },
    onContainerDrop: function (a, c, b) {
        if (this.allowContainerDrops) {
            this.valid = true;
            this.currentPosition = "append";
            this.overRecord = this.view.store.getRoot();
            this.onNodeDrop(this.overRecord, a, c, b)
        }
    },
    notifyOut: function () {
        Ext.view.DropZone.prototype.notifyOut.apply(this, arguments);
        this.cancelExpand()
    },
    handleNodeDrop: function (g, n, j) {
        var p = this, a = p.view, k = n ? n.parentNode : a.panel.getRootNode(), b = a.store.getModel(), c, e, m, h, d,
            l, o, q;
        if (g.copy) {
            c = g.records;
            g.records = [];
            for (e = 0, m = c.length; e < m; e++) {
                h = c[e];
                if (h.isNode) {
                    g.records.push(h.copy())
                } else {
                    g.records.push(new b(Ext.apply({}, h.data)))
                }
            }
        }
        p.cancelExpand();
        if (j === "before") {
            d = k.insertBefore;
            l = [null, n];
            n = k
        } else {
            if (j === "after") {
                if (n.nextSibling) {
                    d = k.insertBefore;
                    l = [null, n.nextSibling]
                } else {
                    d = k.appendChild;
                    l = [null]
                }
                n = k
            } else {
                if (!(n.isExpanded() || n.isLoading())) {
                    o = true
                }
                d = n.appendChild;
                l = [null]
            }
        }
        q = function () {
            var i, r;
            Ext.suspendLayouts();
            for (e = 0, m = g.records.length; e < m; e++) {
                h = g.records[e];
                if (!h.isNode) {
                    if (h.isModel) {
                        h = new b(h.data, h.getId())
                    } else {
                        h = new b(h)
                    }
                    g.records[e] = h
                }
                l[0] = h;
                d.apply(n, l)
            }
            if (p.sortOnDrop) {
                n.sort(n.getOwnerTree().store.getSorters().sortFn)
            }
            Ext.resumeLayouts(true);
            h = g.records[0];
            a.ownerGrid.ensureVisible(h);
            a.getNavigationModel().setPosition(h);
            if (Ext.enableFx && p.dropHighlight) {
                i = p.dropHighlightColor;
                for (e = 0; e < m; e++) {
                    r = a.getNode(g.records[e]);
                    if (r) {
                        Ext.fly(r).highlight(i)
                    }
                }
            }
        };
        if (o) {
            n.expand(false, q)
        } else {
            if (n.isLoading()) {
                n.on({expand: q, delay: 1, single: true})
            } else {
                q()
            }
        }
    }
}, 0, 0, 0, 0, 0, 0, [Ext.tree, "ViewDropZone"], 0));
(Ext.cmd.derive("Ext.tree.plugin.TreeViewDragDrop", Ext.plugin.Abstract, {
    dragText: "{0} selected node{1}",
    allowParentInserts: false,
    allowContainerDrops: false,
    appendOnly: false,
    ddGroup: "TreeDD",
    containerScroll: false,
    expandDelay: 1000,
    enableDrop: true,
    enableDrag: true,
    nodeHighlightColor: "c3daf9",
    nodeHighlightOnDrop: Ext.enableFx,
    displayField: "text",
    init: function (a) {
        a.on("render", this.onViewRender, this, {single: true})
    },
    destroy: function () {
        var a = this;
        a.dragZone = a.dropZone = Ext.destroy(a.dragZone, a.dropZone);
        Ext.plugin.Abstract.prototype.destroy.call(this)
    },
    onViewRender: function (a) {
        var b = this, c;
        if (b.enableDrag) {
            if (b.containerScroll) {
                c = a.getEl()
            }
            b.dragZone = new Ext.tree.ViewDragZone(Ext.apply({
                view: a,
                ddGroup: b.dragGroup || b.ddGroup,
                dragText: b.dragText,
                displayField: b.displayField,
                repairHighlightColor: b.nodeHighlightColor,
                repairHighlight: b.nodeHighlightOnRepair,
                scrollEl: c
            }, b.dragZone))
        }
        if (b.enableDrop) {
            b.dropZone = new Ext.tree.ViewDropZone(Ext.apply({
                view: a,
                ddGroup: b.dropGroup || b.ddGroup,
                allowContainerDrops: b.allowContainerDrops,
                appendOnly: b.appendOnly,
                allowParentInserts: b.allowParentInserts,
                expandDelay: b.expandDelay,
                dropHighlightColor: b.nodeHighlightColor,
                dropHighlight: b.nodeHighlightOnDrop,
                sortOnDrop: b.sortOnDrop,
                containerScroll: b.containerScroll
            }, b.dropZone))
        }
    }
}, 0, 0, 0, 0, ["plugin.treeviewdragdrop"], 0, [Ext.tree.plugin, "TreeViewDragDrop"], function () {
    var a = this.prototype;
    a.nodeHighlightOnDrop = a.nodeHighlightOnRepair = Ext.enableFx
}));
(Ext.cmd.derive("Ext.util.CSS", Ext.Base, function () {
    var c, e = null, d = document, b = /(-[a-z])/gi, a = function (g, h) {
        return h.charAt(1).toUpperCase()
    };
    return {
        singleton: true, rules: e, initialized: false, constructor: function () {
            c = this
        }, createStyleSheet: function (i, k) {
            var h, g = d.getElementsByTagName("head")[0], j = d.createElement("style");
            j.setAttribute("type", "text/css");
            if (k) {
                j.setAttribute("id", k)
            }
            h = j.styleSheet;
            if (h) {
                g.appendChild(j);
                h.cssText = i
            } else {
                j.appendChild(d.createTextNode(i));
                g.appendChild(j);
                h = j.sheet
            }
            c.cacheStyleSheet(h);
            return h
        }, removeStyleSheet: function (h) {
            var g = d.getElementById(h);
            if (g) {
                g.parentNode.removeChild(g)
            }
        }, swapStyleSheet: function (i, g) {
            var h;
            c.removeStyleSheet(i);
            h = d.createElement("link");
            h.setAttribute("rel", "stylesheet");
            h.setAttribute("type", "text/css");
            h.setAttribute("id", i);
            h.setAttribute("href", g);
            d.getElementsByTagName("head")[0].appendChild(h)
        }, cacheStyleSheet: function (m) {
            if (!e) {
                e = c.rules = {}
            }
            try {
                var p = m.cssRules || m.rules, l = p.length - 1, h = m.imports, g = h ? h.length : 0, o, k;
                for (k = 0; k < g; ++k) {
                    c.cacheStyleSheet(h[k])
                }
                for (; l >= 0; --l) {
                    o = p[l];
                    if (o.styleSheet) {
                        c.cacheStyleSheet(o.styleSheet)
                    }
                    c.cacheRule(o, m)
                }
            } catch (n) {
            }
        }, cacheRule: function (h, l) {
            if (h.styleSheet) {
                return c.cacheStyleSheet(h.styleSheet)
            }
            var k = h.selectorText, i, g;
            if (k) {
                k = k.split(",");
                i = k.length;
                for (g = 0; g < i; g++) {
                    e[Ext.String.trim(k[g]).toLowerCase()] = {parentStyleSheet: l, cssRule: h}
                }
            }
        }, getRules: function (i) {
            var h = {}, g;
            if (e === null || i) {
                c.refreshCache()
            }
            for (g in e) {
                h[g] = e[g].cssRule
            }
            return h
        }, refreshCache: function () {
            var j = d.styleSheets, h = 0, g = j.length;
            e = c.rules = {};
            for (; h < g; h++) {
                try {
                    if (!j[h].disabled) {
                        c.cacheStyleSheet(j[h])
                    }
                } catch (k) {
                }
            }
        }, getRule: function (h, k, j) {
            var l, g;
            if (!e || k) {
                c.refreshCache()
            }
            if (!Ext.isArray(h)) {
                g = e[h.toLowerCase()];
                if (g && !j) {
                    g = g.cssRule
                }
                return g || null
            }
            for (l = 0; l < h.length; l++) {
                if (e[h[l]]) {
                    return j ? e[h[l].toLowerCase()] : e[h[l].toLowerCase()].cssRule
                }
            }
            return null
        }, createRule: function (l, h, j) {
            var g, k = l.cssRules || l.rules, i = k.length;
            if (l.insertRule) {
                l.insertRule(h + " {" + j + "}", i)
            } else {
                l.addRule(h, j || " ")
            }
            c.cacheRule(g = k[i], l);
            return g
        }, updateRule: function (g, l, k) {
            var m, h, j;
            if (!Ext.isArray(g)) {
                m = c.getRule(g);
                if (m) {
                    if (arguments.length === 2) {
                        j = Ext.Element.parseStyles(l);
                        for (l in j) {
                            m.style[l.replace(b, a)] = j[l]
                        }
                    } else {
                        m.style[l.replace(b, a)] = k
                    }
                    return true
                }
            } else {
                for (h = 0; h < g.length; h++) {
                    if (c.updateRule(g[h], l, k)) {
                        return true
                    }
                }
            }
            return false
        }, deleteRule: function (g) {
            var i = c.getRule(g, false, true), j, h;
            if (i) {
                j = i.parentStyleSheet;
                h = Ext.Array.indexOf(j.cssRules || j.rules, i.cssRule);
                if (j.deleteRule) {
                    j.deleteRule(h)
                } else {
                    j.removeRule(h)
                }
                delete e[g]
            }
        }
    }
}, 1, 0, 0, 0, 0, 0, [Ext.util, "CSS"], 0));
(Ext.cmd.derive("Ext.util.Cookies", Ext.Base, {
    singleton: true, set: function (c, e) {
        var a = arguments, i = arguments.length, b = (i > 2) ? a[2] : null, h = (i > 3) ? a[3] : "/",
            d = (i > 4) ? a[4] : null, g = (i > 5) ? a[5] : false;
        document.cookie = c + "=" + escape(e) + ((b === null) ? "" : ("; expires=" + b.toUTCString())) + ((h === null) ? "" : ("; path=" + h)) + ((d === null) ? "" : ("; domain=" + d)) + ((g === true) ? "; secure" : "")
    }, get: function (c) {
        var g = document.cookie.split("; "), a = g.length, e, d, b;
        for (d = 0; d < a; ++d) {
            e = g[d].split("=");
            if (e[0] === c) {
                b = e[1];
                return b ? unescape(b) : ""
            }
        }
        return null
    }, clear: function (a, b) {
        if (this.get(a)) {
            b = b || "/";
            document.cookie = a + "=; expires=Thu, 01-Jan-1970 00:00:01 GMT; path=" + b
        }
    }
}, 0, 0, 0, 0, 0, 0, [Ext.util, "Cookies"], 0));
(Ext.cmd.derive("Ext.view.MultiSelectorSearch", Ext.panel.Panel, {
    layout: "fit",
    floating: true,
    resizable: true,
    minWidth: 200,
    minHeight: 200,
    border: true,
    defaultListenerScope: true,
    referenceHolder: true,
    searchText: "Search...",
    initComponent: function () {
        var h = this, a = h.owner, d = h.makeItems(), e, g, c, b;
        h.dockedItems = h.makeDockedItems();
        h.items = d;
        b = Ext.data.StoreManager.lookup(h.store);
        for (e = d.length; e--;) {
            if ((g = d[e]).xtype === "grid") {
                g.store = b;
                g.isSearchGrid = true;
                g.selModel = g.selModel || {
                    type: "checkboxmodel",
                    pruneRemoved: false,
                    listeners: {selectionchange: "onSelectionChange"}
                };
                Ext.merge(g, h.grid);
                if (!g.columns) {
                    g.hideHeaders = true;
                    g.columns = [{flex: 1, dataIndex: h.field}]
                }
                break
            }
        }
        Ext.panel.Panel.prototype.initComponent.call(this);
        c = h.getOwnerStore().getRange();
        if (!a.convertSelectionRecord.$nullFn) {
            for (e = c.length; e--;) {
                c[e] = a.convertSelectionRecord(c[e])
            }
        }
        if (b.isLoading() || (b.loadCount === 0 && !b.getCount())) {
            b.on("load", function () {
                var j = c.length, l, k, m = [];
                if (!h.destroyed) {
                    for (l = 0; l < j; l++) {
                        k = b.getById(c[l].getId());
                        if (k) {
                            m.push(k)
                        }
                    }
                    h.selectRecords(m)
                }
            }, null, {single: true})
        } else {
            h.selectRecords(c)
        }
    },
    getOwnerStore: function () {
        return this.owner.getStore()
    },
    afterShow: function () {
        var a = this.lookupReference("searchField");
        Ext.panel.Panel.prototype.afterShow.apply(this, arguments);
        if (a) {
            a.focus()
        }
    },
    getSearchStore: function () {
        var a = this.lookupReference("searchGrid");
        return a.getStore()
    },
    makeDockedItems: function () {
        return [{
            xtype: "textfield",
            reference: "searchField",
            dock: "top",
            hideFieldLabel: true,
            emptyText: this.searchText,
            triggers: {clear: {cls: "x-form-clear-trigger", handler: "onClearSearch", hidden: true}},
            listeners: {change: "onSearchChange", buffer: 300}
        }]
    },
    makeItems: function () {
        return [{
            xtype: "grid",
            reference: "searchGrid",
            trailingBufferZone: 2,
            leadingBufferZone: 2,
            viewConfig: {deferEmptyText: false, emptyText: "No results."}
        }]
    },
    selectRecords: function (b) {
        var a = this.lookupReference("searchGrid");
        return a.getSelectionModel().select(b)
    },
    deselectRecords: function (b) {
        var a = this.lookupReference("searchGrid");
        return a.getSelectionModel().deselect(b)
    },
    search: function (d) {
        var c = this, a = c.searchFilter, b = c.getSearchStore().getFilters();
        if (d) {
            b.beginUpdate();
            if (a) {
                a.setValue(d)
            } else {
                c.searchFilter = a = new Ext.util.Filter({id: "search", property: c.field, value: d})
            }
            b.add(a);
            b.endUpdate()
        } else {
            if (a) {
                b.remove(a)
            }
        }
    },
    privates: {
        onClearSearch: function () {
            var a = this.lookupReference("searchField");
            a.setValue(null);
            a.focus()
        }, onSearchChange: function (c) {
            var b = c.getValue(), a = c.getTrigger("clear");
            a.setHidden(!b);
            this.search(b)
        }, onSelectionChange: function (j, k) {
            var c = this.owner, l = c.getStore(), e = l.data, g = 0, a = {}, m, d, b, h;
            for (d = k.length; d--;) {
                h = k[d];
                b = h.id;
                a[b] = h;
                if (!e.containsKey(b)) {
                    (m || (m = [])).push(c.convertSearchRecord(h))
                }
            }
            for (d = e.length; d--;) {
                h = e.getAt(d);
                if (!a[h.id]) {
                    (g || (g = [])).push(h)
                }
            }
            if (m || g) {
                e.splice(e.length, g, m)
            }
        }
    }
}, 0, ["multiselector-search"], ["component", "box", "container", "panel", "multiselector-search"], {
    component: true,
    box: true,
    container: true,
    panel: true,
    "multiselector-search": true
}, ["widget.multiselector-search"], 0, [Ext.view, "MultiSelectorSearch"], 0));
(Ext.cmd.derive("Ext.view.MultiSelector", Ext.grid.Panel, {
    config: {search: {xtype: "multiselector-search", width: 200, height: 200, store: {autoLoad: true}}},
    fieldName: "name",
    fieldTitle: null,
    removeRowText: "✖",
    removeRowTip: "Remove this item",
    emptyText: "Nothing selected",
    addToolText: "Search for items to add",
    initComponent: function () {
        var g = this, a = g.emptyText, c = g.getStore(), e = g.getSearch(), h = g.fieldTitle, b, d;
        b = e.store;
        if (b.isStore) {
            d = b.getModel()
        } else {
            d = b.model
        }
        if (!c) {
            g.store = {model: d}
        }
        if (a && !g.viewConfig) {
            g.viewConfig = {deferEmptyText: false, emptyText: a}
        }
        if (!g.columns) {
            g.hideHeaders = !h;
            g.columns = [{text: h, dataIndex: g.fieldName, flex: 1}, g.makeRemoveRowColumn()]
        }
        Ext.grid.Panel.prototype.initComponent.call(this)
    },
    addTools: function () {
        this.addTool({type: "plus", tooltip: this.addToolText, callback: "onShowSearch", scope: this})
    },
    convertSearchRecord: Ext.identityFn,
    convertSelectionRecord: Ext.identityFn,
    makeRemoveRowColumn: function () {
        var a = this;
        return {
            width: 22,
            menuDisabled: true,
            tdCls: "x-multiselector-remove",
            processEvent: a.processRowEvent.bind(a),
            renderer: a.renderRemoveRow,
            updater: Ext.emptyFn,
            scope: a
        }
    },
    processRowEvent: function (h, c, a, d, g, i, b, j) {
        if (i.type !== "click") {
            return
        }
        if (Ext.fly(a).hasCls("x-multiselector-remove")) {
            this.store.remove(b);
            if (this.searchPopup) {
                this.searchPopup.deselectRecords(b)
            }
        }
    },
    renderRemoveRow: function () {
        return '<span data-qtip="' + this.removeRowTip + '" role="button">' + this.removeRowText + "</span>"
    },
    beforeDestroy: function () {
        Ext.un({mousedown: "onDismissSearch", scope: this});
        Ext.grid.Panel.prototype.beforeDestroy.call(this)
    },
    privates: {
        onDismissSearch: function (b) {
            var a = this.searchPopup;
            if (a && !(a.owns(b.getTarget()) || this.owns(b.getTarget()))) {
                Ext.un({mousedown: "onDismissSearch", scope: this});
                a.hide()
            }
        }, onShowSearch: function (b, d) {
            var e = this, a = e.searchPopup, c = e.getStore();
            if (!a) {
                a = Ext.merge({owner: e, field: e.fieldName, floating: true}, e.getSearch());
                e.searchPopup = a = e.add(a);
                if (c.getCount()) {
                    a.selectRecords(c.getRange())
                }
            }
            a.showBy(e, "tl-tr?");
            Ext.on({mousedown: "onDismissSearch", scope: e})
        }
    }
}, 0, ["multiselector"], ["component", "box", "container", "panel", "tablepanel", "gridpanel", "grid", "multiselector"], {
    component: true,
    box: true,
    container: true,
    panel: true,
    tablepanel: true,
    gridpanel: true,
    grid: true,
    multiselector: true
}, ["widget.multiselector"], 0, [Ext.view, "MultiSelector"], 0));
(Ext.cmd.derive("Ext.window.Toast", Ext.window.Window, {
    isToast: true,
    cls: "x-toast",
    bodyPadding: 10,
    autoClose: true,
    plain: false,
    draggable: false,
    resizable: false,
    shadow: false,
    focus: Ext.emptyFn,
    anchor: null,
    useXAxis: false,
    align: "br",
    animate: true,
    spacing: 6,
    paddingX: 30,
    paddingY: 10,
    slideInAnimation: "easeIn",
    slideBackAnimation: "bounceOut",
    slideInDuration: 500,
    slideBackDuration: 500,
    hideDuration: 500,
    autoCloseDelay: 3000,
    stickOnClick: true,
    stickWhileHover: true,
    closeOnMouseDown: false,
    closable: false,
    isHiding: false,
    isFading: false,
    destroyAfterHide: false,
    closeOnMouseOut: false,
    xPos: 0,
    yPos: 0,
    initComponent: function () {
        var a = this;
        if (a.autoClose && !a.hasOwnProperty("closable")) {
            a.closable = false
        }
        a.updateAlignment(a.align);
        a.setAnchor(a.anchor);
        Ext.window.Window.prototype.initComponent.call(this)
    },
    onRender: function () {
        var a = this;
        Ext.window.Window.prototype.onRender.apply(this, arguments);
        a.el.hover(a.onMouseEnter, a.onMouseLeave, a);
        if (a.closeOnMouseDown) {
            Ext.getDoc().on("mousedown", a.onDocumentMousedown, a)
        }
    },
    alignmentProps: {
        br: {paddingFactorX: -1, paddingFactorY: -1, siblingAlignment: "br-br", anchorAlign: "tr-br"},
        bl: {paddingFactorX: 1, paddingFactorY: -1, siblingAlignment: "bl-bl", anchorAlign: "tl-bl"},
        tr: {paddingFactorX: -1, paddingFactorY: 1, siblingAlignment: "tr-tr", anchorAlign: "br-tr"},
        tl: {paddingFactorX: 1, paddingFactorY: 1, siblingAlignment: "tl-tl", anchorAlign: "bl-tl"},
        b: {paddingFactorX: 0, paddingFactorY: -1, siblingAlignment: "b-b", useXAxis: 0, anchorAlign: "t-b"},
        t: {paddingFactorX: 0, paddingFactorY: 1, siblingAlignment: "t-t", useXAxis: 0, anchorAlign: "b-t"},
        l: {paddingFactorX: 1, paddingFactorY: 0, siblingAlignment: "l-l", useXAxis: 1, anchorAlign: "r-l"},
        r: {paddingFactorX: -1, paddingFactorY: 0, siblingAlignment: "r-r", useXAxis: 1, anchorAlign: "l-r"},
        x: {
            br: {anchorAlign: "bl-br"},
            bl: {anchorAlign: "br-bl"},
            tr: {anchorAlign: "tl-tr"},
            tl: {anchorAlign: "tr-tl"}
        }
    },
    updateAlignment: function (e) {
        var c = this, a = c.alignmentProps, b = a[e], d = a.x[e];
        if (d && c.useXAxis) {
            Ext.applyIf(c, d)
        }
        Ext.applyIf(c, b)
    },
    getXposAlignedToAnchor: function () {
        var c = this, g = c.align, a = c.anchor, d = a && a.el, b = c.el, e = 0;
        if (d && d.dom) {
            if (!c.useXAxis) {
                e = b.getLeft()
            } else {
                if (g === "br" || g === "tr" || g === "r") {
                    e += d.getAnchorXY("r")[0];
                    e -= (b.getWidth() + c.paddingX)
                } else {
                    e += d.getAnchorXY("l")[0];
                    e += c.paddingX
                }
            }
        }
        return e
    },
    getYposAlignedToAnchor: function () {
        var d = this, g = d.align, a = d.anchor, e = a && a.el, b = d.el, c = 0;
        if (e && e.dom) {
            if (d.useXAxis) {
                c = b.getTop()
            } else {
                if (g === "br" || g === "bl" || g === "b") {
                    c += e.getAnchorXY("b")[1];
                    c -= (b.getHeight() + d.paddingY)
                } else {
                    c += e.getAnchorXY("t")[1];
                    c += d.paddingY
                }
            }
        }
        return c
    },
    getXposAlignedToSibling: function (b) {
        var c = this, e = c.align, a = c.el, d;
        if (!c.useXAxis) {
            d = a.getLeft()
        } else {
            if (e === "tl" || e === "bl" || e === "l") {
                d = (b.xPos + b.el.getWidth() + b.spacing)
            } else {
                d = (b.xPos - a.getWidth() - c.spacing)
            }
        }
        return d
    },
    getYposAlignedToSibling: function (b) {
        var d = this, e = d.align, a = d.el, c;
        if (d.useXAxis) {
            c = a.getTop()
        } else {
            if (e === "tr" || e === "tl" || e === "t") {
                c = (b.yPos + b.el.getHeight() + b.spacing)
            } else {
                c = (b.yPos - a.getHeight() - b.spacing)
            }
        }
        return c
    },
    getToasts: function () {
        var a = this.anchor, c = this.anchorAlign, b = a.activeToasts || (a.activeToasts = {});
        return b[c] || (b[c] = [])
    },
    setAnchor: function (a) {
        var c = this, b;
        c.anchor = a = ((typeof a === "string") ? Ext.getCmp(a) : a);
        if (!a) {
            b = Ext.window.Toast;
            c.anchor = b.bodyAnchor || (b.bodyAnchor = {el: Ext.getBody()})
        }
    },
    beforeShow: function () {
        var a = this;
        if (a.stickOnClick) {
            a.body.on("click", function () {
                a.cancelAutoClose()
            })
        }
        if (a.autoClose) {
            if (!a.closeTask) {
                a.closeTask = new Ext.util.DelayedTask(a.doAutoClose, a)
            }
        }
        a.el.setX(-10000);
        a.el.setOpacity(1)
    },
    afterShow: function () {
        var e = this, b = e.el, d, a, c, g;
        Ext.window.Window.prototype.afterShow.apply(this, arguments);
        d = e.getToasts();
        c = d.length;
        a = c && d[c - 1];
        if (a) {
            b.alignTo(a.el, e.siblingAlignment, [0, 0]);
            e.xPos = e.getXposAlignedToSibling(a);
            e.yPos = e.getYposAlignedToSibling(a)
        } else {
            b.alignTo(e.anchor.el, e.anchorAlign, [(e.paddingX * e.paddingFactorX), (e.paddingY * e.paddingFactorY)], false);
            e.xPos = e.getXposAlignedToAnchor();
            e.yPos = e.getYposAlignedToAnchor()
        }
        Ext.Array.include(d, e);
        if (e.animate) {
            g = b.getXY();
            b.animate({
                from: {x: g[0], y: g[1]},
                to: {x: e.xPos, y: e.yPos, opacity: 1},
                easing: e.slideInAnimation,
                duration: e.slideInDuration,
                dynamic: true,
                callback: e.afterPositioned,
                scope: e
            })
        } else {
            e.setLocalXY(e.xPos, e.yPos);
            e.afterPositioned()
        }
    },
    afterPositioned: function () {
        if (this.autoClose) {
            this.closeTask.delay(this.autoCloseDelay)
        }
    },
    onDocumentMousedown: function (a) {
        if (this.isVisible() && !this.owns(a.getTarget())) {
            this.hide()
        }
    },
    slideBack: function () {
        var e = this, b = e.anchor, g = b && b.el, c = e.el, d = e.getToasts(), a = Ext.Array.indexOf(d, e);
        if (!e.isHiding && c && c.dom && g && g.isVisible()) {
            if (a) {
                e.xPos = e.getXposAlignedToSibling(d[a - 1]);
                e.yPos = e.getYposAlignedToSibling(d[a - 1])
            } else {
                e.xPos = e.getXposAlignedToAnchor();
                e.yPos = e.getYposAlignedToAnchor()
            }
            e.stopAnimation();
            if (e.animate) {
                c.animate({
                    to: {x: e.xPos, y: e.yPos},
                    easing: e.slideBackAnimation,
                    duration: e.slideBackDuration,
                    dynamic: true
                })
            }
        }
    },
    update: function () {
        var a = this;
        if (a.isVisible()) {
            a.isHiding = true;
            a.hide()
        }
        Ext.window.Window.prototype.update.apply(this, arguments);
        a.show()
    },
    cancelAutoClose: function () {
        var a = this.closeTask;
        if (a) {
            a.cancel()
        }
    },
    doAutoClose: function () {
        var a = this;
        if (!(a.stickWhileHover && a.mouseIsOver)) {
            a.close()
        } else {
            a.closeOnMouseOut = true
        }
    },
    onMouseEnter: function () {
        this.mouseIsOver = true
    },
    onMouseLeave: function () {
        var a = this;
        a.mouseIsOver = false;
        if (a.closeOnMouseOut) {
            a.closeOnMouseOut = false;
            a.close()
        }
    },
    removeFromAnchor: function () {
        var c = this, b, a;
        if (c.anchor) {
            b = c.getToasts();
            a = Ext.Array.indexOf(b, c);
            if (a !== -1) {
                Ext.Array.erase(b, a, 1);
                for (; a < b.length; a++) {
                    b[a].slideBack()
                }
            }
        }
    },
    getFocusEl: Ext.emptyFn,
    hide: function () {
        var b = this, a = b.el;
        b.cancelAutoClose();
        if (b.isHiding) {
            if (!b.isFading) {
                Ext.window.Window.prototype.hide.apply(this, arguments);
                b.removeFromAnchor();
                b.isHiding = false
            }
        } else {
            b.isHiding = true;
            b.isFading = true;
            b.cancelAutoClose();
            if (a) {
                if (b.animate) {
                    a.fadeOut({
                        opacity: 0,
                        easing: "easeIn",
                        duration: b.hideDuration,
                        listeners: {
                            afteranimate: function () {
                                b.isFading = false;
                                b.hide(b.animateTarget, b.doClose, b)
                            }
                        }
                    })
                } else {
                    b.isFading = false;
                    b.hide(b.animateTarget, b.doClose, b)
                }
            }
        }
        return b
    }
}, 0, ["toast"], ["component", "box", "container", "panel", "window", "toast"], {
    component: true,
    box: true,
    container: true,
    panel: true,
    window: true,
    toast: true
}, ["widget.toast"], 0, [Ext.window, "Toast"], function (a) {
    Ext.toast = function (e, g, h, d) {
        var c = e, b;
        if (Ext.isString(e)) {
            c = {title: g, html: e, iconCls: d};
            if (h) {
                c.align = h
            }
        }
        b = new a(c);
        b.show();
        return b
    }
}));"""